<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java进阶13-动态代理和XML]]></title>
    <url>%2F2019%2F08%2F26%2F2019-08-26-Java%E8%BF%9B%E9%98%B613-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CXML%2F</url>
    <content type="text"><![CDATA[主要内容 动态代理 XML 正则表达式 1. 动态代理说明 : 在之后学习Spring框架时，Spring框架有一大核心思想，就是AOP，(Aspact-Oriented-Programming 面向切面编程) 而AOP的原理就是Java的动态代理机制，在Java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 动态代理的基础 : 必须有接口. Java中使用接口来定义统一的行为规范 : 接口. 接口必须有实现类 : 12345678910interface SuperStar 超级明星行为规范 :void sing(int money);void liveShow(int moeny);void sleep();// 接口必须有实现类 :1. LiXiaoLu implements SuperStar2. FanBingBing implements SuperStar...... 动态代理作用 : 拦截和控制 被代理对象 的所有行为. 1.1 Proxy 代理类 :Class Proxy 代理类 是在运行时创建的实现指定的接口列表（称为代理接口）的类 。 代理实例是代理类的一个实例。 每个代理实例都有一个关联的调用处理程序对象，它实现接口InvocationHandler 。 通过其代理接口之一的代理实例上的方法调用将被分派到实例调用处理程序的invoke方法 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 返回指定接口的代理实例，该代理实例将方法调用分派给指定的调用处理程序。 1.2 InvocationHandler 调用处理器接口 :Interface InvocationHandler 每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。 1.3 案例演示 :动态代理的作用 : 拦截并控制被代理对象的所有行为. 演示一 : SuperStar 接口 1234567public interface SuperStar &#123; // 抽象方法 : void sing(int money); void liveShow(int money); void sleep();&#125; LiuYan 类 : 1234567891011121314151617public class LiuYan implements SuperStar &#123; @Override public void sing(int money) &#123; System.out.println("柳岩唱了一首 &lt;&lt;真的真的很爱你&gt;&gt; 歌曲. 挣了 : " + money); &#125; @Override public void liveShow(int money) &#123; System.out.println("柳岩参加了 &lt;&lt;Running Man&gt;&gt; 节目. 挣了 : " + money); &#125; @Override public void sleep() &#123; System.out.println("柳岩累了, 休息一下..."); &#125;&#125; FanBingBing 类 1234567891011121314151617public class FanBingBing implements SuperStar &#123; @Override public void sing(int money) &#123; System.out.println("范冰冰为你唱了一首 &lt;&lt;永远只爱你&gt;&gt; 歌曲. 挣了 : " + money); &#125; @Override public void liveShow(int money) &#123; System.out.println("范冰冰参加了 &lt;&lt;妈妈去哪里&gt;&gt; 节目. 挣了 : " + money); &#125; @Override public void sleep() &#123; System.out.println("范冰冰累了, 要休息休息了..."); &#125;&#125; 测试类 : 12345678910111213141516171819202122232425262728293031323334353637import org.junit.Test;public class AOPTest &#123; @Test public void test1() &#123; // 1. 创建 `柳岩` LiuYan ly = new LiuYan(); // 2. 调用方法 ly.sing(10); ly.sing(100); ly.sleep(); &#125; @Test public void test2() &#123; // 1. 创建 `范冰冰` FanBingBing fbb = new FanBingBing(); // 2. 调用方法 fbb.sing(15); fbb.liveShow(150); fbb.sleep(); &#125;&#125;输出结果 :柳岩唱了一首 &lt;&lt;真的真的很爱你&gt;&gt; 歌曲. 挣了 : 10柳岩唱了一首 &lt;&lt;真的真的很爱你&gt;&gt; 歌曲. 挣了 : 100柳岩累了, 休息一下... 范冰冰为你唱了一首 &lt;&lt;永远只爱你&gt;&gt; 歌曲. 挣了 : 15范冰冰参加了 &lt;&lt;妈妈去哪里&gt;&gt; 节目. 挣了 : 150范冰冰累了, 要休息休息了... 演示二 : （1）创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。 MyInvocationHandler 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; // 属性 private SuperStar star; public MyInvocationHandler(SuperStar star) &#123; this.star = star; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 1. 获取方法的名称 String methodName = method.getName(); // 2. 判断调用方法 if ("sing".equals(methodName)) &#123; // 3. 取出参数 int money = (int) args[0]; // 4. 判断金额 if (money &lt; 10000) &#123; // 5. 金额不足 System.out.println("滚, 你这个穷屌丝, 赶紧回家撸代码去 ..."); return null; &#125; // 6. 抽回扣 int huiKou = (int) (money * 0.3); System.out.println("代理抽取了 : " + huiKou); // 7. 执行真实对象的方法 money = money - huiKou; return method.invoke(star, money); &#125; else if ("liveShow".equals(methodName)) &#123; // 3. 取出参数 int money = (int) args[0]; // 4. 判断金额 if (money &lt; 100000) &#123; // 5. 金额不足 System.out.println("滚, How old are you, 继续回家撸代码去 ..."); return null; &#125; // 6. 抽回扣 int huiKou = (int) (money * 0.3); System.out.println("代理抽取了 : " + huiKou); // 7. 执行真实对象的方法 money = money - huiKou; return method.invoke(star, money); &#125; return method.invoke(star, args); &#125;&#125; 测试： 12345678910111213141516171819202122 @Test public void test3() &#123; // 1. 创建一个被代理对象 SuperStar star = new LiuYan(); // 2. 创建一个代理对象 ClassLoader loader = star.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = star.getClass().getInterfaces(); MyInvocationHandler h = new MyInvocationHandler(star); SuperStar proxy = (SuperStar) Proxy.newProxyInstance(loader, interfaces, h); // 3. 使用代理调用接口中的行为规范 proxy.sing(10); proxy.liveShow(100); proxy.sleep(); &#125;输出结果 :滚, 你这个穷屌丝, 赶紧回家撸代码去 ...滚, How old are you, 继续回家撸代码去 ...柳岩累了, 休息一下... 匿名内部类实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 @Test public void test4() &#123; // 1. 创建一个被代理对象 SuperStar star = new LiuYan(); // 2. 创建一个代理对象 ClassLoader loader = star.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = star.getClass().getInterfaces(); SuperStar proxy = (SuperStar) Proxy.newProxyInstance(loader, interfaces, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 1. 获取方法的名称 String methodName = method.getName(); // 2. 判断调用方法 if ("sing".equals(methodName)) &#123; // 3. 取出参数 int money = (int) args[0]; // 4. 判断金额 if (money &lt; 10000) &#123; // 5. 金额不足 System.out.println("滚, 你这个穷屌丝, 赶紧回家撸代码去 ..."); return null; &#125; // 6. 抽回扣 int huiKou = (int) (money * 0.3); System.out.println("代理抽取了 : " + huiKou); // 7. 执行真实对象的方法 money = money - huiKou; return method.invoke(star, money); &#125; else if ("liveShow".equals(methodName)) &#123; // 3. 取出参数 int money = (int) args[0]; // 4. 判断金额 if (money &lt; 100000) &#123; // 5. 金额不足 System.out.println("滚, How old are you, 继续回家撸代码去 ..."); return null; &#125; // 6. 抽回扣 int huiKou = (int) (money * 0.3); System.out.println("代理抽取了 : " + huiKou); // 7. 执行真实对象的方法 money = money - huiKou; return method.invoke(star, money); &#125; return method.invoke(star, args); &#125; &#125;); // 3. 使用代理调用接口中的行为规范 proxy.sing(10000); proxy.liveShow(100000); proxy.sleep(); &#125;输出结果 :代理抽取了 : 3000柳岩唱了一首 &lt;&lt;真的真的很爱你&gt;&gt; 歌曲. 挣了 : 7000代理抽取了 : 30000柳岩参加了 &lt;&lt;Running Man&gt;&gt; 节目. 挣了 : 70000柳岩累了, 休息一下... Lambda 表达式实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 @Test public void test5() &#123; // 1. 创建一个被代理对象 SuperStar star = new FanBingBing(); // 2. 创建一个代理对象 ClassLoader loader = star.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = star.getClass().getInterfaces(); SuperStar proxy = (SuperStar) Proxy.newProxyInstance(loader, interfaces, (p, method, args) -&gt; &#123; // 1. 获取方法的名称 String methodName = method.getName(); // 2. 判断调用方法 if ("sing".equals(methodName)) &#123; // 3. 取出参数 int money = (int) args[0]; // 4. 判断金额 if (money &lt; 10000) &#123; // 5. 金额不足 System.out.println("滚, 你这个穷屌丝, 赶紧回家撸代码去 ..."); return null; &#125; // 6. 抽回扣 int huiKou = (int) (money * 0.3); System.out.println("代理抽取了 : " + huiKou); // 7. 执行真实对象的方法 money = money - huiKou; return method.invoke(star, money); &#125; else if ("liveShow".equals(methodName)) &#123; // 3. 取出参数 int money = (int) args[0]; // 4. 判断金额 if (money &lt; 100000) &#123; // 5. 金额不足 System.out.println("滚, How old are you, 继续回家撸代码去 ..."); return null; &#125; // 6. 抽回扣 int huiKou = (int) (money * 0.3); System.out.println("代理抽取了 : " + huiKou); // 7. 执行真实对象的方法 money = money - huiKou; return method.invoke(star, money); &#125; return method.invoke(star, args); &#125;); // 3. 使用代理调用接口中的行为规范 proxy.sing(10000); proxy.liveShow(100000); proxy.sleep(); &#125;输出结果 :代理抽取了 : 3000范冰冰为你唱了一首 &lt;&lt;永远只爱你&gt;&gt; 歌曲. 挣了 : 7000代理抽取了 : 30000范冰冰参加了 &lt;&lt;妈妈去哪里&gt;&gt; 节目. 挣了 : 70000范冰冰累了, 要休息休息了... 2. XML 文件简介 : XML全称为Extensible Markup Language，意思是可扩展的标记语言。 123标记 -&gt; 用标记来修饰文本信息.可扩展 -&gt; 标记可随意定义. XML技术 : 与数据相关技术, 在企业中xml技术常用来存储数据和传输数据, xml之所以流行的原因在于xml语言与任何编程语言无关, xml可用于 php, java, .net任何编程语言. XML 技术主要企业应用: 121. 存储和传输数据.2. 作为框架的配置文件. IDEA 设置 xml 模板 : 2.1 书写一个 xml 配置文件 xml编写时也要符合一定的规则 : 123451）xml文件的后缀名是.xml2）xml有且只有一个根标签3）xml的标签是尖括号包裹关键字成对出现的，有开始标签有结束标签，关键字是自定义的, xml也可以有空标签/自关闭标签4）xml允许有属性，属性也是根据需要自定义的，属性格式：属性= &quot;属性值&quot;，多个属性之间使用空格隔开5）xml是区分大小写的 xml 的组成： 1）文档声明：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 2）根标签，例如: &lt;store&gt; 3）其他标签，例如：&lt;name&gt; 4）属性，例如：category=&quot;手机数码&quot; 5）文本，例如：华为手机 6）注释，例如：&lt;!-- 这是xml文档的根标签 --&gt; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;store&gt; &lt;product category="手机数码"&gt; &lt;pid&gt;100&lt;/pid&gt; &lt;name&gt;华为手机&lt;/name&gt; &lt;price&gt;1999&lt;/price&gt; &lt;/product&gt; &lt;product category="电脑办公"&gt; &lt;pid&gt;200&lt;/pid&gt; &lt;name&gt;三星笔记本&lt;/name&gt; &lt;price&gt;3999&lt;/price&gt; &lt;/product&gt; &lt;product category="大型家电"&gt; &lt;pid&gt;300&lt;/pid&gt; &lt;name&gt;海尔洗衣机&lt;/name&gt; &lt;price&gt;999&lt;/price&gt; &lt;/product&gt;&lt;/store&gt; 2.2 约束介绍 DTD, Schema 提供 DTD 约束 : 1234567&lt;!DOCTYPE books[ &lt;!ELEMENT books (book+)&gt; &lt;!ELEMENT book (name, price)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ATTLIST book author CDATA #REQUIRED&gt; &lt;!-- #IMPLIED 可选 --&gt; ]&gt; books.xml 文件编写 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE books[ &lt;!ELEMENT books (book+)&gt; &lt;!ELEMENT book (name, price)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT price (#PCDATA)&gt; &lt;!ATTLIST book author CDATA #REQUIRED&gt; &lt;!-- #IMPLIED 可选 --&gt; ]&gt;&lt;books&gt; &lt;book author="张三丰"&gt; &lt;name&gt;Java从入门到精通&lt;/name&gt; &lt;price&gt;98&lt;/price&gt; &lt;/book&gt; &lt;book author="灭绝师太"&gt; &lt;name&gt;Java编程思想&lt;/name&gt; &lt;price&gt;998&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; bean-schema.xsd schema 约束 : 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 传智播客 Schema 教学实例文档 : 模拟 spring 框架规范 : 如果开发人员需要在 xml 使用当前 schema 约束, 必须包含指定命名空间. 格式如下 : &lt;beans xmlns=&quot;http://www.example.org/bean-schema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.example.org/bean-schema bean-schema.xsd&quot;&gt; &lt;/beans&gt; --&gt;&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.example.org/bean-schema&quot; xmlns:tns=&quot;http://www.example.org/bean-schema&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;!-- 声明根标签 --&gt; &lt;element name=&quot;beans&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;bean&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name=&quot;property&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt; &lt;complexType&gt; &lt;attribute name=&quot;name&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt; &lt;attribute name=&quot;value&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;attribute name=&quot;id&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt; &lt;attribute name=&quot;className&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt;&lt;/schema&gt; beans.xml 文件编写 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.example.org/bean-schema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.example.org/bean-schema bean-schema.xsd"&gt; &lt;bean id="001" className="cn.itcast.bean.User"&gt; &lt;property name="username" value="ZhangSan"&gt;&lt;/property&gt; &lt;property name="password" value="123456"/&gt; &lt;/bean&gt; &lt;bean id="002" className="cn.itcast.bean.User"&gt; &lt;property name="username" value="LiSi"&gt;&lt;/property&gt; &lt;property name="password" value="654321"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.3 xml 解析 :XML的实际应用场景 : 实际开发中，我们一般会使用各种各样的框架进行企业开发，而这些框架一般都会将某些公共的功能都已经写好，我们需要做的只需要按照框架提供的约束进行框架的配置就可以了，当我们使用XML配置好框架后，再运行时，框架底层会解析我们配置XML文档获取有用的信息，从而根据我们的需求实现某些功能。 所以，实际开发中我们很少会自己编写XML约束和解析XML. 解析 books.xml 文件 : 123456789101112131415161718192021222324252627282930313233343536 @Test public void test1() throws DocumentException &#123; // 1. 创建一个 saxReader 解析器 SAXReader saxReader = new SAXReader(); // 2. 调用 read 方法读取 xml 配置文件, 并获取一个 document 对象 Document document = saxReader.read("books.xml"); // 3. 调用 getRootElement 方法, 获取根标签对象 Element root = document.getRootElement(); // 4. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; bookElements = root.elements(); // 5. 遍历 bookElements 数组 for (Element book : bookElements) &#123; // 6. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String author = book.attributeValue("author"); System.out.println("author = " + author); // 7. 获取子标签 List&lt;Element&gt; elements = book.elements(); // 8. 遍历子标签 for (Element e : elements) &#123; // 9. 获取标签名称, 和标签体数据 String name = e.getName(); String text = e.getText(); System.out.println(name + " = " + text); &#125; &#125; &#125;输出结果 :author = 张三丰name = Java从入门到精通price = 98author = 灭绝师太name = Java编程思想price = 998 解析 beans.xml 文件 : 1234567891011121314151617181920212223242526272829303132333435 @Test public void test2() throws DocumentException &#123; // 1. 创建一个 saxReader 解析器 SAXReader saxReader = new SAXReader(); // 2. 调用 read 方法读取 xml 配置文件, 并获取一个 document 对象 Document document = saxReader.read("beans.xml"); // 3. 调用 getRootElement 方法, 获取根标签对象 Element root = document.getRootElement(); // 4. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; beanElements = root.elements(); // 5. 调用 elements 方法, 获取子标签数组 for (Element bean : beanElements) &#123; // 6. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String id = bean.attributeValue("id"); String className = bean.attributeValue("className"); System.out.println(id + " = " + className); // 7. 调用 elements 方法, 获取子标签数组 List&lt;Element&gt; propElements = bean.elements(); // 8. 调用 propElements 方法, 获取子标签数组 for (Element prop : propElements) &#123; // 9. 调用 attributeValue 方法, 传入属性名称, 获取对应的属性值 String name = prop.attributeValue("name"); String value = prop.attributeValue("value"); System.out.println(name + " = " + value); &#125; &#125; &#125;输出结果 :001 = cn.itcast.bean.Userusername = ZhangSanpassword = 123456002 = cn.itcast.bean.Userusername = LiSipassword = 654321 3. 正则表达式Regular Expression 正则表达式 : 在Java中, 正则主要使用在 String 类的方法参数为 regex 的名称上. String 类的三个带 regex 参数的方法 : split(String regex) 切割. matches(String regex) 匹配. replaceAll(String regex, String replacement) 替换. 3.1 正则引入 :需求 : 验证QQ号码是否合法. 分析 : 第一位不能是 0 QQ号码在 5 ~ 12 位之间 (包含) QQ号码都是由数字组成. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class QQVerifyTest1 &#123; public static void main(String[] args) &#123; /* 需求 : 验证QQ号码是否合法. 分析 : 1. 第一位不能是 0 2. QQ号码在 5 ~ 12 位之间 (包含) 3. QQ号码都是由数字组成. */ String qq = "123456"; // 调用方法 boolean result1 = verifyQQNumber1(qq); boolean result2 = verifyQQNumber2(qq); boolean result3 = verifyQQNumber3(qq); System.out.println("result1 = " + result1); System.out.println("result2 = " + result2); System.out.println("result3 = " + result3); &#125; // 方式一 : public static boolean verifyQQNumber1(String qq) &#123; // 1. 第一位不能是 0 if (qq.charAt(0) == '0') &#123; return false; &#125; else if (qq.length() &lt; 5 || qq.length() &gt; 12) &#123; // 2. QQ号码在 5 ~ 12 位之间 (包含) return false; &#125; else &#123; // 3. QQ号码都是由数字组成. for (int i = 0; i &lt; qq.length(); i++) &#123; // 取出每一个字符 char ch = qq.charAt(i); // 判断 if (ch &lt; '0' || ch &gt; '9') &#123; return false; &#125; &#125; // 4. 最后, 返回 true return true; &#125; &#125; // 方式二 : public static boolean verifyQQNumber2(String qq) &#123; // 1. 第一位不能是 0 if (qq.charAt(0) == '0') &#123; return false; &#125; else if (qq.length() &lt; 5 || qq.length() &gt; 12) &#123; // 2. QQ号码在 5 ~ 12 位之间 (包含) return false; &#125; else &#123; // 3. QQ号码都是由数字组成. // 使用 Long.parseLong 解析 try &#123; Long.parseLong(qq); return true; &#125; catch (NumberFormatException e) &#123; return false; &#125; &#125; &#125; // 方式三 : public static boolean verifyQQNumber3(String qq) &#123; return qq.matches("[1-9][0-9]&#123;4,11&#125;"); &#125;&#125;输出结果 :result1 = trueresult2 = trueresult3 = true 3.2 正则的符号介绍 :123456781. [] 取值的范围. 0-9 数值0到9都成立. 说明 : [0-9] 可以使用 \\d 表示2. &#123;&#125; 表示前一个条件中 `值 / 字符` 可以出现的次数. 说明 : &#123;4,11&#125; 至少4次, 最多11次. &#123;0,1&#125; 至少0次,最多一次. 可以使用 ? 表示. &#123;1,&#125; 至少1次,最多无限次 可以使用 + 表示. &#123;0,&#125; 至少0次,最多无限次. 可以使用 * 表示.3. () 表示分组. 在replaceAll方法的第二个参数上可以使用 $ 符号来引用之前的分组,分组编号自动从1开始. 3.3 匹配 – matches (手机号码)需求：验证手机号码 1234手机号码规则 :1. 长度必须是11位2. 第一位只能是数字13. 第二位可以是3, 4, 5, 7, 8 123456789101112131415161718public class MatchesPhoneNumberTest2 &#123; public static void main(String[] args) &#123; /* 手机号码规则 : 1. 长度必须是11位 2. 第一位只能是数字1 3. 第二位可以是3, 4, 5, 7, 8 */ String phone = "13366285946"; boolean result = phone.matches("1[34578]\\d&#123;9&#125;"); System.out.println("result = " + result); &#125;&#125;输出结果 :result = true 3.4 切割 – split (字符串)123String str = "boxing#######basketball#####football###ILOVEYOU###爱我中华";String str = "boxing123basketball4567football888ILOVEYOU9876爱我中华";String str = "boxingaaaaabasketballYYYYYfootball888ILOVEYOU9999爱我中华"; 1234567891011121314151617181920212223242526272829303132333435363738394041import org.junit.Test;public class SplitStringTest3 &#123; @Test public void test1() &#123; String str = "boxing#######basketball#####football###ILOVEYOU###爱我中华"; String[] names = str.split("#+"); for (String name : names) &#123; System.out.println(name); &#125; &#125; @Test public void test2() &#123; String str = "boxing123basketball4567football888ILOVEYOU9876爱我中华"; String[] names = str.split("\\d+"); for (String name : names) &#123; System.out.println(name); &#125; &#125; @Test public void test3() &#123; String str = "boxingaaaaabasketballYYYYYfootball888ILOVEYOU9999爱我中华"; String[] names = str.split("(.)\\1&#123;2,&#125;"); for (String name : names) &#123; System.out.println(name); &#125; &#125;&#125;输出结果 :boxingbasketballfootballILOVEYOU爱我中华 3.5 替换 –replaceAll (隐藏手机号码)113366285946 -&gt; 133****5946 123456789101112131415161718192021public class ReplaceAllTest4 &#123; public static void main(String[] args) &#123; // 13366285946 -&gt; 133****5946 String phone = "13366285946"; /* 源数据 : 13366285946 第一部分 : 133 规则一 : 1[34578]\\d 第二部分 : 6628 规则二 : \\d&#123;4&#125; 第三部分 : 5946 规则三 : \\d&#123;4&#125; */ String result = phone.replaceAll("(1[34578]\\d)(\\d&#123;4&#125;)(\\d&#123;4&#125;)", "$1****$3"); System.out.println("result = " + result); &#125;&#125;输出结果 :result = 133****5946]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶12-反射和注解]]></title>
    <url>%2F2019%2F08%2F26%2F2019-08-26-Java%E8%BF%9B%E9%98%B612-%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[主要内容 Junit 反射 注解 学习目标 能够使用Junit进行单元测试 能够通过反射技术获取Class字节码对象 能够通过反射技术获取构造方法对象，并创建对象。 能够通过反射获取成员方法对象，并且调用方法。 能够说出注解的作用 能够自定义注解和使用注解 能够说出常用的元注解及其作用 能够解析注解并获取注解中的数据 能够完成注解的MyTest案例 第1章 Junit单元测试1.1 Junit的概述 Junit是一个Java语言的单元测试框架，简单理解为可以用于取代java的main方法。Junit属于第三方工具，一般情况下需要导入jar包。不过，多数Java开发环境已经集成了JUnit作为单元测试工具。 在Java中，一个类就是一个单元。 单元测试是开发者编写的一小段代码，用于检验某个类某个方法的功能或某个业务逻辑是否正确。 Java语言的最小单位 : 类 1.2 Junit的使用1.2.1 下载一般IDE都内置了junit,若需要自行下载jar包,可以访问官网,官网地址如下：http://www.junit.org 1.2.2 步骤 编写业务类 创建测试类 编写测试方法 1.2.3 测试方法12345678910111213141516171819202122232425262728import org.junit.Test;public class Test1 &#123; @Test public void testSum() &#123; int num1 = 10; int num2 = 20; int sum = num1 + num2; System.out.println("sum = " + sum); &#125; @Test public void testMinus() &#123; int total = 100; int num1 = 20; int minus = total - num1; System.out.println("minus = " + minus); &#125; @Test public void testDivide() &#123; int num1 = 10; int num2 = 0; int divide = num1 / num2; System.out.println("divide = " + divide); &#125;&#125; 特点 方法命名规则：以test开头，使用驼峰命名法。 方法声明上：必须使用注解：@Test，必须使用public修饰符，没有返回值，方法没有参数。 运行测试方法 选中方法名：右键 –&gt; Run 测试方法名，则运行选中的测试方法 比如测试方法名为testSum，则右键 –&gt; Run testSum 选中类名：右键 –&gt; Run 类名，则运行该类的所有测试方法 比如类名为TestCalculte，则右键 –&gt; Run TestCalculte 选中模块名或项目名：右键 –&gt; Run ‘All Tests’，则运行整个模块中所有类的所有测试方法。 查看测试结果 绿色：表示测试通过，如下图 红色：表示失败或出现错误，如下图 1.2.4 常用注解 @Before：在每个测试方法之前都会运行一次 @After：在每个测试方法运行以后运行的方法 @BeforeClass：在所有的测试方法运行之前，只运行一次，而且必须用在静态方法上面。 @AfterClass：所有的测试方法运行以后，只运行一次，必须用在静态方法上面。 1.2.5 示例代码 业务类 123456789101112131415161718/** 业务类 */public class Calculate &#123; /* 求a和b之和 */ public int sum(int a,int b)&#123; return a + b; &#125; /** 求a和b之差 */ public int sub(int a,int b)&#123; return a - b; &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.*;public class Test2 &#123; @BeforeClass public static void testBeforeClass() &#123; System.out.println("类加载时, 只运行一次."); &#125; @Before public void testBefore() &#123; System.out.println("测试方法运行前被执行 ..."); &#125; @Test public void testSum() &#123; Calculator calculator = new Calculator(); int sum = calculator.sum(10, 20); System.out.println("sum = " + sum); &#125; @Test public void testSub() &#123; Calculator calculator = new Calculator(); int sub = calculator.sub(100, 20); System.out.println("sub = " + sub); &#125; @After public void testAfter() &#123; System.out.println("每个测试方法被执行后执行 ..."); &#125; @AfterClass public static void testAfterClass() &#123; System.out.println("类结束前, 只执行一次."); &#125;&#125;输出结果 :类加载时, 只运行一次.测试方法运行前被执行 ...sub = 80每个测试方法被执行后执行 ...测试方法运行前被执行 ...sum = 30每个测试方法被执行后执行 ...类结束前, 只执行一次. 第2章 反射2.1 反射的基本概念2.1.1 什么是反射​ 反射是一种机制，利用该机制可以在程序运行过程中对类进行解剖并操作类中的方法，属性，构造方法等成员。 2.1.2 反射在实际开发中的应用 开发IDE(集成开发环境) 以上的IDE内部都大量使用了反射机制，我们在使用这些IDE写代码也无时无刻的使用着反射机制，一个常用反射机制的地方就是当我们通过对象调用方法或访问属性时，开发工具都会以列表的形式显示出该对象所有的方法或属性，以供方便我们选择使用，如下图： 这些开发工具之所有能够把该对象的方法和属性展示出来就使用利用了反射机制对该对象所有类进行了解剖获取到了类中的所有方法和属性信息，这是反射在IDE中的一个使用场景。 各种框架的设计 以上三个图标上面的名字就是Java的三大框架，简称SSH. 这三大框架的内部实现也大量使用到了反射机制，所有要想学好这些框架，则必须要求对反射技术有所了解。 2.1.3 使用反射机制解剖类的前提​ 必须先要获取到该类的字节码文件对象，即Class类型对象。关于Class描述字节码文件如下图所示： 说明： 1）Java中使用Class类表示某个class文件. 2）任何一个class文件都是Class这个类的一个实例对象. 2.2 获取Class对象的三种方式 创建测试类：Student 12345public class Student &#123; // 属性 // 行为&#125; 2.2.1 方式1：通过类名.class获取1234567891011 @Test public void test1() &#123; // 方式一 : 通过类名获取 class 对象 // 格式 : 类名.class 属性 // 常用场景 : 反射获取方法时, 确定方法的形参列表类型 Class&lt;Student&gt; cls = Student.class; System.out.println("cls = " + cls); &#125;输出结果 :cls = class cn.itcast.test2.Student 2.2.2 方式2：通过Object类的成员方法getClass()方法获取12345678910111213141516171819202122 @Test public void test2() &#123; // 1. 创建一个 Student 类型的对象 Student stu = new Student(); // 2. 调用方法, 并传入 stu 对象 showInfo(stu); &#125; public void showInfo(Object obj) &#123; // 方式二 : 使用对象名调用 getClass() 方法. // 格式 : 对象名.getClass() 方法. // 使用场景 : 在方法内部, 确定传入形参的真实类型. Class&lt;?&gt; cls = obj.getClass(); System.out.println("cls = " + cls); &#125;输出结果 :cls = class cn.itcast.test2.Student 2.2.3 方式3：通过Class.forName(“全限定类名”)方法获取123456789101112 @Test public void test3() throws ClassNotFoundException &#123; // 方式三 : 使用 Class 调用静态方法 forName(全限定类名); `包名+类名` // 使用场景 : 加载外部的配置文件时使用 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); System.out.println("cls = " + cls); &#125;输出结果 :cls = class cn.itcast.test2.Student 2.3 获取Class对象的信息​ 知道怎么获取Class对象之后，接下来就介绍几个Class类中常用的方法了。 2.3.1 Class对象相关方法123String getSimpleName(); 获得简单类名，只是类名，没有包 String getName(); 获取完整类名，包含包名+类名 T newInstance() ;创建此 Class 对象所表示的类的一个新实例。要求：类必须有public的无参数构造方法 2.3.2 方法演示123456789101112131415161718192021222324252627public class TestDate &#123; @Test public void testDate1() throws Exception &#123; // 1. 获取 Date 表示的 Class 对象. Class&lt;?&gt; cls = Class.forName("java.util.Date"); // 2. 获取简单类名 String simpleName = cls.getSimpleName(); System.out.println("simpleName = " + simpleName); // 3. 获取完成名称 (包名 + 类名) String name = cls.getName(); System.out.println("name = " + name); // 3. 创建一个日期对象 // cls.newInstance(); 已过时. Object obj = cls.getDeclaredConstructor().newInstance(); System.out.println("obj = " + obj); &#125;&#125;输出结果 :simpleName = Datename = java.util.Dateobj = Sun Jul 15 15:39:01 CST 2018 2.4 获取Class对象的Constructor信息​ 一开始在阐述反射概念的时候，我们说到利用反射可以在程序运行过程中对类进行解剖并操作里面的成员。而一般常操作的成员有构造方法，成员方法，成员变量等等，那么接下来就来看看怎么利用反射来操作这些成员以及操作这些成员能干什么，先来看看怎么操作构造方法。而要通过反射操作类的构造方法，我们需要先知道一个Constructor类。 2.4.1 Constructor类概述​ Constructor是构造方法类，类中的每一个构造方法都是Constructor的对象，通过Constructor对象可以实例化对象。 2.4.2 Class类中与Constructor相关方法123456789101112131. Constructor getConstructor(Class... parameterTypes) 根据参数类型获取构造方法对象，只能获得public修饰的构造方法。 如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。 2. Constructor getDeclaredConstructor(Class... parameterTypes) 根据参数类型获取构造方法对象，包括private修饰的构造方法。 如果不存在对应的构造方法，则会抛出 java.lang.NoSuchMethodException 异常。 3. Constructor[] getConstructors() 获取所有的public修饰的构造方法 4. Constructor[] getDeclaredConstructors() 获取所有构造方法，包括privat修饰的 2.4.3 Constructor类中常用方法12341. T newInstance(Object... initargs) 根据指定参数创建对象。2. void setAccessible(true) 暴力反射，设置为可以直接访问私有类型的构造方法。 2.4.4 示例代码 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Student &#123; // 属性 private String name; private int age; private char gender; // 公开构造方法 : public Student(String name, int age, char gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; // 私有构造方法 : private Student(String name, int age) &#123; this.name = name; this.age = age; &#125; // 公开无参构造方法 public Student() &#123; &#125; // 行为 @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender=" + gender + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125;&#125; 测试一 : 123456789101112131415161718 @Test public void testConstructor1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getConstructor 方法 Constructor&lt;?&gt; constructor = cls.getConstructor(String.class, int.class, char.class); // 3. 调用 Constructor 对象的 newInstance 方法, 创建对象 Object obj = constructor.newInstance("柳岩", 18, '女'); // 4. 查看创建的对象 System.out.println("obj = " + obj); &#125;输出结果 :obj = Student&#123;name='柳岩', age=18, gender=女&#125; 测试二 : 123456789101112131415161718192021 @Test public void testDeclaredConstructor2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getDeclaredConstructor 方法 Constructor&lt;?&gt; constructor = cls.getDeclaredConstructor(String.class, int.class); // 3. 暴力反射 (设置可访问权限) constructor.setAccessible(true); // 4. 调用 Constructor 对象的 newInstance 方法, 创建对象 Object obj = constructor.newInstance("柳岩", 18); // 5. 查看创建的对象 System.out.println("obj = " + obj); &#125;输出结果 :obj = Student&#123;name='柳岩', age=18, gender= &#125; 测试三 : 123456789101112131415161718 @Test public void testConstructors3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getConstructors 方法 Constructor&lt;?&gt;[] constructors = cls.getConstructors(); // 3. 遍历构造方法数组 for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125;输出结果 : (不包含私有的构造方法)public cn.itcast.test2.Student()public cn.itcast.test2.Student(java.lang.String,int,char) 测试四 : 12345678910111213141516171819 @Test public void testDeclaredConstructors4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getDeclaredConstructors 方法 Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors(); // 3. 遍历构造方法数组 for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; &#125;输出结果 :public cn.itcast.test2.Student()private cn.itcast.test2.Student(java.lang.String,int)public cn.itcast.test2.Student(java.lang.String,int,char) 2.5 获取Class对象的Method信息​ 操作完构造方法之后，就来看看反射怎么操作成员方法了。同样的在操作成员方法之前我们需要学习一个类：Method类。 2.5.1 Method类概述​ Method是方法类，类中的每一个方法都是Method的对象，通过Method对象可以调用方法。 2.5.2 Class类中与Method相关方法12345678910111. Method getMethod("方法名", 方法的参数类型... 类型) 根据方法名和参数类型获得一个方法对象，只能是获取public修饰的 2. Method getDeclaredMethod("方法名", 方法的参数类型... 类型) 根据方法名和参数类型获得一个方法对象，包括private修饰的 3. Method[] getMethods() (了解) 获取所有的public修饰的成员方法，包括父类中。4. Method[] getDeclaredMethods() (了解) 获取当前类中所有的方法，包含私有的，不包括父类中。 2.5.3 Method类中常用方法1234561. Object invoke(Object obj, Object... args) 根据参数args调用对象obj的该成员方法 如果obj=null，则表示该方法是静态方法 2. void setAccessible(boolean flag) 暴力反射，设置为可以直接调用私有修饰的成员方法 2.5.4 示例代码测试一 : 12345678910111213141516 @Test public void testMethod1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getMethod 方法 Method eat = cls.getMethod("eat", String.class); // 3. 调用 invoke 方法 Object obj = cls.getDeclaredConstructor().newInstance(); eat.invoke(obj, "牛肉"); &#125;输出结果 :正在吃牛肉 测试二 : 12345678910111213141516171819 @Test public void testDeclaredMethod2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 declaredMethod 方法 Method sleep = cls.getDeclaredMethod("fallInLove"); // 3. 暴力反射 (设置可访问权限) sleep.setAccessible(true); // 4. 调用 invoke 执行 Object obj = cls.getDeclaredConstructor().newInstance(); sleep.invoke(obj); &#125;输出结果 :正在谈恋爱 ... 测试三 : 123456789101112131415 @Test public void testStaticMethod3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getMethod 方法 Method study = cls.getMethod("study"); // 3. 调用 invoke 方法 study.invoke(null); &#125;输出结果 :正在学习中 ... 测试四 : 123456789101112131415161718192021222324252627282930313233 @Test public void tesMethods4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getMethods 方法 Method[] methods = cls.getMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;输出结果 : (获取所有的公开访问权限方法, 包含父类继承的)public java.lang.String cn.itcast.test2.Student.toString()public java.lang.String cn.itcast.test2.Student.getName()public void cn.itcast.test2.Student.setName(java.lang.String)public static void cn.itcast.test2.Student.study()public void cn.itcast.test2.Student.eat(java.lang.String)public void cn.itcast.test2.Student.setGender(char)public char cn.itcast.test2.Student.getGender()public int cn.itcast.test2.Student.getAge()public void cn.itcast.test2.Student.setAge(int)public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 测试五 : 1234567891011121314151617181920212223242526 @Test public void tesDelcaredMethods5() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getDeclaredMethods 方法 Method[] methods = cls.getDeclaredMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; System.out.println(method); &#125; &#125;输出结果 : (获取本类的所有方法, 私有和非私有, 但不包含父类中继承而来的方法)public java.lang.String cn.itcast.test2.Student.toString()public java.lang.String cn.itcast.test2.Student.getName()public void cn.itcast.test2.Student.setName(java.lang.String)public void cn.itcast.test2.Student.eat(java.lang.String)private void cn.itcast.test2.Student.fallInLove()public static void cn.itcast.test2.Student.study()public int cn.itcast.test2.Student.getAge()public void cn.itcast.test2.Student.setAge(int)public char cn.itcast.test2.Student.getGender()public void cn.itcast.test2.Student.setGender(char) 2.6 获取Class对象的Field信息(了解)2.6.1 Field类概述​ Field是属性类，类中的每一个属性(成员变量)都是Field的对象，通过Field对象可以给对应的成员变量赋值和取值。 2.6.2 Class类中与Field相关方法12345678910111. Field getDeclaredField(String name) 根据属性名获得属性对象，包括private修饰的 2. Field getField(String name) 根据属性名获得属性对象，只能获取public修饰的 3. Field[] getFields() 获取所有的public修饰的属性对象，返回数组。 4. Field[] getDeclaredFields() 获取所有的属性对象，包括private修饰的，返回数组。 2.6.3 Field类中常用方法12345void set(Object obj, Object value) Object get(Object obj) void setAccessible(true);暴力反射，设置为可以直接访问私有类型的属性。Class getType(); 获取属性的类型，返回Class对象。 2.6.4 示例代码测试一 : 1234567891011121314151617181920 @Test public void testField1() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getField 方法 Field description = cls.getField("description"); // 3. 设置属性 Object obj = cls.getDeclaredConstructor().newInstance(); description.set(obj, "这就是那个神奇的学生."); // 4. 获取属性 Object desc = description.get(obj); System.out.println("desc = " + desc); &#125;输出结果 :desc = 这就是那个神奇的学生. 测试二 : 12345678910111213141516171819202122 @Test public void testDeclaredField2() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getDeclaredField 方法 Field name = cls.getDeclaredField("name"); // 3. 暴力反射 name.setAccessible(true); // 4. 设置属性 Object obj = cls.getDeclaredConstructor().newInstance(); name.set(obj, "渣渣辉"); // 5. 查看 System.out.println(obj); &#125;输出结果 :Student&#123;name='渣渣辉', age=0, gender= &#125; 测试三 : 1234567891011121314151617 @Test public void testFields3() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getFields 方法 Field[] fields = cls.getFields(); // 3. 遍历 fields 数组 for (Field field : fields) &#123; System.out.println(field); &#125; &#125;输出结果 :public java.lang.String cn.itcast.test2.Student.description 测试四 : 1234567891011121314151617181920 @Test public void testDeclaredFields4() throws Exception &#123; // 1. 获取 Student 类表示的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.test2.Student"); // 2. 调用 getDeclaredFields 方法 Field[] fields = cls.getDeclaredFields(); // 3. 遍历 fields 数组 for (Field field : fields) &#123; System.out.println(field); &#125; &#125;输出结果 :private java.lang.String cn.itcast.test2.Student.nameprivate int cn.itcast.test2.Student.ageprivate char cn.itcast.test2.Student.genderpublic java.lang.String cn.itcast.test2.Student.description 2.7 反射案例2.7.1 案例说明​ 编写一个工厂方法可以根据配置文件产任意类型的对象。 例如有配置文件stu.properties，存储在当前项目下，内容如下： 1234className=cn.itcast.reflect.Studentname=roseage=18gender=女 根据配置文件信息创建一个学生对象。 2.7.2 案例代码Student 类 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Student &#123; // 属性 private String name; private int age; private char gender; // 公开构造方法 : public Student(String name, int age, char gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; // 公开无参构造方法 public Student() &#123; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender=" + gender + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getGender() &#123; return gender; &#125; public void setGender(char gender) &#123; this.gender = gender; &#125;&#125; CreateObject 类 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Field;import java.util.Properties;import java.util.Set;public class CreateObject &#123; // 属性 private static Properties prop; // 静态方法 : 加载配置文件 static &#123; // 初始化 : prop = new Properties(); try &#123; prop.load(new FileReader("stu.properties")); &#125; catch (IOException e) &#123; // e.printStackTrace(); throw new RuntimeException("配置文件加载失败!"); &#125; &#125; // 方法 : 根据配置文件, 创建对象 public static Object createObject() throws Exception &#123; // 1. 获取 class 名称 String className = prop.getProperty("className"); // 2. 获取 class 对象 Class&lt;?&gt; cls = Class.forName(className); // 3. 创建一个 cls 表示的对象 Object obj = cls.getDeclaredConstructor().newInstance(); // 4. 获取属性集对象的所有 `键集` Set&lt;String&gt; keys = prop.stringPropertyNames(); // 5. 遍历 for (String key : keys) &#123; // 判断 : if ("className".equals(key)) continue; // 6. 根据 key 获取对应的 value String value = prop.getProperty(key); // 7. 获取所有的 fields 数组 Field field = cls.getDeclaredField(key); // 8. 设置访问权限 field.setAccessible(true); // 9. 获取属性的类型 Class&lt;?&gt; type = field.getType(); // 10. 判断类型 if (type == int.class) &#123; int v = Integer.parseInt(value); // 设置属性 field.set(obj, v); &#125; else if (type == char.class) &#123; char c = value.charAt(0); // 设置属性 field.set(obj, c); &#125; else &#123; field.set(obj, value); &#125; &#125; // 11. 返回对象 return obj; &#125;&#125; 测试类 : 12345678910public class Test &#123; public static void main(String[] args) throws Exception &#123; Object obj = CreateObject.createObject(); System.out.println("obj = " + obj); &#125;&#125;输出结果 :obj = Student&#123;name='rose', age=18, gender=女&#125; 2.7.4 案例小结​ 该反射案例的目的是让同学们感受反射机制的强大之处，在后面即将学习的Spring框架中就会有大量根据配置文件信息创建对象的过程，其内部的原理和我们这个案例的原理是一样，有这个案例做基础，以后学到spring框架时就会容易理解了。 第3章 注解3.1 注解的概述3.1.1 注解的概念 注解是JDK1.5的特性。 注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。 标记(注解)可以加在包，类，字段，方法，方法参数以及局部变量上。 注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。 注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。 3.1.2 注解的作用 注解的作用就是给程序带入参数。 以下几个常用操作中都使用到了注解： 生成帮助文档：@author和@version @author：用来标识作者姓名。 @version：用于标识对象的版本号，适用范围：文件、类、方法。 使用@author和@version注解就是告诉Javadoc工具在生成帮助文档时把作者姓名和版本号也标记在文档中。如下图： 编译检查：@Override @Override：用来修饰方法声明。 用来告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。如下图 框架的配置(框架=代码+配置) 具体使用请关注框架课程的内容的学习。 3.1.3 常见注解 @author：用来标识作者名。 @version：用于标识对象的版本号。 @Override ：用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。 @Deprecated: 用来表示不赞成使用. 3.2 自定义注解3.2.1 定义格式12345678public @interface 注解名 &#123;&#125;如：定义一个名为 Student 的注解public @interface Student &#123;&#125; 以上定义出来的注解就是一个最简单的注解了，但这样的注解意义不大，因为注解中没有任何内容，就好像我们定义一个类而这个类中没有任何成员变量和方法一样，这样的类意义也是不大的，所以在定义注解时会在里面添加一些成员来让注解功能更加强大，这些成员就是属性。接下来就看看怎么给注解添加属性。 3.2.2 注解的属性 属性的作用 可以让用户在使用注解时传递参数，让注解的功能更加强大。 属性的格式 格式1：数据类型 属性名(); 格式2：数据类型 属性名() default 默认值; 属性定义示例 123456789// 该注解拥有三个属性 (name, age, gender)public @interface Student &#123; String name(); int age() default 18; char gender() default '男';&#125; 属性适用的数据类型 八种基本数据类型（byte, short, int, long, float, double, char, boolean) String类型，Class类型，枚举类型，注解类型 以上所有类型的一维数组 3.3 使用自定义注解3.3.1 定义注解 定义一个注解：Book 包含属性：String value() 书名 包含属性：double price() 价格，默认值为 100 包含属性：String[] authors() 多位作者 说明 : 当注解中只有一个属性且名称是value，在使用注解时给value属性赋值可以直接给属性值，无论value是单值元素还是数组类型。 代码实现 12345678public @interface Book &#123; // 书名 String value(); // 价格 int price() default 100; // 多位作者 String[] authors();&#125; 3.3.2 使用注解 定义类在成员方法上使用Book注解 1234567public class BookShelf &#123; @Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;) public void show() &#123; &#125;&#125; 使用注意事项 如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。 如果属性没有默认值，那么在使用注解时一定要给属性赋值。 3.4 注解之元注解3.4.1 元注解的概述 Java API 提供的注解 专门用来定义注解的注解。 任何 Java 官方提供的非元注解的定义中都使用到了元注解。 3.4.2 常用元注解 @Target 注释的使用位置. @Retention 注解的生命周期. 3.4.2.1 元注解之@Target 作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用。 可选的参数值在枚举类ElemenetType中包括： 123456TYPE： 用在类,接口上FIELD：用在成员变量上METHOD： 用在方法上PARAMETER：用在参数上CONSTRUCTOR：用在构造方法上LOCAL_VARIABLE：用在局部变量上 3.4.2.2 元注解之@Retention 作用：定义该注解的生命周期(有效范围)。 可选的参数值在枚举类型RetentionPolicy中包括 123SOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了。CLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值。RUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解。 3.4.3 元注解使用示例1234567891011121314151617181920// (书名, 价格, 作者)import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;// 元注解 : Target 目标 (注解使用的位置)@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)// 元注解 : Retention 保留策略 (SOURCE, CLASS, RUNTIME)@Retention(RetentionPolicy.RUNTIME)public @interface Book &#123; String value(); // 说明 : 如果注解只有一个属性, 最好取名为 value, 因为书写时, 可以省略. int price() default 100; String[] authors(); // 多位作者&#125; BookShelf 类 1234567891011121314151617@Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;)public class BookShelf &#123; // 属性 // @Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;) private int id; @Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;) public void show() &#123; String value = ""; int price = 0; String[] authors = &#123;&#125;; System.out.println("书名为 : " + value); System.out.println("价格为 : " + price); System.out.println("作者为 : " + Arrays.toString(authors)); &#125;&#125; 3.5 注解解析3.5.1 什么是注解解析 通过Java技术获取注解数据的过程则称为注解解析。 3.5.2 与注解解析相关的接口 Anontation：所有注解类型的公共接口，类似所有类的父类是Object。 AnnotatedElement：定义了与注解解析相关的方法，常用方法： 12boolean isAnnotationPresent(Class annotationClass); 判断当前对象是否有指定的注解，有则返回true，否则返回false。T getAnnotation(Class&lt;T&gt; annotationClass); 获得当前对象上指定的注解对象。 3.5.3 获取注解数据的原理 注解作用在那个成员上，就通过反射获得该成员的对象(Filed)来得到它的注解。 如注解作用在方法上，就通过方法(Method)对象得到它的注解* 如注解作用在类上，就通过Class对象得到它的注解 3.5.4 使用反射获取注解的数据3.5.4.1 需求说明 定义注解Book，要求如下： 包含属性：String value() 书名 包含属性：double price() 价格，默认值为 100 包含属性：String[] authors() 多位作者 限制注解使用的位置：类和成员方法上 指定注解的有效范围：RUNTIME 定义BookStore类，在类和成员方法上使用Book注解 定义TestAnnotation测试类获取Book注解上的数据 3.5.4.2 代码实现1.注解Book 123456789101112131415import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Book &#123; // 书名 String value(); // 价格 int price() default 100; // 作者 (多位作者) String[] authors();&#125; 2.BookShelf 类 1234567891011121314151617181920212223242526272829303132333435363738394041import java.lang.reflect.Method;import java.util.Arrays;@Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;)public class BookShelf &#123; // 属性 // @Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;) private int id; @Book(value = "西游记", price=998, authors = &#123;"吴承恩", "白求恩"&#125;) public void show() &#123; // 定义变量 String value = ""; int price = 0; String[] authors = &#123;&#125;; // 获取当前类的 Class 对象 Class&lt;? extends BookShelf&gt; cls = this.getClass(); try &#123; // 获取当前方法对象 Method show = cls.getMethod("show"); // 判断当前方法上是否有注解信息 if (show.isAnnotationPresent(Book.class)) &#123; // 条件成立, 获取到当前注解对象 Book book = show.getAnnotation(Book.class); // 取出信息, 并实现赋值 value = book.value(); price = book.price(); authors = book.authors(); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; // 输出查看 System.out.println("书名为 : " + value); System.out.println("价格为 : " + price); System.out.println("作者为 : " + Arrays.toString(authors)); &#125;&#125; 3.TestBookShelf 类 12345678910111213141516public class TestBookShelf &#123; public static void main(String[] args) &#123; BookShelf bookShelf = new BookShelf(); bookShelf.show(); &#125;&#125;输出结果 :书名为 : 西游记价格为 : 998作者为 : [吴承恩, 白求恩]书名为 : 价格为 : 0作者为 : [] 补充 : 解析类上的注解 123456789101112131415161718192021222324252627import java.util.Arrays;public class TestBookShelf2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 1. 获取类 Class&lt;?&gt; cls = Class.forName("cn.itcast.annotation.BookShelf"); // 2. 判断该类上是否有 Book 注解信息 if (cls.isAnnotationPresent(Book.class)) &#123; // 3. 获取 Book 注解对象 Book book = cls.getAnnotation(Book.class); // 4. 取出注解信息 String value = book.value(); int price = book.price(); String[] authors = book.authors(); // 5. 输出查看 System.out.println("value = " + value); System.out.println("price = " + price); System.out.println("authors = " + Arrays.toString(authors)); &#125; &#125;&#125;输出结果 :value = 西游记price = 998authors = [吴承恩, 白求恩] 3.6 注解案例3.5.1 案例说明​ 模拟Junit测试的@Test 3.5.2 案例分析 模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。 然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。 最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行。 3.5.3 案例代码 注解MyTest 123456789import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyTest &#123;&#125; 目标类MyTestClass 12345678910111213141516public class MyTestClass &#123; @MyTest public void test01() &#123; System.out.println("测试方法一被执行 ..."); &#125; public void test02() &#123; System.out.println("测试方法二被执行 ..."); &#125; @MyTest public void test03() &#123; System.out.println("测试方法三被执行 ..."); &#125;&#125; 调用类ParseAnnotation 1234567891011121314151617181920212223242526272829import java.lang.reflect.Method;// 解析注解类 :public class ParseAnnotation &#123; public static void main(String[] args) throws Exception &#123; // 1. 获取 MyTestClass 的 Class 对象 Class&lt;?&gt; cls = Class.forName("cn.itcast.practice.MyTestClass"); Object obj = cls.getDeclaredConstructor().newInstance(); // 2. 调用 getMethods 获取所有方法 Method[] methods = cls.getMethods(); // 3. 遍历 methods 数组 for (Method method : methods) &#123; // 4. 判断当前方法上是否存在 MyTest 注解 if (method.isAnnotationPresent(MyTest.class)) &#123; // 5. 执行当前方法 method.invoke(obj); &#125; &#125; &#125;&#125;输出结果 :测试方法一被执行 ...测试方法三被执行 ...]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶11-网络编程]]></title>
    <url>%2F2019%2F08%2F25%2F2019-08-25-Java%E8%BF%9B%E9%98%B611-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[主要内容 软件架构CS／BS 网络通信三要素 TCP通信 Socket套接字 ServerSocket 学习目标 能够辨别UDP和TCP协议特点 能够说出TCP协议下两个常用类名称 能够编写UDP协议下字符串数据传输程序 能够编写TCP协议下字符串数据传输程序 能够理解TCP协议下文件上传案例 能够理解TCP协议下BS案例 第一章 网络编程入门1.1软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 1.2 网络通信协议 网络通信协议：通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 1.3 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。 第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。 ​ 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。 1.4 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 12ping 空格 IP地址ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 被称为 本机回环地址. 端口号网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？ 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 第二章 TCP通信程序2.1 概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 类表示。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 类表示。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 2.2 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 构造举例，代码如下： 1Socket client = new Socket("127.0.0.1", 6666); 成员方法 public InputStream getInputStream() ： 返回此套接字的输入流。 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() ： 返回此套接字的输出流。 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() ：关闭此套接字。 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流。 2.3 ServerSocket类 ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。 构造举例，代码如下： 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 2.4 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 客户端向服务器发送数据服务端实现： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端启动, 等待连接 ..."); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取 socket 通道输入流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 4. 解析数据 String str = new String(buf, 0, len); System.out.println("服务端读取的数据为 : " + str); &#125; // 5. 关闭资源 serverSocket.close(); System.out.println("服务端关闭, 结束连接."); &#125;&#125;输出结果 :服务端启动, 等待连接 ...服务端读取的数据为 : hello, 小姐姐, 约吗?服务端关闭, 结束连接. 客户端实现： 1234567891011121314151617181920import java.io.IOException;import java.io.OutputStream;import java.net.Socket;public class ClientTCP &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字, 尝试连接服务器 Socket socket = new Socket("127.0.0.1", 8888); // 2. 获取 socket 通道输出流 OutputStream out = socket.getOutputStream(); // 3. 输出数据 out.write("hello, 小姐姐, 约吗?".getBytes()); // 4. 关闭资源 socket.close(); &#125;&#125; 服务器向客户端回写数据服务端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端启动, 等待连接 ..."); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取 socket 通道输入流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 4. 解析数据 String str = new String(buf, 0, len); System.out.println("服务端读取的数据为 : " + str); &#125; /*************** 服务端实现数据回写 ****************/ // 5. 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 6. 回写数据 out.write("不约, 叔叔.".getBytes()); // 注意 : 需要调用 socket.shutdown(); 方法, 向 socket 通道中写出结束符 socket.shutdownOutput(); // 7. 关闭资源 serverSocket.close(); System.out.println("服务端关闭, 结束连接."); &#125;&#125;输出结果 :服务端启动, 等待连接 ...服务端读取的数据为 : hello, 小姐姐, 约吗?服务端关闭, 结束连接. 客户端实现： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class ClientTCP &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字, 尝试连接服务器 Socket socket = new Socket("127.0.0.1", 8888); // 2. 获取 socket 通道输出流 OutputStream out = socket.getOutputStream(); // 3. 输出数据 out.write("hello, 小姐姐, 约吗?".getBytes()); // 注意 : 需要调用 socket.shutdown(); 方法, 向 socket 通道中写出结束符 socket.shutdownOutput(); /*************** 客户端解析回写数据 ****************/ // 4. 获取 socket 通道的输入流 InputStream in = socket.getInputStream(); // 5. 读取, 并解析回写数据 byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; String str = new String(buf, 0, len); System.out.println("客户端读写服务端的回写数据为 : " + str); &#125; // 6. 关闭资源 socket.close(); &#125;&#125;输出结果 :客户端读写服务端的回写数据为 : 不约, 叔叔. 第三章 综合案例3.1 文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端已启动, 等待客户端连接."); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File("D:/upload"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 String ip = socket.getInetAddress().getHostAddress(); File file = new File(parentFile, ip + ".jpg"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write("上传成功!".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); // 6. 关闭资源 serverSocket.close(); System.out.println("文件保存成功!"); &#125;&#125;输出结果 :服务端已启动, 等待客户端连接.文件保存成功! 客户端实现： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.net.Socket;public class FileUploadClient &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个客户端套接字对象, 尝试连接服务端 Socket socket = new Socket("127.0.0.1", 8888); // 2. 复制文件 (先读后写) // 2.1 创建一个高效的字节缓冲输入流, 关联硬盘路径文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("D:/柳岩.jpg")); // 2.2 创建一个高效的字节缓冲输出流, 关联 socket 通道输出流 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 3. 读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 注意 : 向通道中写入一个结束符 socket.shutdownOutput(); // 4. 读取服务端的反馈信息 // 4.1 获取 socket 通道的输入流 InputStream in = socket.getInputStream(); byte[] readBuf = new byte[1024]; int readLen = -1; while ((readLen = in.read(readBuf)) != -1) &#123; String str = new String(readBuf, 0, readLen); System.out.println(str); &#125; // 5. 关闭资源 socket.close(); &#125;&#125;输出结果 :上传成功! 文件上传优化分析 :问题1 : 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+".jpg") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 使用 UUID 类解决图片名称的问题 : 1234for (int i = 0; i &lt; 10; i++) &#123; String name = UUID.randomUUID().toString().replaceAll("-", ""); System.out.println(name + ".jpg");&#125; 输出结果 : 12345678910345154742a884d0c8d38a981b06d0f51.jpg828cade0a69b485983efa2efb6c2edf8.jpg2522a1462142450195a32997aa00968b.jpg0fb24406d79b40dcbefdd99298224d8f.jpg8d9f7ed4cf12430ba4b9904bc17541a3.jpg558fc7d91f614ae6845958cc81f9cfb6.jpg5ede501fbd624f9d8d021f582da73219.jpg5b51a105b3cf473ba0e2751029411ec9.jpg42ea3479a85b4c7db915335302661515.jpg89e58cb12a014c5faa83b6bb99a33ca6.jpg 问题2 : 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 问题3 : 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现 : 实现类完成123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端已启动, 等待客户端连接."); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 UploadTask uploadTask = new UploadTask(socket); new Thread(uploadTask, "上传线程").start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125;输出结果 :服务端已启动, 等待客户端连接.文件保存成功!文件保存成功! 实现类 : UploadTask 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.*;import java.net.Socket;public class UploadTask implements Runnable &#123; // 属性 private Socket socket; // 构造方法 public UploadTask(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File("D:/upload"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + ".jpg"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write("上传成功!".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("文件保存成功!"); &#125;&#125; 匿名内部类实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端已启动, 等待客户端连接."); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File("D:/upload"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + ".jpg"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write("上传成功!".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("文件保存成功!"); &#125; &#125;, "上传线程").start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125; Lambda 表达式实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.*;import java.net.ServerSocket;import java.net.Socket;/*文件上传 : TCP 服务端 数据源 : socket 通道. 目的地 : 硬盘路径 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端已启动, 等待客户端连接."); // 1. 创建一个服务端套接字 ServerSocket serverSocket = new ServerSocket(8888); // 2. 循环接收客户端连接请求 while (true) &#123; // 2. 等待接收客户端的请求 Socket socket = serverSocket.accept(); // 3. 将上传文件的耗时操作放到子线程单独执行, 不要影响主线程接收客户端的连接请求 new Thread(() -&gt; &#123; try &#123; // 3. 复制文件 (先读后写) // 3.1 创建一个高效的字节缓冲输入流对象, 关联 socket 通道输入流 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); // 3.2 创建一个高效的字节缓冲输出流对象, 关联硬盘路径 File parentFile = new File("D:/upload"); // 3.2.1 判断文件夹是否存在 if (parentFile.exists() == false) &#123; parentFile.mkdirs(); &#125; // 3.2.2 拼接文件对象 File file = new File(parentFile, System.currentTimeMillis() + ".jpg"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 4. 执行读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 5. 回送上传成功信息 // 5.1 获取 socket 通道的输出流 OutputStream out = socket.getOutputStream(); // 5.2 写入信息 out.write("上传成功!".getBytes()); // 5.3 向通道内写入结束符 socket.shutdownOutput(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("文件保存成功!"); &#125;).start(); &#125; // 6. 关闭资源 // serverSocket.close(); &#125;&#125; 3.2 模拟服务器模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 复制到当前项目中. 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910111213141516171819202122232425import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String str = new String(buf, 0, len); System.out.println(str); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125; 返回数据内容 : 1234567GET / HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:8888Connection: Keep-Alive 返回数据内容 : 1234567GET /web/index.html HTTP/1.1Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-Hans-CN,zh-Hans;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:8888Connection: Keep-Alive GET /web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); // 读取数据的第一行 String line = reader.readLine(); System.out.println("line = " + line); // GET /web/index.html HTTP/1.1 // 切割字符 String[] split = line.split(" "); // 取出需要的一部分 String path = split[1].substring(1); System.out.println("path = " + path); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125;输出结果如下 :line = GET /web/index.html HTTP/1.1path = web/index.html 案例实现服务器向浏览器回送数据的HTTP协议响应固定头书写格式 : 12345// 写入HTTP协议响应头,固定写法bos.write("HTTP/1.1 200 OK\r\n".getBytes());bos.write("Content-Type:text/html\r\n".getBytes());// 必须要写入空行,否则浏览器不解析bos.write("\r\n".getBytes()); 服务端实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); // 读取数据的第一行 String line = reader.readLine(); System.out.println("line = " + line); // GET /web/index.html HTTP/1.1 // 切割字符 String[] split = line.split(" "); // 取出需要的一部分 String path = split[1].substring(1); System.out.println("path = " + path); /*************** 读取客户端请求的资源文件 ***************/ // A: 创建高效的缓冲输入流, 与资源文件绑定 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path)); // B: 创建高效的缓冲输出流, 与 socket 通道输出流绑定 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 写入HTTP协议响应头,固定写法 bos.write("HTTP/1.1 200 OK\r\n".getBytes()); bos.write("Content-Type:text/html\r\n".getBytes()); // 必须要写入空行,否则浏览器不解析 bos.write("\r\n".getBytes()); // C: 读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // D: 关闭资源 bos.close(); bis.close(); // 4. 关闭服务端套接字 serverSocket.close(); &#125;&#125; 访问效果edge浏览器 : chrome浏览器 : 火狐浏览器 : 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 说明 : 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入多线程技术。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个服务端套接字对象, 绑定端口号为 8888 ServerSocket serverSocket = new ServerSocket(8888); while (true) &#123; // 2. 等待客户端连接 Socket socket = serverSocket.accept(); // 3. 启动子线程 new Thread(new WebImage(socket)).start(); &#125; // 4. 关闭服务端套接字 // serverSocket.close(); &#125; // 定义一个静态内部类 : private static class WebImage implements Runnable &#123; // 属性 private Socket socket; public WebImage(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; // 3. 获取通道输出流, 读取数据 InputStream in = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); // 读取数据的第一行 String line = reader.readLine(); System.out.println("line = " + line); // GET /web/index.html HTTP/1.1 // 切割字符 String[] split = line.split(" "); // 取出需要的一部分 String path = split[1].substring(1); System.out.println("path = " + path); /*************** 读取客户端请求的资源文件 ***************/ // A: 创建高效的缓冲输入流, 与资源文件绑定 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path)); // B: 创建高效的缓冲输出流, 与 socket 通道输出流绑定 BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); // 写入HTTP协议响应头,固定写法 bos.write("HTTP/1.1 200 OK\r\n".getBytes()); bos.write("Content-Type:text/html\r\n".getBytes()); // 必须要写入空行,否则浏览器不解析 bos.write("\r\n".getBytes()); // C: 读写操作 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // D: 关闭资源 bos.close(); bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 访问效果： edge浏览器 : chrome浏览器 : 火狐浏览器 : 练习题练习一:ip地址和端口号概念描述: 一、请写出IP地址的概念： 二、请写出端口号的概念： 答案: IP地址:互联网协议地址(Internet Protocol Address),俗称IP.IP地址用来给一个网络中的计算机设备做唯一的编号. 端口号:端口号用来给计算机里的应用程序(进程)做唯一的标识,用2个字节表示的整数,取值范围0~65535. 练习二:UDP协议判断下列说法是否正确 由于UDP面向无连接的协议,可以保证数据完整性,因此在传输重要数据时采用UDP协议. 答案 判断错误,因为面向无连接,容易丢失包,所以不能保证数据完整. 练习三:TCP协议TCP协议中”三次握手”,第一次握手指的是什么： 答案 第一次握手:客户端向服务器发送请求,等待服务器确认 练习四:ServerSocket以下哪个方法是ServerSocket类用于接收来自客户端请求： A. receive() B. accept() C. set() D. send() 答案：B 练习五:TCP网络程序需求说明：创建新项目，按以下要求编写代码： 在项目下创建TCP 服务器端 端口号为8888 1:等待客户端连接 如果有客户端连接 获取到客户端对象 2:获取到客户端对象之后 当前在服务器读取数据客户端传送数据 答案： 12345678910111213141516171819public class TCPServer &#123; public static void main(String[] args) throws Exception &#123; //1创建服务器对象 ServerSocket ss = new ServerSocket(8888); //2等待客户端连接 如果有客户端连接 获取到客户端对象 Socket socket = ss.accept(); //3当前在服务器中 要读取数据 需要输入流 流由谁提供 客户端 InputStream in = socket.getInputStream();//获取输入流 //4:读数据 int len; byte[] buffer = new byte[1024]; while((len=in.read(buffer))!=-1)&#123; System.out.println(new String(buffer, 0, len)); &#125; //释放资源 in.close();// ss.close();服务器一般不会关闭 &#125;&#125; 练习六:TCP网络程序需求说明：创建新项目，按以下要求编写代码： 在项目下创建TCP 客户端 访问之前创建的服务器端,服务器端ip127.0.0.1 端口号8888 1:客户端连接服务器,并发送 hello.服务器,我是客户端. 2:开启上一题服务器,等待客户端连接,客户端连接并发送数据 答案: 12345678910111213public class TCPClient &#123; public static void main(String[] args) throws Exception &#123; //创建 Socket客户端对象 Socket socket = new Socket("127.0.0.1", 8888); //写数据 需要输出流 谁提供 客户端 OutputStream out = socket.getOutputStream(); //写数据 out.write("hello.服务器,我是客户端.".getBytes()); //释放资源 out.close(); socket.close(); &#125;&#125; 练习七:TCP程序需求说明：使用TCP编写一个网络程序,设置服务器程序监听端口为8002,当于客户端建立后,向客户端发送”hello world”,客户端将信息输出 答案 操作步骤: 建立项目 创建TCPServer类,包含main()方法 使用ServerSocket创建服务器对象,监听8002端口,调用accept()方法等待客户端连接,当于客户端连接上之后,获取输出流对象,输出”hello world” 创建TCPClient类，包含main()方法 使用Socket创建客户端对象,指定服务器IP和端口号,与服务器端建立连接后,获取输入流对象,读取数据,并打印. 代码: 1234567891011121314151617181920212223242526272829public class TCPClient &#123; public static void main(String[] args) throws Exception &#123; //创建 Socket客户端对象 Socket socket = new Socket("127.0.0.1", 8002); //读服务器数据 InputStream in = socket.getInputStream();//获取输入流 //读数据 byte[] buffer = new byte[1024]; int len = in.read(buffer); System.out.println(new String(buffer, 0, len)); //释放资源 in.close(); socket.close(); &#125;&#125;public class TCPServer &#123; public static void main(String[] args) throws Exception &#123; //1创建服务器对象 ServerSocket ss = new ServerSocket(8002); //2等待客户端连接 如果有客户端连接 获取到客户端对象 Socket socket = ss.accept(); //3当前在服务器中 将数据写到流中 OutputStream out = socket.getOutputStream(); out.write("hello world".getBytes()); //释放资源 out.close();// ss.close();服务器一般不会关闭 &#125;&#125; 练习八:TCP上传案例需求说明：我们来做一个“文件上传案例”，有以下要求： 将项目中的一个图片,通过客户端上传至服务器 答案 操作步骤: 1,创建服务器，等待客户端连接 2,创建客户端Socket，连接服务器 3,获取Socket流中的输出流，功能：用来把数据写到服务器 4,创建字节输入流，功能：用来读取数据源(图片)的字节 5,把图片数据写到Socket的输出流中(把数据传给服务器) 6,客户端发送数据完毕，结束Socket输出流的写入操作，告知服务器端 7,获取Socket的输入流 8,创建目的地的字节输出流 9,把Socket输入流中的数据，写入目的地的字节输出流中 10,获取Socket的输出流, 作用：写反馈信息给客户端 11,写反馈信息给客户端 12,获取Socket的输入流 作用： 读反馈信息 13,读反馈信息 代码: 1234567891011121314151617181920212223public class TCPServer &#123; public static void main(String[] args)throws IOException &#123; //1创建服务器对象 ServerSocket server = new ServerSocket(9898); //2等待客户端连接 如果有客户端连接 获取到客户端对象 Socket s = server.accept(); //3当前在服务器中 读取数据 InputStream in = s.getInputStream(); //4当前在服务器中 将数据写到流中 FileOutputStream fos = new FileOutputStream("/Users/apple/Documents/复制品.JPG"); byte[] bytes = new byte[1024]; int len = 0 ; while((len = in.read(bytes))!=-1)&#123; fos.write(bytes, 0, len); &#125; //5写完数据提示上传成功 s.getOutputStream().write("上传成功".getBytes()); //6释放资源 fos.close(); s.close(); server.close(); &#125;&#125; 123456789101112131415161718192021222324public class TCPCleint &#123; public static void main(String[] args)throws IOException &#123; //1创建服务器对象 Socket s = new Socket("127.0.0.1", 9898); //2指定路径 FileInputStream fis = new FileInputStream("/Users/apple/Desktop/1.JPG"); //3读取服务器数据 OutputStream out = s.getOutputStream(); byte[] bytes = new byte[1024]; int len = 0; while((len = fis.read(bytes))!=-1) &#123; out.write(bytes,0,len); &#125; //4告知书写完毕 s.shutdownOutput(); //5书写到服务器 InputStream in = s.getInputStream(); len = in.read(bytes); System.out.println("服务器:"+new String(bytes,0,len)); //6释放资源 fis.close(); s.close(); &#125;&#125; 练习九:上传图片文件客户端需求：把一个图片文件发送到服务端并读取回馈信息。要求判断文件是否存在及格式是否为jpg并要求文件小于2M。 服务端需求：接收客户端发送过来的图片数据。进行存储后，回馈一个“上传成功”字样。支持多用户的并发访问。 客户端代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class MyClient &#123; public static void main(String[] args) throws Exception &#123; File file = new File("D:\\aa.jpg"); if(!file.exists())&#123; return; &#125; if (!file.getName().endsWith(".jpg"))&#123; return; &#125; if (file.length()&gt;=1024*1024*2)&#123; return; &#125; Socket socket = new Socket("127.0.0.1",9999); //输出流 OutputStream outputStream = socket.getOutputStream(); FileInputStream fileInputStream = new FileInputStream(file); int len; byte[] arr = new byte[1024]; while ((len=fileInputStream.read(arr))!=-1)&#123; outputStream.write(arr,0,len); &#125; socket.shutdownOutput(); InputStream inputStream = socket.getInputStream(); int i = inputStream.read(arr); System.out.println(new String(arr,0,i)); fileInputStream.close(); outputStream.close(); socket.close(); &#125;&#125; 服务端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(9999); while (true)&#123; Socket socket = serverSocket.accept(); new Thread()&#123; @Override public void run() &#123; try &#123; InputStream inputStream = socket.getInputStream(); FileOutputStream fileOutputStream = new FileOutputStream(System.currentTimeMillis()+".jpg"); int len; byte[] arr = new byte[1024]; while ((len=inputStream.read(arr))!=-1)&#123; fileOutputStream.write(arr,0,len); &#125; OutputStream outputStream = socket.getOutputStream(); outputStream.write("上传成功".getBytes()); outputStream.close(); fileOutputStream.close(); inputStream.close(); socket.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶10-缓冲流和转换流]]></title>
    <url>%2F2019%2F08%2F25%2F2019-08-25-Java%E8%BF%9B%E9%98%B610-%E7%BC%93%E5%86%B2%E6%B5%81%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%B5%81%2F</url>
    <content type="text"><![CDATA[主要内容 Properties 属性集 转换流 缓冲流 序列化流 打印流 学习目标 能够使用字节缓冲流读取数据到程序 能够使用字节缓冲流写出数据到文件 能够明确字符缓冲流的作用和基本用法 能够使用缓冲流的特殊功能 能够阐述编码表的意义 能够使用转换流读取指定编码的文本文件 能够使用转换流写入指定编码的文本文件 能够说出打印流的特点 能够使用序列化流写出对象到文件 能够使用反序列化流读取文件到程序中 第一章 属性集1.1 概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 1.2 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) ： 保存一对属性。 public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Properties;import java.util.Set;public class PropertiesTest1 &#123; public static void main(String[] args) &#123; // 1. 创建属性集对象 Properties prop = new Properties(); // 2. 添加键值对元素 prop.setProperty("filename", "a.txt"); prop.setProperty("length", "1024"); prop.setProperty("location", "D:/a.txt"); // 3. 打印属性集对象 System.out.println("prop = " + prop); // 4. 通过键,获取属性值 String filename = prop.getProperty("filename"); String length = prop.getProperty("length"); String location = prop.getProperty("location"); System.out.println("filename = " + filename); System.out.println("length = " + length); System.out.println("location = " + location); // 5. 遍历属性集,获取所有键的集合 Set&lt;String&gt; keys = prop.stringPropertyNames(); System.out.println("--------------"); // 6. 打印键值对 for (String key : keys) &#123; String value = prop.getProperty(key); System.out.println(key + " = " + value); &#125; &#125;&#125;输出结果：prop = &#123;filename=a.txt, length=1024, location=D:/a.txt&#125;filename = a.txtlength = 1024location = D:/a.txt--------------filename = a.txtlength = 1024location = D:/a.txt 与流相关的方法 public void load(InputStream inStream)： 从字节输入流中读取键值对。 参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式: 123filename=a.txtlength=209385038location=D:\\a.txt 加载代码演示： 123456789101112131415161718192021222324252627import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;import java.util.Set;public class PropertiesTest2 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个属性集对象 Properties prop = new Properties(); // 2. 加载数据到 prop 对象中 prop.load(new FileInputStream("a.txt")); // 3. 获取所有的 key, 然后实现遍历 Set&lt;String&gt; keys = prop.stringPropertyNames(); for (String key : keys) &#123; String value = prop.getProperty(key); System.out.println(key + " = " + value); &#125; &#125;&#125;输出结果：filename = a.txtlength = 209385038location = D:\a.txt 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 第二章 转换流2.1 字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 字符集 字符集 Charset：是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 2.2 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 12345678910111213141516171819202122232425262728import java.io.FileReader;import java.io.IOException;public class Test1 &#123; public static void main(String[] args) throws IOException &#123; // FileReader reader = new FileReader("a.txt"); FileReader reader = new FileReader("D:/a.txt"); int read = -1; while ((read = reader.read()) != -1) &#123; System.out.println((char) read); &#125; reader.close(); &#125;&#125;输出结果：�������Ա. 那么如何读取GBK编码的文件呢？ 2.3 InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12InputStreamReader isr = new InputStreamReader(new FileInputStream("in.txt"));InputStreamReader isr2 = new InputStreamReader(new FileInputStream("in.txt") , "GBK"); 指定编码读取12345678910111213141516171819202122232425262728293031323334353637import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class Test3 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符转换流对象 (默认为项目编码 UTF-8) InputStreamReader reader1 = new InputStreamReader(new FileInputStream("D:/a.txt")); // 2. 创建一个字符转换流对象 (指定编码为 GBK) InputStreamReader reader2 = new InputStreamReader(new FileInputStream("D:/a.txt"), "GBK"); // 读取数据 int read = -1; while ((read = reader1.read()) != -1) &#123; System.out.print((char)read); &#125; System.out.println(); System.out.println("-------------"); read = -1; while ((read = reader2.read()) != -1) &#123; System.out.print((char) read); &#125; // 关闭资源 reader2.close(); reader1.close(); &#125;&#125;输出结果 :�Ұ��Ϻ�������.-------------我爱上海明珠塔. 2.4 OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。 构造举例，代码如下： 12OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("out.txt"));OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream("out.txt") , "GBK"); 指定编码写出12345678910111213141516171819202122import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符转换流对象 (默认编码: UTF-8) OutputStreamWriter writer1 = new OutputStreamWriter(new FileOutputStream("D:/b.txt")); // 2. 创建一个字符转换流对象 (执行编码: GBK) OutputStreamWriter writer2 = new OutputStreamWriter(new FileOutputStream("D:/c.txt"), "GBK"); // 3. 写入数据 writer1.write("我爱上海明珠塔."); // b.txt 22个字节 writer2.write("我爱上海明珠塔."); // c.txt 15个字节 // 4. 关闭资源 writer2.close(); writer1.close(); &#125;&#125; 转换流理解图解转换流是字节与字符间的桥梁！ 2.5 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现1234567891011121314151617181920212223import java.io.*;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; // 1. 使用 GBK 编码读取 Windows 系统上创建的文件 InputStreamReader reader = new InputStreamReader(new FileInputStream("D:/a.txt"), "GBK"); // 2. 创建一个 UTF-8 编码的写入字符转换流, 按照指定编码格式将读取的数据重新写入到文件中 OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream("D:/aa.txt"), "UTF-8"); int read = -1; while ((read = reader.read()) != -1) &#123; // 写入 writer.write(read); // System.out.println((char) read); &#125; writer.close(); reader.close(); &#125;&#125; 第三章 序列化3.1 概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的数据等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化： 3.2 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 构造举例，代码如下： 12FileOutputStream fileOut = new FileOutputStream("employee.txt");ObjectOutputStream out = new ObjectOutputStream(fileOut); 序列化操作 一个对象要想序列化，必须满足两个条件: 条件一 : 序列化接口 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。 条件二 : 序列版本号 格式 : private static final long serialVersionUID = 1L; Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。 如此，当JVM反序列化对象时，能找到class文件，如果class文件在序列化对象之后发生了修改，那么反序列化操作也不会失败，如果没有序列化版本号, 则反序列化会抛出一个InvalidClassException异常。 Employee 类定义 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.Serializable;public class Employee implements Serializable &#123; // 需要为序列化的类添加一个 `序列版本号` 属性 private static final long serialVersionUID = 1L; // 属性 private String name; private String address; private transient int age; // 被 transient 修饰的属性不参与序列化 @Override public String toString() &#123; return "Employee&#123;" + "name='" + name + '\'' + ", address='" + address + '\'' + ", age=" + age + '&#125;'; &#125; // 行为 public void checkAddress() &#123; System.out.println(name + " = " + address); &#125; public Employee(String name, String address, int age) &#123; this.name = name; this.address = address; this.age = age; &#125; public Employee() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 1234567891011121314151617181920212223242526272829import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class ObjectOutputStreamTest &#123; public static void main(String[] args) &#123; // 序列化 : 将一个Java对象存储到文件中. // 1. 创建一个 Employee 对象, 并初始化数值 Employee emp = new Employee("张三", "上海南京西路100号", 30); // 2. 创建一个对象输出流 try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:/emp.txt"))) &#123; oos.writeObject(emp); &#125; catch (IOException e) &#123; // e.printStackTrace(); // 将一个编译时期的异常转换为运行时期的异常抛出. throw new RuntimeException("序列化对象失败."); &#125; System.out.println("序列化成功!"); &#125;&#125;输出结果：序列化成功! 3.3 ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 12345678910111213141516171819202122232425262728293031import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;public class ObjectInputStreamTest &#123; public static void main(String[] args) &#123; // 反序列化 : 将文件中的数据读取为一个 Java 对象 // 1. 创建一个对象读取流 try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:/emp.txt"))) &#123; // 2. 读取文件中的数据为 Java 对象 Object obj = ois.readObject(); System.out.println(obj); // 3. 将 obj 类型强转为 Employee 类型, 并实现方法的调用 Employee emp = (Employee) obj; emp.checkAddress(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;输出结果 :Employee&#123;name='张三', address='上海南京西路100号', age=0&#125;张三 = 上海南京西路100号 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 3.4 练习：序列化集合(使用try-catch) 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学习对象 ，保存到集合中。 把集合序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 案例实现Student 类 12345678910111213141516171819202122232425262728293031323334353637import java.io.Serializable;/*1. 实现 `序列化` 接口2. 提供 `序列化版本号属性` */public class Student implements Serializable &#123; // 属性 private static final long serialVersionUID = 1L; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 序列化类 123456789101112131415161718192021222324252627282930313233import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.ArrayList;public class ObjectOuputStreamTest &#123; public static void main(String[] args) &#123; // 准备一个集合, 存储 Student 对象 ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("西施", 18)); list.add(new Student("貂蝉", 19)); list.add(new Student("王昭君", 20)); list.add(new Student("杨玉环", 21)); // 1. 创建一个 `对象写入流` try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:/stu.txt"))) &#123; // 2. 写入集合 oos.writeObject(list); &#125; catch (IOException e) &#123; // e.printStackTrace(); // 转换异常 throw new RuntimeException("序列化对象失败!"); &#125; System.out.println("序列化成功!"); &#125;&#125;输出结果 :序列化成功! 反序列化 12345678910111213141516171819202122232425262728293031323334353637import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.util.ArrayList;public class ObjectInputStreamTest &#123; public static void main(String[] args) &#123; // 1. 创建一个对象读取流 try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:/stu.txt"))) &#123; // 2. 读取文件数据为 Java 对象 Object obj = ois.readObject(); System.out.println(obj); // 3. 将对象转换为 list 集合 ArrayList&lt;Student&gt; list = (ArrayList) obj; for (Student stu : list) &#123; System.out.println(stu.getName() + " = " + stu.getAge()); &#125; &#125; catch (IOException e) &#123; // e.printStackTrace(); throw new RuntimeException("反序列化失败!"); &#125; catch (ClassNotFoundException e) &#123; // e.printStackTrace(); throw new RuntimeException("反序列化类找不到!"); &#125; &#125;&#125;输出结果 :[cn.itcast.test3.Student@2812cbfa, cn.itcast.test3.Student@2acf57e3, cn.itcast.test3.Student@506e6d5e, cn.itcast.test3.Student@96532d6]西施 = 18貂蝉 = 19王昭君 = 20杨玉环 = 21 第四章 打印流4.1 概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 4.2 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 构造举例，代码如下： 1PrintStream ps = new PrintStream("ps.txt")； 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。 12345678910111213141516import java.io.FileNotFoundException;import java.io.PrintStream;public class PrintStreamTest &#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintStream ps = new PrintStream("D:/ps.txt"); // 技巧 : 设置系统的打印流方向 System.setOut(ps); // 输出数据 System.out.println("How old are you."); System.out.println("怎么老是你呀."); &#125;&#125; 练习 : 文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 解析文本信息到集合中。 遍历集合，按顺序，写出文本信息。 案例实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.*;import java.util.HashMap;public class Test1 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建两个高效的缓冲字符输入流与换出流对象 BufferedReader reader = new BufferedReader(new FileReader("in.txt")); BufferedWriter writer = new BufferedWriter(new FileWriter("out.txt")); // 2. 定义一个 HashMap 映射集合. HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); // 3. 一行行读取文件中的数据 String line = null; while ((line = reader.readLine()) != null) &#123; // 3.2 切割读取的每行数据 String[] split = line.split("\\."); int key = Integer.parseInt(split[0]); String value = split[1]; // 3.3 将切割的数据按照键值对存储到映射表中 map.put(key, value); // System.out.println(key); // System.out.println(value); &#125; // 4. 循环映射表集合, 将 i 作为 map 的 key. for (int i = 1; i &lt;= map.size(); i++) &#123; String value = map.get(i); // System.out.println(i + " = " + value); // 4.2 拼接数据 String str = i + "." + value; // 4.3 写入黄金三部曲 : 写入, 换行, 刷新 writer.write(str); writer.newLine(); writer.flush(); &#125; // 5. 关闭资源 writer.close(); reader.close(); &#125;&#125; 实现方式二 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.*;import java.util.Arrays;import java.util.HashMap;import java.util.Map;public class PracticeTest1 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个高效缓冲字符输入流 BufferedReader reader = new BufferedReader(new FileReader("in.txt")); // 5. 准备一个 map 集合, 存储数据 HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); // 2. 一行行读取文件中的数据 String line = null; while ((line = reader.readLine()) != null) &#123; // 3. 使用点, 切割读取的行数据 String[] split = line.split("\\."); // System.out.println("split = " + Arrays.toString(split)); // 4. 取出切割完毕后的数据 int key = Integer.parseInt(split[0]); String value = split[1]; // 6. 存储数据到映射表集合中 map.put(key, value); // System.out.println(key + " = " + value); &#125; // 7. 关闭资源 reader.close(); // 9. 准备一个高效缓冲字符输出流 BufferedWriter writer = new BufferedWriter(new FileWriter("out.txt")); // 8. 遍历 Map 集合 for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123; Integer key = entry.getKey(); String value = entry.getValue(); // 10. 拼接, 并写入数据 String str = key + "." + value; writer.write(str); writer.newLine(); writer.flush(); // System.out.println(key + " = " + value); &#125; // 11. 关闭写入资源 writer.close(); System.out.println("写入完毕 ..."); &#125;&#125; 练习题练习一:高效字节输出流写出字节数据描述:利用高效字节输出流往C盘下的d.txt文件输出一个字节数。 答案 操作步骤: 创建字节输出流对象关联文件路径 利用字节输出流对象创建高效字节输出流对象 调用高效字节输出流对象的write方法写出一个字节 关闭高效流，释放资源。 代码: 123456789101112public class Test01_01 &#123; public static void main(String[] args) throws IOException &#123; // 创建字节输出流FileOutputStream对象并指定文件路径。 FileOutputStream fos = new FileOutputStream("c:\\d.txt"); // 利用字节输出流创建高效字节输出流对象 BufferedOutputStream bos = new BufferedOutputStream(fos); // 调用高效字节输出流对象的write(int byte)方法写出一个字节数据 bos.write(97); // 关闭流 bos.close(); &#125;&#125; 练习二:高效字节输出流写出字节数组数据描述:利用高效字节输出流往C盘下的e.txt文件写出一个字节数组数据，如写出：”i love java” 答案 操作步骤: 创建字节输出流对象关联文件路径 利用字节输出流对象创建高效字节输出流对象 定义字符串存放要输出的数据，然后将字符串转换为字节数组。 调用高效字节输出流对象的write方法将字节数组输出。 关闭高效流。 代码: 123456789101112public class Test01_02 &#123; public static void main(String[] args) throws IOException &#123; // 创建字节输出流FileOutputStream对象并指定文件路径。 FileOutputStream fos = new FileOutputStream("c:\\e.txt"); // 利用字节输出流创建高效字节输出流对象 BufferedOutputStream bos = new BufferedOutputStream(fos); // 调用高效字节输出流对象的write(byte[] buff)方法写出一个字节数据 bos.write("i love java".getBytes()); // 关闭流 bos.close(); &#125;&#125; 练习三:高效流文件复制描述:利用高效字节输入流和高效字节输出流完成文件的复制。 要求： 1.将C盘下的c.png文件复制到D盘下 2.一次读写一个字节数组方式复制 答案 操作步骤: 创建字节输入流对象并关联文件路径 利用字节输入流对象创建高效字节输入流对象 创建字节输出流对象并关联文件路径 利用字节输出流对象创建高效字节输出流对象 创建字节数组用来存放读取的字节数 利用高效字节输入流循环读取文件数据，每读取一个字节数组，利用高效字节输出流对象将字节数组的内容输出到目标文件中。直到读取到文件末尾。 关闭高效流对象 代码: 123456789101112131415161718192021222324public class Test01_03 &#123; public static void main(String[] args) throws IOException&#123; // 创建字节输入流对象并关联文件路径 FileInputStream fis = new FileInputStream("c:\\c.png"); // 利用字节输出流对象创建高效字节输出流对象 BufferedInputStream bis = new BufferedInputStream(fis); // 创建字节输出流对象并指定文件路径。 FileOutputStream fos = new FileOutputStream("d:\\c.png"); // 利用字节输出流创建高效字节输出流对象 BufferedOutputStream bos = new BufferedOutputStream(fos); // 定义字节数组接收读取的字节 byte[] buffer = new byte[1024]; // 定义变量接收读取的字节数 int len = -1; // 循环读取图片数据 while((len = bis.read(buffer)) != -1) &#123; // 每读取一个字节的数据就写出到目标文件中 bos.write(buffer,0,len); &#125; // 关闭流 bis.close(); bos.close(); &#125;&#125; 练习四:高效字符流和集合的综合使用描述: 分析以下需求，并用代码实现 实现一个验证码小程序，要求如下： 在项目根目录下新建一个文件：data.txt,键盘录入3个字符串验证码，并存入data.txt中，要求一个验证码占一行； 键盘录入一个需要被校验的验证码，如果输入的验证码在data.txt中存在：在控制台提示验证成功，如果不存在控制台提示验证失败 答案代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Test01_04 &#123; public static void main(String[] args) throws Exception &#123; //键盘录入3个字符串并写入项目根路径下的data.txt文件中 writeString2File(); //验证码验证 verifyCode(); &#125; /** * 验证码验证 * @throws Exception */ private static void verifyCode() throws Exception &#123; //创建ArrayList集合，用于存储文件中的3个验证码 ArrayList&lt;String&gt;list = new ArrayList&lt;&gt;(); //创建高效字符缓冲输入流对象,并和data.txt文件关联 BufferedReader br = new BufferedReader(new FileReader(new File("data.txt"))); String line = null; //循环读取每一行 while(null!=(line = br.readLine())) &#123; //将读到的每一行信息存入到list集合中 list.add(line); &#125; //关闭流对象 br.close(); //创建键盘录入对象 Scanner sc = new Scanner(System.in); //提示用户输入验证码 System.out.println("请输入一个验证码"); String code = sc.nextLine(); if(list.contains(code)) &#123; System.out.println("验证成功"); &#125; else &#123; System.out.println("验证失败"); &#125; &#125; /** * 键盘录入3个字符串并写入项目根路径下的data.txt文件中 * @throws Exception */ private staticvoid writeString2File() throws Exception &#123; //创建高效字符缓冲输出流对象并和data.txt文件关联 BufferedWriter bw = new BufferedWriter(new FileWriter(new File("data.txt"))); String line = null; //创建键盘录入对象 Scanner sc = new Scanner(System.in); for(inti = 0;i&lt;3;i++) &#123; System.out.println("请输入第"+(i+1)+"个字符串验证码"); //读取用户键盘录入的一行验证码信息 line = sc.nextLine(); //将读取到的一行验证码写入到文件中 bw.write(line); //写入换行符 bw.newLine(); &#125; //关闭流对象 bw.close(); &#125;&#125; 练习五:转换输出流的使用描述:现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。 要求：使用gbk编码保存。 注意：idea的默认编码是utf-8,所以可以通过fileàsettingsàfile encodings设置为gbk格式，否则打开a.txt文件看到的将会是乱码。 答案 操作步骤: 创建文件字节输出流关联目标文件 根据文件字节输出流创建转换输出流对象，并指定编码字符集为：gbk 调用流对象的方法将字符串写出到文件中。 关闭流并释放资源。 代码: 1234567891011121314public class Test01_05 &#123; public static void main(String[] args) throws IOException&#123; // 要保存的字符串 String content = "我爱Java"; // 创建字节输出流对象 FileOutputStream fos = new FileOutputStream("a.txt"); // 创建转换输出流对象 OutputStreamWriter osw = new OutputStreamWriter(fos, "gbk"); // 调用方法写出数据 osw.write(content); // 关闭流释放资源 osw.close(); &#125;&#125; 练习六:转换输入流的使用描述:利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。 要求：不能出现乱码的情况。 答案 操作步骤: 创建字节输入流对象指定文件路径。 根据字节输入流对象创建转换输入流对象并指定字符集编码为：gbk 调用转换输入流对象的读取方法读取内容 关闭流释放资源 代码: 1234567891011121314151617public class Test01_06 &#123; public static void main(String[] args) throws IOException&#123; // 创建字节输入流对象并关联文件 FileInputStream fis = new FileInputStream("a.txt"); // 创建转换输入流对象 InputStreamReader isr = new InputStreamReader(fis,"gbk"); // 定义字符数组存放读取的内容 char[] buffer = newchar[1024]; // 定义变量接收读取的字符个数 intlen = -1; while((len = isr.read(buffer)) != -1) &#123; System.out.print(new String(buffer,0,len)); &#125; // 关闭流 isr.close(); &#125;&#125; 练习七:对象的序列化描述:定义一个学生类，包含姓名，年龄，性别等成员变量，提供setters和getters方法以及构造方法。在测试类中创建一个学生对象，给学生对象的三个成员变量赋值。然后将该对象保存到当前项目根目录下的stu.txt文件中。 答案 操作步骤: 定义学生类并实现序列化接口和测试类 在测试类中创建学生对象 创建文件字节输出流对象并关联目标文件 根据文件字节输出流对象创建对象输出流对象 调用对象输出流对象的方法将学生对象保存到文件中 关闭流释放资源 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test02_01 &#123; public static void main(String[] args) throws IOException &#123; // 创建学生对象 Student s = new Student("jack",20,"男"); // 创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("stu.txt")); // 将学生对象保存文件中 oos.writeObject(s); // 关闭流并释放资源 oos.close(); &#125;&#125;class Student implements Serializable&#123; Private static final long serialVersionUID = 4983659706961705248L; private String name; privateint age; private String gender; public Student() &#123; &#125; public Student(String name, intage, String gender) &#123; this.name = name; this.age = age; this.gender = gender; &#125; public String getName() &#123; returnname; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; returnage; &#125; public void setAge(intage) &#123; this.age = age; &#125; public String getGender() &#123; returngender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125;&#125; 练习八:对象的反序列化描述:将上一题保存到stu.txt文件中的学生对象读取出来。 答案 操作步骤: 创建文件字节输入流对象关联目标文件 根据文件字节输入流对象创建对象输入流对象 调用对象输入流对象的方法从文件中获取学生对象 关闭流释放资源。 代码: 12345678910111213public class Test02_02 &#123; public static void main(String[] args) throws IOException &#123; // 创建字节输入流对象并关联文件 FileInputStream fis = new FileInputStream("stu.txt"); // 创建对象输入流对象 ObjectInputStream ois = new ObjectInputStream(fis); // 读取学生对象 Student s = (Student) ois.readObject(); System.out.println(s); // 关闭流 ois.close(); &#125;&#125; 练习九:字节打印流的使用描述:从键盘录入一行字符串，利用字节打印流将该行字符串保存到当前项目根目录下的d.txt文件中 答案 操作步骤: 1.创建字节打印流对象并关联文件路径 2.调用字节打印流对象的打印方法将内容输入到目标文件中 3.关闭流释放资源 代码: 123456789101112131415public class Test02_03 &#123; public static void main(String[] args) throws IOException &#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入一行字符串："); // 接收用户输入的数据 String line = sc.nextLine(); // 创建字节打印流对象 PrintStream ps = new PrintStream("d.txt"); // 将字符串写出到文件中 ps.println(line); // 关流 ps.close(); &#125;&#125; 练习十:高效字符流读写数据描述: 项目根路径下有text.txt文件，内容如下： 12我爱Java123456 利用IO流的知识读取text.txt文件的内容反转后写入text1.txt文件中，内容如下： 12123456我爱Java 提示：List集合反转元素的顺序时，用到了如下API。 java.util类 Collections static void reverse)(List&lt;?&gt; list) 反转指定列表中元素的顺序。 答案代码 1234567891011121314151617181920212223242526public class Test02_04 &#123; public static void main(String[] args) throws IOException &#123; //创建集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //读取关联文件 BufferedReader br = new BufferedReader(new FileReader("text.txt")); String line; while((line = br.readLine()) != null) &#123; //每读取一行放入集合 list.add(line); &#125; //关闭流 br.close(); //反转集合 Collections.reverse(list); //写入关联文件 BufferedWriter bw = new BufferedWriter(new FileWriter("text1.txt")); for(inti = 0; i&lt;list.size(); i++) &#123; //逐行写入 bw.write(list.get(i)); bw.newLine();//换行 bw.flush();//刷新 &#125; bw.close();//关闭流 &#125;&#125; 练习十一:对象的序列化,对象输出流的使用描述: 定义一个学生类，成员变量有姓名，年龄，性别，提供setters和getters方法以及构造方法 定义一个测试类，在测试类创建多个学生对象保存到集合中，然后将集合存储到当前项目根目录下的stus.txt文件中。 答案 操作步骤: 创建集合对象用来存放学生 创建多个学生对象添加到集合中 创建对象输出流关联目标文件 调用对象输出流的方法将集合对象保存到文件中 关闭流并释放资源 代码: 12345678910111213141516public class Test02_05 &#123; public static void main(String[] args) &#123; // 创建集合对象，存放学生对象 List&lt;Student&gt; stus = new ArrayList&lt;Student&gt;(); // 添加学生对象 stus.add(new Student("jack",20,"男")); stus.add(new Student("rose",18,"女")); stus.add(new Student("laowang",20,"男")); // 创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("stus.txt")); // 将学生对象保存文件中 oos.writeObject(stus); // 关闭流并释放资源 oos.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶09-字节流和字符流]]></title>
    <url>%2F2019%2F08%2F25%2F2019-08-25-Java%E8%BF%9B%E9%98%B609-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[主要内容 IO流 字节流 字符流 异常处理 学习目标 能够说出IO流的分类和功能 能够使用字节输出流写出数据到文件 能够使用字节输入流读取数据到程序 能够理解读取数据read(byte[])方法的原理 能够使用字节流完成文件的复制 能够使用FileWirter写数据到文件 能够说出FileWriter中关闭和刷新方法的区别 能够使用FileWriter写数据的5个方法 能够使用FileWriter写数据实现换行和追加写 能够使用FileReader读数据 能够使用FileReader读数据一次一个字符数组 能够使用Properties的load方法加载文件中配置信息 第一章 IO概述1.1 什么是IO生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。 我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。 Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。 1.2 IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 1.3 IO的流向说明图解 1.4 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 第二章 字节流2.1 一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 2.2 字节输出流【OutputStream】java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 public abstract void write(int b) ：将指定的字节输出流。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.3 FileOutputStream类OutputStream有很多子类，我们从最简单的一个子类开始。 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;public class FileOutputStreamTest1 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 1. 创建一个文件字节输出流对象 // 1.1 FileOutputStream(String name); 父目录存在, 文件才能写入成功. FileOutputStream out = new FileOutputStream("D:/aaa.txt"); System.out.println(out); // 1.2 FileOutputStream(File file); 说明 : 如果父目录不存在, 文件对象都会创建失败. // 前提条件 : 必须要保证父目录的存在. File file = new File("D:/aaa/bbb/aaa.txt"); // 1.2.1 先获取 file 对象的父目录 File parentFile = file.getParentFile(); // System.out.println("parentFile = " + parentFile); // 1.2.2 判断父目录是否存在 if (parentFile.exists() == false) &#123; // 1.2.3 父目录不存在, 需要手动创建 parentFile.mkdirs(); &#125; FileOutputStream out2 = new FileOutputStream(file); System.out.println(out2); &#125;&#125;输出结果 :out1 = java.io.FileOutputStream@1d251891out2 = java.io.FileOutputStream@48140564 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示： 123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 需求 : 写出字节数据 FileOutputStream out = new FileOutputStream("a.txt"); // write(int) 一个字节一个字节写出 out.write(97); out.write(98); out.write(99); // 关闭资源 out.close(); &#125;&#125;结果：abc 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 需求 : 写出字节数据 FileOutputStream out = new FileOutputStream("a.txt"); // write(byte[] b) 写入一个字节数组的长度 byte[] b = "黑马程序员".getBytes(); out.write(b); // 关闭资源 out.close(); &#125;&#125;结果：黑马程序员 写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示： 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 需求 : 写出字节数据 FileOutputStream out = new FileOutputStream("a.txt"); // write(byte[] b, int off, int len) 从一个字节数组的 0 位置开始, 取 2 个长度. byte[] b = "abcdefg".getBytes(); out.write(b, 0, 2); // 关闭资源 out.close(); &#125;&#125;结果：ab 数据追加续写经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？ public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示： 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 需求 : 写出字节数据 FileOutputStream out = new FileOutputStream("a.txt", true); // write(byte[] b) byte[] b = "我爱上海明珠塔".getBytes(); out.write(b); // 关闭资源 out.close(); &#125;&#125;文件操作前：ab文件操作后：ab我爱上海明珠塔 写出换行Windows系统里，换行符号是\r\n 。把 以指定是否追加续写了，代码使用演示： 12345678910111213141516171819202122232425262728import java.io.FileOutputStream;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 需求 : 写出字节数据 FileOutputStream out = new FileOutputStream("a.txt", true); // write(byte[] b) // 换行 : 1. \r\n 2. System.lineSeparator(); byte[] b = "\r\n我爱上海黄浦江".getBytes(); out.write(b); String lineSeparator = System.lineSeparator(); b = (lineSeparator + "我爱上海大传智").getBytes(); out.write(b); // 关闭资源 out.close(); &#125;&#125;输出结果：ab我爱上海明珠塔我爱上海黄浦江我爱上海大传智 回车符\r和换行符\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\r\n； Unix系统里，每行结尾只有 换行 ，即\n； Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。 2.4 字节输入流【InputStream】java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 2.5 FileInputStream类java.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 构造举例，代码如下： 123456789101112131415161718192021import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;public class Test3 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 File file = new File("a.txt"); FileInputStream in = new FileInputStream(file); System.out.println("in = " + in); // FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。 FileInputStream in2 = new FileInputStream("a.txt"); System.out.println("in2 = " + in2); &#125;&#125;输出结果 :in = java.io.FileInputStream@1d251891in2 = java.io.FileInputStream@48140564 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示： 1234567891011121314151617181920212223242526272829import java.io.FileInputStream;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个文件读取对象 FileInputStream in = new FileInputStream("a.txt"); // 2. read(); 一个一个字节读取数据 int read = in.read(); System.out.println("read = " + read); read = in.read(); System.out.println("read = " + read); read = in.read(); System.out.println("read = " + read); read = in.read(); System.out.println("read = " + read); // 3. close(); 关闭资源 in.close(); &#125;&#125;输出结果：read = 97read = 98read = 99read = -1 循环改进读取方式，代码使用演示： 123456789101112131415161718192021222324import java.io.FileInputStream;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个文件读取对象 FileInputStream in = new FileInputStream("a.txt"); // 2. read(); 一个一个字节读取数据 int read = -1; while ((read = in.read()) != -1) &#123; System.out.println("read = " + read); &#125; // 3. close(); 关闭资源 in.close(); &#125;&#125;输出结果：read = 97read = 98read = 99 小贴士： 虽然读取了一个字节，但是会自动提升为int类型。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 2.6 字节流练习：图片复制复制原理图解 复制案例实现1 : 读取一个字节,写入一个字节复制图片文件，代码使用演示： 1234567891011121314151617181920212223242526272829303132import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; long start = System.currentTimeMillis(); // 1.1 创建一个文件读取对象 FileInputStream in = new FileInputStream("D:\\1.jpg"); // 1.2 创建一个文件写出对象 FileOutputStream out = new FileOutputStream("1.jpg"); // 2. 读写数据 int read = -1; while ((read = in.read()) != -1) &#123; out.write(read); out.flush(); &#125; // 3. close(); 关闭资源 out.close(); in.close(); long end = System.currentTimeMillis(); System.out.println("共耗时 : " + (end - start) + "毫秒."); &#125;&#125;输出结果 :图片 : 共耗时 : 3821毫秒. 视频: 共耗时 : 51683毫秒. 小贴士： 流的关闭原则：先开后关，后开先关。 read方法的区别 : 读取字节数组 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示： 说明 : 由于最后一次读取时，只读取了 len 的长度, 但是写入了整个字节数组 buf, 造成了数据的错误, 因为为, 读取多少长度, 就应该写入多少长度, 因为代码需要修正为 write(b, off, len); 12345678910111213141516171819202122232425262728293031323334import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; FileInputStream in = new FileInputStream("a.txt"); FileOutputStream out = new FileOutputStream("b.txt"); byte[] buf = new byte[8]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // out.write(buf); out.write(buf, 0, len); // 写入数组中的数据, 从 0 (开头) 开始写, 写入读取的 len 长度. &#125; /* int len = in.read(buf); System.out.println("Arrays.toString(buf) = " + Arrays.toString(buf)); System.out.println("len = " + len); len = in.read(buf); System.out.println("Arrays.toString(buf) = " + Arrays.toString(buf)); System.out.println("len = " + len); */ out.close(); in.close(); &#125;&#125;写入结果：abcdefghijklmnopqrstuvwxyz 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 复制案例实现2 : 读取字节数组,写入字节数组123456789101112131415161718192021222324252627282930313233import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; long start = System.currentTimeMillis(); // 1.1 创建一个文件读取对象 FileInputStream in = new FileInputStream("D:\\1.jpg"); // 1.2 创建一个文件写出对象 FileOutputStream out = new FileOutputStream("1.jpg"); // 2. 读写数据 byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; out.write(buf, 0, len); out.flush(); &#125; // 3. close(); 关闭资源 out.close(); in.close(); long end = System.currentTimeMillis(); System.out.println("共耗时 : " + (end - start) + "毫秒."); &#125;&#125;输出结果 :图片 : 共耗时 : 16毫秒. 视频 : 共耗时 : 79毫秒. 复制案例实现3 : 字节缓冲流包装in,out构造方法 public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。 构造举例，代码如下： 1234// 创建字节缓冲输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream("bis.txt"));// 创建字节缓冲输出流BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bos.txt")); 效率测试 12345678910111213141516171819202122232425262728293031import java.io.*;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; long start = System.currentTimeMillis(); // 1.1 创建一个文件读取对象 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("D:\\福利赠送.flv")); // 1.2 创建一个文件写出对象 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("福利赠送.flv")); // 2. 读写数据 byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; // 3. close(); 关闭资源 bos.close(); bis.close(); long end = System.currentTimeMillis(); System.out.println("共耗时 : " + (end - start) + "毫秒."); &#125;&#125;输出结果 :视频 : 共耗时 : 63毫秒. 第三章 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 3.1 字符输入流【Reader】java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。 public void close() ：关闭此流并释放与此流相关联的任何系统资源。 public int read()： 从输入流读取一个字符。 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。 3.2 FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 构造举例，代码如下： 123456789101112131415161718192021import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;public class Test1 &#123; public static void main(String[] args) throws FileNotFoundException &#123; // 方式1. 创建一个字符输入流 File file = new File("a.txt"); FileReader reader = new FileReader(file); System.out.println("reader = " + reader); // 方式2. 创建一个字符输入流 FileReader reader2 = new FileReader("a.txt"); System.out.println("reader2 = " + reader2); &#125;&#125;输出结果 :reader = java.io.FileReader@48140564reader2 = java.io.FileReader@58ceff1 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 1234567891011121314151617181920212223242526import java.io.FileReader;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符输入流 FileReader reader = new FileReader("a.txt"); // 2. 读取数据 int read = -1; while ((read = reader.read()) != -1) &#123; System.out.println((char) read); &#125; // 3. 关闭资源 reader.close(); &#125;&#125;输出结果：黑马程序员 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示： 1234567891011121314151617181920212223242526import java.io.FileReader;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符输入流 FileReader reader = new FileReader("a.txt"); // 2. 读取数据 char[] ch = new char[2]; int len = -1; while ((len = reader.read(ch)) != -1) &#123; String str = new String(ch); System.out.println(str); &#125; // 3. 关闭资源 reader.close(); &#125;&#125;输出结果：黑马程序员序 获取有效的字符改进，代码使用演示： 1234567891011121314151617181920212223242526import java.io.FileReader;import java.io.IOException;public class Test2 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符输入流 FileReader reader = new FileReader("a.txt"); // 2. 读取数据 char[] ch = new char[2]; int len = -1; while ((len = reader.read(ch)) != -1) &#123; String str = new String(ch, 0, len); System.out.println(str); &#125; // 3. 关闭资源 reader.close(); &#125;&#125;输出结果：黑马程序员 3.3 字符输出流【Writer, FileWriter】java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。 public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。 public void write(int c) ：写出一个字符。 public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 public void write(String str) ：写出一个字符串。 1234567891011121314151617181920212223242526272829import java.io.FileWriter;import java.io.IOException;public class Test3 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个字符输出流 FileWriter writer = new FileWriter("b.txt"); // public void write(int c) ：写出一个字符。 writer.write(97); // public void write(char[] cbuf)：将 b.length字符从指定的字符数组写出此输出流。 char[] cbuf = new char[]&#123;'A', 'B', 'C', 'D', 'E'&#125;; writer.write(cbuf); // public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。 writer.write(cbuf, 0, 2); // public void write(String str) ：写出一个字符串。 writer.write("黑马程序员"); // 关闭资源 writer.close(); &#125;&#125;写出结果 :aABCDEAB黑马程序员 3.4 续写和换行与读取：字符缓冲流代码演示 : 1234// 创建字节缓冲输入流BufferedReader br = new BufferedReader(new FileReader("br.txt", true));// 创建字节缓冲输出流BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt", true)); 特有方法 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 newLine方法演示，代码如下： 12345678910111213141516171819202122232425import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; BufferedWriter writer = new BufferedWriter(new FileWriter("c.txt")); // 写入数据三部曲 : (写入, 换行, 刷新) writer.write("我爱上海明珠塔."); writer.newLine(); writer.flush(); writer.write("我爱北京天安门."); writer.newLine(); writer.flush(); writer.close(); &#125;&#125;输出结果:我爱上海明珠塔.我爱北京天安门. 续写 : 12345678910111213141516171819202122import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test4 &#123; public static void main(String[] args) throws IOException &#123; BufferedWriter writer = new BufferedWriter(new FileWriter("c.txt", true)); // 写入数据三部曲 : (写入, 换行, 刷新) writer.write("我爱广州小蛮腰."); writer.newLine(); writer.flush(); writer.close(); &#125;&#125;输出结果 :我爱上海明珠塔.我爱北京天安门.我爱广州小蛮腰. 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 readLine方法演示，代码如下： 123456789101112131415161718192021222324252627282930import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个缓冲字符流对象 BufferedReader reader = new BufferedReader(new FileReader("c.txt")); // 2. 一行一行读取 String line = reader.readLine(); System.out.println(line); line = reader.readLine(); System.out.println(line); line = reader.readLine(); System.out.println(line); line = reader.readLine(); System.out.println(line); // 3. 关闭资源 reader.close(); &#125;&#125;输出结果 :我爱上海明珠塔.我爱北京天安门.我爱广州小蛮腰.null 优化读取代码 : 12345678910111213141516171819202122232425import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建一个缓冲字符流对象 BufferedReader reader = new BufferedReader(new FileReader("c.txt")); // 2. 一行一行读取 String line = null; while ((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; // 3. 关闭资源 reader.close(); &#125;&#125;输出结果 :我爱上海明珠塔.我爱北京天安门.我爱广州小蛮腰. 第四章 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用 try...catch...finally 代码块，处理异常部分，代码使用演示： 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test6 &#123; public static void main(String[] args) &#123; // 1. 定义一个 writer 对象 BufferedWriter writer = null; try &#123; // 2. 初始化 writer 对象 writer = new BufferedWriter(new FileWriter("d.txt")); // 写入三部曲 : writer.write("黑马程序员"); writer.newLine(); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; // 3. 关闭 writer 对象 if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;写入结果 :黑马程序员 JDK7的处理还可以使用JDK7优化后的try-with-resources 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。 格式： 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 1234567891011121314151617181920212223import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;public class Test6 &#123; public static void main(String[] args) &#123; // () 括号中解决的是 `流` 资源关闭的问题. try (BufferedWriter writer = new BufferedWriter(new FileWriter("d.txt"))) &#123; // 写入三部曲 : writer.write("黑马程序员"); writer.newLine(); writer.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;写出结果 :黑马程序员 JDK9的改进(了解内容)JDK9中try-with-resources 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。 改进前格式： 12345678910111213141516171819202122import java.io.*;public class Test7 &#123; public static void main(String[] args) &#123; // () 小括号中定义需要释放的资源对象. try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("D:/1.jpg")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("1.jpg"))) &#123; // 读写操作 : byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 改进后格式： 123456789101112131415161718192021222324import java.io.*;public class Test7 &#123; public static void main(String[] args) throws FileNotFoundException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream("D:/1.jpg")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("1.jpg")); // () 小括号中定义需要释放的资源对象. try (bis; bos) &#123; // 读写操作 : byte[] buf = new byte[1024]; int len = -1; while ((len = bis.read(buf)) != -1) &#123; bos.write(buf, 0, len); bos.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 练习题练习一:字节输出流写出字节数据描述:利用字节输出流一次写一个字节的方式，向D盘的a.txt文件输出字符‘a’。 答案 操作步骤: 1.创建字节输出流FileOutputStream对象并指定文件路径。 2.调用字节输出流的write(int byte)方法写出数据 代码: 12345678910public class Test01_01 &#123; public static void main(String[] args) throws IOException &#123; // 1.创建字节输出流FileOutputStream对象并指定文件路径。 FileOutputStream fos = new FileOutputStream("d:/a.txt"); // 2.调用字节输出流的write(int byte)方法写出数据 fos.write(97); // 3.关闭流 fos.close(); &#125;&#125; 练习二:字节输出流写出字节数组数据描述:利用字节输出流一次写一个字节数组的方式向D盘的b.txt文件输出内容:”i love java”。 答案 操作步骤: 1.创建字节输出流FileOutputStream对象并指定文件路径。 2.调用字节输出流的write(byte[] buf)方法写出数据。 代码: 1234567891011public class Test01_02 &#123; public static void main(String[] args) throws IOException &#123; // 1.创建字节输出流FileOutputStream对象并指定文件路径。 FileOutputStream fos = new FileOutputStream("d:/b.txt"); // 2.调用字节输出流的write(byte[] buf)方法写出数据。 byte[] buf = "i love java".getBytes(); fos.write(buf); // 3.关闭资源 fos.close(); &#125;&#125; 练习三:文件的续写和换行输出描述:在D盘下，有一c.txt 文件中内容为：HelloWorld 在c.txt文件原内容基础上，添加五句 I love java，而且要实现一句一行操作(注：原文不可覆盖)。 利用字节输出流对象往C盘下c.txt文件输出5句：”i love java” 答案 操作步骤: 利用两个参数的构造方法创建字节输出流对象，参数一指定文件路径，参数二指定为true 调用字节输出流的write()方法写入数据，在每一行后面加上换行符:”\r\n” 代码: 1234567891011121314public class Test01_03 &#123; public static void main(String[] args) throws IOException&#123; // 1.创建字节输出流FileOutputStream对象并指定文件路径,并追加方式 FileOutputStream fos = new FileOutputStream("c:/c.txt",true); // 2.调用字节输出流的write方法写出数据 // 2.1 要输出的字符串 String content = "i love java \r\n"; for (int i = 0; i&lt; 5; i++) &#123; fos.write(content.getBytes()); &#125; // 3.关闭流 fos.close(); &#125;&#125; 练习四:字节输入流一次读取一个字节数据描述:利用字节输入流读取D盘文件a.txt的内容，文件内容确定都为纯ASCII字符,使用循环读取，一次读取一个字节，直到读取到文件末尾。将读取的字节输出到控制台。 答案 操作步骤: 创建字节输入流对象指定文件路径。 调用read(byte b)方法循环读取文件中的数据 直到读取到-1时结束读取 代码: 1234567891011121314public class Test01_04 &#123; public static void main(String[] args) throws IOException&#123; // 创建字节输入流对象并关联文件 FileInputStream fis = new FileInputStream("d:/a.txt"); // 定义变量接收读取的字节 int len = -1; // 循环从流中读取数据 while((len = fis.read()) != -1) &#123; System.out.print((char)len); &#125; // 关闭流 fis.close(); &#125;&#125; 练习五:字节输入流一次读取一个字节数组数据描述:利用字节输入流读取D盘文件b.txt的内容，文件内容确定都为纯ASCII字符,使用循环读取，一次读取一个字节数组，直到读取到文件末尾，将读取到的字节数组转换成字符串输出到控制台。 答案 操作步骤: 创建字节输入流对象指定文件路径。 定义一个字节数数组，用来存放读取的字节数 调用read(byte[] buf)方法传入字节数组，循环读取文件中的数据 直到读取到-1时结束读取 代码: 12345678910111213141516public class Test01_05 &#123; public static void main(String[] args) throws IOException&#123; // 创建字节输入流对象并关联文件 FileInputStream fis = new FileInputStream("d:/b.txt"); // 定义字节数组存放读取的字节数 byte[] buffer = new byte[1024]; // 定义变量接收读取的字节 int len = -1; // 循环从流中读取数据 while((len = fis.read(buffer)) != -1) &#123; System.out.print(new String(buffer,0,len)); &#125; // 关闭流 fis.close(); &#125;&#125; 练习六:字节流复制文件描述:利用字节流将E盘下的a.png图片复制到D盘下(文件名保存一致) 要求： 一次读写一个字节的方式 答案 操作步骤: 创建字节输入流对象关联文件路径：E盘下的a.png 创建字节输出流对象关联文件路径：D盘下的a.png 使用循环不断从字节输入流读取一个字节，每读取一个字节就利用输出流写出一个字节。 关闭流，释放资源 代码: 123456789101112131415161718public class Test01_06 &#123; public static void main(String[] args) throws IOException &#123; // 创建字节输入流对象并关联文件 FileInputStream fis = new FileInputStream("e:/a.png"); // 创建字节输出流对象并关联文件 FileOutputStream fos = new FileOutputStream("d:/a.png"); // 定义变量接收读取的字节数 int len = -1; // 循环读取图片数据 while((len = fis.read()) != -1) &#123; // 每读取一个字节的数据就写出到目标文件中 fos.write(len); &#125; // 关闭流 fis.close(); fos.close(); &#125;&#125; 练习七:字符输出流写出字符数据项目需求：请用户从控制台输入信息，程序将信息存储到文件Info.txt中。可以输入多条信息，每条信息存储一行。当用户输入：”886”时，程序结束。 答案 操作步骤: 创建MainAPP类,并包含main()方法 按照上述要求实现程序 代码: 1234567891011121314151617181920212223public class Test01_07 &#123; public static void main(String[]args) throws IOException &#123; //1. 指定输出流， 对应的文件Info.txt FileWriter bw= new FileWriter("Info.txt"); //2.采用循环的方式，把每条信息存储一行到Info.txt中 Scanner sc= new Scanner(System.in); while(true)&#123; //获取键盘输入的一行内容 System.out.print("请输入内容："); String str= sc.nextLine(); //当用户输入：”886”时，程序结束。 if ("886".equals(str)) &#123; break;//跳出循环 &#125; //把内容写入到Info.txt文件中 bw.write(str); //换行 bw.write(System.lineSeparator()); &#125; //关闭流 bw.close(); &#125;&#125; 练习八:IO对象Properties结合使用,设置properties文件描述: 我有一个文本文件score.txt，我知道数据是键值对形式的，但是不知道内容是什么。 请写一个程序判断是否有”lisi”这样的键存在，如果有就改变其实为”100” score.txt文件内容如下： 12345zhangsan = 90lisi = 80wangwu = 85 答案 操作步骤: 创建一个空的Properties集合 读取数据到集合中 遍历集合，获取到每一个key 判断当前的key 是否为 “lisi”，如果是就把”lisi”的值设置为100 把集合中所有的信息，重新存储到文件中 提示信息： 把集合中的信息，存储到文件中，可以用如下方法。 java.util 类 Properties void store)(OutputStreamout,Stringcomments) 以适合使用load(InputStream))方法加载到Properties表中的格式，将此Properties表中的属性列表（键和元素对）写入输出流。 123参数： out - 输出流。 comments - 属性列表的描述。 代码: 1234567891011121314151617181920public class Test02_06 &#123; public static void main(String[] args) throws IOException &#123; //1：创建一个空的集合 Properties prop = new Properties(); //2:读取数据到集合中 prop.load(new FileInputStream("score.txt")); //3:遍历集合，获取到每一个key Set&lt;String&gt; keys = prop.stringPropertyNames(); //获取到每一个key for (String key : keys) &#123; //4:判断当前的key 是否为 "lisi" if ("lisi".equals(key)) &#123; //把"lisi"的值设置为100 prop.setProperty(key, "100"); &#125; &#125; //把集合中所有的信息，重新存储到文件中 prop.store(new FileOutputStream("score.txt"), "haha"); &#125;&#125; 练习九:字节输入流使用描述: 在D盘下有一个文本文件test.txt(里面的内容由数字和字母组成) 定义一个方法统计test.txt文件中’a’字符出现的次数。 比如a字符在文件中出现了10次则调用方法传入a后，方法内部输出：a出现10次 答案 操作步骤: 创建字节输入流对象，循环从文件中读取一个字节 定义一个整数变量用来统计字符出现的次数。 将读取的字节转换字符跟传入的字符进行比较，相同则计数加一。 输出结果。 代码: 12345678910111213141516171819202122232425262728293031import java.io.FileInputStream;import java.io.IOException;public class Test02_01&#123; public static void main(String[] args) throws IOException &#123; // 调用方法 calcuteCount('a'); &#125; /* * 统计字符在文件中出现的次数 */ public static void calcuteCount(char ch) throws IOException &#123; // 创建字节输入流 final FileInputStream fis = new FileInputStream("d:/test.txt"); try (fis) &#123; // 定义一个计数变量，统计字符出现的次数 int count = 0; // 循环读取数据 int len = -1; while ((len = fis.read()) != -1) &#123; // 判断字符c和外界传入的字符是否相同 if (len == ch) &#123; count++; &#125; &#125; System.out.println(ch + "出现了" + count + "次"); &#125; catch (IOExceptione) &#123; e.printStackTrace(); &#125; &#125;&#125; 练习十:字节输出流写出数据描述: 从控制台循环接收用户录入的学生信息，输入格式为：学号-学生名字 将学生信息保存到D盘下面的stu.txt文件中，一个学生信息占据一行数据。 当用户输入end时停止输入。 答案 操作步骤: 1.使用Scanner类进行键盘录入数据 2.创建字节输入流对象关联目标文件 3.使用死循环不停的接收用户输入的学生数据 4.接收用户输入的学生数据 5.判断输入的内容是否是end，是则终止循环，停止输入。否则就数据写出到文件中。 代码: 123456789101112131415161718192021222324252627282930import java.io.FileOutputStream;import java.io.IOException;import java.util.Scanner;public class Test02_02&#123; public static void main(String[] args) throws IOException &#123; // 创建字节输出流对象 final FileOutputStream fos = new FileOutputStream("d:/stu.txt"); // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入学生信息，格式：学号-姓名"); try (fos; sc) &#123; // 使用死循环不停的接收用户输入的学生数据 while (true) &#123; // 接收用户输入的学生数据 String line = sc.nextLine(); // 判断输入的内容是否是end，是则终止循环 if ("end".equals(line)) &#123; break; &#125; // 将数据写出到文件中。 fos.write(line.getBytes()); // 写出换行符号 fos.write(System.lineSeparator().getBytes()); &#125; &#125; catch (IOExceptione) &#123; e.printStackTrace(); &#125; &#125;&#125; 练习十一:字符输出流写出字符数据并存到集合中需求说明：从控制台接收3名学员的信息，每条信息存储到一个Student对象中，将多个Student对象存储到一个集合中。输入完毕后，将所有学员信息存储到文件Student.txt中。每名学员信息存储一行，多个属性值中间用逗号隔开。 答案 操作步骤: 创建Student类，有如下属性： 学号、姓名、性别、年龄 全部属性使用String类型。要求有无参，全参构造方法。所有属性私有，并提供公有get/set方法。 创建MainApp类，包含main()方法 在main()方法中： 1) 定义一个存储Student对象的集合； 2) 循环3次，从控制台接收3名学员信息，每条信息封装一个Student对象，将每个Student对象存储到集合中。 3) 遍历集合，获取每个Student对象，取出所有属性值，输出到文件Test2_2.txt中。每名学员信息占一行。 代码: 123456789101112131415161718192021222324252627282930313233343536public class Task02_03 &#123; public static void main(String[] args) throws IOException &#123; // 1.定义学生类, 定义存学生的集合 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); // 2.通过3次循环，完成如下操作 Scanner sc = new Scanner(System.in); for (int i = 1; i&lt;= 3; i++) &#123; // 键盘输入学生的信息， System.out.print("请输入第" + i + "名学生的学号："); String id = sc.next(); System.out.print("请输入第" + i + "名学生的姓名："); String name = sc.next(); System.out.print("请输入第" + i + "名学生的性别："); String sex = sc.next(); System.out.print("请输入第" + i + "名学生的年龄："); String age = sc.next(); // 把信息封装到Student对象中 Student s = new Student(id, name, sex, age); // 把Student对象存到集合里 list.add(s); &#125; // 3.将所有学员信息存储到文件Student.txt中。 FileWriter out = new FileWriter("Student.txt"); // 每名学员信息存储一行，多个属性值中间用逗号隔开。 for (int i = 0; i&lt;list.size(); i++) &#123; // 1.获取集合中每一个学生对象 Student s = list.get(i); // 2.获取对象中的每一个属性值,多个属性值中间用逗号隔开 String line = s.getId() + "," + s.getName() + "," + s.getSex() + "," + s.getAge(); // 3.按照指定的格式把对象的属性值，写入到文件中 out.write(line); out.write(System.lineSeparator()); &#125; out.close();// 关闭流 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找算法的实现与比较]]></title>
    <url>%2F2019%2F08%2F25%2F2019-08-25-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[在java中，我们常用的查找有四种:（1）顺序(线性)查找（2）二分查找/折半查找（3）插值查找（4）斐波那契查找 1、线性查找有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此数【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值。 代码实现： 123456789101112131415161718192021222324252627282930313233package search;public class SeqSearch &#123; public static void main(String[] args) &#123; int arr[] = &#123;1,9,11,-1,34,89&#125;;//没有顺序的数组 int index = seqSearch(arr,11); if(index == -1)&#123; System.out.println("没有查找到~"); &#125;else&#123; System.out.println("找到，下标为=" + index); &#125; &#125; /** * 这里我们实现的线性查找是找到一个满足条件的值，就返回 * @param arr * @param value * @return */ private static int seqSearch(int[] arr, int value) &#123; //线性查找是逐一比对，发现有相同值，就返回下标 for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == value)&#123; return i; &#125; &#125; return -1; &#125;&#125; 输出结果： 1找到，下标为=2 2、二分查找二分查找：请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234}，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。 二分查找的思路分析： 首先确定该数组的中间的下标 mid = (left + right) / 2 然后让需要查找的数 findVal 和 arr[mid] 比较 （1）findVal &gt; arr[mid] , 说明你要查找的数在mid 的右边, 因此需要递归的向右查找 （2）findVal &lt; arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找 （3）findVal == arr[mid] 说明找到，就返回 什么时候我们需要结束递归。 （1）找到就结束递归 （2）递归完整个数组，仍然没有找到findVal ，也需要结束递归 ； 当 left &gt; right 就需要退出。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package search;import java.util.ArrayList;import java.util.List;//注意：使用二分查找的前提是 该数值是有序的public class BinarySearch &#123; public static void main(String[] args) &#123; int arr[] = &#123;1,8,10,89,1000,1000,1234&#125;; /*int resIndex = binarySearch(arr,0,arr.length-1,10000); if(resIndex == -1)&#123; System.out.println("没有查找到~"); &#125;else&#123; System.out.println("找到，下标为=" + resIndex); &#125;*/ List&lt;Integer&gt; resIndexList = binarySearch2(arr,0,arr.length-1,1000); System.out.println("resIndexList=" + resIndexList); &#125; /** * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000. * * 思路分析： * 1.在找到mid索引值，不要马上返回 * 2.向mid索引值的左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList * 3.向mid索引值的右边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList * 4.将ArrayList返回 * * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return */ private static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123; // 当left&gt;right 时，说明递归整个数组，但是没有找到 if(left&gt;right)&#123; return new ArrayList&lt;Integer&gt;(); &#125; int mid = (left+right)/2; int midVal = arr[mid]; if(findVal&gt;midVal)&#123;//向 右递归 return binarySearch2(arr,mid+1,right,findVal); &#125;else if(findVal&lt;midVal)&#123;//向 左递归 return binarySearch2(arr,left,mid-1,findVal); &#125;else&#123; /* * 思路分析： * 1.在找到mid索引值，不要马上返回 * 2.向mid索引值的左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList * 3.向mid索引值的右边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList * 4.将ArrayList返回 */ List&lt;Integer&gt; resIndexList = new ArrayList&lt;Integer&gt;(); //向mid索引值的左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList int temp = mid - 1; while(true)&#123; if(temp&lt;0||arr[temp]!=findVal)&#123;//退出 break; &#125; //否则，就将temp放入到resIndexList resIndexList.add(temp); temp = temp - 1;//temp左移 &#125; resIndexList.add(mid); //向mid索引值的右边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList temp = mid + 1; while(true)&#123; if(temp&gt;arr.length||arr[temp]!=findVal)&#123;//退出 break; &#125; //否则，就将temp放入到resIndexList resIndexList.add(temp); temp = temp + 1;//temp右移 &#125; return resIndexList; &#125; &#125; /** * * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return */ private static int binarySearch(int[] arr, int left, int right, int findVal) &#123; // 当left&gt;right 时，说明递归整个数组，但是没有找到 if(left&gt;right)&#123; return -1; &#125; int mid = (left+right)/2; int midVal = arr[mid]; if(findVal&gt;midVal)&#123;//向 右递归 return binarySearch(arr,mid+1,right,findVal); &#125;else if(findVal&lt;midVal)&#123;//向 左递归 return binarySearch(arr,left,mid-1,findVal); &#125;else&#123; return mid; &#125; &#125;&#125; binarySearch返回结果： 1找到，下标为=5 binarySearch2返回结果： 1resIndexList=[4, 5] 3、插值查找4、斐波那契查找]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶07-线程池和Lambda表达式]]></title>
    <url>%2F2019%2F08%2F24%2F2019-08-24-Java%E8%BF%9B%E9%98%B607-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[主要内容 线程池 Lambda表达式 学习目标 能够理解线程通信概念 能够理解等待唤醒机制 能够描述Java中线程池运行原理 能够理解函数式编程相对于面向对象的优点 能够掌握Lambda表达式的标准格式 能够使用Lambda标准格式使用Runnable与Comparator接口 能够掌握Lambda表达式的省略格式与规则 能够使用Lambda省略格式使用Runnable与Comparator接口 能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法） 能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法） 能够明确Lambda的两项使用前提 第一章 等待唤醒机制1.1 线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。 为什么要处理线程间通信： 多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个数据的使用或操作。 避免对同一共享数据的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 1.2 等待唤醒机制什么是等待唤醒机制 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后再将其唤醒（notify()）; 在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中 notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。 notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 1.3 生产者与消费者问题等待唤醒机制其实就是经典的“生产者与消费者”的问题。 就拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 1包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。 代码演示： 包子资源类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 包子 : 表示多线程操作的 `资源类`public class BaoZi &#123; // 属性 private String pier; // 皮儿 private String xianer; // 馅儿 // 提供一个数据, 用于判断包子是否已经 `有` 了. private boolean flag = false; // 默认没有包子. // 构造方法 : public BaoZi(String pier, String xianer) &#123; this.pier = pier; this.xianer = xianer; &#125; public BaoZi() &#123; &#125; // setter &amp; getter public String getPier() &#123; return pier; &#125; public void setPier(String pier) &#123; this.pier = pier; &#125; public String getXianer() &#123; return xianer; &#125; public void setXianer(String xianer) &#123; this.xianer = xianer; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125;&#125; 吃货线程类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 吃货 : 消费包子public class ChiHuo extends Thread &#123; // 属性 private BaoZi baoZi; public ChiHuo(BaoZi baoZi) &#123; this.baoZi = baoZi; &#125; @Override public void run() &#123; // 不断消费包子 while (true) &#123; synchronized (baoZi) &#123; // 调用消费包子的方法 consume(); &#125; &#125; &#125; // 行为 : 消费包子 public void consume() &#123; // 1. 判断是否有包子 if (baoZi.isFlag() == false) &#123; // 没有包子, 吃货需要等待 try &#123; baoZi.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 2. 如果有包子, 吃货开吃 System.out.println("吃货吃了" + baoZi.getPier() + baoZi.getXianer() + " 的包子."); // 将数据清空 baoZi.setPier(null); baoZi.setXianer(null); // 3. 将 baoZi 的 flag 设置为 false baoZi.setFlag(false); // 4. 需要唤醒包子铺去生产包子 baoZi.notify(); &#125;&#125; 包子铺线程类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 包子铺 : 生产包子public class BaoZiPu extends Thread &#123; // 属性 (包子铺的包子和吃货吃的包子应该是同一个包子对象, 因此该对象不能内部创建, 应该由外部传入) private BaoZi baoZi; private boolean pierXian = false; // 每次生产不相同的包子 // 构造方法 public BaoZiPu(BaoZi baoZi) &#123; this.baoZi = baoZi; &#125; @Override public void run() &#123; // 循环生产包子 while (true) &#123; synchronized (baoZi) &#123; // 调用生产包子的方法 produce(); &#125; &#125; &#125; // 行为 : 生产包子 (不断生产) public void produce() &#123; // 故意延时 : 查看效果 /*try &#123; Thread.sleep((long) (Math.random() * 1000)); // 0 ~ 1000 毫秒之间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;*/ // 判断, 是否只存已经 `有` 了 ??? 如果没有包子, 那么包子铺应该生产包子, // 1. 如果有包子, 那包子铺就不要生产包子了, 等待吃货吃完后, 再生产. if (baoZi.isFlag() == true) &#123; // 有包子, 包子铺需要等待 ... (需要一个锁对象, 调用 wait 方法) try &#123; // IllegalMonitorStateException 这里的线程没有资格调用 `wait` 方法. // wait / notify 方法必须在 synchronized 环境中被调用. baoZi.wait(); // 包子铺使用 `包子这把锁` 对象进行了等待 &#125; catch (InterruptedException e) &#123; // 含义 : 线程 wait 了, 被了 `中断` 后的异常. (不是唤醒) e.printStackTrace(); &#125; &#125; // 2. 没有包子, 包子铺就开始生产包子 if (pierXian == false) &#123; // 1.1 薄皮五仁馅 baoZi.setPier("薄皮"); baoZi.setXianer("五仁馅"); &#125; else &#123; // 1.2 牛肉大葱馅 baoZi.setPier("牛肉"); baoZi.setXianer("大葱馅"); &#125; // 修改包子的 `皮和馅`, (属性取反) pierXian = !pierXian; // 3. 修改包子的 flag 属性 baoZi.setFlag(true); System.out.println("包子铺生产了 " + baoZi.getPier() + baoZi.getXianer() + " 包子."); // 4. 需要唤醒 `chiHuo` 开始吃包子 baoZi.notify(); &#125;&#125; 测试类： 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // 1. 创建一个 `BaoZi` 对象, (多线程操作的共享数据) BaoZi baoZi = new BaoZi(); // 2. 创建一个包子铺对象 BaoZiPu baoZiPu = new BaoZiPu(baoZi); // baoZiPu 对象就是一个线程类对象 // 3. 包子铺类中有一个生产包子功能, 将生产包子功能放到子线程实现循环生产 baoZiPu.start(); // 4. 创建一个吃货对象 ChiHuo chiHuo = new ChiHuo(baoZi); // 5. 启动吃货线程 chiHuo.start(); &#125;&#125; 执行效果： 1234567891011121314包子铺生产了 薄皮五仁馅 包子.吃货吃了薄皮五仁馅 的包子.包子铺生产了 牛肉大葱馅 包子.吃货吃了牛肉大葱馅 的包子.包子铺生产了 薄皮五仁馅 包子.吃货吃了薄皮五仁馅 的包子.包子铺生产了 牛肉大葱馅 包子.吃货吃了牛肉大葱馅 的包子.包子铺生产了 薄皮五仁馅 包子.吃货吃了薄皮五仁馅 的包子.包子铺生产了 牛肉大葱馅 包子.吃货吃了牛肉大葱馅 的包子.包子铺生产了 薄皮五仁馅 包子.吃货吃了薄皮五仁馅 的包子. 第二章 线程池2.1 线程池思想概述 我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题： 如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？ 在Java中可以通过线程池来达到这样的效果。 2.2 线程池概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 合理利用线程池能够带来三个好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 2.3 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有限线程池,也就是池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。 提交Runnable接口子类对象。 关闭线程池。 Runnable实现类代码： 12345678910public class MyRunnable implements Runnable &#123; @Override public void run() &#123; int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; System.out.println(Thread.currentThread().getName() + " 执行完毕: sum = " + sum); &#125;&#125; 线程池测试类： 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolTest &#123; public static void main(String[] args) &#123; // 1. 创建一个任务类对象 MyRunnable task = new MyRunnable(); // 2. 创建一个线程池对象 ExecutorService executorService = Executors.newFixedThreadPool(5); // 3. 提交任务 for (int i = 0; i &lt; 10; i++) &#123; // 循环, 提交了 10 次任务, 查看输出结果 executorService.submit(task); &#125; // 4. 所有任务执行完毕后, 关闭线程池对象 executorService.shutdown(); &#125;&#125;输出结果 :pool-1-thread-5 执行完毕: sum = 5050pool-1-thread-4 执行完毕: sum = 5050pool-1-thread-1 执行完毕: sum = 5050pool-1-thread-2 执行完毕: sum = 5050pool-1-thread-1 执行完毕: sum = 5050pool-1-thread-1 执行完毕: sum = 5050pool-1-thread-1 执行完毕: sum = 5050pool-1-thread-1 执行完毕: sum = 5050pool-1-thread-2 执行完毕: sum = 5050pool-1-thread-3 执行完毕: sum = 5050 第三章 Lambda表达式3.1 函数式编程思想概述 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 3.2 冗余的Runnable代码传统写法当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下： 12345678910111213141516171819202122232425262728293031public class RunnableTest1 &#123; public static void main(String[] args) &#123; Runnable task = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125; &#125;; Thread thread = new Thread(task, "新线程"); thread.start(); // 主线程执行代码 ... for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125;输出结果 :新线程 -&gt; run ... 0main -&gt; run ... 0新线程 -&gt; run ... 1main -&gt; run ... 1新线程 -&gt; run ... 2main -&gt; run ... 2新线程 -&gt; run ... 3main -&gt; run ... 3 本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个Runnable接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。 代码分析对于Runnable的匿名内部类用法，可以分析出几点内容： Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心； 为了指定run的方法体，不得不需要Runnable接口的实现类； 为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类； 必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错； 而实际上，似乎只有方法体才是关键所在。 3.3 编程思想转换做什么，而不是怎么做我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。 传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。 生活举例 当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。 而现在这种飞机（甚至是飞船）已经诞生：Java 8（JDK 1.8）中，加入了Lambda表达式的重量级新特性，为我们打开了新世界的大门。 3.4 体验Lambda的更优写法借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效： 123456789101112131415public class RunnableTest1 &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;, "新线程").start(); // 主线程执行代码 ... for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125; 这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。 不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！ 3.5 匿名内部类与LambdaLambda是怎样击败面向对象的？ 需求 : 定义一个Student类, 按照学生的年龄进行排序, 如果年龄一致, 顺序排放. 123456789101112131415161718192021222324252627282930313233343536public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public Student() &#123; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 使用匿名内部类123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class StudentSortTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("张三", 18)); list.add(new Student("李四", 16)); list.add(new Student("王五", 19)); list.add(new Student("赵六", 17)); // Collections.sort(集合, 比较器对象); Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;); for (Student stu : list) &#123; System.out.println(stu); &#125; &#125;&#125;输出结果 :Student&#123;name='李四', age=16&#125;Student&#123;name='赵六', age=17&#125;Student&#123;name='张三', age=18&#125;Student&#123;name='王五', age=19&#125; 匿名内部类的好处与弊端一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！ Lambda 标准格式Lambda省去面向对象的条条框框，格式由3个部分组成： 一些参数 一个箭头 一段代码 Lambda表达式的标准格式为： 1(参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.Collections;public class Test &#123; public static void main(String[] args) &#123; // 需求 : 定义一个 Student 类, 对 Student 类的对象实现排序. // 排序规则 : 按照 `年龄` 升序排列, 如果年龄一致, 顺序排列. // 1. 创建一个集合, 存储 Student 类型的对象 ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student("张三", 18)); list.add(new Student("李四", 17)); list.add(new Student("王五", 19)); list.add(new Student("赵六", 16)); // 2. 排序方法 Collections.sort(集合, 比较器对象) // 实现方式一 : 匿名实现类 /* 1. new 接口类型 &#123;&#125; 2. 重写 compare 方法. */ /*Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;);*/ // 实现方式二 : Lambda 实现 // 该接口类型 : 必须仅有一个 `抽象方法`. 这个的接口被称为 `函数式` 接口. // Lambda 表达式就是函数式接口的简写方案. // Collections.sort(list, (Student o1, Student o2) -&gt; &#123;return o1.getAge() - o2.getAge();&#125;); // 实现方式三 : 省略原则 : // 1. 参数类型可以省略. 如果参数仅有一个参数, 小括号也可以省略. // 2. 如果&#123;&#125;实现类, 仅有一句话, 大括号也可以省略. 无论是否有返回, 如果仅有一条语句, return 和 ; 也可以省略 Collections.sort(list, (o1, o2) -&gt; o1.getAge() - o2.getAge()); // 3. 查看 for (Student stu : list) &#123; System.out.println(stu); &#125; &#125;&#125;输出结果 :Student&#123;name='赵六', age=16&#125;Student&#123;name='李四', age=17&#125;Student&#123;name='张三', age=18&#125;Student&#123;name='王五', age=19&#125; 3.6 练习：使用Lambda标准格式（无参无返回）题目给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。如下： 123public interface Cook &#123; void makeFood();&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样： 1234567891011public class Test &#123; public static void main(String[] args) &#123; // TODO 请在此使用Lambda【标准格式】调用invokeCook方法 &#125; public static void invokeCook(Cook cook) &#123; cook.makeFood(); &#125;&#125; 解答1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; // 传统方式 : invokeCook(new Cook() &#123; @Override public void makeFood() &#123; System.out.println("开饭啦 ..."); &#125; &#125;); // TODO 请在此使用Lambda【标准格式】调用invokeCook方法 invokeCook(() -&gt; System.out.println("吃饭啦 ...")); &#125; public static void invokeCook(Cook cook) &#123; cook.makeFood(); &#125;&#125;输出结果 :开饭啦 ...吃饭啦 ... 备注：小括号代表Cook接口makeFood抽象方法的参数为空，大括号代表makeFood的方法体。 3.7 练习：使用Lambda标准格式（有参有返回）题目给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值： 123public interface Calculator &#123; int calc(int a, int b);&#125; 在下面的代码中，请使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算： 12345678910111213141516171819202122232425public class Test2 &#123; public static void main(String[] args) &#123; // 传统方式 : invokeCalculator(10, 20, new Calculator() &#123; @Override public int calc(int num1, int num2) &#123; return num1 + num2; &#125; &#125;); // TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果 invokeCalculator(120, 130, (a, b) -&gt; a + b); &#125; // 计算 : public static void invokeCalculator(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println("result = " + result); &#125;&#125;输出结果 :result = 30result = 250 3.8 Lambda省略规则可推导即可省略 (省略规则)在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。 3.9 Lambda的使用前提Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。 练习题练习一：线程池概念问题： 请描述什么是线程池。 答： 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 练习二：线程池优点问题： 请描述合理利用线程池能够带来的三个好处。 答： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 练习三：Lambda表达式问题： 请列举Lambda语法的省略规则 答： 在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 练习四：Lambda表达式问题： 请列举Lambda表达式的3个组成部分，并解释说明。 答： Lambda标准格式 Lambda省去面向对象的条条框框，格式由3个部分组成：一些参数，一个箭头，一段代码。 Lambda表达式的标准格式为：格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 练习五：Lambda表达式问题： 请描述Lambda的使用前提 答： Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 练习六：多线程问题： 请在指定位置插入代码实现打印输出1-99。 123456789101112public class Test06 &#123; public int start = 1; public int end = 99; public static void main (String[] args) &#123; new Test06().method(); &#125; public void method() &#123; //请在此处插入代码，实现功能 Thread t = new Thread( a ); t.start(); &#125;&#125; 答： 12345678910111213141516171819public class Test06 &#123; public int start = 1; public int end = 99; public static void main(String[] args) &#123; new Test06().method(); &#125; public void method() &#123; //插入代码处 Runnable a = () -&gt; &#123; for (int i = start; i &lt;end; i++) &#123; System.out.println(i); &#125; &#125;; Thread t = new Thread(a); t.start(); &#125;&#125; 练习七：多线程问题：给出以下代码，请问该程序的运行结果是什么?如有问题，请说明原因。 123456789101112public class Test07 implements Runnable &#123; public static void main(String[] args) &#123; Thread t = new Thread(new Test07()); t.start(); &#125; public void run(int num) &#123; for (int i = 0; i &lt; num; i++) &#123; System.out.println(i); &#125; &#125;&#125; 答： 在编译时期就会报错 Test类没有重写Runnable接口中的run()方法 public void run(int num)不是Runnable接口中的run()方法。 注意：Runnable接口中的run()方法，参数列表为空，不带参数。 练习八：线程池练习问题： 使用线程池创建多线程。模拟同学找老师学习Java。 创建线程池对象，包含2个线程。从线程池中获取线程对象，然后调用MyRunnable中的run()。 在MyRunnable实现类中，首先在控制台打印需求，“我需要一个老师”。模拟需要2秒钟时间老师可以过来指导学生，并在控制台打印老师的姓名。最后，在控制台打印“教我java,教完后，老师回到了办公室”； 12345678910111213141516171819/* *1.Runnable实现类代码： */import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("我要一个老师"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("老师来了"+Thread.currentThread().getName()); System.out.println("教我java,教完后，老师回到了办公室"); &#125;&#125; 123456789101112131415161718192021222324252627/* *2.线程池测试类： */import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ‐‐‐&gt;调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125; 练习九：Lambda（无参无返回）练习问题： 给定一个导演 Director接口，内含唯一的抽象方法makeMovie，且无参数、无返回值，使用lambda表达式在Test中完成调用。 123public interface Director &#123; void makeMovie();&#125; 在下面的代码中，请使用Lambda的省略格式调用 invokeDirect 方法，打印输出“导演拍电影啦！”字样： 1234567891011public class Test09InvokeDirect &#123; public static void main(String[] args) &#123; // TODO 请使用Lambda【省略格式】调用invokeDirect方法 &#125; private static void invokeDirect(Director director) &#123; director.makeMovie(); &#125;&#125; 答： 使用Lambda【省略格式】调用invokeDirect方法 1234567891011public class Test09InvokeDirect &#123; public static void main(String[] args) &#123; // TODO 请使用Lambda【省略格式】调用invokeDirect方法 invokeDirect(() -&gt; System.out.println("导演拍电影啦！")); &#125; private static void invokeDirect(Director director) &#123; director.makeMovie(); &#125;&#125; 练习十：Lambda（有参有返回）练习问题： 给定一个计算器 Calculator 接口，内含抽象方法 calc (减法)，其功能是可以将两个数字进行相减，并返回差值。使用Lambda表达式在Test中完成调用。 123public interface Calculator &#123; int calc(int a, int b);&#125; 在下面的代码中，请分别使用Lambda的标准格式及省略格式调用 invokeCalc 方法，完成130和120的相减计算： 1234567891011public class Test10InvokeCalc &#123; public static void main(String[] args) &#123; // TODO 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß &#125; private static void invokeCalc(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println("结果是：" + result); &#125;&#125; 答： 1.使用Lambda【标准格式】调用invokeCalc方法来计算130-120的结果ß 12345678910111213public class Test10InvokeCalc &#123; public static void main(String[] args) &#123; // TODO 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß invokeCalc(130, 120, (int a, int b) -&gt; &#123; return a - b; &#125;); &#125; private static void invokeCalc(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println("结果是：" + result); &#125;&#125; 2.使用Lambda【省略格式】调用invokeCalc方法来计算130-120的结果ß 1234567891011public class Test10InvokeCalc &#123; public static void main(String[] args) &#123; // TODO 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß invokeCalc(130, 120, (a, b) -&gt; a - b); &#125; private static void invokeCalc(int a, int b, Calculator calculator) &#123; int result = calculator.calc(a, b); System.out.println("结果是：" + result); &#125;&#125; 练习十一：Lambda（省略格式）练习问题：对Java基础班学生的考试成绩进行排序 定义一个学生类，有两个属性。姓名，考试成绩 在测试类中定义一个学生数组，存储学生信息。 使用Lambda省略格式写法对学生数组按照考试成绩由高到低进行排序。 答： 12345678/** * 1.定义学生类*/public class Student &#123; private String name; private int score; // 省略构造器、toString方法与Getter Setter&#125; 1234567891011121314151617181920212223242526/** * 2.测试类代码* 按照成绩从大到小排序*/import java.util.Arrays;import java.util.Comparator;public class Test11Comparator &#123; public static void main(String[] args) &#123; // 本来成绩乱序的对象数组 Student[] array = &#123; new Student("宋远桥", 99), new Student("俞岱岩", 98), new Student("张翠山", 100)&#125;; //使用lambda省略格式排序 Arrays.sort(array, (s1, s2) -&gt; s2.getScore() - s1.getScore()); //遍历数组 for (Student student : array) &#123; System.out.println(student); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶06-线程和同步]]></title>
    <url>%2F2019%2F08%2F24%2F2019-08-24-Java%E8%BF%9B%E9%98%B606-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[主要内容 线程 同步 线程状态 学习目标 能够描述Java中多线程运行原理 能够使用继承类的方式创建多线程 能够使用实现接口的方式创建多线程 能够说出实现接口方式的好处 能够解释安全问题的出现的原因 能够使用同步代码块解决线程安全问题 能够使用同步方法解决线程安全问题 能够说出线程6个状态的名称 第一章 线程1.1 多线程原理昨天的时候我们已经写过一版多线程的代码，很多同学对原理不是很清楚，那么我们今天先画个多线程执行时序图来体现一下多线程程序的执行流程。 代码如下： 自定义线程类： 1234567891011121314public class MyThread extends Thread &#123; public MyThread(String name) &#123; // 说明 : 利用继承中的特点, 将线程名称传递给父类进行设置 super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(this.getName() + " -&gt; run ... " + i); &#125; &#125;&#125; 测试类： 12345678910111213141516171819202122232425public class ThreadTest1 &#123; public static void main(String[] args) &#123; // 1. 创建一个 MyThread 类对象 MyThread myThread = new MyThread("下载线程"); // 2. 启动子线程 myThread.start(); // 主线程执行代码 ... for (int i = 0; i &lt; 20; i++) &#123; // Thread.currentThread 获取当前线程对象 System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125;输出结果 :main -&gt; run ... 0下载线程 -&gt; run ... 0main -&gt; run ... 1下载线程 -&gt; run ... 1main -&gt; run ... 2下载线程 -&gt; run ... 2main -&gt; run ... 3下载线程 -&gt; run ... 3 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用myThread的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 1.2 Thread类在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread类，API中该类中定义了有关线程的一些方法，具体如下： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上之前已经完成，接下来讲解方式二实现的方式。 1.3 创建线程方式二采用java.lang.Runnable也是非常常见的一种，我们只需要重写run方法即可。 步骤如下： 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动线程。 代码如下： 12345678910// 1. 定义一个 `任务类`, 该类需要实现 Runnable 接口public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125; 1234567891011121314151617181920212223242526public class ThreadTest2 &#123; public static void main(String[] args) &#123; // 1. 创建一个 `任务类` 对象 MyRunnable myRunnable = new MyRunnable(); // 2. 创建一个 `线程类` 对象, 并同时将任务类对象作为参数传入 Thread thread = new Thread(myRunnable, "下载线程"); // 3. 使用 `线程类` 对象调用 start 方法, 启动子线程 thread.start(); // 4. 主线程执行代码 ... for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125;输出结果 :main -&gt; run ... 0main -&gt; run ... 1下载线程 -&gt; run ... 0下载线程 -&gt; run ... 1下载线程 -&gt; run ... 2下载线程 -&gt; run ... 3main -&gt; run ... 2main -&gt; run ... 3 通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 1.4 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 总结： 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 1.5 匿名内部类方式实现线程的创建使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。 使用匿名内部类的方式实现 Runnable 接口，重新 Runnable 接口中的 run 方法 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125;public class ThreadTest1 &#123; public static void main(String[] args) &#123; // 实现多线程代码执行 ... // Thread(Runnable target, String name); // Runnable target = new Runnable(); 接口不能实例化对象 // Runnable target = new MyRunnable(); 接口引用接收接口实现类对象 // 请问 : new Runnable(); 和 new MyRunnable(); 的最大区别 ??? 有没有重写接口中抽象方法. (run方法) // 接口引用 = 匿名实现类对象; (多态) Runnable target = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125; &#125;; Thread t1 = new Thread(target, "下载线程"); t1.start(); // 更加简洁的写法 ... new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125; &#125;, "上传线程").start(); // 主线程执行代码 ... for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName() + " -&gt; run ... " + i); &#125; &#125;&#125;输出结果 :下载线程 -&gt; run ... 0main -&gt; run ... 0下载线程 -&gt; run ... 1上传线程 -&gt; run ... 0下载线程 -&gt; run ... 2 第二章 线程安全2.1 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 我们通过一个案例，演示线程的安全问题 ： 电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟. 模拟票 ： 1234567891011121314151617181920212223242526272829public class TicketTask implements Runnable &#123; // 属性 private int tickets = 100; @Override public void run() &#123; // 循环卖票 while (true) &#123; // 判断, 是否还要票 if (tickets &gt; 0) &#123; // 模拟延时操作 (演示安全问题) try &#123; Thread.sleep((int)(Math.random() * 100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在售出第" + tickets + "张票."); // 票数自减 tickets--; &#125; else &#123; // 结束循环卖票 break; &#125; &#125; &#125;&#125; 测试类： 1234567891011121314151617public class TicketWindowTest &#123; public static void main(String[] args) &#123; // 1. 创建一个 `售票任务` 对象 TicketTask ticketTask = new TicketTask(); // 2. 创建三个线程对象, 将售票任务对象传入 Thread ticketWindow1 = new Thread(ticketTask, "窗口一"); Thread ticketWindow2 = new Thread(ticketTask, "窗口二"); Thread ticketWindow3 = new Thread(ticketTask, "窗口三"); // 3. 启动三个售票窗口, 实现售票 ticketWindow1.start(); ticketWindow2.start(); ticketWindow3.start(); &#125;&#125; 结果中有一部分这样现象： 1234567窗口三正在售出第5张票.窗口二正在售出第5张票.窗口三正在售出第3张票.窗口二正在售出第2张票.窗口一正在售出第1张票.窗口三正在售出第0张票.窗口二正在售出第-1张票. 发现程序出现了两个问题： 相同的票数,比如5这张票被卖了两回。 不存在的票，比如0票与-1票，是不存在的。 这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 2.2 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。 根据案例简述： 1窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。 为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 那么怎么去使用呢？有三种方式完成同步操作： 同步代码块。 同步方法。 锁机制。 2.3 同步代码块 同步代码块：synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。 使用同步代码块解决代码： 12345678910111213141516171819202122232425262728293031323334public class TicketTask implements Runnable &#123; // 属性 private int tickets = 100; // 定义一个 `锁` 对象 Object lock = new Object(); @Override public void run() &#123; // 循环卖票 while (true) &#123; synchronized (lock) &#123; // 判断, 是否还要票 if (tickets &gt; 0) &#123; // 模拟延时操作 (演示安全问题) try &#123; Thread.sleep((int)(Math.random() * 100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在售出第" + tickets + "张票."); // 票数自减 tickets--; &#125; else &#123; // 结束循环卖票 break; &#125; &#125; &#125; &#125;&#125; 当使用了同步代码块后，上述的线程的安全问题，解决了。 2.4 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 同步锁是谁? ​ 对于非static方法,同步锁就是this。 ​ 对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 使用同步方法代码如下： 12345678910111213141516171819202122232425262728293031323334353637public class TicketTask implements Runnable &#123; // 属性 private int tickets = 100; @Override public void run() &#123; // 循环卖票 while (true) &#123; // 判断, 是否还要票 sellTicket(); if (tickets &lt;= 0) &#123; // 结束循环卖票 break; &#125; &#125; &#125; // 定义一个卖票方法 private synchronized void sellTicket() &#123; if (tickets &gt; 0) &#123; // 模拟延时操作 (演示安全问题) try &#123; Thread.sleep((int)(Math.random() * 100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在售出第" + tickets + "张票."); // 票数自减 tickets--; &#125; &#125;&#125; 2.5 Lock锁java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() : 加同步锁。 public void unlock() : 释放同步锁。 使用如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class TicketTask implements Runnable &#123; // 属性 private int tickets = 100; // 定义一个 `锁` 对象 Lock lock = new ReentrantLock(); @Override public void run() &#123; // 循环卖票 while (true) &#123; // 判断, 是否还要票 sellTicket(); if (tickets &lt;= 0) &#123; // 结束循环卖票 break; &#125; &#125; &#125; // 定义一个卖票方法 private void sellTicket() &#123; // 获取锁 lock.lock(); if (tickets &gt; 0) &#123; // 模拟延时操作 (演示安全问题) try &#123; Thread.sleep((int)(Math.random() * 100)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在售出第" + tickets + "张票."); // 票数自减 tickets--; &#125; // 释放锁 lock.unlock(); &#125;&#125; 第三章 线程状态 (了解)3.1 线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。 3.2 Timed Waiting（计时等待）Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ 在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。 实现一个计数器，计数到10，在每个数字之间暂停1秒. 代码： 123456789101112131415161718192021222324252627282930313233public class TimedWaitingState1 &#123; public static void main(String[] args) &#123; // 启动一条子线程 new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep(1000); // 线程状态 : Timed Waiting &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(i); &#125; &#125; &#125;, "等待线程").start(); &#125;&#125;输出结果 :0123456789 通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点： 进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠 sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。 小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。 Timed Waiting 线程状态图： 3.3 BLOCKED（锁阻塞）Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 这是由Runnable状态进入Blocked状态。除此Waiting以及Timed Waiting状态也会在某种情况下进入阻塞状态。 Blocked 线程状态图 3.4 Waiting（无限等待）Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来学习一下： 计时等待 : 123456789101112131415161718192021222324252627282930313233public class MyThreadTest &#123; // 属性 private static Object lock = new Object(); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (lock) &#123; // 计时等待 try &#123; System.out.println(Thread.currentThread().getName() + " - 进入计时等待 5 秒."); lock.wait(5000); // timed-waiting System.out.println(Thread.currentThread().getName() + " - 时间到, 自己醒来."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;, "等待线程").start(); &#125;&#125;输出结果 :等待线程 - 进入计时等待 5 秒.等待线程 - 时间到, 自己醒来.等待线程 - 进入计时等待 5 秒.等待线程 - 时间到, 自己醒来.等待线程 - 进入计时等待 5 秒. 无限等待 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyThreadTest &#123; // 属性 private static Object lock = new Object(); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (lock) &#123; // 计时等待 try &#123; System.out.println(Thread.currentThread().getName() + " - 进入无限等待."); lock.wait(); // waiting 状态 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;, "等待线程").start(); // 唤醒线程 new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lock) &#123; // 每隔 3 秒, 唤醒一次 System.out.println(Thread.currentThread().getName() + " - 每隔 3 秒, 唤醒一次."); lock.notify(); &#125; &#125; &#125; &#125;, "唤醒线程").start(); &#125;&#125;输出结果 :等待线程 - 进入无限等待.唤醒线程 - 每隔 3 秒, 唤醒一次.等待线程 - 进入无限等待.唤醒线程 - 每隔 3 秒, 唤醒一次.等待线程 - 进入无限等待.唤醒线程 - 每隔 3 秒, 唤醒一次.等待线程 - 进入无限等待. 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 Object.notify()方法 或 Object.notifyAll()方法。 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 Waiting 线程状态图 3.5 补充知识点到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图： 一条有意思的tips: 我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。 练习题练习一：多线程开启问题： 请描述Thread类中的start()方法与run()方法的区别。 答： 线程对象调用run()方法不开启线程，仅是对象调用方法。线程对象调用start()方法开启线程，并让jvm调用run()方法在开启的线程中执行。 练习二：创建多线程问题： 请描述创建线程的两种方式。 答： 第一种方式是将类声明为 Thread 的子类。 （1）定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。 第二种方式是声明一个类实现Runnable 接口。 （1）定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动线程。 练习三：多线程练习问题： 请编写程序，分别打印主线程的名称和子线程的名称。 要求使用两种方式实现： 第一种方式：继承Thread类。 第二种方法：实现Runnable接口。 答： 操作步骤描述 第一种方式：继承Thread类 ​ 1.定义一个子线程的类，继承Thread类； ​ 2.在子线程类中重写run方法，在run方法中打印子线程的名称； ​ 3.定义一个测试类； ​ 4.在main方法中打印主线程的名称； ​ 5.在main方法中创建子线程对象； ​ 6.调用子线程对象的start方法，开启子线程； 第二种方式：实现Runnable接口 ​ 1.定义一个子任务类，实现Runnable接口； ​ 2.在子任务类中重写run方法，在run方法中打印子线程的名称； ​ 3.定义一个测试类； ​ 4.在main方法中打印主线程的名称； ​ 5.在main方法中创建一个子任务对象； ​ 6.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的构造方法； ​ 7.调用Thread类对象的start方法开启子线程； 操作步骤答案 第一种方式：继承Thread类 123456789101112/* * 1.定义一个子线程的类，继承Thread类； */public class SubThread extends Thread &#123; /* *2.在子线程类中重写run方法，在run方法中打印子线程的名称； */ public void run() &#123; // 打印子线程的名称 System.out.println("subThread:" + Thread.currentThread().getName()); &#125;&#125; 12345678910111213/* * 3.定义一个测试类 */public class ThreadDemo &#123; public static void main(String[] args) &#123; // 4.在main方法中打印主线程的名称； System.out.println("main:" + Thread.currentThread().getName()); // 5.在main方法中创建子线程对象； SubThread st = new SubThread(); // 6.调用子线程对象的start方法，开启子线程。 st.start(); &#125;&#125; 第二种方式：实现Runnable接口 12345678910/* * 1.定义一个子任务类，实现Runnable接口。 */public class SubRunnable implements Runnable &#123; @Override public void run() &#123; // 2.在子任务类中重写run方法，在run方法中打印子线程的名称。 System.out.println("SubRunnable:"+ Thread.currentThread().getName()); &#125;&#125; 123456789101112131415/* * 3.定义一个测试类。 */public class RunnableDemo &#123; public static void main(String[] args) &#123; // 4.在main方法中打印主线程的名称。 System.out.println("RunnableDemo:"+ Thread.currentThread().getName()); // 5.在main方法中创建一个子任务对象。 SubRunnable r = new SubRunnable(); // 6.在main方法中创建一个Thread类的对象，并把子任务对象传递给Thread类的 构造方法。 Thread t = new Thread(r); // 7.调用Thread类对象的start方法开启子线程。 t.start(); &#125;&#125; 练习四：实现Runnable接口的优势问题： 请描述实现Runnable接口比继承Thread类所具有的优势： 答： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和数据独立。 线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类。 练习五：线程状态问题：请描述在线程的生命周期中，有几种状态呢 ? 答： NEW(新建) 线程刚被创建，但是并未启动。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 练习六：多线程练习问题： 编写程序，在主线程中，循环输出“主线程执行”；在一条新线程中，循环输出“子线程执行”。 答： 12345678910//1.创建一个子线程类public class Son implements Runnable &#123; public void run() &#123; while (true) &#123; System.out.println("子线程执行...."); &#125; &#125;&#125; 1234567891011//2.创建一个测试类public class Test06 &#123; public static void main(String[] args) &#123; //创建一个子线程对象 Thread son = new Thread(new Son()); son.start();//开启子线程 while (true) &#123; System.out.println("主线程执行"); &#125; &#125;&#125; 练习七：多线程匿名内部类练习问题： 编写程序，创建两个线程对象，一根线程循环输出“播放背景音乐”，另一根线程循环输出“显示画面”，要求线程实现Runnable接口，且使用匿名内部类实现。 答： 123456789101112131415161718192021222324252627//1.定义一个测试类public class Test07 &#123; public static void main(String[] args) &#123; //1.新建第一条线程并开启 new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println("播放背景音乐"); &#125; &#125; &#125;).start(); //2.新建第二条线程并开启 new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println("显示画面"); &#125; &#125; &#125;).start(); &#125;&#125; 练习八：多线程练习问题： 编写一个Java程序，要求在同一个类中除main线程外，再开启一个线程，2个线程都循环执行20次。 答： 12345678910111213141516171819public class Test08 extends Thread &#123; int a = 1; public static void main(String[] args) &#123; Test08 thread = new Test08(); thread.start(); for (int i = 1; i &lt;= 20; i++) &#123; System.out.println(Thread.currentThread().getName() + "执行第:" + i + "次"); &#125; &#125; @Override public void run() &#123; for (; a &lt;= 20; a++) &#123; System.out.println(Thread.currentThread().getName() + "执行第:" + a + "次"); &#125; &#125;&#125; 练习九：多线程练习问题： 请按要求编写多线程应用程序，模拟多个人通过一个山洞： 1.这个山洞每次只能通过一个人，每个人通过山洞的时间为5秒； 2.随机生成10个人，同时准备过此山洞，并且定义一个变量用于记录通过隧道的人数。显示每次通过山洞人的姓名，和通过顺序； 答： 操作步骤描述 ​ 1.定义一个隧道类，实现Runnable接口： ​ 1.1 定义一个变量，用来记录通过隧道的人数； ​ 1.2 重写Runnable的run方法； ​ 1.3 定义一个同步方法，模拟每个人通过隧道需要5秒钟： ​ 1.3.1 子线程睡眠5秒钟，模拟每个人通过隧道需要5秒钟； ​ 1.3.2 改变通过的人次； ​ 1.3.3 打印线程名称及其通过隧道的顺序，模拟人通过隧道及其顺序； ​ 1.4 调用通过隧道的方法； ​ 2.定义一个测试类： ​ 2.1 在main方法中创建一个隧道类对象； ​ 2.2 在main方法中，循环创建10个子线程对象，通过构造方法把隧道对象 ​ 和线程名（作为人的姓名）传递进去，并开启子线程； 操作步骤答案 123456789101112131415161718192021222324252627282930313233/* * 1.定义一个隧道类，实现Runnable接口 */public class Tunnel implements Runnable &#123; // 1.1 定义一个变量，用来记录通过隧道的人数 private int crossNum = 0; /* * 1.2 重写Runnable的run方法 */ @Override public void run() &#123; // 1.4 调用通过隧道的方法 cross(); &#125; /* * 1.3 定义一个同步方法，模拟每个人通过隧道需要5秒钟 */ public synchronized void cross() &#123; // 1.3.1 子线程睡眠5秒钟，模拟每个人通过隧道需要5秒钟 try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 1.3.2 改变通过的人次 crossNum++; // 1.3.3 打印线程名称及其通过隧道的顺序，模拟人通过隧道及其顺序 System.out.println(Thread.currentThread().getName() + "已经通过隧道，TA是第" + crossNum + "通过的！"); &#125;&#125; 12345678910111213141516/* * 2.定义一个测试类 */public class TunnelDemo &#123; public static void main(String[] args) &#123; // 2.1 在main方法中创建一个隧道类对象 Tunnel tul = new Tunnel(); // 2.2 在main方法中，循环创建10个子线程对象，通过构造方法把隧道对象和// 线程名（作为人的姓名）传递进去，并开启子线程 for (int i = 1; i &lt;= 10; i++) &#123; Thread t = new Thread(tul, "p" + i); t.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶08-File类和递归]]></title>
    <url>%2F2019%2F08%2F24%2F2019-08-24-Java%E8%BF%9B%E9%98%B608-File%E7%B1%BB%E5%92%8C%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[主要内容 File类 递归 学习目标 能够说出File对象的创建方式 能够说出File类获取名称的方法名称 能够说出File类获取绝对路径的方法名称 能够说出File类获取文件大小的方法名称 能够说出File类判断是否是文件的方法名称 能够说出File类判断是否是文件夹的方法名称 能够辨别相对路径和绝对路径 能够遍历文件夹 能够解释递归的含义 能够使用递归的方式计算5的阶乘 能够说出使用递归会内存溢出隐患的原因 第一章 File类1.1 概述java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Collections;public class FileConstructorTest &#123; public static void main(String[] args) &#123; // 请问 : 为什么要学习 File 类 ??? File 代表 `文件和目录 (文件夹)`. // File 在硬盘上的形式, 类似于数据的永久性存储. (关闭后, 重新开机, 数据依然存在) // 程序中的数据, `变量, 数组, 集合`, 程序一旦结束, 所有程序中的数据都会被销毁. int num = 10; int[] arr = &#123;10, 20, 30, 40, 50&#125;; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, "张三", "李四", "王五"); // 请问 : 如果我们想将程序中的数据, 实现永久性的存储, 如何做呢 ??? // 程序如何与硬盘实现交互 ??? // 方向1 : 将程序中的数据写入到硬盘, 实现永久性存储. // 方向2 : 从硬盘中将数据读取到程序中, 实现操作. // 参照物 : 内存 // 输入流 : 从硬盘上流入到内存的操作类, 被称为输入流类. InputStream / Reader // 输出流 : 从内存中写出到硬盘中的操作类, 被称为输出流类. OutputStream / Writer // 流分成两大类 : // 字节流 : 所有数据皆字节数据. (文字, 图片, 音频, 视频 ...) 01010101010... // 字符流 : 字节流 + 编码表(翻译) `中国人` (2个字节 `GBK` / 3个字节 `UTF-8`) // File类 : 所有数据最终都存储在文件中, 文件可以存储到文件夹中进行管理. &#125;&#125; 1.2 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 12345678910111213141516171819202122232425262728293031import java.io.File;public class FileConstructorTest2 &#123; public static void main(String[] args) &#123; // 需求 : 如何创建一个 File 对象 // File 类的说明 : 文件和目录路径名的抽象表示 // 目的 : 创建文件, 创建文件夹, 判断是文件还是文件夹, 删除文件, 重命名 ... // 1. public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File file1 = new File("D:\\aaa.txt"); System.out.println("file1 = " + file1); // 2. public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 String parent = "D:\\aaa"; String child = "aaa.txt"; File file2 = new File(parent, child); System.out.println("file2 = " + file2); // 3. public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 File parent2 = new File("D:\\aaa"); String child2 = "aaa.txt"; File file3 = new File(parent2, child2); System.out.println("file3 = " + file3); &#125;&#125;输出结果 :file1 = D:\aaa.txtfile2 = D:\aaa\aaa.txtfile3 = D:\aaa\aaa.txt 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 1.3 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;public class FileMethodTest3 &#123; public static void main(String[] args) &#123; // 绝对路径 : 从根盘符开始的路径, 被称为 `绝对路径`. // 相对路径 : 针对当前而言. File file1 = new File("D:/aaa.txt"); // 绝对路径 File file2 = new File("aaa.txt"); // 相对路径 (相对当前项目而言) //- public String getAbsolutePath() ：返回此File的绝对路径名字符串。 System.out.println("file1的绝对路径 : " + file1.getAbsolutePath()); System.out.println("file2的绝对路径 : " + file2.getAbsolutePath()); //- public String getPath() ：将此File转换为路径名字符串。 (构造路径) System.out.println("file1的构造路径 : " + file1.getPath()); System.out.println("file2的构造路径 : " + file2.getPath()); //- public String getName() ：返回由此File表示的文件或目录的名称。 System.out.println("file1对象的文件名称 : " + file1.getName()); System.out.println("file2对象的文件名称 : " + file2.getName()); //- public long length() ：返回由此File表示的文件的长度。 System.out.println("file1对象的文件长度为 : " + file1.length()); // 文件中数据的字节数 File file = new File("D:/aaa"); // 如果此路径名表示目录，则返回值未指定。 System.out.println("file文件夹的长度 : " + file.length()); // 说明 : 获取文件夹的长度是不固定的. &#125;&#125;输出结果：file1的绝对路径 : D:\aaa.txtfile2的绝对路径 : D:\Java\IdeaProjects\44期\Day08\aaa.txtfile1的构造路径 : D:\aaa.txtfile2的构造路径 : aaa.txtfile1对象的文件名称 : aaa.txtfile2对象的文件名称 : aaa.txtfile1对象的文件长度为 : 1508file文件夹的长度 : 0 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 123456789101112131415161718import java.io.File;public class Test3 &#123; public static void main(String[] args) &#123; // 绝对路径 : 从盘符开始的路径, 这是一个完整的路径. File file1 = new File("D:\\bbb.java"); System.out.println("file1 = " + file1.getAbsolutePath()); // 相对路径 : 相对于项目目录的路径, 这是一个便捷的路径, 开发中经常使用. File file2 = new File("bbb.java"); System.out.println("file2 = " + file2.getAbsolutePath()); &#125;&#125;输出结果：file1 = D:\bbb.javafile2 = D:\Java\IdeaProjects\MyTest1\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： 1234567891011121314151617181920212223242526272829import java.io.File;public class Test4 &#123; public static void main(String[] args) &#123; File file1 = new File("D:\\aaa\\bbb.java"); File file2 = new File("D:\\aaa"); // public boolean exists() ：此File表示的文件或目录是否实际存在。 System.out.println("file1描述的文件是否存在 : " + file1.exists()); System.out.println("file2描述的目录是否存在 : " + file2.exists()); // public boolean isDirectory() ：此File表示的是否为目录。 System.out.println("file1描述的是目录吗 ? " + file1.isDirectory()); System.out.println("file2描述的是目录吗 ? " + file2.isDirectory()); // public boolean isFile() ：此File表示的是否为文件。 System.out.println("file1描述的是文件吗 ? " + file1.isFile()); System.out.println("file2描述的是文件吗 ? " + file2.isFile()); &#125;&#125;输出结果：file1描述的文件是否存在 : truefile2描述的目录是否存在 : truefile1描述的是目录吗 ? falsefile2描述的是目录吗 ? truefile1描述的是文件吗 ? truefile2描述的是文件吗 ? false 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 文件的创建演示 : 12345678910111213141516171819202122import java.io.File;import java.io.IOException;public class Test5 &#123; public static void main(String[] args) throws IOException &#123; File file1 = new File("D:\\aaa.txt"); System.out.println("file1表示的文件是否存在 ? " + file1.exists()); // public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 boolean result = file1.createNewFile(); System.out.println("file1表示的文件是否创建 ? " + result); System.out.println("file1表示的文件是否存在 ? " + file1.exists()); &#125;&#125;输出结果 :file1表示的文件是否存在 ? falsefile1表示的文件是否创建 ? truefile1表示的文件是否存在 ? true 目录的创建演示 : 123456789101112131415161718192021222324252627282930313233343536import java.io.File;public class Test6 &#123; public static void main(String[] args) &#123; File file1 = new File("D:\\bbb"); System.out.println("file1表示的目录是否存在 ? " + file1.exists()); // public boolean mkdir() ：创建由此File表示的目录。 boolean result = file1.mkdir(); System.out.println("file1表示的目录是否创建成功 ? " + result); System.out.println("file1表示的目录是否存在 ? " + file1.exists()); System.out.println("-----------------------------"); File file2 = new File("D:\\ccc\\ddd\\eee"); System.out.println("file2表示的目录是否存在 ? " + file2.exists()); // public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 boolean result2 = file2.mkdirs(); System.out.println("file2表示的目录是否创建成功 ? " + result2); System.out.println("file2表示的目录是否存在 ? " + file2.exists()); &#125;&#125;输出结果 :file1表示的目录是否存在 ? truefile1表示的目录是否创建成功 ? falsefile1表示的目录是否存在 ? true-----------------------------file2表示的目录是否存在 ? falsefile2表示的目录是否创建成功 ? truefile2表示的目录是否存在 ? true 删除文件与目录 : 123456789101112131415161718192021import java.io.File;public class Test7 &#123; public static void main(String[] args) &#123; // public boolean delete() ：删除由此File表示的文件或目录。 File file1 = new File("D:\\aaa.txt"); File file2 = new File("D:\\aaa"); File file3 = new File("D:\\bbb"); System.out.println("file1文件是否删除成功 ? " + file1.delete()); System.out.println("file2非空文件夹是否删除成功 ? " + file2.delete()); System.out.println("file3空文件夹是否删除成功 ? " + file3.delete()); &#125;&#125;输出结果 :file1文件是否删除成功 ? truefile2非空文件夹是否删除成功 ? falsefile3空文件夹是否删除成功 ? true API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 补充说明 : 在文件夹中直接创建文件, 一步到位, 如何实现 ??? 1234567891011121314151617181920212223242526272829import java.io.File;import java.io.IOException;public class FileCreateFileTest3 &#123; public static void main(String[] args) throws IOException &#123; File file = new File("D:/zzz/yyy/hello.txt"); // 创建文件 // 注意点 : 如果创建文件的父目录不存在, 文件就会创建失败! // 1. 获取文件的父目录对象 File parentFile = file.getParentFile(); // 2. 判断父目录文件夹是否存在 if (parentFile.exists() == false) &#123; // 3. 如果父目录不存在, 需要创建父目录 parentFile.mkdirs(); &#125; // 4. 程序来到这里, 就能够保证父目录文件夹一定存在. 文件就可以被创建成功. boolean result = file.createNewFile(); System.out.println("result = " + result); &#125;&#125;输出结果 :result = true 1.4 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516171819202122232425262728293031import java.io.File;public class Test8 &#123; public static void main(String[] args) &#123; File file = new File("D:\\课程资料"); // public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 String[] names = file.list(); for (String name : names) &#123; System.out.println(name); &#125; System.out.println("--------------"); // public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 File[] files = file.listFiles(); for (File f : files) &#123; System.out.println(f); &#125; &#125;&#125;输出结果 :1.jpg2.jpg3.jpg--------------D:\课程资料\1.jpgD:\课程资料\2.jpgD:\课程资料\3.jpg 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 第二章 递归2.1 概述 递归：指在当前方法内调用自己的这种现象。 123456789public class Test1 &#123; public static void main(String[] args) &#123; System.out.println("main"); // StackOverflowError 栈内存溢出错误! main(args); &#125;&#125; 2.2 递归累和计算1 ~ n的和分析：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。 实现代码： 1234567891011121314151617181920212223242526272829303132333435363738public class Test2 &#123; public static void main(String[] args) &#123; // 需求 : 计算 1 ~ n 的累积和 // num = 5; result = 5 + 4 + 3 + 2 + 1; // 方式一 : 打印实现 System.out.println(5 + 4 + 3 + 2 + 1); // 方式二 : 循环实现 int num = 5; int result = 0; for (int i = num; i &gt;= 1; i--) &#123; result += i; &#125; System.out.println("result = " + result); // 方式三 : 递归实现 /* 问 : 1到5的累加值是多少 ??? 不知道, 但是等于 5 + 1到4的累加和. 问 : 1到4的累加值是多少 ??? 不知道, 但是等于 4 + 1到3的累加和. 问 : 1到3的累加值是多少 ??? 不知道, 但是等于 3 + 1到2的累加和. 问 : 1到2的累加值是多少 ??? 不知道, 但是等于 2 + 1到1的累加和. 问 : 1到1的累加值是多少 ??? 等于 1. */ int sum = getResult(5); System.out.println("sum = " + sum); &#125; // 定义一个方法 : 求指定数值的累加和 public static int getResult(int num) &#123; if (num == 1) &#123; return 1; &#125; else &#123; return num + getResult(num - 1); &#125; &#125;&#125; 代码执行图解 小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。 2.3 递归求阶乘 阶乘：所有小于及等于该数的正整数的积。 1n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 分析：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。 1推理得出：n! = n * (n-1)! 代码实现： 123456789101112131415161718192021222324252627public class Test3 &#123; public static void main(String[] args) &#123; // 方式 : 递归实现 /* 问 : 5的阶乘是多少 ??? 不知道, 但是5的阶乘等于 5 * 4的阶乘. 问 : 4的阶乘是多少 ??? 不知道, 但是4的阶乘等于 4 * 3的阶乘. 问 : 3的阶乘是多少 ??? 不知道, 但是3的阶乘等于 3 * 2的阶乘. 问 : 2的阶乘是多少 ??? 不知道, 但是2的阶乘等于 2 * 1的阶乘. 问 : 1的阶乘是多少 ??? 1的阶乘等于 1. */ int result = getFactorial(5); System.out.println("result = " + result); &#125; public static int getFactorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * getFactorial(n - 1); &#125; &#125;&#125;输出结果 :result = 120 求年龄 : 有 5 个人, 问 : 第 5 个人多大 ? 我比第 4 个人大 2 岁. 问 : 第 4 个人多大 ? 我比第 3 个人大 2 岁…第1个人10岁, 请问, 第5个人多大 ??? 1234567891011121314151617181920212223242526272829303132public class RecursiveCallTest3 &#123; public static void main(String[] args) &#123; /* 需求 : 有 5 个人, 问 : 第 5 个人多大 ? 我比第 4 个人大 2 岁. 问 : 第 4 个人多大 ? 我比第 3 个人大 2 岁. 问 : 第 3 个人多大 ? 我比第 2 个人大 2 岁. 问 : 第 2 个人多大 ? 我比第 1 个人大 2 岁. 问 : 第 1 个人多大 ? 第 10 岁. 步骤一 : 定义一个方法. int getAge(int n); 步骤二 : 结束递归 ??? n == 1; return 10; 步骤三 : 继续递归 ??? n != 1; getAge(n - 1) + 2; */ int age = getAge(5); System.out.println("age = " + age); &#125; // 求年龄 public static int getAge(int n) &#123; if (n == 1) &#123; return 10; &#125; else &#123; return getAge(n - 1) + 2; &#125; &#125;&#125;输出结果 :age = 18 2.4 递归打印多级目录分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;public class Test4 &#123; public static void main(String[] args) &#123; // 递归打印多级目录 : File file = new File("D:\\课程资料"); // 调用方法 scanFolders(file); &#125; public static void scanFolders(File file) &#123; // listFiles(); File[] files = file.listFiles(); // 遍历 for (File f : files) &#123; // 判断是否为文件夹 if (f.isDirectory()) &#123; // 递归调用 ... scanFolders(f); &#125; else &#123; // 输出 System.out.println(f); &#125; &#125; &#125;&#125;输出结果 :D:\课程资料\1.jpgD:\课程资料\2.jpgD:\课程资料\3.jpgD:\课程资料\BEYOND-不再犹豫.mp3D:\课程资料\Beyond-冲上云霄.mp3D:\课程资料\Beyond-曾经拥有.mp3D:\课程资料\Demo.javaD:\课程资料\folders\1.jpgD:\课程资料\folders\2.jpgD:\课程资料\folders\3.jpg 第三章 综合案例3.1 文件搜索搜索D:\aaa 目录中的.java 文件。 分析： 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;public class Test5 &#123; public static void main(String[] args) &#123; // 文件搜索 File file = new File("D:\\课程资料"); // 调用方法 : searchFile(file); &#125; public static void searchFile(File file) &#123; // 1. 获取文件数组 File[] files = file.listFiles(); // 2. 遍历文件数组 for (File f : files) &#123; // 3. 判断当前遍历文件对象是文件还是文件夹 if (f.isDirectory()) &#123; // 3.1 文件夹, 递归遍历 searchFile(f); &#125; else &#123; // 3.2 文件对象, 判断是否为指定或后缀名 if (f.getName().endsWith(".java")) &#123; System.out.println(f); &#125; &#125; &#125; &#125;&#125;输出结果 :D:\课程资料\Demo.javaD:\课程资料\folders\Demo.javaD:\课程资料\folders\folder2\Demo.javaD:\课程资料\folders\folder2\HelloWorld.javaD:\课程资料\folders\HelloWorld.javaD:\课程资料\HelloWorld.javaD:\课程资料\HelloWorld3.javaD:\课程资料\HelloWorld5.javaD:\课程资料\HelloWorld6.javaD:\课程资料\HelloWorld7.javaD:\课程资料\HelloWorld8.java 3.2 文件过滤器优化java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter) 作为参数， 接口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyFileFilter implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; boolean result = pathname.isDirectory() || pathname.getName().endsWith(".java"); // System.out.println("pathname = " + pathname + ", result = " + result); return result; &#125;&#125;public class Test1 &#123; public static void main(String[] args) &#123; // 文件搜索 File file = new File("D:\\课程资料"); // 调用方法 : searchFile(file); &#125; public static void searchFile(File file) &#123; // 1. 获取文件数组, 传递一个文件过滤器对象 File[] files = file.listFiles(new MyFileFilter()); for (File f : files) &#123; // 判断 if (f.isDirectory()) &#123; searchFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125;&#125;输出结果 :D:\课程资料\Demo.javaD:\课程资料\folders\Demo.javaD:\课程资料\folders\folder2\Demo.javaD:\课程资料\folders\folder2\HelloWorld.javaD:\课程资料\folders\HelloWorld.javaD:\课程资料\HelloWorld.javaD:\课程资料\HelloWorld3.javaD:\课程资料\HelloWorld5.javaD:\课程资料\HelloWorld6.javaD:\课程资料\HelloWorld7.javaD:\课程资料\HelloWorld8.java 代码实现二 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.io.FileFilter;public class Test1 &#123; public static void main(String[] args) &#123; // 文件搜索 File file = new File("D:\\课程资料"); // 调用方法 : searchFile(file); &#125; public static void searchFile(File file) &#123; // 1. 获取文件数组, 传递一个文件过滤器对象 File[] files = file.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.isDirectory() || pathname.getName().endsWith(".java"); &#125; &#125;); for (File f : files) &#123; // 判断 if (f.isDirectory()) &#123; searchFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125;&#125;输出结果 :D:\课程资料\Demo.javaD:\课程资料\folders\Demo.javaD:\课程资料\folders\folder2\Demo.javaD:\课程资料\folders\folder2\HelloWorld.javaD:\课程资料\folders\HelloWorld.javaD:\课程资料\HelloWorld.javaD:\课程资料\HelloWorld3.javaD:\课程资料\HelloWorld5.javaD:\课程资料\HelloWorld6.javaD:\课程资料\HelloWorld7.javaD:\课程资料\HelloWorld8.java 3.3 Lambda优化分析：FileFilter是只有一个方法的接口，因此可以用lambda表达式简写。 lambda格式： 1()-&gt; &#123;&#125; 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.File;import java.io.FileFilter;public class Test1 &#123; public static void main(String[] args) &#123; // 文件搜索 File file = new File("D:\\课程资料"); // 调用方法 : searchFile(file); &#125; public static void searchFile(File file) &#123; // 1. 获取文件数组, 传递一个文件过滤器对象 File[] files = file.listFiles(f -&gt; f.isDirectory() || f.getName().endsWith(".java")); for (File f : files) &#123; // 判断 if (f.isDirectory()) &#123; searchFile(f); &#125; else &#123; System.out.println(f); &#125; &#125; &#125;&#125;输出结果 :D:\课程资料\Demo.javaD:\课程资料\folders\Demo.javaD:\课程资料\folders\folder2\Demo.javaD:\课程资料\folders\folder2\HelloWorld.javaD:\课程资料\folders\HelloWorld.javaD:\课程资料\HelloWorld.javaD:\课程资料\HelloWorld3.javaD:\课程资料\HelloWorld5.javaD:\课程资料\HelloWorld6.javaD:\课程资料\HelloWorld7.javaD:\课程资料\HelloWorld8.java 练习题练习一:相对路径和绝对路径的使用描述:创建两个文件对象，分别使用相对路径和绝对路径创建。 答案 操作步骤: 绝对路径创建文件对象：使用File类一个参数的构造方法。 相对路径创建文件对象：使用File类两个参数的构造方法。 代码: 12345678public class Test01_01 &#123;public static void main(String[] args) &#123;// 创建文件对象：绝对路径 File f1 = new File("d:/aaa/a.txt"); // 创建文件对象：相对路径 File f2 = new File("a.txt"); &#125;&#125; 练习二:检查文件是否存在,文件的创建描述:检查D盘下是否存在文件a.txt,如果不存在则创建该文件。 答案 操作步骤: 使用绝对路径创建对象关联到D盘的a.txt。 通过文件对象方法判断文件是否存在。 不存在则调用创建文件的方法创建文件。 代码: 12345678910public class Test01_02 &#123; public static void main(String[] args) throws IOException&#123; // 创建文件对象：绝对路径 File f = new File("d:/a.txt"); // 如果文件不存在，则创建文件 if(!f.exists()) &#123; f.createNewFile(); &#125; &#125;&#125; 练习三:单级文件夹的创建描述:在D盘下创建一个名为bbb的文件夹。 答案 操作步骤: 创建文件对象指定路径为d:/bbb 调用文件对象创建文件夹的方法 代码: 12345678public class Test01_03 &#123; public static void main(String[] args) &#123; // 创建文件对象 File f = new File("d:/bbb"); // 创建单级文件夹 f.mkdir(); &#125;&#125; 练习四:多级文件夹的创建描述:在D盘下创建一个名为ccc的文件夹，要求如下： 1.ccc文件夹中要求包含bbb子文件夹 2.bbb子文件夹要求包含aaa文件夹 答案: 操作步骤: 创建文件对象关联路径：d:/ccc/bbb/aaa 调用文件对象创建多级文件夹的方法 代码: 12345678public class Test01_04 &#123; public static void main(String[] args) &#123; // 创建文件对象 File f = new File("d:/ccc/bbb/aaa"); // 创建多级文件夹 f.mkdirs(); &#125;&#125; 练习五:删除文件和文件夹描述: 将D盘下a.txt文件删除 将D盘下aaa文件夹删除,要求文件夹aaa是一个空文件夹。 答案: 操作步骤: 创建文件对象关联路径：d:/a.txt 调用文件对象删除文件的方法 创建文件对象关联路径：d:/aaa 调用文件对象删除文件夹的方法 代码: 12345678910111213public class Test01_05 &#123; public static void main(String[] args) &#123; // 创建文件对象 File f = new File("d:/a.txt"); // 删除文件 f.delete(); // 创建文件夹对象 File dir = new File("d:/aaa"); // 删除文件夹 dir.delete(); &#125;&#125; 练习六:获取文件信息:文件名,文件大小,文件的绝对路径,文件的父路径描述: 获取D盘aaa文件夹中b.txt文件的文件名，文件大小，文件的绝对路径和父路径等信息，并将信息输出在控制台。 答案: 操作步骤: 在D盘aaa文件夹中创建一个b.txt文件并输入数据 创建文件对象关联路径：d:/aaa/b.txt 调用文件对象的相关方法获得信息并输出。可以通过API帮助文档查询方法。 代码: 12345678910111213141516171819202122public class Test01_06 &#123; public static void main(String[] args) &#123; // 创建文件对象 File f = new File("d:/aaa/b.txt"); // 获得文件名 String filename = f.getName(); // 获得文件大小 longfilesize = f.length(); // 获得文件的绝对路径 String path = f.getAbsolutePath(); // 获得父文件夹路径，返回字符串 String parentPath = f.getParent(); // 获得父文件夹路径，返回文件对象 File parentFile = f.getParentFile(); // 输出信息 System.out.println("文件名：" + filename); System.out.println("文件大小：" + filesize); System.out.println("文件路径：" + path); System.out.println("文件父路径：" + parentPath); System.out.println("文件父路径：" + parentFile); &#125;&#125; 练习七:文件夹或文件的判断描述: 1.判断File对象是否是文件,是文件则输出：xxx是一个文件，否则输出：xxx不是一个文件。 2.判断File对象是否是文件夹,是文件夹则输出：xxx是一个文件夹，否则输出：xxx不是一个文件夹。(xxx是文件名或文件夹名) 答案: 操作步骤: 创建两个文件对象分别关联到不同的文件，比如：d:/a.txt，d:/aaa 调用文件对象的判断是否是文件或是否是文件夹的方法 获得文件名，根据判断结果输出信息。 代码: 1234567891011121314151617181920public class Test01_07 &#123; public static void main(String[] args) &#123; // 创建文件对象 File f1 = new File("d:/b.txt"); // 判断是否是一个文件 if(f1.isFile()) &#123; System.out.println(f1.getName()+"是一个文件"); &#125; else &#123; System.out.println(f1.getName()+"不是一个文件"); &#125; // 创建文件对象 File f2 = new File("d:/aaaa"); // 判断是否是一个文件夹 if(f2.isDirectory()) &#123; System.out.println(f2.getName()+"是一个文件夹"); &#125; else &#123; System.out.println(f2.getName()+"不是一个文件夹"); &#125; &#125;&#125; 练习八:文件夹的获取方法描述: 获取指定文件夹下所有的文件，并将所有文件的名字输出到控制台。 注意：不包含子文件夹下的文件 答案 操作步骤: 创建文件对象关联到指定文件夹，比如：c:/aaa 调用文件对象的listFiles方法获得文件数组 遍历文件数组将每一个文件的名字输出到控制台 代码: 12345678910111213public class Test01_08 &#123; public static void main(String[] args) &#123; // 创建文件对象 File f = new File("d:/aaa"); // 获得文件夹下所有文件 File[] files = f.listFiles(); // 遍历文件数组 for (File file :files) &#123; // 将文件的名字打印到控制台 System.out.println(file.getName()); &#125; &#125;&#125; 练习九:文件创建、判断功能、获取功能描述: 键盘录入一个文件路径，根据文件路径创建文件对象，判断是文件还是文件夹 如果是文件，则输出文件的大小 如果是文件夹，则计算该文件夹下所有文件大小之和并输出(不包含子文件夹)。 答案 操作步骤: 创建键盘录入对象 接收键盘录入的字符串路径 根据字符串路径创建文件对象 判断文件对象是文件还是文件夹，如果是文件，则直接输出文件大小 如果是文件夹，则获得该文件夹下所有的文件，定义一个求和变量，遍历文件数组获得每一个文件的大小并累加到求和变量中，最后输出求和变量的值。 代码: 1234567891011121314151617181920212223242526272829303132public class Test02_01 &#123; public static void main(String[] args) &#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); // 提示用户输入一个文件路径 System.out.println("请输入一个文件路径:"); // 接收用户输入的文件路径 String filePath = sc.nextLine(); // 根据文件路径创建文件对象 File file = new File(filePath); // 判断是否是文件 if(file.isFile()) &#123; // 输出文件大小 System.out.println("文件大小为：" + file.length()); &#125; else &#123; // 是文件夹 // 定义变量统计文件大小之和 long length = 0; // 获得该文件夹下的所有文件 File[] files = file.listFiles(); // 遍历文件数组 for (File f :files) &#123; if(f.isFile()) &#123; // 累加文件大小 length += f.length(); &#125; &#125; // 输出文件夹文件的总大小 System.out.println("文件总大小为：" + length); &#125; &#125;&#125; 练习十:递归的使用(一)描述: 用递归实现不死神兔 故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。 在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔， 再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，没有发生死亡， 问：现有一对刚出生的兔子2年后(24个月)会有多少对兔子? 答案 解题思路: 用递归法求斐波那契数列第n项 斐波那契数列，又称黄金分割数列，指的是这样一个数列： 1、1、2、3、5、8、13、21、…… 这个数列大家很容易的就推算出来后面好几项的值，那么到底有什么规律，简单说，就是前两项的和是第三项的值 代码: 123456789101112131415161718192021import java.util.Scanner;public class Test02_02 &#123; public static void main(String[] args) &#123; // 键盘输入并接收 Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 调用递归方法并打印 System.out.println(fun(n)); &#125;public static int fun(int n) &#123; // 判断如果是第1个或者第2个月就返回1 if (n == 1 || n == 2) &#123; return 1; &#125; else &#123; // 如果是第3个月就返回前两个月的值 return fun(n - 1) + fun(n - 2); &#125; &#125;&#125; 练习十一:递归的使用(二)描述:猴子吃桃子问题，猴子第一天摘下若干个桃子，当即吃了快一半，还不过瘾，又多吃了一个。第二天又将仅剩下的桃子吃掉了一半，又多吃了一个。以后每天都吃了前一天剩下的一半多一个。到第十天，只剩下一个桃子。试求第一天共摘了多少桃子？ 答案 解题思路:采用逆向思维，从后往前推断，发现其中有相同的地方，即出现递推公式，可以采用递归方法。 123456789令S10=1,容易看出S9=2(S10+1),简化一下S9=2S10+2 S8=2S9+2 ….. Sn=2S(n+1)+2 代码: 123456789101112131415161718public class Test02_03 &#123; public static void main(String[] args) &#123; // 定义桃子数量调用递归方法 int sum = sumPeach(1); // 调用递归函数并打印 System.out.println(sum); &#125; public static int sumPeach(int day) &#123; // 判断如果是第10天就返回1 if (day == 10) &#123; return 1; &#125; else &#123; // 递归计算前一天的数量 return 2 * sumPeach(day + 1) + 2; &#125; &#125;&#125; 练习十二:文件过滤器的使用描述: 获得指定文件夹下所有的java文件(不考虑子文件夹的)并输出到控制台 答案 操作步骤: 创建一个类实现文件过滤器FileFilter接口并重新accept方法，在该方法根据传入的文件判断是否文件Java文件，如果是则返回true，否则返回false。 根据文件夹路径字符串创建文件对象和创建文件过滤器接口实现类对象 调用文件对象的listFiles(FileFilter f) 方法，传递文件过滤器实现类对象。 遍历文件数组，输入每一个文件对象 代码: 123456789101112131415161718192021public class Test02_04 &#123; public static void main(String[] args) &#123; // 创建文件夹对象 File file= new File("d:/aaa"); // 获得该文件夹下的所有java文件 File[] files = file.listFiles(new FileFilter() &#123; public boolean accept(File pathname) &#123; // 判断文件后缀名是否.java文件 if (pathname.getName().endsWith(".java")) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;); //遍历文件数组,打印所有的Java文件路径 for (File f : files) &#123; System.out.println(f.getAbsolutePath()); &#125; &#125;&#125; 练习十三:文件和文件夹删除描述: 键盘录入一个文件夹路径，删除该文件夹以及文件夹路径下的所有文件。 要求：录入的文件夹里面要有多个文件，不能包含有子文件夹。 提示：如果文件夹里面有文件，则需要先将文件删除才能删除文件夹。 答案 操作步骤: 创建键盘录入对象Scanner 定义字符串接收用户输入的文件夹路径 根据文件夹路径创建文件对象 调用文件对象的listFiles方法获得文件数组 遍历文件数组，删除每一个文件 最后调用删除方法删除文件夹。 代码: 123456789101112131415161718192021public class Test02_05 &#123; public static void main(String[] args) &#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); // 提示用户输入一个文件路径 System.out.println("请输入一个文件夹路径:"); // 接收用户输入的文件夹路径 String dirPath = sc.nextLine(); // 根据文件夹路径创建文件对象 File dir = new File(dirPath); // 获得该文件夹下的所有文件 File[] files = dir.listFiles(); // 遍历文件数组删除每一个文件 for (File file :files) &#123; // 删除文件 file.delete(); &#125; // 删除文件夹 System.out.println(dir.delete()?"删除成功":"删除失败"); &#125;&#125; 练习十四:文件获取方法,递归的使用描述:从键盘接收一个文件夹路径,获得该文件夹大小并输出到控制台。 答案 操作步骤: 创建键盘录入对象Scanner 定义字符串接收用户输入的文件夹路径 根据文件夹路径创建文件对象 定义一个方法calculate用来计算指定文件夹的大小，接收文件参数，返回long类型数值表示文件夹的大小。 调用calculate方法传入文件夹对象，在该方法内部获得文件夹中所有文件，得到一个文件数组，定义一个变量size累加每一个文件的大小，遍历文件数组，判断是否是文件，如果是文件则获得文件大小并累加到变量size中，如果是文件夹，继续递归调用当前方法。 代码: 1234567891011121314151617181920212223242526272829303132public class Test02_06 &#123; public static void main(String[] args) &#123; // 创建键盘输入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入一个文件夹路径："); // 接收用户输入的路径 String filePath = sc.nextLine(); // 根据路径字符串创建文件对象 File dir = new File(filePath); // 调用calculate方法获得文件大小 long length = calculate(dir); System.out.println("文件夹总大小：" + length); &#125; /* * 获得文件夹的大小 */ public static long calculate(File dir)&#123; long length = 0; // 获得文件数组 File files[] = dir.listFiles(); // 遍历数组 for (File file :files) &#123; // 判断是否是文件 if(file.isFile()) &#123; length += file.length(); &#125; else &#123; length += calculate(file); &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶05-异常和线程]]></title>
    <url>%2F2019%2F08%2F23%2F2019-08-23-Java%E8%BF%9B%E9%98%B605-%20%E5%BC%82%E5%B8%B8%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[主要内容 异常、线程 学习目标 能够辨别程序中异常和错误的区别 说出异常的分类 说出虚拟机处理异常的方式 列举出常见的三个运行期异常 能够使用try…catch关键字处理异常 能够使用throws关键字处理异常 能够自定义异常类 能够处理自定义异常类 说出进程的概念 说出线程的概念 能够理解并发与并行的区别 能够开启新线程 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常: checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常: runtime异常。在运行时期,检查异常.在编译时期,运行异常不会被编译器检测(不报错)。(如数学异常) 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 12345678910// 数组工具类 :public class ArrayTools &#123; // 行为 : 根据传入的数组与下标, 返回指定的元素 public static int getElement(int[] arr, int index) &#123; // 2. 正常逻辑代码 ... int element = arr[index]; return element; &#125;&#125; 测试类 12345678910111213public class ArrayToolsTest1 &#123; public static void main(String[] args) &#123; // 定义一个数组 int[] arr = &#123;10, 20, 30&#125;; // 调用工具类的方法 int element = ArrayTools.getElement(null, 2); // 查看结果 System.out.println("element = " + element); System.out.println("程序执行完毕 ..."); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接收参数。那么，当调用方法使用接收到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 数组工具类 :public class ArrayTools &#123; // 行为 : 根据传入的数组与下标, 返回指定的元素 public static int getElement(int[] arr, int index) &#123; // 0.1 判断, arr 是否为 null if (arr == null) &#123; // 0.2 抛出一个 `异常` // 程序一旦执行到 throw 代码, 后续代码就不执行了, 此时, 程序就会直接返回到调用处. throw new NullPointerException("数组引用不能为空, 请修正代码."); &#125; // 1.1 判断, index 是否越界 if (index &lt; 0 || index &gt;= arr.length) &#123; // 1.2 抛出一个 `异常`, 提前终止程序的执行 // 格式 : throw new 异常类型(自定义信息); throw new ArrayIndexOutOfBoundsException("数组下标越界异常, 请修正代码."); &#125; // 2. 正常逻辑代码 ... int element = arr[index]; return element; &#125;&#125;public class ArrayToolsTest1 &#123; public static void main(String[] args) &#123; /* String str = "abcdefg"; // StringIndexOutOfBoundsException char c = str.charAt(str.length()); System.out.println("c = " + c); */ // 定义一个数组 int[] arr = &#123;10, 20, 30&#125;; // 调用工具类的方法 int element = ArrayTools.getElement(null, 2); // 查看结果 System.out.println("element = " + element); System.out.println("程序执行完毕 ..."); &#125;&#125;输出结果 :Exception in thread "main" java.lang.NullPointerException: 数组引用不能为空, 请修正代码. 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 1234567891011121314151617181920212223242526272829303132import java.util.Objects;// 数组工具类 :public class ArrayTools &#123; // 行为 : 根据传入的数组与下标, 返回指定的元素 public static int getElement(int[] arr, int index) &#123; // 0.1 判断, arr 是否为 null /*if (arr == null) &#123; // 0.2 抛出一个 `异常` // 程序一旦执行到 throw 代码, 后续代码就不执行了, 此时, 程序就会直接返回到调用处. throw new NullPointerException("数组引用不能为空, 请修正代码."); &#125;*/ // Objects 工具类提供了一个方法, 可以针对 `对象` 进行空引用判断. // 含义 : 判断 arr 对象是否为空, 如果为空, 底层就会抛出一个 `空引用` 类型. // Objects.requireNonNull(arr); Objects.requireNonNull(arr, "数组引用不能为空, 请修正代码."); // 1.1 判断, index 是否越界 if (index &lt; 0 || index &gt;= arr.length) &#123; // 1.2 抛出一个 `异常`, 提前终止程序的执行 // 格式 : throw new 异常类型(自定义信息); throw new ArrayIndexOutOfBoundsException("数组下标越界异常, 请修正代码."); &#125; // 2. 正常逻辑代码 ... int element = arr[index]; return element; &#125;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 123456789101112131415161718192021222324import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class ThrowsExceptionTest2 &#123; public static void main(String[] args) throws ParseException &#123; String str = "2018-08-08"; parseDate(str); &#125; public static void parseDate(String str) throws ParseException &#123; // 1. 创建一个日期格式化对象 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); // 2. 解析 Date date = df.parse(str); // 3. 查看 System.out.println("date = " + date); &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class ExceptionTest1 &#123; public static void main(String[] args) &#123; // 需求 : 将一个字符串解析为一个 `Date` 对象 String str1 = "2018年08月08日"; String str2 = "2018-08-08"; // 调用方法时, 只要调用了 `声明编译时期异常` 的方法, 此时, 程序就会报错. // 含义 : 编译器问调用者, 你调用一个带编译时期的异常方法, 如果发生了该异常, 请问, 您如何处理呢 ??? // 回答1 : 编译器兄弟呀, 如果发生了异常, 请将该问题交给我的调用者去处理. (继续声明 throws) // 回答2 : 编译器兄弟呀, 如果发生了该异常, 请将该异常交给我来处理. 不管我怎么处理, 都与你无关. (异常捕获 try-catch) /* try &#123; // 编写可能会发生异常的代码 ... &#125; catch (异常类型 exception) &#123; // 如果发生了该异常, 这个大括号中就是对该异常进行的处理方案代码 ... (不管写什么. 都是处理方案代码, 哪怕什么都不写) &#125; finally &#123; // 无论是否发生异常, 都会被执行到的代码 ... &#125; */ try &#123; parseStringToDate(str1); &#125; catch (ParseException e) &#123; // 说明 : catch 语句必须发生异常后, 才可以进入. // 打印日志 ... 处理逻辑 ... // System.out.println("发生了解析异常. 传入字符串日期格式错误. 格式: yyyy-MM-dd."); // 含义 : 输出异常发生的堆栈信息 e.printStackTrace(); // Throwable 类定义的方法. // getMassage &amp; toString() String message = e.getMessage(); String str = e.toString(); System.out.println("message = " + message); System.out.println("str = " + str); &#125; // 后续代码 ... int num1 = 10; int num2 = 20; int sum = num1 + num2; System.out.println("sum = " + sum); System.out.println("程序正常执行完毕 ..."); &#125; // 异常声明 : 位置 (方法参数列表之后) 格式 : throws 异常类型 public static void parseStringToDate(String str) throws ParseException &#123; // 1. 创建一个 `简单日期格式化` 对象 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); // 2. 将传入的参数实现解析 // unhandled exception : java.text.parseException 未处理的异常, 解析异常. // 说明1 : parseException 是编译时期的异常. // 说明2 : NullPointerException / IndexOutOfBoundsException 属于运行时异常. // 说明3 : 如果异常类型为运行时异常, 编译器不检查该类异常, 因此, 程序可以选择不处理. // 说明4 : 如果异常类型为编译时异常, 编译器会检查该类异常, 因此, 程序必须做出处理. 不处理的话, 编译报错, 程序无法运行. // 处理有两种方式 : 1. 继续抛 (继续声明 throws) 2. 异常捕获. (try-catch) // 1. 继续抛 (继续声明 throws) 含义 : 这个异常问题, 我不处理, 交给我的调用者进行处理. // 2. 异常捕获. (try-catch) 含义 : 这个问题交给我来处理, 不用调用者关心. Date date = df.parse(str); // 查看结果 System.out.println("date = " + date); &#125;&#125;输出结果 :java.text.ParseException: Unparseable date: "2018年08月08日" at java.base/java.text.DateFormat.parse(DateFormat.java:388) at cn.itcast.exception2.ExceptionTest1.parseStringToDate(ExceptionTest1.java:68) at cn.itcast.exception2.ExceptionTest1.main(ExceptionTest1.java:28)message = Unparseable date: "2018年08月08日"str = java.text.ParseException: Unparseable date: "2018年08月08日"sum = 30程序正常执行完毕 ... 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class ExceptionTest1 &#123; public static void main(String[] args) &#123; String result = readFile("a.txt"); System.out.println("result = " + result); &#125; // 需求 : IO (BufferedReader &amp; BufferedWriter) // 说明 : 定义一个方法, 读取指定文件中的数据, 并返回是否读取成功字符串. public static String readFile(String fileName) &#123; // 1. 读取文件 // 说明 : 创建 FileReader 时, 会发生一个 `FileNotFoundException` 文件找不到异常. // 选择捕获异常 : try - catch FileReader reader = null; try &#123; reader = new FileReader(fileName); &#125; catch (FileNotFoundException e) &#123; System.out.println("发生了文件找不到异常, 请检查文件路径或文件名称."); // 如果程序进入 catch 语句, 说明程序发生了异常. 文件读取失败了. return "文件读取失败"; // return 之前会先执行 finally 代码块. &#125; finally &#123; // finally 代码块就是为 `关闭资源` 而设计. (硬件文件资源, 数据库资源, 网络资源 ...) // 说明 : finally 块的设计就是为了解决 catch 块中 return 语句的问题. System.out.println("finally 代码块被执行 ..."); // 说明 : 如果一个对象的默认值为null, 调用时, 必须要做 null 判断. if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException exception) &#123; // 忽略 ... &#125; &#125; // finally 块中, 在开发时, 绝对不会出现 return 语句, 因为 finally 块就是用来关闭资源的, 而不是返回结果的. // 如果要返回结果, 请在 catch 语句中返回. // return "哈哈哈哈"; &#125; return "文件读取成功"; &#125;&#125;输出结果 :发生了文件找不到异常, 请检查文件路径或文件名称.finally 代码块被执行 ...result = 文件读取失败 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。 子父类 1234567891011121314151617181920212223242526public class Person &#123; public void introduce() &#123; System.out.println("大家好, 我是 Person 类."); &#125;&#125;public class Student extends Person &#123; @Override public void introduce() &#123; System.out.println("大家好, 我是 Student 类."); // 子类重写父类的方法, 如果父类被重写的方法没有声明编译时期异常, 子类重写时, 不可以抛出编译时期异常. // 如果有异常, 子类重写方法中, 只能选择 try-catch 语句进行捕获. try &#123; readFile(); &#125; catch (FileNotFoundException e) &#123; System.out.println("文件找不到异常."); &#125; &#125; public void readFile() throws FileNotFoundException &#123; FileReader reader = new FileReader("a.txt"); &#125;&#125; 接口与接口实现类 1234567891011121314151617181920212223public interface MyRunnable &#123; void run();&#125;public class MyRunnableImpl implements MyRunnable &#123; @Override public void run() &#123; System.out.println("MyRunnableImpl run ..."); // 实现类重写接口中抽象方法时, 如果该抽象方法没有声明编译时期异常, 实现类重写也不能声明该异常. // 如果内部有编译时期异常, 实现类需要在内部使用 try-catch 自行处理. try &#123; readFile(); &#125; catch (FileNotFoundException e) &#123; System.out.println("文件不存在, 读取失败!"); &#125; &#125; public void readFile() throws FileNotFoundException &#123; FileReader reader = new FileReader("a.txt"); &#125;&#125; 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个登陆异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 1234567891011121314// 自定义了一个 `注册异常` 类// 说明 : 能抛出的对象都必须继承自 Throwable 类.// 说明 : 如果是自定异常, 不直接继承 Throwble 类, 可以选择继承 `Exception / RuntimeException` 这两个类.public class RegisterException extends Exception &#123; // 提供两个构造方法即可. public RegisterException() &#123; super(); &#125; public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 1234567891011121314151617181920212223242526272829public class RegisterTest &#123; // 属性 : 数据库 private static String[] names = &#123;"Jack", "Peter", "Tom"&#125;; public static void main(String[] args) &#123; try &#123; boolean result = checkUserExists("Jackie"); System.out.println("result = " + result); &#125; catch (RegisterException e) &#123; e.printStackTrace(); &#125; System.out.println("程序正常执行完毕 ..."); &#125; // 行为 : 查看该用户是否已经存在, 如果存在, 不能再注册 public static boolean checkUserExists(String username) throws RegisterException &#123; // 判断, 遍历 names for (String name : names) &#123; if (name.equals(username)) &#123; // 用户名已经存在, 不能再注册, 需要抛出一个 `RegisterException` 异常. // 说明 : 自己 throw 出来的异常, 只需要声明一下即可. throw new RegisterException("用户是否已经存在, 请重新选择."); &#125; &#125; return true; &#125;&#125; 3.3 异常流程的思考 :思考程序运行时输出的序号语句 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThinkingException &#123; public static void main(String[] args) &#123; System.out.println(1); try &#123; System.out.println(2); int[] arr = &#123;10, 20, 30&#125;; System.out.println(arr[3]); // ArrayIndexOutOfBoundsException: 3 System.out.println(3); String str1 = ""; System.out.println(str1.toString()); System.out.println(4); String str2 = null; System.out.println(str2.toString()); // NullPointerException System.out.println(5); int num = 10 / 0; System.out.println("num = " + num); // ArithmeticException: / by zero System.out.println(6); Object obj = new Object(); // 这不是多态 : 子类引用 -&gt; 父类对象 (类型转换错误) String str = (String) obj; // ClassCastException: System.out.println("str = " + str); System.out.println(7); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println(8); &#125; catch (NullPointerException e) &#123; System.out.println(9); &#125; catch (ArithmeticException e) &#123; System.out.println(10); &#125; catch (ClassCastException e) &#123; System.out.println(11); &#125; finally &#123; System.out.println(12); &#125; System.out.println(13); &#125;&#125;输出结果 :1281213 说明 : 当多异常处理时，捕获处理，前边的类不能是后边类的父类 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 12345678910111213141516public class ThinkintExceptionTest2 &#123; public static void main(String[] args) &#123; // 父类 : Exception -&gt; 子类 : IOException -&gt; 子子类 : FileNotFoundException try &#123; FileReader reader = new FileReader("a.txt"); reader.read(); &#125; catch (FileNotFoundException e) &#123; // 子子类 System.out.println("FileNotFoundException 被捕获 ..."); &#125; catch (IOException e) &#123; // 子类 System.out.println("IOException 被捕获 ..."); &#125; catch (Exception e) &#123; // 父类 System.out.println("Exception 被捕获 ..."); &#125; &#125;&#125; 第四章 多线程多线程 : 理解为程序中的多条执行路径. 迅雷 : 下载电影, 同时下载多部电影, 显示的结果好像是多部电影同时下载. 说明 : 迅雷也是一个程序, 那么一个程序中只存在一个 main 方法. 就一个入口, 如何实现多条执行路径呢 ??? 思考 : 同一个Java程序, 可不可以同时执行多个死循环 ??? 123456789101112131415161718192021public class ThreadTest1 &#123; public static void main(String[] args) &#123; // 思考 : 同一个 Java 程序中, 是否可以同时执行多个死循环 ??? // 死循环 : (耗时操作) // `常量` 编译器知道数值. `变量` 编译器是不知道数值. // 为了解决这种现实生活中的问题, Java 出现 `多线程` 的语法. // 网络聊天 (发送 / 接收) 上传下载 (程序的多条执行路径) boolean flag = true; while (flag) &#123; // 电影 1 (1G -&gt; 5分钟) System.out.println("电影 1 下载中 ..."); &#125; while (true) &#123; // 电影 2 (1G -&gt; 5分钟) System.out.println("电影 2 下载中 ..."); &#125; &#125;&#125; 4.1 并发与并行 并行：指两个或多个事件在同一时刻发生（同时发生）。 并发：指两个或多个事件在同一个时间段内发生。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，可以理解为一个进程便相当于一个单 CPU 操作系统，而线程便是这个系统中运行的多个任务。 进程就理解为 正在执行的程序. 线程就类似于进程中的小进程. 进程一般有 操作系统 实现分配, 但是 线程 是由程序编写中实现分配的. 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程和线程 ： 进程 线程 进程与线程的区别 进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。 线程：堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。 堆空间是对象, 栈空间是方法. 对象数据是可以共享的, 而方法中局部变量的数据是独立的. 不能共享. 注意： 因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执行完全取决于 CPU 的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。 Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收机制线程。每当使用 java 命令执行一个类时，实际上都会启动一个 JVM，每一个 JVM 实际上就是在操作系统中启动了一个线程，java 本身具备了垃圾的收集机制，所以在 Java 运行时至少会启动两个线程。 由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，通常考虑创建多线程，而不是创建多进程。 线程调度: 计算机通常只有一个CPU时,在任意时刻只能执行一条计算机指令,每一个进程只有获得CPU的使用权才能执行指令。所谓多进程并发运行,从宏观上看,其实是各个进程轮流获得CPU的使用权,分别执行各自的任务。那么,在可运行池中,会有多个线程处于就绪状态等到CPU,JVM就负责了线程的调度。JVM采用的是抢占式调度,没有采用分时调度,因此可以能造成多线程执行结果的的随机性。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 12345678910111213141516171819202122232425262728/*1. 自定义一个类, 继承 Thread 类. (线程类)2. 自定义类重写 Thread 类的 run() 方法. 将耗时代码编写到 run() 方法实现体中.3. 创建一个自定义类的对象.4. 调用自定义对象的 start() 方法, 启动线程. */public class ThreadTest2 &#123; // Java虚拟机在程序运行时, 自动启动了一条线程 (主线程) public static void main(String[] args) &#123; // 第一条子线程 ... // 3. 创建一个自定义类的对象. DownloadThread1 downloadThread1 = new DownloadThread1(); // 4. 启动 downloadThread1.start(); // 第二条子线程 ... DownloadThread2 downloadThread2 = new DownloadThread2(); downloadThread2.start(); // 主线程中运行的代码 ... while (true) &#123; System.out.println("主线程中运行的代码 ..."); &#125; &#125;&#125; 自定义线程类： 123456789101112131415161718192021public class DownloadThread1 extends Thread &#123; @Override public void run() &#123; while (true) &#123; // 电影 1 (1G -&gt; 5分钟) System.out.println("电影 1 下载中 ..."); &#125; &#125;&#125;public class DownloadThread2 extends Thread &#123; @Override public void run() &#123; while (true) &#123; // 电影 2 (1G -&gt; 5分钟) System.out.println("电影 2 下载中 ..."); &#125; &#125;&#125; OK 相信我们都看到多线程的现象了，那么接下来几天我们就进入多线程的世界！ 那么现在有个小问题，请问植物大战僵尸游戏中，是用了多进程设计程序呢，还是多线程？ 练习题练习一：异常的体系问题： （1）请描述异常的继承体系 （2）请描述你对错误(Error)的理解 （3）请描述你对异常(Expection的理解) （4）请描述你对运行时异常(RuntimeException)的理解 答： （1）异常继承体系为：异常的根类是 java.lang.Throwable，其下有两个子类：java.lang.Error 与 java.util.Exception 。而Exception又分为编译时期异常：checked异常，与运行时期异常：runtime异常。 （2）Error:表示不可修复的恶性的错误，只能通过修改代码规避错误的产生，通常是系统级别的，所以很严重。 （3）Exception:表示可修复的良性（相对于错误）的异常，异常产生后程序员可以并且应该通过代码的方式纠正，使程序继续运行，是必须要处理的。 （4）运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。 练习二：throw与throws的区别问题： （1）请描述throw的使用位置,作用是什么? （2）请描述throws的使用位置,作用是什么? 答： （1）throw关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到throw语句时立即停止，它后面的语句都不执行。 （2）throws关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会将异常对象抛给方法调用处。 练习三：异常的处理方式问题： （1）异常处理方式有几种,分别是什么? （2）详细阐述每种方式对异常是如何处理的 答： （1）异常的处理方式有两种,分别是使用throws和try…catch…finally （2）throws用在方法的声明上后接异常类名,是把异常抛给调用者进行处理 （3）try…catch…finally是捕获异常,自己处理,处理完毕后面的程序可以继续运行 ​ a) try代码块中是可能出现异常的代码 ​ b) catch代码块,是遇到异常,对异常进行处理的代码 ​ c) finally代码块是无论是否发生异常,都必须执行的代码,用于释放资源. 练习四：常见异常，及产生原因问题：请列举常见异常，并说明产生原因。 答： NullPointerException:空指针异常。 ​ 当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度等等。 ArrayIndexOutOfBoundsException:数组索引越界异常。 当对数组的索引值为负数或大于等于数组大小时抛出此异常。 ArithmeticException:算术运算异常。 ​ 程序中出现了除以零这样的运算就会出这样的异常，对这种异常，大家就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了。 NumberFormatException:数字格式异常。 ​ 当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 注意：答案不唯一，合理即可。 练习五：看代码，分析结果问题：根据给出的相应代码，分析可能产生的结果。 1.举例： 1234public static void main(String[]args)&#123; String str=null; System.out.println(str.length());&#125; 答：变量str的值为null，调用方法时，报空指针异常NullPointerException 2.举例： 1234public static void main(String[]args)&#123; int arr[]=&#123;1,2&#125;; System.out.println(arr[2]);&#125; 答：索引值2大于等于数组arr的长度时，报数组索引越界异常ArrayIndexOutOfBoundsException 3.举例： 123public static void main(String[]args)&#123; System.out.println(1/0);&#125; 答：整数0做了分母，报算术运算异常ArithmeticException:/byzero 4.举例： 123public static void main(String[]args)&#123; System.out.println(Integer.parseInt("itcast"));&#125; 答：把字符串“itcast”转换为Integer类型时，当然会报数字格式化异常啦NumberFormatException 5.举例： 1234567891011public static void main(String[] args) &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-mm-dd"); try &#123; Date date = format.parse("2018-04-03"); System.out.println("程序正常"); &#125; catch (ParseException e) &#123; System.out.println("程序异常"); &#125;&#125; 答：打印结果“程序正常”.try代码块中并没有产生异常，catch代码块中的代码不会执行。date为2018年1月3日00点04分00秒。 练习六：并行、并发概念问题：请简单描述什么是并行，什么是并发? 答： 并行：指两个或多个事件在同一时刻发生（同时发生）。 并发：指两个或多个事件在同一个时间段内发生。 通俗易懂版： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时。 并行的关键是你有同时处理多个任务的能力。 所以它们最关键的点就是：是否是『同时』。 练习七：进程概念、线程概念、线程与进程联系问题：请描述什么是进程，什么是线程，进程与线程之间的关系，并举例说明。 答： 进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。 线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 一个程序运行后至少有一个进程，一个进程中可以包含多个线程,但一个进程中至少包含一个线程。比如使用迅雷软件下载网络文件时，同时下载多个文件，就使用到了多线程下载。 练习八：自定义异常类问题： 请使用代码实现 每一个学生(Student)都有学号,姓名和分数,分数永远不能为负数； 如果老师给学生赋值一个负数,抛出一个自定异常。 123456789101112131415/* *1.定义异常类NoScoreException,继承RuntimeException * a)提供空参和有参构造方法 */public class NoScoreException extends RuntimeException &#123; // 空参构造 public NoScoreException() &#123; super(); &#125; // 有参构造 public NoScoreException(String message) &#123; super(message); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 2.定义学生类(Student) a)属性:name,score b)提供空参构造 c)提供有参构造; i.使用setXxx方法给名称和score赋值 d)提供setter和getter方法 i.在setScore(int score)方法中 1.首先判断,如果score为负数,就抛出NoScoreException 异常信息为:分数不能为负数:xxx. 2.然后在给成员score赋值. */public class Student &#123; private String name; private int score; // 空参构造 public Student() &#123; super(); &#125; // c)提供有参构造; // i.使用setXxx方法给名称和score赋值 public Student(String name,int score)&#123; setName(name); setScore(score); &#125; // d)提供setter和getter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; // i.在setScore(int score)方法中 public void setScore(int score) &#123; // 1.首先判断,如果score为负数,就抛出NoScoreException,异常信息为:分数不能为负数:xxx. if(score &lt;0)&#123; throw new NoScoreException(":分数不能为负数:"+score); &#125; // 2.然后在给成员score赋值. this.score = score; &#125;&#125; 1234567891011121314151617181920212223/*3.定义测试类Test9 a)提供main方法,在main方法中 i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序 ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码 iii.使用空参构造创建Student对象 iv.调用setScore(int score)方法,传入一个正数,运行程序 v.调用setScore(int score)方法,传入一个负数,运行程序 */public class Test9 &#123; public static void main(String[] args) &#123; // i.使用满参构造方法创建Student对象,分数传入一个负数,运行程序 // Student s = new Student("景甜", -10); // ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码 // iii.使用空参构造创建Student对象 Student s = new Student(); // iv.调用setScore(int score)方法,传入一个正数,运行程序 s.setScore(100); // v.调用setScore(int score)方法,传入一个负数,运行程序 s.setScore(-5); &#125;&#125; 练习九：多线程问题： 创建多线程对象，开启多线程。在子线程中输出1-100之间的偶数，主线程输出1-100之间的奇数。 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; /* * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 1; i &lt;= 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println("子线程打印输出偶数：" + i); &#125; &#125; &#125;&#125; 测试类： 123456789101112131415public class Test11 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(); //开启线程 mt.start(); //在主方法中执行for循环 for (int i = 1; i &lt;= 100; i++) &#123; if (i % 2 == 1) &#123; System.out.println("主线程打印输出奇数：" + i); &#125; &#125; &#125;&#125; 练习十：自定义异常类问题： 请用代码描述: 在一款角色扮演游戏中,每一个人都会有名字和生命值;角色的生命值不能为负数 要求:当一个人物的生命值为负数的时候需要抛出自定的异常 操作步骤描述 创建包com.itheima.level2 自定义异常类NoLifeValueExption继承RuntimeException a)提供空参和有参构造 b)在有参构造中,需要调用父类的有参构造,把异常信息传入 定义Person类 a)属性:名称(name)和生命值(lifeValue) a)提供空参构造 b)提供有参构造; ​ i.使用setXxx方法给name和lifeValue赋值 c)提供setter和getter方法 ​ i.在setLifeValue(int lifeValue)方法中 ​ （1）首先判断,如果 lifeValue为负数,就抛出NoLifeValueException,异常信息为:生命值不能为负数:xxx. ​ （2）然后在给成员lifeValue赋值. 定义测试类Test10 d)提供main方法,在main方法中 ​ i.使用满参构造方法创建Person对象,分数传入一个负数,运行程序 ​ ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码 ​ iii.使用空参构造创建Person对象 ​ iv.调用setLifeValue(int lifeValue)方法,传入一个正数,运行程序 ​ v.调用setLifeValue(int lifeValue)方法,传入一个负数,运行程序 操作步骤答案： 1234567891011121314/* 1.自定义异常类NoLifeValueExption继承RuntimeException a)提供空参和有参构造 b)在有参构造中,需要调用父类的有参构造,把异常信息传入 */public class NoLifeValueExption extends RuntimeException &#123; public NoLifeValueExption() &#123; super(); &#125; public NoLifeValueExption(String message) &#123; super(message); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 2.定义Person类 a)属性:名称(name)和生命值(lifeValue) b)提供空参构造 c)提供有参构造; i.使用setXxx方法给name和lifeValue赋值 d)提供setter和getter方法 i.在setLifeValue(int lifeValue)方法中 1.首先判断,如果 lifeValue为负数,就抛出 NoLifeValueException,异常信息为:生命值不能为负数:xxx. 2.然后在给成员lifeValue赋值. */public class Person &#123; // 名称(name) private String name; // 生命值(lifeValue) private int lifeValue; // 空参构造 public Person() &#123; super(); &#125; // c)提供有参构造; public Person(String name, int lifeValue) &#123; super(); // i.使用setXxx方法给name和lifeValue赋值 setName(name); setLifeValue(lifeValue); &#125; //d)提供setter和getter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getLifeValue() &#123; return lifeValue; &#125; // i.在setLifeValue(int lifeValue)方法中 public void setLifeValue(int lifeValue) &#123; // 1.首先判断,如果 lifeValue为负数,就抛出NoLifeValueException,异常信息为:生命值不能为负数:xxx. if (lifeValue &lt;0) &#123; throw new NoLifeValueExption("生命值不能为负数:" + lifeValue); &#125; // 2.然后在给成员lifeValue赋值. this.lifeValue = lifeValue; &#125;&#125; 12345678910111213141516171819202122/*3.定义测试类Test10 a)提供main方法,在main方法中 i.使用满参构造方法创建Person对象,分数传入一个负数,运行程序 ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码 iii.使用空参构造创建Person对象 iv.调用setLifeValue(int lifeValue)方法,传入一个正数,运行程序 v.调用setLifeValue(int lifeValue)方法,传入一个负数,运行程序 */public class Test10 &#123; public static void main(String[] args) &#123; // i.使用满参构造方法创建Person对象,分数传入一个负数,运行程序 // Person p = new Person("林思意", -100); // ii.由于一旦遇到异常,后面的代码的将不在执行,所以需要注释掉上面的代码 // iii.使用空参构造创建Person对象 Person p = new Person(); // iv.调用setLifeValue(int lifeValue)方法,传入一个正数,运行程序 p.setLifeValue(1000); // v.调用setLifeValue(int lifeValue)方法,传入一个负数,运行程序 p.setLifeValue(-100); &#125;&#125; 练习十一：多线程问题： 创建三个子线程，在每个线程中开启10万次的循环，线程1循环中将循环自增变量i赋值给Integer类型变量 a，线程2循环中将字符串”程序员”赋值给String类型变量b,线程3循环中将字符串”程序员”和循环自增变量i拼接后赋值给String类型变量c。 分别计算三个线程完成任务所用的毫秒值。 线程1： 1234567891011public class Thread1 extends Thread&#123; @Override public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; Integer a = i; &#125; long end = System.currentTimeMillis(); System.out.println("线程1执行时间："+(end-start)); &#125;&#125; 线程2： 1234567891011public class Thread2 extends Thread&#123; @Override public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; String b = "程序员"; &#125; long end = System.currentTimeMillis(); System.out.println("线程2执行时间："+(end-start)); &#125;&#125; 线程3： 1234567891011public class Thread3 extends Thread&#123; @Override public void run() &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; String c = "程序员"+i; &#125; long end = System.currentTimeMillis(); System.out.println("========线程3执行时间："+(end-start)); &#125;&#125; 测试类： 1234567public class TestThread &#123; public static void main(String[] args) &#123; new Thread1().start(); new Thread2().start(); new Thread3().start(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶04-Map]]></title>
    <url>%2F2019%2F08%2F23%2F2019-08-23-Java%E8%BF%9B%E9%98%B604-%20Map%2F</url>
    <content type="text"><![CDATA[主要内容 Map集合 学习目标 能够说出Map集合特点 使用Map集合添加方法保存数据 使用”键找值”的方式遍历Map集合 使用”键值对”的方式遍历Map集合 能够使用HashMap存储自定义键值对的数据 能够使用HashMap编写斗地主洗牌发牌案例 第一章 Map集合1.1 概述现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即java.util.Map接口。 我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。 Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 1.2 Map常用子类通过查看Map接口描述，看到Map有多个实现类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 1.3 Map接口中的常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map接口的方法演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.HashMap;public class Test &#123; public static void main(String[] args) &#123; // HashMap 哈希映射表集合 : HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 1. 增加 put map.put("刘德华", 18); map.put("张学友", 22); map.put("黎明", 19); map.put("郭富城", 21); map.put("郭德刚", 30); map.put("王宝强", 10); System.out.println("map = " + map); // 2. 删除 remove Integer value = map.remove("郭德刚"); System.out.println("value = " + value); System.out.println("map = " + map); // 3. 修改 put Integer value2 = map.put("王宝强", 20); System.out.println("value2 = " + value2); System.out.println("map = " + map); // 4. 查询 get Integer value3 = map.get("王宝强"); System.out.println("value3 = " + value3); System.out.println("map = " + map); &#125;&#125;输出结果 :map = &#123;黎明=19, 郭富城=21, 张学友=22, 王宝强=10, 郭德刚=30, 刘德华=18&#125;value = 30map = &#123;黎明=19, 郭富城=21, 张学友=22, 王宝强=10, 刘德华=18&#125;value2 = 10map = &#123;黎明=19, 郭富城=21, 张学友=22, 王宝强=20, 刘德华=18&#125;value3 = 20map = &#123;黎明=19, 郭富城=21, 张学友=22, 王宝强=20, 刘德华=18&#125; tips: 使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 1.4 Map集合遍历键找值方式键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) 代码演示： 123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.Set;public class Test &#123; public static void main(String[] args) &#123; // HashMap 哈希映射表集合 : HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 添加元素 map.put("刘德华", 18); map.put("张学友", 22); map.put("黎明", 19); map.put("郭富城", 21); map.put("郭德刚", 30); map.put("王宝强", 10); // 通过 `键找值` 的方法遍历 map 集合 Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) &#123; Integer value = map.get(key); System.out.println(key + " = " + value); &#125; &#125;&#125;输出结果 :黎明 = 19郭富城 = 21张学友 = 22王宝强 = 10郭德刚 = 30刘德华 = 18 1.5 Entry键值对对象我们已经知道，Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值的方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 1.6 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() 代码演示： 12345678910111213141516171819202122232425262728293031323334353637import java.util.HashMap;import java.util.Map;import java.util.Set;public class Test &#123; public static void main(String[] args) &#123; // HashMap 哈希映射表集合 : HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 添加元素 map.put("刘德华", 18); map.put("张学友", 22); map.put("黎明", 19); map.put("郭富城", 21); map.put("郭德刚", 30); map.put("王宝强", 10); // 通过获取 `键找对对象` 的方法遍历 map 集合 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;String, Integer&gt; entry : entrySet) &#123; // 1. getKey() 获取键值对对象的 key // 2. getValue() 获取键值对对象的 value String key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key + " = " + value); &#125; &#125;&#125;输出结果 :黎明 = 19郭富城 = 21张学友 = 22王宝强 = 10郭德刚 = 30刘德华 = 18 tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 1.7 HashMap存储自定义类型键值练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。 注意，学生姓名相同并且年龄相同视为同一名学生。 编写学生类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Objects;public class Student &#123; // 属性 private String name; private int age; // 注意 : 如果自定义对象作为 `HashMap` 的 key, 那么该自定义对象所属的类就必须要重写 Object 类的 equals() 与 toString() 方法. @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 编写测试类： 12345678910111213141516171819202122232425262728293031323334353637import java.util.HashMap;import java.util.Map;import java.util.Set;public class Test &#123; public static void main(String[] args) &#123; // HashMap 哈希映射表集合 : HashMap&lt;Student, String&gt; map = new HashMap&lt;&gt;(); // 添加元素 map.put(new Student("郭德刚", 30), "哈尔冰"); map.put(new Student("王宝强", 10), "北京"); map.put(new Student("刘德华", 18), "香港"); map.put(new Student("张学友", 22), "上海"); map.put(new Student("黎明", 17), "大陆"); map.put(new Student("郭富城", 21), "台湾"); map.put(new Student("郭德刚", 30), "哈尔冰"); map.put(new Student("王宝强", 10), "北京"); // 通过获取 `键找对对象` 的方法遍历 map 集合 Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123; Student key = entry.getKey(); String value = entry.getValue(); System.out.println(key + " = " + value); &#125; &#125;&#125;输出结果 :Student&#123;name='黎明', age=17&#125; = 大陆Student&#123;name='郭富城', age=21&#125; = 台湾Student&#123;name='刘德华', age=18&#125; = 香港Student&#123;name='王宝强', age=10&#125; = 北京Student&#123;name='郭德刚', age=30&#125; = 哈尔冰Student&#123;name='张学友', age=22&#125; = 上海 当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。 如果要保证map中存放的key和取出的顺序一致，可以使用java.util.LinkedHashMap集合来存放。 1.8 LinkedHashMap我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？ 在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。 123456789101112131415161718192021222324252627282930import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;import java.util.Set;public class Test &#123; public static void main(String[] args) &#123; // HashMap 哈希映射表集合 : HashMap&lt;Student, String&gt; map = new LinkedHashMap&lt;&gt;(); // 添加元素 map.put(new Student("郭德刚", 30), "哈尔冰"); map.put(new Student("王宝强", 10), "北京"); map.put(new Student("刘德华", 18), "香港"); map.put(new Student("张学友", 22), "上海"); map.put(new Student("黎明", 17), "大陆"); map.put(new Student("郭富城", 21), "台湾"); map.put(new Student("郭德刚", 30), "哈尔冰"); map.put(new Student("王宝强", 10), "北京"); // 通过获取 `键找对对象` 的方法遍历 map 集合 Set&lt;Map.Entry&lt;Student, String&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;Student, String&gt; entry : entrySet) &#123; Student key = entry.getKey(); String value = entry.getValue(); System.out.println(key + " = " + value); &#125; &#125;&#125; 结果: 123456Student&#123;name=&apos;郭德刚&apos;, age=30&#125; = 哈尔冰Student&#123;name=&apos;王宝强&apos;, age=10&#125; = 北京Student&#123;name=&apos;刘德华&apos;, age=18&#125; = 香港Student&#123;name=&apos;张学友&apos;, age=22&#125; = 上海Student&#123;name=&apos;黎明&apos;, age=17&#125; = 大陆Student&#123;name=&apos;郭富城&apos;, age=21&#125; = 台湾 1.9 Map集合练习需求： 计算一个字符串中每个字符出现次数。 分析： 获取一个字符串对象 创建一个Map集合，键代表字符，值代表次数。 遍历字符串得到每个字符。 判断Map中是否有该键。 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。 打印最终结果 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.HashMap;import java.util.Map;import java.util.Scanner;import java.util.Set;public class HashMapTest &#123; public static void main(String[] args) &#123; // 需求 : 计算一个字符串中每个字符出现次数。 // 1. 创建一个键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("亲, 请输入一个字符串 :"); String str = sc.nextLine(); sc.close(); // 2. 调用方法 findCharacter(str); &#125; // 定义方法, 查找每一个字符出现的次数 public static void findCharacter(String str) &#123; // 1. 定义一个 Map 集合, 用于统计每一个字符出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // 2. 遍历字符串 for (int i = 0; i &lt; str.length(); i++) &#123; // 3. 取出当前遍历的每一个字符 char c = str.charAt(i); // 4. 判断 map 集合中是否包含 c 这个 key 值. if (map.containsKey(c)) &#123; // 4.1 包含 (该键不是第一次出现) // 4.1.1 取出该键对应的值 Integer value = map.get(c); // 4.1.2 将 value += 1, 重新存入到 map 集合中 map.put(c, ++value); &#125; else &#123; // 4.2 不包含 (说明该键是第一次出现, 将值设置为 1 集合. map.put(c, 1); &#125; &#125; // 5. 查看集合中每一个字符对应出现的次数 Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet(); for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123; Character key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key + " = " + value); &#125; &#125;&#125;输出结果 :亲, 请输入一个字符串 :asdfaskdywerwibbnmzsdfa = 2b = 2d = 3e = 1f = 2i = 1k = 1m = 1n = 1r = 1s = 3w = 2y = 1z = 1 第二章 补充知识点2.1 Debug追踪使用IDEA的断点调试功能，查看程序的运行过程 在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序 点击Debug运行模式 程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口 Debug调试窗口介绍 快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行） 切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入 快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea 回车之后效果： 调试界面效果： 此时到达findChar方法，快捷键F7，进入方法findChar 快捷键F8 接续执行，创建了map对象，变量区域显示 快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97 快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中 快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素 快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了 如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示 2.2 JDK9对集合添加的优化通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法调用，使得代码重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class JDK9Of &#123; public static void main(String[] args) &#123; // 需求 : 往集合中添加元素 // 1. 方式一 : add ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); list.add(20); list.add(30); list.add(40); list.add(50); System.out.println("list = " + list); // 2. 方式二 : 集合工具类 addAll ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); Collections.addAll(list2, 10, 20, 30); Collections.addAll(list2, 40, 50); System.out.println("list2 = " + list2); // 3. 方式三 : JDK 9 出现了静态方法. of (List, Set, Map) // 注意 : 该集合返回的是不可变的集合. 不可以操作集合中的元素. List&lt;Integer&gt; list3 = List.of(10, 20, 30, 40, 50); // UnsupportedOperationException 不支持的操作异常. // list3.add(60); System.out.println("list3 = " + list3); // Set 接口 Set&lt;Integer&gt; set = Set.of(10, 20, 30, 40, 50); System.out.println("set = " + set); // Map 接口 Map&lt;String, Integer&gt; map = Map.of("Jack", 18, "Rose", 16, "Peter", 20); // map.put("Lindi", 20); UnsupportedOperationException System.out.println("map = " + map); &#125;&#125;输出结果 :list = [10, 20, 30, 40, 50]list2 = [10, 20, 30, 40, 50]list3 = [10, 20, 30, 40, 50]set = [20, 40, 30, 50, 10]map = &#123;Jack=18, Rose=16, Peter=20&#125; Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和实现类并没有这个方法，比如 HashSet，ArrayList, Collection等等. 2:返回的集合是不可变的； 第三章 模拟斗地主洗牌发牌3.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。 具体规则： 组装54张扑克牌将 54张牌顺序打乱 三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 查看三人各自手中的牌（按照牌的大小排序）、底牌 规则：手中扑克牌从小到大的摆放顺序：3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, 小王, 大王 3.2 案例需求分析 准备牌： 完成数字与纸牌的映射关系： 使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。 洗牌： 通过数字完成洗牌发牌 发牌： 将每个人以及底牌设计为ArrayList&lt;String&gt;,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 存放的过程中要求数字大小与斗地主规则的大小对应。 将代表不同纸牌的数字分配给不同的玩家与底牌。 看牌： 通过Map集合找到对应字符展示。 通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。 思路说明 : 12345678910111213141516171819202122public class PokersTest &#123; public static void main(String[] args) &#123; // 1. 准备一副 `扑克牌映射表` // 3♥ 3♦ 3♣ 3♠ 4♥ 4♦ 4♣ 4♠ 5♥ 5♦ 5♣ 5♠ ...... 2♥ 2♦ 2♣ 2♠ 小☺ 大☠ value // 0 1 2 3 4 5 6 7 8 9 10 11 ...... 48 49 50 51 52 53 key // 2. 准备一副 `数字牌`, 发给玩家的数字牌 // [0 1 2 3 4 5 6 7 8 9 10 11 ... 53] // 3. 给数字牌洗牌 (Collections.shuffle) // 4. 给玩家发牌 (玩家手中的牌是数字牌, 注意: 这个数字牌是乱序的) // 5. 给玩家手中的数字排序实现排序. (Collections.sort) 玩家手中的数字牌就已经有序了. // 6. 根据玩家手中的数字牌去 `映射表` 中取出对应的字符串牌. // 因为玩家手中的数字牌排序, 因此从映射表中取出的字符串牌也是有序的. // 7. 查看每个玩家手中的排序. &#125;&#125; 准备扑克牌方式一 : 12345678910// 1.1 创建一个 `映射表对象` 集合HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();// 1.2 创建一个 `数字` 集合ArrayList&lt;String&gt; numbers = new ArrayList&lt;&gt;();Collections.addAll(numbers, "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2");System.out.println("numbers = " + numbers);// 1.3 创建一个 `花色` 集合ArrayList&lt;String&gt; colors = new ArrayList&lt;&gt;();Collections.addAll(colors, "♥", "♦", "♣", "♠");System.out.println("colors = " + colors); 说明 : 由于 numbers 和 colors 集合中的元素后期是不需要进行 增删改 操作, 因此, 我们有一种更加简单的方式实现, 使用 JDK9 提供的接口 List, Set, Map 静态方法 : of 就可以实现. 3.3 实现代码步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;public class PokersTest &#123; public static void main(String[] args) &#123; // 1. 准备一副 `扑克牌映射表` // 3♦ 3♣ 3♥ 3♠ 4♦ 4♣ 4♥ 4♠ 5♦ 5♣ 5♥ 5♠ ... 2♦ 2♣ 2♥ 2♠ 小☺ 大☠ value // 0 1 2 3 4 5 6 7 8 9 10 11 ... 48 49 50 51 52 53 key // 1.1 准备一个 `扑克牌映射表`, 存储每一张扑克牌 HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); // 1.2 准备一个 `数字` 集合 /* ArrayList&lt;String&gt; numbers = new ArrayList&lt;&gt;(); for (int i = 3; i &lt;= 10; i++) &#123; numbers.add(i + ""); &#125; Collections.addAll(numbers, "J", "Q", "K", "A", "2"); System.out.println("numbers = " + numbers); */ List&lt;String&gt; numbers = List.of("3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"); System.out.println("numbers = " + numbers); // 1.3 准备一个 `花色` 集合 List&lt;String&gt; colors = List.of("♦", "♣", "♥", "♠"); System.out.println("colors = " + colors); // 1.4 遍历 `数字 + 花色` 集合, 拼接每一张扑克牌 int map_key = 0; for (String number : numbers) &#123; for (String color : colors) &#123; String poker = number + color; // 1.5 将拼接完成的 poker 存储到映射表中 map.put(map_key++, poker); &#125; &#125; // 1.6 最后添加 `大小王` map.put(map_key++, "小☺"); map.put(map_key, "大☠"); System.out.println("map = " + map); // 2. 准备一副数字牌. // [0, 1, 2, 3, 4, 5, 6, ... 53] ArrayList&lt;Integer&gt; numbers_poker = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 54; i++) &#123; numbers_poker.add(i); &#125; System.out.println("numbers_poker = " + numbers_poker); // 3. 洗牌 (数字牌 Collections.shuffle) Collections.shuffle(numbers_poker); System.out.println("numbers_poker = " + numbers_poker); // 4.1 发牌 (数字牌 -&gt; 三个玩家, 一个底牌, 获取到的都是数字) ArrayList&lt;Integer&gt; num_player1 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; num_player2 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; num_player3 = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; num_base = new ArrayList&lt;&gt;(); // 4.2 for i 循环, 取模判断 for (int i = 0; i &lt; numbers_poker.size(); i++) &#123; // 4.3 取出当前遍历的数组 Integer num_poker = numbers_poker.get(i); // 4.4 判断底牌 if (i &gt;= numbers_poker.size() - 3) &#123; num_base.add(num_poker); &#125; else &#123; // 4.5 玩家 if (i % 3 == 0) &#123; num_player1.add(num_poker); &#125; else if (i % 3 == 1) &#123; num_player2.add(num_poker); &#125; else &#123; num_player3.add(num_poker); &#125; &#125; &#125; System.out.println("------------------------------------"); System.out.println("num_player1 = " + num_player1); System.out.println("num_player2 = " + num_player2); System.out.println("num_player3 = " + num_player3); System.out.println("num_base = " + num_base); // 5. 排序 (Integer类本身具备 `自然排序` Collections.sort) System.out.println("------------------------------------"); Collections.sort(num_player1); Collections.sort(num_player2); Collections.sort(num_player3); Collections.sort(num_base); System.out.println("num_player1 = " + num_player1); System.out.println("num_player2 = " + num_player2); System.out.println("num_player3 = " + num_player3); System.out.println("num_base = " + num_base); // 6. 玩家可以根据手中的数字牌从映射表中取出对应的 `字符串牌`, 放入到字符串的扑克牌集合中 // 6.1 创建三个玩家, 和一个底牌 (泛型为 String) ArrayList&lt;String&gt; str_player1 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; str_player2 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; str_player3 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; str_base = new ArrayList&lt;&gt;(); // 6.2 根据玩家手中的数字牌. 从映射表取出对应的 `字符串牌` for (Integer key : num_player1) &#123; String poker = map.get(key); str_player1.add(poker); &#125; for (Integer key : num_player2) &#123; String poker = map.get(key); str_player2.add(poker); &#125; for (Integer key : num_player3) &#123; String poker = map.get(key); str_player3.add(poker); &#125; for (Integer key : num_base) &#123; String poker = map.get(key); str_base.add(poker); &#125; // 7. 看牌 (输出集合即可) System.out.println("张三丰 : " + str_player1); System.out.println("张无忌 : " + str_player2); System.out.println("张学友 : " + str_player3); System.out.println("底牌 : " + str_base); &#125;&#125;输出结果 :numbers = [3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, 2]colors = [♦, ♣, ♥, ♠]map = &#123;0=3♦, 1=3♣, 2=3♥, 3=3♠, 4=4♦, 5=4♣, 6=4♥, 7=4♠, 8=5♦, 9=5♣, 10=5♥, 11=5♠, 12=6♦, 13=6♣, 14=6♥, 15=6♠, 16=7♦, 17=7♣, 18=7♥, 19=7♠, 20=8♦, 21=8♣, 22=8♥, 23=8♠, 24=9♦, 25=9♣, 26=9♥, 27=9♠, 28=10♦, 29=10♣, 30=10♥, 31=10♠, 32=J♦, 33=J♣, 34=J♥, 35=J♠, 36=Q♦, 37=Q♣, 38=Q♥, 39=Q♠, 40=K♦, 41=K♣, 42=K♥, 43=K♠, 44=A♦, 45=A♣, 46=A♥, 47=A♠, 48=2♦, 49=2♣, 50=2♥, 51=2♠, 52=小☺, 53=大☠&#125;numbers_poker = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53]numbers_poker = [20, 36, 0, 27, 17, 30, 37, 46, 52, 1, 31, 18, 10, 28, 53, 6, 5, 38, 33, 14, 24, 21, 44, 25, 47, 50, 16, 39, 43, 45, 49, 29, 40, 35, 11, 41, 32, 19, 22, 15, 34, 7, 42, 8, 13, 4, 48, 9, 2, 3, 26, 51, 23, 12]------------------------------------num_player1 = [20, 27, 37, 1, 10, 6, 33, 21, 47, 39, 49, 35, 32, 15, 42, 4, 2]num_player2 = [36, 17, 46, 31, 28, 5, 14, 44, 50, 43, 29, 11, 19, 34, 8, 48, 3]num_player3 = [0, 30, 52, 18, 53, 38, 24, 25, 16, 45, 40, 41, 22, 7, 13, 9, 26]num_base = [51, 23, 12]------------------------------------num_player1 = [1, 2, 4, 6, 10, 15, 20, 21, 27, 32, 33, 35, 37, 39, 42, 47, 49]num_player2 = [3, 5, 8, 11, 14, 17, 19, 28, 29, 31, 34, 36, 43, 44, 46, 48, 50]num_player3 = [0, 7, 9, 13, 16, 18, 22, 24, 25, 26, 30, 38, 40, 41, 45, 52, 53]num_base = [12, 23, 51]张三丰 : [3♣, 3♥, 4♦, 4♥, 5♥, 6♠, 8♦, 8♣, 9♠, J♦, J♣, J♠, Q♣, Q♠, K♥, A♠, 2♣]张无忌 : [3♠, 4♣, 5♦, 5♠, 6♥, 7♣, 7♠, 10♦, 10♣, 10♠, J♥, Q♦, K♠, A♦, A♥, 2♦, 2♥]张学友 : [3♦, 4♠, 5♣, 6♣, 7♦, 7♥, 8♥, 9♦, 9♣, 9♥, 10♥, Q♥, K♦, K♣, A♣, 小☺, 大☠]底牌 : [6♦, 8♠, 2♠] 练习题练习一：Map接口的特点请简述Map 的特点。 （1）Map每个元素由键与值两部分组成 （2）Map键不能重复,每个键对应一个值 （3）键和值可以为null 练习二：Entry键值对对象说出Entry键值对对象遍历Map集合的原理。 Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map 中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。 练习三：Map接口中的常用方法请使用Map集合的方法完成添加元素，根据键删除，以及根据键获取值操作。 12345678910111213141516171819202122232425public class MapTest01&#123; public static void main(String[] args) &#123; // 1.创建HashMap HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); // 2.使用put添加元素 hm.put("黄晓明", "Baby"); hm.put("邓超", "孙俪"); hm.put("李晨", "范冰冰"); hm.put("大黑牛", "范冰冰"); // 3.使用put修改元素 String v1 = hm.put("李晨", "白百合"); // 4.使用get获取元素 String string = hm.get("大黑牛"); // 5.使用remove删除元素 String v2 = hm.remove("大黑牛"); System.out.println(v2); // 6.打印集合中的元素 System.out.println(hm); &#125;&#125; 练习四：Map接口中的方法往一个Map集合中添加若干元素。获取Map中的所有value，并使用增强for和迭代器遍历输出每个value。 123456789101112131415161718192021222324252627public class MapTest02 &#123; public static void main(String[] args) &#123; // 1.创建HashMap HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); // 2.使用put添加元素 hm.put("黄晓明", "Baby"); hm.put("邓超", "孙俪"); hm.put("李晨", "范冰冰"); hm.put("大黑牛", "范冰冰"); // 3.使用Map的values方法获取到所有的value Collection&lt;String&gt; values = hm.values(); // 4.使用增强for获取每个value for (String value : values) &#123; System.out.println(value); &#125; System.out.println("----------------"); // 5.使用迭代器获取每个value Iterator&lt;String&gt; itr = values.iterator(); while (itr.hasNext()) &#123; System.out.println(itr.next()); &#125; &#125;&#125; 练习五：HashMap存储键是自定义对象值是String请使用Map集合存储自定义数据类型Car做键，对应的价格做值。并使用keySet和entrySet两种方式遍历Map集合。 汽车类: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 1.定义汽车类.包含名称和价格属性,重写hashCode和equals方法public class Car &#123; private String name; private String color; public Car() &#123; &#125; public Car(String name, String color) &#123; this.name = name; this.color = color; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Car)) return false; Car car = (Car) o; if (name != null ? !name.equals(car.name) : car.name != null) return false; return color != null ? color.equals(car.color) : car.color == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + (color != null ? color.hashCode() : 0); return result; &#125;&#125; 测试类: 123456789101112131415161718192021222324252627282930313233public class MapTest03 &#123; public static void main(String[] args) &#123; // 2.创建HashMapkey保存汽车对象,value是汽车价格 HashMap&lt;Car, Integer&gt; hm = new HashMap&lt;&gt;(); // 3.添加汽车到HashMap中 Car c1 = new Car("长安奔奔", "黄色"); Car c3 = new Car("奇瑞QQ", "黑色"); Car c2 = new Car("铃木奥拓", "白色"); hm.put(c1, 10000); hm.put(c2, 20000); hm.put(c3, 30000); // 4.使用keySet方式遍历Map Set&lt;Car&gt; keySet = hm.keySet(); for (Car c : keySet) &#123; // 根据key获取value Integer value = hm.get(c); System.out.println(c.getName() + ","+ c.getPrice() + " - "+ value); &#125; System.out.println("-------------"); // 5.使用entrySet方式遍历Map Set&lt;Map.Entry&lt;Car, Integer&gt;&gt; entrySet = hm.entrySet(); for (Map.Entry&lt;Car, Integer&gt; entry : entrySet) &#123; Car key = entry.getKey(); Integer value = entry.getValue(); System.out.println(key.getName() + ","+ key.getPrice() + " - "+ value); &#125; &#125;&#125; 练习六：Map集合的使用（一）现在有一个map集合如下： 12345Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, "张三丰"); map.put(2, "周芷若"); map.put(3, "汪峰"); map.put(4, "灭绝师太"); 要求： 1.遍历集合，并将序号与对应人名打印。 2.向该map集合中插入一个编码为5姓名为李晓红的信息 3.移除该map中的编号为1的信息 4.将map集合中编号为2的姓名信息修改为”周林” 1234567891011121314151617181920212223242526272829public class MapTest04 &#123; public static void main(String[] args) &#123; // 1.定义HashMap,编号作为key,姓名作为value Map&lt;Integer,String&gt; map = new HashMap&lt;Integer, String&gt;(); // 2.使用put方法添加元素 map.put(1, "张三丰"); map.put(2, "周芷若"); map.put(3, "汪峰"); map.put(4, "灭绝师太"); // 3.使用keySet+增强for迭代map中的元素,并打印 Set&lt;Integer&gt; keySet = map.keySet(); for (Integer key : keySet) &#123; String value = map.get(key); System.out.println(key + " -- "+ value); &#125; // 4.使用put向该map集合中插入一个编码为5姓名为李晓红的信息 map.put(5, "李晓红"); // 5.使用remove移除该map中的编号为1的信息 map.remove(1); // 6.使用put将map集合中编号为2的姓名信息修改为"周林" map.put(2, "周林"); System.out.println(map); &#125;&#125; 练习七：Map集合的使用（二）有2个数组， 第一个数组内容为：[黑龙江省,浙江省,江西省,广东省,福建省]， 第二个数组为：[哈尔滨,杭州,南昌,广州,福州]， 将第一个数组元素作为key，第二个数组元素作为value存储到Map集合中。 如{黑龙江省=哈尔滨, 浙江省=杭州, …}。 123456789101112131415161718192021222324public class MapTest05 &#123; public static void main(String[] args) &#123; // 1.定义第一个数组arr1 String[] arr1 = &#123;"黑龙江省", "浙江省", "江西省", "广东省", "福建省"&#125;; // 2.定义第二个数组arr2 String[] arr2 = &#123;"哈尔滨", "杭州", "南昌", "广州", "福州"&#125;; // 3.创建HashMap,key存放省,value存放市 HashMap&lt;String, String&gt; hm = new HashMap&lt;&gt;(); // 4.使用普通for循环遍历arr1 for (int i = 0; i &lt; arr1.length; i++) &#123; // 5.根据索引到arr1中获取到省 String key = arr1[i]; // 6.根据索引到arr2中获取到省会城市 String value = arr2[i]; // 7.将省和省会城市添加到HashMap中 hm.put(key, value); &#125; // 8.输出HashMap中的内容 System.out.println(hm); &#125;&#125; 练习八：Map集合的使用（三）定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。例如：集合中有”abc”、”bcd”两个元素，程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 123456789101112131415161718192021222324252627282930313233343536public class MapTest06 &#123; public static void main(String[] args) &#123; // 1.定义ArrayList存放元素 ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); // 2.使用add方法添加需要的元素 arr.add("abc"); arr.add("bcd"); // 3.定义HashMap,key是字符,value是字符对应的次数 HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); // 4.使用增强for获取ArrayList中的每个字符串 for (String str : arr) &#123; // 5.将每个字符串转成字符数组 char[] charArray = str.toCharArray(); // 6.使用增强for遍历字符数组 for (char ch : charArray) &#123; // 7.获取拿到每个字符,使用字符去HashMap中查找次数 Integer num = hm.get(ch); // 8.如果为空,说明该字符第一次出现 if (num == null) &#123; // 9.放入字符作为key,把次数设置为1 hm.put(ch, 1); &#125; else &#123; // 10.如果之前,已经有字符了,就把字符的次数+1 hm.put(ch, num + 1); &#125; &#125; &#125; // 11.输出map中的内容 System.out.println(hm); &#125;&#125; 练习九：Map集合的使用（四） 利用Map，完成下面的功能： 从命令行读入一个字符串，表示一个年份，输出该年的世界杯冠军是哪支球队。如果该年没有举办世界杯，则输出：没有举办世界杯。 //tips:参阅Map接口containsKey(Object key)方法 在原有世界杯Map 的基础上，增加如下功能： 读入一支球队的名字，输出该球队夺冠的年份列表。 例如，读入“巴西”，应当输出 1958 1962 1970 1994 2002 读入“荷兰”，应当输出 没有获得过世界杯。 //tips:参阅Map接口containsValue(Object value)方法 示例： 1234567891011121314请输入一个年份19781978年，获得世界杯冠军的是：阿根廷请输入一个国家名称巴西1958、1962、1994、1970、2002、 附：历届世界杯冠军 届数 举办年份 举办地点 冠军 第一届 1930年 乌拉圭 乌拉圭 第二届 1934年 意大利 意大利 第三届 1938年 法国 意大利 第四届 1950年 巴西 乌拉圭 第五届 1954年 瑞士 西德 第六届 1958年 瑞典 巴西 第七届 1962年 智利 巴西 第八届 1966年 英格兰 英格兰 第九届 1970年 墨西哥 巴西 第十届 1974年 前西德 西德 第十一届 1978年 阿根廷 阿根廷 第十二届 1982年 西班牙 意大利 第十三届 1986年 墨西哥 阿根廷 第十四届 1990年 意大利 西德 第十五届 1994年 美国 巴西 第十六届 1998年 法国 法国 第十七届 2002年 韩日 巴西 第十八届 2006年 德国 意大利 第十九届 2010年 南非 西班牙 第二十届 2014年 巴西 德国 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class MapTest09 &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; m = new HashMap&lt;&gt;(); m.put(1930, "乌拉圭"); m.put(1934, "意大利"); m.put(1938, "意大利"); m.put(1950, "乌拉圭"); m.put(1954, "西德"); m.put(1958, "巴西"); m.put(1962, "巴西"); m.put(1966, "英格兰"); m.put(1970, "巴西"); m.put(1974, "西德"); m.put(1978, "阿根廷"); m.put(1982, "意大利"); m.put(1986, "阿根廷"); m.put(1990, "西德"); m.put(1994, "巴西"); m.put(1998, "法国"); m.put(2002, "巴西"); m.put(2006, "意大利"); m.put(2010, "西班牙"); m.put(2014, "德国"); System.out.println("请输入一个年份"); Scanner s = new Scanner(System.in); int key = s.nextInt(); if (m.containsKey(key)) &#123; System.out.println(key + "年，获得世界杯冠军的是：" + m.get(key)); &#125; else &#123; System.out.println("该年没有举办世界杯！"); &#125; System.out.println("请输入一个国家名称"); Scanner g = new Scanner(System.in); String val = g.nextLine(); if (m.containsValue(val)) &#123; for (Integer year : m.keySet()) &#123; if (m.get(year).equals(val)) &#123; System.out.println(year + "、\n"); &#125; &#125; &#125; else &#123; System.out.println("该国家没有获得世界杯冠军"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶03-List和Set]]></title>
    <url>%2F2019%2F08%2F23%2F2019-08-23-Java%E8%BF%9B%E9%98%B603-%20List%E5%92%8CSet%2F</url>
    <content type="text"><![CDATA[主要内容 List集合 Set集合 数据结构 学习目标 能够说出List集合特点 能够说出常见的数据结构 能够说出数组结构特点 能够说出栈结构特点 能够说出队列结构特点 能够说出单向链表结构特点 能够说出Set集合的特点 能够说出哈希表的特点 使用HashSet集合存储自定义元素 能够说出可变参数的格式 能够使用集合工具类 能够使用Comparator比较器进行排序 第一章 List集合我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？ 接下来，我们一起学习Collection中的常用几个子类（java.util.List集合、java.util.Set集合）。 1.1 List接口介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支，习惯性地会将实现了List接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 看完API，我们总结一下： List接口特点： 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。 1.2 List接口中常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.ArrayList;import java.util.Collection;import java.util.LinkedList;import java.util.List;public class ListTest1 &#123; public static void main(String[] args) &#123; // 1. 创建一个 List 集合 // Collection&lt;String&gt; c = new ArrayList&lt;String&gt;(); // 这里没有多态语法 : // ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 多态 : 接口应用指向了接口的实现类对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 请问 : list 可以调用 Collection 接口中的方法, 完全可以, 因为子接口继承了父接口中的所有方法 list.add("刘德华"); list.add("张学友"); list.add("黎明"); list.add("郭富城"); System.out.println("list = " + list); // list = [刘德华, 张学友, 黎明, 郭富城] // 2. add(index, element) // 需求 : 在刘德华之前添加 `郭德纲` list.add(0, "郭德纲"); // 需求 : 郭富城之后添加 `方媛` list.add(5, "方媛"); System.out.println("list = " + list); // 3. remove(index) String obj = list.remove(0); System.out.println("obj = " + obj); // 4. set(index, element) // 需求 : 将方媛换成 `柳岩` list.set(4, "柳岩"); System.out.println("list = " + list); // 5. get(index) 经常与fori 循环一起使用, 主要用来遍历集合 for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); System.out.println("str = " + str); &#125; &#125;&#125;输出结果 :list = [刘德华, 张学友, 黎明, 郭富城]list = [郭德纲, 刘德华, 张学友, 黎明, 郭富城, 方媛]obj = 郭德纲list = [刘德华, 张学友, 黎明, 郭富城, 柳岩]str = 刘德华str = 张学友str = 黎明str = 郭富城str = 柳岩 tips:我们之前学习Colletion体系的时候，发现List集合下有很多集合，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？在下一章我们来介绍： 第二章 List的子类3.1 ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。 3.2 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true。 LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可） 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.LinkedList;public class Test1 &#123; public static void main(String[] args) &#123; // 1. 创建一个 `链表` 集合 LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); // 2. addFirst / addLast list.addFirst("张三"); list.addFirst("李四"); list.addFirst("王五"); list.addFirst("赵六"); System.out.println("list = " + list); list.addLast("赵本山"); list.addLast("郭德纲"); System.out.println("list = " + list); // 3. getFirst / getLast String first = list.getFirst(); String last = list.getLast(); System.out.println("first = " + first); System.out.println("last = " + last); System.out.println("list = " + list); // 4. removeFirst / removeLast String removeFirst = list.removeFirst(); String removeLast = list.removeLast(); System.out.println("removeFirst = " + removeFirst); System.out.println("removeLast = " + removeLast); System.out.println("list = " + list); &#125;&#125;输出结果 :list = [赵六, 王五, 李四, 张三]list = [赵六, 王五, 李四, 张三, 赵本山, 郭德纲]first = 赵六last = 郭德纲list = [赵六, 王五, 李四, 张三, 赵本山, 郭德纲]removeFirst = 赵六removeLast = 郭德纲list = [王五, 李四, 张三, 赵本山] 第三章 数据结构2.1 数据结构有什么用？当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。 现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。 我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。 2.2 常见的数据结构数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下： 栈 栈：stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。 简单的说：采用该结构的集合，对元素的存取有如下的特点 先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。 栈的入口、出口的都是栈的顶端位置。 这里两个名词需要注意： 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 12345678910111213141516171819202122232425262728import java.util.LinkedList;public class Test &#123; public static void main(String[] args) &#123; // push -&gt; addFirst LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); list.push("张三"); list.push("李四"); list.push("王五"); list.push("赵六"); System.out.println("list = " + list); // pop 弹栈 -&gt; removeFirst while (!list.isEmpty()) &#123; String name = list.pop(); System.out.println("name = " + name); &#125; &#125;&#125;输出结果 :list = [赵六, 王五, 李四, 张三]name = 赵六name = 王五name = 李四name = 张三 队列 队列：queue,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 12345678910111213141516171819202122232425262728import java.util.LinkedList;public class Test &#123; public static void main(String[] args) &#123; // offer -&gt; addLast LinkedList&lt;String&gt; list3 = new LinkedList&lt;&gt;(); list3.offer("张三"); list3.offer("李四"); list3.offer("王五"); list3.offer("赵六"); System.out.println("list3 = " + list3); // poll -&gt; first while (!list3.isEmpty()) &#123; String name = list3.poll(); System.out.println("name = " + name); &#125; &#125;&#125;输出结果 :list3 = [张三, 李四, 王五, 赵六]name = 张三name = 李四name = 王五name = 赵六 数组 数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。 简单的说,采用该结构的集合，对元素的存取有如下的特点： 查找元素快：通过索引，可以快速访问指定位置的元素 ![05æ°ç&quot;æ¥è¯¢å¿&quot;.png](https://github.com/aimanyeye/blog-images/blob/master/blog-img/Java/Java%E8%BF%9B%E9%98%B6/2019-08-23-Java%E8%BF%9B%E9%98%B603-%20List%E5%92%8CSet/05%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png?raw=true) 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图 链表 链表:linked list,由一系列节点node（链表中每一个元素称为节点）组成，节点可以在运行时动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 红黑树 二叉树：binary tree ,是每个结点不超过2的有序树（tree） 。 简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。 二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。 如图： 我们要说的是二叉树的一种比较有意思的叫做红黑树，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。 12345678910111213141516171819202122232425262728293031323334353637import java.util.TreeSet;public class TreeSetTest1 &#123; public static void main(String[] args) &#123; // 1. 创建一个 TreeSet 集合 TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); // 2. 添加元素 set.add(38); set.add(15); set.add(66); set.add(78); set.add(19); set.add(22); set.add(55); set.add(86); set.add(33); set.add(55); // 3. 遍历集合 for (Integer num : set) &#123; System.out.println("num = " + num); &#125; &#125;&#125;输出结果 :num = 15num = 19num = 22num = 33num = 38num = 55num = 66num = 78num = 86 第四章 Set接口java.util.Set接口和java.util.List接口一样，同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格了。与List接口不同的是，Set接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set集合有多个子类，这里我们介绍其中的java.util.HashSet、java.util.LinkedHashSet这两个集合。 tips:Set集合取出元素的方式可以采用：迭代器、增强for。 3.1 HashSet集合介绍java.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet底层的实现其实是一个java.util.HashMap支持，由于我们暂时还未学习，先做了解。 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：hashCode与equals方法。 我们先来使用一下Set集合存储，看下现象，再进行原理的讲解: 1234567891011121314151617181920public class HashSetTest2 &#123; public static void main(String[] args) &#123; // 1. 创建一个 set 集合 HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); // 2. 添加元素 set.add("刘德华"); set.add("张学友"); set.add("黎明"); set.add("郭富城"); set.add("刘德华"); set.add("张学友"); // 3. 遍历集合 for (String name : set) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果如下，说明集合中不能存储重复元素： 1234黎明郭富城张学友刘德华 tips:根据结果我们发现字符串”刘德华, 张学友”只存储了一个，也就是说重复的元素set集合不存储。 2.2 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？ 在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 看到这张图就有人要问了，这个是怎么存储的呢？ 为了方便大家的理解我们结合一个存储流程图来说明一下： 总而言之，JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。 2.3 HashSet存储自定义类型元素给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一 创建自定义Student类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Objects;public class Student &#123; // 属性 private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; // 重写 toString() 方法 @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; // 记住 : 只要自定义对象往 Set 集合中存储时, 自定义对象所属类就必须重写 `hashCode + equals` 方法来保证元素的唯一性 @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); &#125; @Override public int hashCode() &#123; return Objects.hash(name, age); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 12345678910111213141516171819202122232425262728import java.util.HashSet;public class HashSetTest2 &#123; public static void main(String[] args) &#123; // 1. 创建一个 set 集合 HashSet&lt;Student&gt; set = new HashSet&lt;&gt;(); // 2. 添加元素 set.add(new Student("刘德华", 18)); set.add(new Student("张学友", 22)); set.add(new Student("黎明", 19)); set.add(new Student("郭富城", 20)); set.add(new Student("刘德华", 18)); set.add(new Student("张学友", 22)); // 3. 遍历集合 for (Student stu : set) &#123; System.out.println(stu); &#125; &#125;&#125;执行结果：Student&#123;name='黎明', age=19&#125;Student&#123;name='刘德华', age=18&#125;Student&#123;name='郭富城', age=20&#125;Student&#123;name='张学友', age=22&#125; 2.3 LinkedHashSet我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？ 在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 12345678910111213141516171819202122232425262728import java.util.LinkedHashSet;public class HashSetTest2 &#123; public static void main(String[] args) &#123; // 1. 创建一个 set 集合 LinkedHashSet&lt;Student&gt; set = new LinkedHashSet&lt;&gt;(); // 2. 添加元素 set.add(new Student("刘德华", 18)); set.add(new Student("张学友", 22)); set.add(new Student("黎明", 19)); set.add(new Student("郭富城", 20)); set.add(new Student("刘德华", 18)); set.add(new Student("张学友", 22)); // 3. 遍历集合 for (Student stu : set) &#123; System.out.println(stu); &#125; &#125;&#125;输出结果：Student&#123;name='刘德华', age=18&#125;Student&#123;name='张学友', age=22&#125;Student&#123;name='黎明', age=19&#125;Student&#123;name='郭富城', age=20&#125; 1.9 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。 JDK1.5以后。出现了简化操作。… 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。 代码演示： 123456789101112131415161718192021222324252627282930313233343536public class VariableArgumentsTest1 &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123;10, 20, 30, 40, 50, 60, 70, 80, 90&#125;; int sum = getSum(arr); System.out.println("sum = " + sum); // 需求 : 能不能传递参数 ??? // 说明 : getSum 方法需要接收一个 `引用类型参数 / 数组就是引用类型参数`. 不可以传递基本数据类型. int sum2 = getSum(10, 20, 30, 40, 50, 60, 70, 80, 90); System.out.println("sum2 = " + sum2); &#125; // 需求 : 定义一个方法, 求多个元素数值的累加和 // 请问 : 是不是参数不知道是几个 int 类型, 不知道的话, 请写 : ... // 说明 : 可变参数底层就是数组. 传递参数时, 可变参数比数组更加灵活. // 注意点 : 可变参数必须位于参数列表的 `最后一位`. public static int getSum(int... array) &#123; int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; sum += array[i]; &#125; return sum; &#125; /*public static int getSum(int[] array) &#123; int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; sum += array[i]; &#125; return sum; &#125;*/&#125;输出结果 :sum = 450sum2 = 450 tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 第五章 Collections2.1 常用功能 java.utils.Collections是集合工具类，用来对集合进行操作。部分方法如下： public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中添加一些元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 代码演示： 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;public class CollectionsTest1 &#123; public static void main(String[] args) &#123; // Collections 集合工具类 : // 1. addAll(Collection集合对象, 可变参数); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); /* list.add(55); list.add(45); list.add(88); */ // 含义 : 将所有可变参数中的元素添加指定的集合中. Collections.addAll(list, 55, 45, 88, 66, 98, 12, 36, 76); System.out.println("list = " + list); // shuffle 将集合中的元素进行随机置换 // Collections.shuffle(list); // sort 排序 (升序, 数值的自然排序) Collections.sort(list); System.out.println("list = " + list); &#125;&#125;输出结果：list = [55, 45, 88, 66, 98, 12, 36, 76]list = [12, 36, 45, 55, 66, 76, 88, 98] 代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？ 我们发现还有个方法没有讲，public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。 2.2 Comparator比较器我们还是先研究这个方法 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 不过这次存储的是字符串类型。 12345678910111213141516import java.util.ArrayList;import java.util.Collections;public class CollectionsTest2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, "abc", "xyz", "ABC", "sss", "SSS"); Collections.sort(list); // 查看 System.out.println("list = " + list); // ["ABC", "SSS", "abc", "sss", "xyz"] &#125;&#125; 结果： 1list = [ABC, SSS, abc, sss, xyz] 我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？ 说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; 字符串的比较规则说明 : 123456789101112131415161718192021222324public class StringComparableTest3 &#123; public static void main(String[] args) &#123; // Comparable 自然比较规则 : (String, Integer ... 都实现了该接口, 因为 Integer, String 对象就可以完成比较) 从而实现排序. // int compareTo(T o) 将此对象与指定的对象进行比较以进行排序。 // 请问 : 为什么 compareTo 方法返回 int 类型结果 ??? // 字符串是一个字符一个字符进行比较, 一旦有结果, 立刻返回, 之后的所有字符否不再比较. /* 0 表示比较的两个对象相等. 正数 调用对象比传入对象大. 负数 调用对象比传入对象小. */ String str1 = "abcd"; // 97 String str2 = "Abcd"; // 65 int result = str1.compareTo(str2); System.out.println("result = " + result); &#125;&#125;输出结果 :result = 32 String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class StringSortTest5 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("Peter"); list.add("Jim"); list.add("Ann"); list.add("Angel Baby"); list.add("Michel Jackson"); list.add("JK"); list.add("Tom"); list.add("Jerry"); // 排序 // Collections.sort(list); // 自然排序 // 需求 : 从字符串的 `短 -&gt; 长` 进行排序. // 问题 : 修改 String 类的比较规则. 如何使用呢 ??? // static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 根据指定的比较器引起的顺序对指定的列表进行排序。 // 请问 : 如果一个参数类型为 `接口类型`, 其真正需要的是什么 ??? 该接口的实现类对象. // Comparator 比较器排序规则接口. 如果一个类已经存在了 `自然比较规则`, 那么我们可以使用 `比较器规则` 修改自然规则. Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // 需求 : 根据字符串的长短实现排序 int result = o1.length() - o2.length(); if (result == 0) &#123; result = o1.compareTo(o2); &#125; return result; &#125; &#125;); for (String name : list) &#123; System.out.println(name); &#125; &#125;&#125; 结果如下： 12345678JKAnnJimTomJerryPeterAngel BabyMichel Jackson 2.3 简述Comparable和Comparator两个接口的区别。Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 2.4 练习创建一个学生类，存储到ArrayList集合中完成指定排序操作。 Student 初始类 123456789101112131415161718192021222324252627282930313233public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 测试类： 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Collections;public class CollectionsSortStudentTest4 &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); // 存储学生对象 list.add(new Student("Jack", 18)); list.add(new Student("Rose", 16)); list.add(new Student("Peter", 20)); list.add(new Student("Lucy", 19)); list.add(new Student("Ann", 18)); list.add(new Student("Lindi", 16)); list.add(new Student("Michel", 20)); list.add(new Student("Mark", 19)); // 排序 : // &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) // 解释 : List 集合中的 T 类型必须继承 Comparable 接口. // T 类型为 Student, 请问 : Student 类是 Comparable 接口的实现类吗 ??? 不是, 无法排序. // 解决方法 : Student implements Comparable 接口. 并重写 compareTo 抽象方法. Collections.sort(list); // System.out.println("list = " + list); for (Student stu : list) &#123; System.out.println(stu); &#125; &#125;&#125; 发现，当我们调用Collections.sort()方法的时候 程序报错了。 原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。 于是我们就完成了Student类的一个实现，如下： 123456789101112131415161718192021public class Student implements Comparable&lt;Student&gt; &#123; ...... @Override public int compareTo(Student o) &#123; // 自定义 Student 类的自然比较规则. // 1. 先按年龄比较 int result = this.age - o.age; // 18 - 16 -&gt; 2 // 2. 如果年龄相同, 再按照姓名进行自然排序. (姓名: String, 该类已经实现了 Comparable 接口) if (result == 0) &#123; // 这里直接调用 String 类的自然比较规则. 重新赋值 result result = this.name.compareTo(o.name); &#125; // 3. 返回比较后的结果 return result; &#125;&#125; 再次测试，代码就OK 了效果如下： 12345678Student&#123;name='Lindi', age=16&#125;Student&#123;name='Rose', age=16&#125;Student&#123;name='Ann', age=18&#125;Student&#123;name='Jack', age=18&#125;Student&#123;name='Lucy', age=19&#125;Student&#123;name='Mark', age=19&#125;Student&#123;name='Michel', age=20&#125;Student&#123;name='Peter', age=20&#125; Comparator 比较器规则实现 : Student 123456789101112131415161718192021222324252627282930313233public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 比较器代码实现 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class ComparatorTest1 &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); // 存储学生对象 list.add(new Student("Jack", 18)); list.add(new Student("Rose", 16)); list.add(new Student("Peter", 20)); list.add(new Student("Lucy", 19)); list.add(new Student("Ann", 18)); list.add(new Student("Lindi", 16)); list.add(new Student("Michel", 20)); list.add(new Student("Mark", 19)); // 比较自定义对象, 可以选择 `自然排序 Comparable`, 同样, 也可以选择 `比较器排序 Comparator`. Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; // 年龄 (升序) // int result = o1.getAge() - o2.getAge(); // 年龄 (降序) int result = o2.getAge() - o1.getAge(); if (result == 0) &#123; // 姓名 (升序) result = -o1.getName().compareTo(o2.getName()); // 姓名 (降序) // result = -o1.getName().compareTo(o2.getName()); &#125; return result; &#125; &#125;); for (Student stu : list) &#123; System.out.println(stu); &#125; &#125;&#125;输出结果 :Student&#123;name='Peter', age=20&#125;Student&#123;name='Michel', age=20&#125;Student&#123;name='Mark', age=19&#125;Student&#123;name='Lucy', age=19&#125;Student&#123;name='Jack', age=18&#125;Student&#123;name='Ann', age=18&#125;Student&#123;name='Rose', age=16&#125;Student&#123;name='Lindi', age=16&#125; 练习题练习一：List接口的特点请简述List接口的特点。 1234（1）它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。 那么集合中，元素的存储就是按照11、22、33的顺序完成的）。（2）它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。（3）集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 练习二：hashCode和equals方法请简述HashSet去除重复元素的原理。 12345（1）调用被添加元素的hashCode()，和HashSet中已有元素的hashCode比较是否相同（2）如果不相同，直接存储（3）如果相同，调用equals方法比较是否相同（4）不相同，直接存储元素（5）相同，认为是同一元素.不存储 练习三：数据结构简述常见的数据结构中元素的存取特点。 123456789101112131415161718栈：stack，又称堆栈，对元素的存取特点是：先进后出。 即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素。队列：queue，简称队，对元素的存取特点是：先进先出。 即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素。数组:Array，是有序的元素序列，对元素的存取特点是： 1、查找元素快：通过索引，可以快速访问指定位置的元素 2、增删元素慢 （1）指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置， 再把原数组元素根据索引，复制到新数组对应索引的位置。 （2）指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引， 复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。链表:linked list，对元素的存取有如下的特点： 1、多个结点之间，通过地址进行连接。例如，多个人手拉手， 每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 2、查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。 3、增删元素快： 增加元素：只需要修改连接下个元素的地址即可。 删除元素：只需要修改连接下个元素的地址即可。 练习四：Comparable和Comparator比较器简述Comparable和Comparator两个接口的区别。 Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator：强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。 练习五：LinkedList方法的使用根据要求练习LinkedList方法： （1）基本方法：add, set, get, remove, clear, size等方法； （2）特有方法：addFirst, addLast, getFirst, getLast, removeFirst, removeLast, push, pop, clear等方法。 基本方法： 123456789101112131415161718192021222324252627282930313233343536public class LinkedListTest01 &#123; public static void main(String[] args) &#123; // 1.创建LinkedList LinkedList&lt;String&gt; arr = new LinkedList&lt;String&gt;(); // 2.使用add方法添加元素 arr.add("西门吹雪"); arr.add("西门吹雪"); arr.add("西门吹雪"); arr.add("西门吹风"); arr.add("西门吹水"); // 3.使用add方法在指定索引添加元素 arr.add(2, "西门吹雨"); // 4.使用set方法修改指定位置索引 arr.set(0, "东门"); for (String str : arr) &#123; System.out.println(str); &#125; System.out.println("--------------"); // 5.使用get方法获取指定索引的元素 System.out.println(arr.get(1)); // 6.使用size方法获取集合大小 System.out.println(arr.size()); // 7.使用remove方法删除指定索引的元素 arr.remove(3); // 8.使用clear清空集合中的元素 arr.clear(); System.out.println(arr); &#125;&#125; 特有方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LinkedListTest02 &#123; public static void main(String[] args) &#123; // 1.创建LinkedList LinkedList&lt;String&gt; linked = new LinkedList&lt;String&gt;(); // 2.使用add方法添加元素 linked.add("周杰伦"); linked.add("周星驰"); linked.add("周华健"); linked.add("周润发"); // 3.使用addFirst添加元素到集合最前面 linked.addFirst("周传雄"); // 4.使用addLast添加元素到集合最后面 linked.addLast("周渝民"); System.out.println(linked); // 5.使用getFirst获取集合第一个元素 System.out.println(linked.getFirst()); // 6.使用getLast获取集合最后一个元素 System.out.println(linked.getLast()); // 7.使用removeLast删除集合第一个元素 String first = linked.removeFirst(); System.out.println(first); // 8.使用removeLast删除集合最后一个元素 String last = linked.removeLast(); System.out.println(last); System.out.println(linked); // 9.使用pop弹出第一个元素 String p = linked.pop(); System.out.println(p); // 10.使用push在集合开头插入元素 linked.push("周立波"); System.out.println(linked); // 11.使用clear清空集合 linked.clear(); System.out.println(linked); &#125;&#125; 练习六：HashSet存储自定义类型定义人类，包含姓名和年龄属性。创建4个人存储到HashSet中，姓名和年龄相同的人看做同一人不存储。 Person类: 123456789101112131415161718192021222324252627282930313233343536373839// 1.定义Person类.包好姓名年龄属性,重写hashCode()和equals()方法public class Person &#123; private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Person)) return false; Person person = (Person) o; if (age != person.age) return false; return name != null ? name.equals(person.name) : person.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试类: 12345678910111213141516171819public class HashSetTest01 &#123; public static void main(String[] args) &#123; // 2.创建HashSet用于存储Person类型 HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;(); // 3.添加多个Person到HashSet中 hashSet.add(new Person("王昭君", 21)); hashSet.add(new Person("西施", 21)); hashSet.add(new Person("杨玉环", 20)); hashSet.add(new Person("貂蝉", 19)); hashSet.add(new Person("杨玉环", 20)); hashSet.add(new Person("貂蝉", 19)); // 4.遍历获取HashSet中的内容 for (Person p : hashSet) &#123; System.out.println(p); &#125; &#125;&#125; 练习七：List集合元素替换向list集合添加姓名{张三,李四,王五,二丫,钱六,孙七},将二丫替换为王小丫。 12345678910111213141516171819202122232425public class ListTest01 &#123; public static void main(String[] args) &#123; //1.创建List集合对象 List&lt;String&gt; list = new ArrayList&lt;&gt;(); //2.存入数据 list.add("张三"); list.add("李四"); list.add("王五"); list.add("二丫"); list.add("钱六"); list.add("孙七"); //3.遍历集合，找到"二丫",便将其替换为"王小丫" //利用普通for循环遍历List集合 for(int i = 0;i&lt;list.size();i++) &#123; //获取当前元素 String thisName = list.get(i); //如果当前元素是"二丫" if("二丫".equals(thisName)) &#123; //将其改为"王小丫" list.set(i, "王小丫"); &#125; &#125; System.out.println(list); &#125;&#125; 练习八：LinkedHashSet基本使用使用LinkedHashSet存储以下元素：”王昭君”,”王昭君”,”西施”,”杨玉环”,”貂蝉”。使用迭代器和增强for循环遍历LinkedHashSet。 1234567891011121314151617181920212223242526public class LinkedHashSetTest01 &#123; public static void main(String[] args) &#123; // 1.创建LinkedHashSet LinkedHashSet&lt;String&gt; lhSet = new LinkedHashSet&lt;String&gt;(); // 2.使用add方法添加元素到LinkedHashSet lhSet.add("王昭君"); lhSet.add("王昭君"); lhSet.add("王昭君"); lhSet.add("西施"); lhSet.add("杨玉环"); lhSet.add("貂蝉"); // 3.使用迭代器获取LinkedHashSet中的元素 Iterator&lt;String&gt; iterator = lhSet.iterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; // 4.使用增强for获取LinkedHashSet中的元素 System.out.println("---------------------"); for (String string : lhSet) &#123; System.out.println(string); &#125; &#125;&#125; 练习九：Collections工具类使用ArrayList集合中有如下内容： {33,11,77,55}，使用Collections.sort()对ArrayList集合中的数据进行排序，并打印出排序后的结果。 1234567891011121314151617181920public class CollectionsTest01 &#123; public static void main(String[] args) &#123; // 1.创建ArrayList ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); // 2.使用add方法添加&#123;33,11,77,55&#125;四个元素 arr.add(33); arr.add(11); arr.add(77); arr.add(55); // 3.调用Collections的sort方法,对集合排序 Collections.sort(arr); // 4.使用增强for遍历ArrayList集合 for (Integer integer : arr) &#123; System.out.println(integer); &#125; &#125;&#125; 练习十：LinkedList使用已知数组存放一批QQ号码，QQ号码最长为11位，最短为5位。 String[] strs = {&quot;12345&quot;,&quot;67891&quot;,&quot;12347809933&quot;,&quot;98765432102&quot;,&quot;67891&quot;,&quot;12347809933&quot;}。 将该数组里面的所有qq号都存放在LinkedList中，将list中重复元素删除，将list中所有元素分别用迭代器和增强for循环打印出来。 12345678910111213141516171819202122232425262728293031public class LinkedListTest03 &#123; public static void main(String[] args) &#123; // 1.定义QQ号码数组String[] strs = &#123;"12345","67891",1"2347809933","98765432102","67891","12347809933"&#125; String[] strs = &#123; "12345", "67891", "2347809933", "98765432102", "67891", "12347809933" &#125;; // 2.创建LinkedList LinkedList&lt;String&gt; qqList = new LinkedList&lt;&gt;(); // 3.遍历strs获取每个qq号码 for (String qq : strs) &#123; // 4.判断LinkedList是否已经存在这个qq号码 if (!qqList.contains(qq)) &#123; // 5.不存在这个qq号码则添加到LinkedList中 qqList.add(qq); &#125; &#125; // 6.增强for遍历 for (String qq : qqList) &#123; System.out.println(qq); &#125; System.out.println("------------------"); // 7.迭代器遍历 Iterator&lt;String&gt; iterator = qqList.iterator(); while (iterator.hasNext()) &#123; String string = iterator.next(); System.out.println(string); &#125; &#125;&#125; 练习十一：LinkedHashSet的使用键盘录入一个字符串，去掉其中重复字符，打印出不同的那些字符，必须保证顺序。 例如输入：aaaabbbcccddd，打印结果为：abcd。 12345678910111213141516171819202122232425262728public class LinkedHashSetTest02 &#123; public static void main(String[] args) &#123; // 1.创建Scanner对象,用于键盘录入 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串"); // 2.调用Scanner的nextLine()方法,让用户输入一个字符串 String line = sc.nextLine(); // 3.创建LinkedHashSet.用于去除重复的字符串,并保证迭代顺序 LinkedHashSet&lt;Character&gt; chs = new LinkedHashSet&lt;&gt;(); // 4.将字符串串转成char[] char[] charArray = line.toCharArray(); // 5.使用增强for循环遍历每个字符 for (char c : charArray) &#123; // 6.将每个字符添加到LinkedHashSet中 chs.add(c); &#125; // 7.使用增强for打印LinkedHashSet中的内容 for (char c : chs) &#123; System.out.print(c); &#125; &#125;&#125; 练习十二：HashSet的使用双色球规则：双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。红色球号码从1—33中选择；蓝色球号码从1—16中选择；请随机生成一注双色球号码。（要求同色号码不重复） 123456789101112131415161718192021222324252627282930public class HashSetTest02 &#123; public static void main(String[] args) &#123; // 1.创建Random随机数对象 Random ran = new Random(); // 2.创建HashSet用于保存不重复的红球 HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;(); // 3.循环判断红球数量是否小于6个 while (hs.size() &lt; 6) &#123; // 4.球数量小于6个就产生一个红球.添加到HashSet中 // 5.如果产生重复号码，往HashSet里添加不进去，所以会再次生成号码 int num = ran.nextInt(33) + 1; hs.add(num); &#125; // 6.再生成一个篮球 int blueBall = ran.nextInt(16) + 1; // 7.打印中奖号码 System.out.println("双色球中奖号码:"); System.out.print("红球是: "); for (Integer redBall : hs) &#123; System.out.print(redBall + " "); &#125; System.out.println(); System.out.println("蓝球是: " + blueBall); &#125;&#125; 练习十三：Comparable和Comparator两个接口的使用分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序，如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。 姓名（String） 年龄（int） 分数（float） liusan 20 90.0F lisi 22 90.0F wangwu 20 99.0F sunliu 22 100.0F （1）Comparable Student 类: 12345678910111213141516171819202122232425262728293031323334public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; private float score; public Student(String name, int age, float score) &#123; this.name = name; this.age = age; this.score = score; &#125; public String toString() &#123; return name+"\t\t"+age+"\t\t"+score; &#125; @Override public int compareTo(Student o) &#123; if(this.score&gt;o.score)&#123; //由高到底排序 return -1; &#125;else if(this.score&lt;o.score) &#123; return 1; &#125;else&#123; if(this.age&gt;o.age) &#123; //由底到高排序 return 1; &#125;else if(this.age&lt;o.age) &#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125;&#125; 测试类: 123456789101112public class ComparableTest &#123; public static void main(String[] args) &#123; Student stu[]=&#123;new Student("liusan",20,90.0f), new Student("lisi",22,90.0f), new Student("wangwu",20,99.0f), new Student("sunliu",22,100.0f)&#125;; java.util.Arrays.sort(stu); for(Student s:stu)&#123; System.out.println(s); &#125; &#125;&#125; （2）Comparator Student 类: 12345678910111213141516171819202122232425262728293031323334public class Student &#123; private String name; private int age; private float score; public Student(String name, int age, float score) &#123; this.name = name; this.age = age; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public float getScore() &#123; return score; &#125; public void setScore(float score) &#123; this.score = score; &#125; public String toString() &#123; return name+"\t\t"+age+"\t\t"+score; &#125;&#125; Comparator比较器: 123456789101112131415161718public class StudentComparator implements Comparator&lt;Student&gt; &#123; @Override public int compare(Student o1, Student o2) &#123; if(o1.getScore()&gt;o2.getScore()) &#123; return -1; &#125;else if(o1.getScore()&lt;o2.getScore()) &#123; return 1; &#125;else&#123; if(o1.getAge() &gt; o2.getAge()) &#123; return 1; &#125;else if(o1.getAge() &lt; o2.getAge()) &#123; return -1; &#125;else&#123; return 0; &#125; &#125; &#125;&#125; 测试类: 123456789101112public class ComparatorTest &#123; public static void main(String[] args) &#123; Student stu[]=&#123;new Student("liusan",20,90.0f), new Student("lisi",22,90.0f), new Student("wangwu",20,99.0f), new Student("sunliu",22,100.0f)&#125;; java.util.Arrays.sort(stu,new StudentComparator()); for(Student s:stu) &#123; System.out.println(s); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶02-Collection类和泛型]]></title>
    <url>%2F2019%2F08%2F20%2F2019-08-20-Java%E8%BF%9B%E9%98%B602-Collection%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[主要内容 Collection集合 迭代器 增强for 泛型 学习目标 能够说出集合与数组的区别 说出Collection集合的常用功能 能够使用迭代器对集合进行取元素 能够说出集合的使用细节 能够使用集合存储自定义类型 能够使用foreach循环遍历集合 能够使用泛型定义集合对象 能够理解泛型上下限 能够阐述泛型通配符的作用 第一章 Collection集合1.1 集合概述在前面基础班我们已经学习过并使用过集合ArrayList&lt;E&gt; ,那么集合到底是什么呢? 集合：集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组既然都是容器，它们有啥区别呢？ 数组的长度是固定的。集合的长度是可变的。 数组列表(ArrayList)集合就是 可变数组 Object[] 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 1.2 集合框架JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map，今天我们主要学习Collection集合，在day04时讲解Map集合。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。 其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。 集合本身是一个工具，它存放在java.util包中。在Collection接口定义着单列集合框架中最最共性的内容。 1.3 Collection 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 方法演示： 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Collection;public class Demo1Collection &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add("小李广"); coll.add("扫地僧"); coll.add("石破天"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 扫地僧 是否在集合中"+coll.contains("扫地僧")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除石破天："+coll.remove("石破天")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。 第二章 Iterator迭代器2.1 Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口java.util.Iterator。Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的。 下面介绍一下迭代的概念： 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 接下来我们通过案例学习如何使用Iterator迭代集合中元素： 12345678910111213141516171819public class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("串串星人"); coll.add("吐槽星人"); coll.add("汪星人"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 2.2 迭代器的实现原理我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程： 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 2.3 Iterator迭代集合的两个注意点 :注意1 : 迭代时, 一个 hasNext() 不要对应多个 next() 方法一起使用. 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class Test1 &#123; public static void main(String[] args) &#123; // 1. 多态 : 接口类型接收该接口的实现类对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); // 2. 添加元素 c.add("刘德华"); c.add("张学友"); c.add("黎明"); c.add("郭富城"); c.add("郭德纲"); // 3. 迭代集合 Iterator&lt;String&gt; it = c.iterator(); while (it.hasNext()) &#123; String name = it.next(); System.out.println(it.next()); &#125; &#125;&#125;输出结果 :Exception in thread "main" java.util.NoSuchElementException张学友郭富城 at java.base/java.util.ArrayList$Itr.next(ArrayList.java:896) at cn.itcast.test1.Test1.main(Test1.java:24) 注意2 : 迭代器迭代元素的同时, 不要使用集合对象对元素进行 增删改 操作. 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class Test1 &#123; public static void main(String[] args) &#123; // 1. 多态 : 接口类型接收该接口的实现类对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); // 2. 添加元素 c.add("刘德华"); c.add("张学友"); c.add("黎明"); c.add("郭富城"); c.add("郭德纲"); // 3. 迭代集合 Iterator&lt;String&gt; it = c.iterator(); while (it.hasNext()) &#123; String name = it.next(); // 删除 `郭德纲` if ("郭德纲".equals(name)) &#123; c.remove(name); &#125; &#125; &#125;&#125;输出结果 :Exception in thread "main" java.util.ConcurrentModificationException at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:939) at java.base/java.util.ArrayList$Itr.next(ArrayList.java:893) at cn.itcast.test1.Test1.main(Test1.java:23) 解决方案 : Iterator接口的删除方法如下： default void remove():从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class Test1 &#123; public static void main(String[] args) &#123; // 1. 多态 : 接口类型接收该接口的实现类对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); // 2. 添加元素 c.add("刘德华"); c.add("张学友"); c.add("黎明"); c.add("郭富城"); c.add("郭德纲"); // 3. 迭代集合 Iterator&lt;String&gt; it = c.iterator(); while (it.hasNext()) &#123; String name = it.next(); // 删除 `郭德纲` if ("郭德纲".equals(name)) &#123; // c.remove(name); it.remove(); &#125; &#125; System.out.println("c = " + c); &#125;&#125;输出结果 :c = [刘德华, 张学友, 黎明, 郭富城] 2.4 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 练习1：遍历数组123456789public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125; 练习2:遍历集合123456789101112public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("小河神"); coll.add("老河神"); coll.add("神婆"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。 第三章 泛型3.1 泛型概述在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。 大家观察下面代码： 1234567891011121314public class GenericDemo &#123; public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add("abc"); coll.add("itcast"); coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放 Iterator it = coll.iterator(); while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length()); &#125; &#125;&#125; 程序在运行时发生了问题java.lang.ClassCastException。 为什么会发生类型转换异常呢？ 我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。 怎么来解决这个问题呢？ Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了泛型(Generic)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 3.2 使用泛型的好处上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？ 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 123456789101112131415public class GenericDemo2 &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc"); list.add("itcast"); // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错 // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型 System.out.println(str.length()); &#125; &#125;&#125; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 3.3 泛型的定义与使用我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。 泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。 定义和使用含有泛型的类定义格式： 1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型 例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 此时，变量E的值就是String类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;&#123; public boolean add(String e)&#123; &#125; public String get(int index)&#123; &#125; ...&#125; 再例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量E的值就是Integer类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; &#123; public boolean add(Integer e) &#123; &#125; public Integer get(int index) &#123; &#125; ...&#125; 举例自定义泛型类 1234567891011121314public class GenericClass&lt;T&gt; &#123; // 属性 : private T t; // 行为 : public T getT() &#123; return t; &#125; public void setT(T t) &#123; this.t = t; &#125;&#125; 使用: 1234567891011121314151617181920public class Test4 &#123; public static void main(String[] args) &#123; // 1. 定义泛型类的泛型为 String 类型 GenericClass&lt;String&gt; g1 = new GenericClass&lt;&gt;(); g1.setT("hello world."); String str = g1.getT(); System.out.println("str = " + str); // 2. 定义泛型类的泛型为 Integer 类型 GenericClass&lt;Integer&gt; g2 = new GenericClass&lt;&gt;(); g2.setT(998); Integer number = g2.getT(); System.out.println("number = " + number); &#125;&#125;输出结果 :str = hello world.number = 998 含有泛型的方法定义格式： 1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789101112public class GenericMethod &#123; // 泛型作为方法的参数 : public &lt;T&gt; void show(T t) &#123; System.out.println("t = " + t + ", t.getClass() = " + t.getClass()); &#125; // 泛型作为方法的返回值类型 : public &lt;T&gt; T show2(T t) &#123; return t; &#125;&#125; 使用格式：调用方法时，确定泛型的类型 123456789101112131415161718public class Test3 &#123; public static void main(String[] args) &#123; // 1. 创建一个对象 GenericMethod method = new GenericMethod(); // 2. 调用泛型参数方法 method.show("hello world."); // 3. 调用泛型返回值方法 Integer result = method.show2(998); System.out.println("result = " + result); &#125;&#125;输出结果 :t = hello world., t.getClass() = class java.lang.Stringresult = 998 含有泛型的接口定义格式： 1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345678public interface GenericInterface&lt;T&gt; &#123; // 泛型作为方法参数 void add(T t); // 泛型作为方法的返回值 T get();&#125; 使用格式： 1、定义类时确定泛型的类型 例如 12345678910111213public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt; &#123; // 方法参数类型为 String @Override public String get() &#123; return null; &#125; // 方法返回值类型为 String @Override public void add(String s) &#123; &#125;&#125; 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011121314public class GenericInterfaceImpl2&lt;T&gt; implements GenericInterface&lt;T&gt; &#123; // 方法参数依然是泛型 @Override public T get() &#123; return null; &#125; // 方法返回值依然是泛型 @Override public void add(T t) &#123; &#125;&#125; 确定泛型： 12345678910public class Test5 &#123; public static void main(String[] args) &#123; // 1. 确定了 `类和接口` 的泛型都为 String 类型. GenericInterfaceImpl2&lt;String&gt; g1 = new GenericInterfaceImpl2&lt;&gt;(); // 2. 确定了 `类和接口` 的泛型都为 Integer 类型. GenericInterfaceImpl2&lt;Integer&gt; g2 = new GenericInterfaceImpl2&lt;&gt;(); &#125;&#125; 3.4 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Collection;public class Test &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); c.add("刘德华"); c.add("张学友"); c.add("黎明"); c.add("郭富城"); printCollection(c); System.out.println("------------------"); Collection&lt;Integer&gt; c2 = new ArrayList&lt;&gt;(); c2.add(10); c2.add(20); c2.add(30); c2.add(40); printCollection(c2); &#125; // 定义方法 : 将 Collection 的泛型定义为 `通配符` 类型 public static void printCollection(Collection&lt;?&gt; c) &#123; for (Object obj : c) &#123; System.out.println(obj); &#125; &#125;&#125;输出结果 :刘德华张学友黎明郭富城------------------10203040 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.Collection;public class Test2 &#123; public static void main(String[] args) &#123; Collection&lt;Person&gt; c = new ArrayList&lt;&gt;(); printCollection(c); Collection&lt;Student&gt; c2 = new ArrayList&lt;&gt;(); printCollection(c2); Collection&lt;String&gt; c3 = new ArrayList&lt;&gt;(); // printCollection(c3); 错误! &#125; // 定义方法 : 将 Collection 的泛型定义为 `通配符` 类型 // 类型可以为 Person, 和 Person 的子类类型. public static void printCollection(Collection&lt;? extends Person&gt; c) &#123; for (Person p : c) &#123; System.out.println(p); &#125; &#125;&#125;public class Person &#123;&#125;public class Student extends Person &#123;&#125; 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.Collection;public class Test3 &#123; public static void main(String[] args) &#123; Collection&lt;ArmyDog&gt; c = new ArrayList&lt;&gt;(); printCollection(c); Collection&lt;Dog&gt; c2 = new ArrayList&lt;&gt;(); printCollection(c2); Collection&lt;Animal&gt; c3 = new ArrayList&lt;&gt;(); printCollection(c3); Collection&lt;Cat&gt; c4 = new ArrayList&lt;&gt;(); // printCollection(c4); 报错! &#125; // 定义方法 : 将 Collection 的泛型定义为 `通配符` 类型 // 类型可以为 ArmyDog 和 ArmyDog 的父类类型. public static void printCollection(Collection&lt;? super ArmyDog&gt; c) &#123; for (Object obj : c) &#123; System.out.println(obj); &#125; &#125;&#125;class Animal &#123; &#125;class Dog extends Animal &#123; &#125;class Cat extends Animal &#123; &#125;class ArmyDog extends Dog &#123; &#125; 第四章 集合综合案例4.1 案例介绍按照斗地主的规则，完成洗牌发牌的动作。具体规则： 使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。 4.2 案例分析 准备牌： 牌可以设计为一个ArrayList&lt;String&gt;,每个字符串为一张牌。每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。牌由Collections类的shuffle方法进行随机排序。 发牌 将每个人以及底牌设计为ArrayList,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。 看牌 直接打印每个集合。 4.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.ArrayList;import java.util.Collections;public class Poker &#123; public static void main(String[] args) &#123; /* * 1: 准备牌操作 */ //1.1 创建牌盒 将来存储牌面的 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;(); //1.2 创建花色集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); //1.3 创建数字集合 ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); //1.4 分别给花色 以及 数字集合添加元素 colors.add("♥"); colors.add("♦"); colors.add("♠"); colors.add("♣"); for(int i = 2; i &lt;= 10; i++)&#123; numbers.add(i + ""); &#125; numbers.add("J"); numbers.add("Q"); numbers.add("K"); numbers.add("A"); //1.5 创造牌 拼接牌操作 // 拿出每一个花色 然后跟每一个数字 进行结合 存储到牌盒中 for (String color : colors) &#123; //color每一个花色 //遍历数字集合 for(String number : numbers)&#123; //结合 String card = number + color; //存储到牌盒中 pokerBox.add(card); &#125; &#125; //1.6大王小王 pokerBox.add("小☺"); pokerBox.add("大☠"); // System.out.println(pokerBox); //洗牌 是不是就是将 牌盒中 牌的索引打乱 // Collections类 工具类 都是 静态方法 // shuffer方法 /* * static void shuffle(List&lt;?&gt; list) * 使用默认随机源对指定列表进行置换。 */ //2:洗牌 Collections.shuffle(pokerBox); //3 发牌 //3.1 创建 三个 玩家集合 创建一个底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); //遍历 牌盒 必须知道索引 for(int i = 0; i &lt; pokerBox.size(); i++)&#123; //获取 牌面 String card = pokerBox.get(i); //留出三张底牌 存到 底牌集合中 if(i &gt;= 51)&#123;//存到底牌集合中 dipai.add(card); &#125; else &#123; //玩家1 %3 ==0 if(i % 3 == 0)&#123; player1.add(card); &#125;else if(i % 3 == 1)&#123;//玩家2 player2.add(card); &#125;else&#123;//玩家3 player3.add(card); &#125; &#125; &#125; //看牌 System.out.println("令狐冲：" + player1); System.out.println("田伯光：" + player2); System.out.println("绿竹翁：" + player3); System.out.println("底牌：" + dipai); &#125;&#125;输出结果 :令狐冲：[10♠, 10♥, Q♥, 7♦, K♠, J♥, 8♠, A♦, 6♣, 8♣, A♣, K♣, 6♥, 3♥, 3♦, 5♦, 10♣]田伯光：[8♥, 8♦, 3♣, 9♠, 2♥, 7♣, J♠, 4♦, 9♥, 5♣, 9♣, 6♠, 2♦, 3♠, 4♠, 大☠, 6♦]绿竹翁：[2♣, Q♦, Q♣, K♦, 4♥, 5♠, K♥, 7♥, J♣, A♠, 2♠, 4♣, 小☺, J♦, Q♠, 7♠, A♥]底牌：[5♥, 10♦, 9♦] 练习题练习一：集合框架请简述集合框架。 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map。 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。其中，List的特点是元素有序、元素可重复。Set的特点是元素无序，而且不可重复。List接口的主要实现类有java.util.ArrayList和java.util.LinkedList，Set接口的主要实现类有java.util.HashSet和java.util.TreeSet。 练习二：Collection集合统计元素出现次数给定以下代码，请定义方法listTest()统计集合中指定元素出现的次数，如&quot;a&quot;: 2,&quot;b&quot;: 2,&quot;c&quot; :1, &quot;xxx&quot;:0。 12345678910Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("a"); list.add("b"); list.add("b"); list.add("c"); System.out.println("a:"+listTest(list, "a")); System.out.println("b:"+listTest(list, "b")); System.out.println("c:"+listTest(list, "c")); System.out.println("xxx:"+listTest(list, "xxx")); 1234567891011121314151617181920212223242526272829public class CollectionTest01&#123; public static void main(String[] args) &#123; Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("a"); list.add("a"); list.add("b"); list.add("b"); list.add("c"); System.out.println("a:"+listTest(list, "a")); System.out.println("b:"+listTest(list, "b")); System.out.println("c:"+listTest(list, "c")); System.out.println("xxx:"+listTest(list, "xxx")); &#125; //定义方法统计集合中指定元素出现的次数 public static int listTest(Collection&lt;String&gt; list,String s)&#123; //定义计数器，初始化为0 int count = 0; //增强for遍历集合 for (String string : list) &#123; //判断传入方法的字符与遍历集合的是否一致 if (s.equals(string)) &#123; //如果一致，加1 count++; &#125; &#125; return count; &#125;&#125; 练习三：Collection集合 数组转集合定义一个方法，要求此方法把int数组转成存有相同元素的集合(集合里面的元素是Integer)，并返回。 123456789101112131415161718public class CollectionTest02 &#123; public static void main(String[] args) &#123; //定义int数组 int[] arr = &#123;1,2,3,4,5&#125;; ArrayList&lt;Integer&gt; list = listTest(arr); System.out.println(list); &#125; public static ArrayList&lt;Integer&gt; listTest(int[] arr) &#123; //定义集合 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //遍历数组，把元素依次添加到集合当中 for (int a : arr) &#123; list.add(a); &#125; return list; &#125;&#125; 练习四：Collection集合 集合转数组定义一个集合，并把集合(集合里面的元素是Integer)转成存有相同元素的数组，并将结果输出在控制台。（可以使用Object[]数组类型接收转换的数组） 123456789101112131415public class CollectionTest03 &#123; public static void main(String[] args) &#123; //定义集合,添加数据 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(100); list.add(200); list.add(300); //Object[] toArray()转换成一个Object数组 Object[] obj = list.toArray(); // 遍历数组 for (int i = 0; i &lt; obj.length; i++) &#123; System.out.println(obj[i]); &#125; &#125;&#125; 练习五：Collection集合contains()方法使用定义一个方法listTest(ArrayList&lt;String&gt; al, String s),要求使用contains()方法判断al集合里面是否包含s。 123456789101112131415161718public class CollectionTest04 &#123; public static void main(String[] args) &#123; //定义集合，添加数据 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("itcast"); list.add("itheima"); list.add("java"); System.out.println(listTest(list,"java")); &#125; public static boolean listTest(ArrayList&lt;String&gt; al, String s) &#123; //判断s是否在集合中存在,存在返回true，不存在返回false if (al.contains(s)) &#123; return true; &#125; return false; &#125;&#125; 练习六：Collection集合isEmpty()方法的使用定义一个方法listTest(ArrayList&lt;String&gt; al), 要求使用isEmpty()判断al里面是否有元素。 12345678910111213141516public class CollectionTest05 &#123; public static void main(String[] args) &#123; //定义集合，添加数据 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("1"); System.out.println(listTest(list)); &#125; public static boolean listTest(ArrayList&lt;String&gt; al) &#123; //判断al集合是否为空,为空返回true，不为空返回false if(al.isEmpty())&#123; return true; &#125; return false; &#125;&#125; 练习七：简述迭代器的实现原理请简述迭代器的实现原理 当遍历集合时，首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用Iterator的next()方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 练习八：Collection集合返回首次出现索引定义一个方法listTest(ArrayList&lt;Integer&gt; al, Integer s)，要求返回s在al里面第一次出现的索引，如果s没出现过返回-1。 12345678910111213141516171819202122public class CollectionTest06 &#123; public static void main(String[] args) &#123; //定义集合，添加数据 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); list.add(5); System.out.println(listTest(list, 5)); &#125; public static int listTest(ArrayList&lt;Integer&gt; al, Integer s) &#123; //遍历集合，获取元素，判断元素是否与s相等，相等返回索引 for (int i = 0; i &lt; al.size(); i++) &#123; if (al.get(i).equals(s)) &#123; return i; &#125; &#125; return -1; &#125;&#125; 练习九：Collection集合练习(复杂，并不难)定义一个学生类Student，包含三个属性姓名、年龄、性别，创建三个学生对象存入ArrayList集合中。 A：遍历集合遍历输出。 B：求出年龄最大的学生，然后将该对象的姓名变为：小猪佩奇。 123456789101112131415161718192021222324252627282930313233343536373839public class CollectionTest07 &#123; public static void main(String[] args) &#123; //定义集合，向集合中添加student对象 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student("张三", 23, "男")); list.add(new Student("王五", 28, "男")); list.add(new Student("李四", 25, "男")); print(list); System.out.println("--------------"); change(list); System.out.println("--------------"); System.out.println(list); &#125; // public static void change(ArrayList&lt;Student&gt; list) &#123; //定义变量存放年龄 int a = 0; //定义变量存放最大年龄的索引值 int index = 0; //遍历集合获取年龄值，与a相比较 for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i).getAge() &gt; a) &#123; //如果年龄大于a，记录次数 index = i; //并把年龄的最大值赋予a a = list.get(i).getAge(); &#125; &#125; System.out.println("年龄最大的学生是" + list.get(index).getName()); //将年龄最大的学生姓名变为：小猪佩奇 list.get(index).setName("小猪佩奇"); &#125; //定义方法，遍历集合输出 public static void print(ArrayList&lt;Student&gt; list) &#123; for (Student student : list) &#123; System.out.println(student); &#125; &#125;&#125; 练习十：Collection集合练习产生10个1-100的随机数，并放到一个数组中，把数组中大于等于10的数字放到一个list集合中，并打印到控制台。 1234567891011121314151617181920212223public class CollectionTest08 &#123; public static void main(String[] args) &#123; //1.产生10个1-100的随机数,把数组中大于等于10的数字放到一个list集合中，并打印到控制台。 //(1)定义长度为10的int数组 int[] arr = new int[10]; //(2)创建产生随机数的对象 Random r = new Random(); //(3)产生随机数,并存入数组中 for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = r.nextInt(100) + 1; &#125; //(4)把数组中大于等于10的数字放到一个list集合中，并打印到控制台。 //定义List集合 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //遍历arr数组,将&gt;=10的元素存入到list集合中 for (Integer thisNum : arr) &#123; if (thisNum &gt;= 10) &#123; list.add(thisNum); &#125; &#125; System.out.println("产生的随机数是:" + list); &#125;&#125; 练习十一：泛型方法编写一个泛型方法，实现任意引用类型数组指定位置元素交换。 12345678910111213141516public class Demo09 &#123; public static void main(String[] args) &#123; Integer[] a = &#123;1,2,3,4,5,6&#125;; method(a,0,1); &#125; //编写泛型方法 public static &lt;E&gt; void method( E[] e,int a,int b)&#123; //元素互换 E temp = e[a]; e[a] = e[b]; e[b] = temp; for (int i = 0; i &lt; e.length; i++) &#123; System.out.println(e[i]); &#125; &#125;&#125; 练习十二：泛型方法编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素 123456789101112131415161718public class Demo13 &#123; public static void main(String[] args) &#123; Integer[] a = &#123;1,2,3,4,5,6&#125;; method(a); &#125; //编写泛型方法 public static &lt;E&gt; void method( E[] e)&#123; //元素反转 for (int min = 0,max = e.length - 1; min &lt; max; min++,max--) &#123; E temp = e[min]; e[min] = e[max]; e[max] = temp; &#125; for (int i = 0; i &lt; e.length; i++) &#123; System.out.println(e[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶01-Object类和常用API]]></title>
    <url>%2F2019%2F08%2F19%2F2019-08-19-Java%E8%BF%9B%E9%98%B601-Object%E7%B1%BB%E5%92%8C%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[主要内容 Object类 Date类 DateFormat类 Calendar类 System类 StringBuilder类 包装类 学习目标 能够说出Object类的特点 能够重写Object类的toString方法 能够重写Object类的equals方法 能够使用日期类输出当前日期 能够使用将日期格式化为字符串的方法 能够使用将字符串转换成日期的方法 能够使用System类的数组复制方法 能够使用System类获取当前毫秒时刻值 能够说出使用StringBuilder类可以解决的问题 能够使用StringBuilder进行字符串拼接操作 能够说出8种基本类型对应的包装类名称 能够说出自动装箱、自动拆箱的概念 能够将字符串转换为对应的基本类型 能够将基本类型转换为对应的字符串 第一章 Object类1.1 概述java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。 如果一个类没有特别指定父类， 那么默认则继承自Object类。例如： 123public class MyClass /*extends Object*/ &#123; // ...&#125; 根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个： public String toString()：返回该对象的字符串表示。 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 1.2 toString 方法方法摘要 public String toString()：返回该对象的字符串表示。 toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。 由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。 覆盖重写如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类： 123456789101112131415161718192021222324252627282930313233import java.util.Objects;public class Person &#123; // 属性 private String name; private int age; // 构造方法 public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125; // setter &amp; getter public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; toString() 方法重写 : 123456789101112131415// 重写 Object 类的 toString() 方法.// 说明 : 几乎开发中, 每一个类都需要重写 Object 类的 toString() 方法. 因为每一个类都拥有自己的特有数据.@Overridepublic String toString() &#123; return "Person &#123;name = "+name+", age = "+age+"&#125;";&#125;// 小结 : toString() 方法的作用 : 自定义对象的输出信息./*@Overridepublic String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;';&#125;*/ 在IntelliJ IDEA中，可以点击Code菜单中的Generate...，也可以使用快捷键alt+insert，点击toString()选项。选择需要包含的成员变量并确定。如下图所示： 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。 1.3 equals方法方法摘要 public boolean equals(Object obj)：指示其他某个对象是否与此对象“相等”。 调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。 默认地址比较如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false。 对象内容比较如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如： 123456789101112131415161718192021222324252627282930313233343536373839 // 重写 equals 方法 // 目的 : 自定以两个对象的比较规则. 每一个对象都会拥有自己的比较规则. 因为每一个类都应该重写 Object 类的 equals 方法. @Override public boolean equals(Object obj) &#123; // 1. 先比较一下对象的内存地址 if (this == obj) &#123; return true; &#125; // 2. 比较姓名和年龄 // 条件一 : obj 传入参数不能为 null. // 条件二 : 两个对象的类型必须一致. this 目前是 Person 类, 要求 obj 对象必须是 Person 类, 否则直接返回 false if (obj == null || this.getClass() != obj.getClass()) &#123; return false; &#125; // 3. 如果 obj 是 Person 类型, 比较两个对象的 `年龄和姓名` // 3.1 将 obj 对象向下转型 Person p = (Person) obj; // 3.2 比较两个对象的姓名和年龄 // 说明 : String 类重写了 Object 类的 equals 方法, 实现了根据字符内容来进行比较. 而不是字符串的地址. // boolean result = this.age == p.age &amp;&amp; this.name.equals(p.name); // 说明 : this.name.equals(p.name); 该方法可以优化. JDK 7 之后, 出现了 Objects 工具类. // Objects 工具类提供一个 equals 方法, 可以使用 // return (this.age == p.age) &amp;&amp; (this.name == p.name &amp;&amp; this.name != null &amp;&amp; this.name.equals(p.name)); return this.age == p.age &amp;&amp; Objects.equals(this.name, p.name); &#125;/* @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age &amp;&amp; Objects.equals(name, person.name); &#125;*/ 这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用Code菜单中的Generate…选项，也可以使用快捷键alt+insert，并选择equals() and hashCode()进行自动代码生成。如下图所示： tips：Object类当中的hashCode等其他方法，今后学习。 1.4 Objects类在刚才IDEA自动重写equals代码中，使用到了java.util.Objects类，那么这个类是什么呢？ 在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。 在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下： public static boolean equals(Object a, Object b):判断两个对象是否相等。 我们可以查看一下源码，学习一下： 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; 测试类代码 123456789101112131415161718192021222324252627282930313233343536public class Test &#123; public static void main(String[] args) &#123; // 1. 创建一个 Person 对象 Person p1 = new Person("张三", 18); Person p2 = new Person("张三", 18); // 2. 输出对象, 查看信息 (对象的属性信息). // p1 = cn.itcast.object.Person `包名+类名` @ 58ceff1 (内存地址) // Java 语言 : 打印打印, 默认就是调用该对象的 toString() 方法. // 请问1 : toString() 是谁定义的方法 ??? 是 Object 类定义的. // Person 类默认继承 Object 类, 因此, Person 类拥有 toString() 方法. // 请问2 : Object 父类实现的 toString() 方法, 不是 Person 类想要的结果. Person 类可以选择重写该方法. // 请问3 : 子类重写父类的方法, 程序执行时, 调用的是子类重写的方法. System.out.println("p1 = " + p1.toString()); // variable 变量 System.out.println("p2 = " + p2); // 需求 : 比较两个对象是否相等. // 方式一 : == 符号 boolean result1 = p1 == p2; // 比较的是两个对象的内存地址, 而不是比较两个对象的属性信息 System.out.println("result1 = " + result1); // false System.out.println("------------------"); // 请问1 : Object 类的 equals 不是 Person 类想要的, 怎么办 ??? Person 类重写该方法. boolean result2 = p1.equals(p2); System.out.println("result2 = " + result2); // true &#125;&#125;输出结果 :p1 = Person &#123;name = 张三, age = 18&#125;p2 = Person &#123;name = 张三, age = 18&#125;result1 = false------------------result2 = true 第二章 日期时间类2.1 Date类概述java.util.Date类 表示特定的瞬间，精确到毫秒。 继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如： 12345678910import java.util.Date;public class Demo01Date &#123; public static void main(String[] args) &#123; // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 &#125;&#125; tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。 常用方法Date类中的多数方法已经过时，常用的方法有： public long getTime() 把日期对象转换成对应的时间毫秒值。 2.2 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 参数pattern是一个字符串，代表日期时间的自定义格式。 格式规则常用的格式规则为： 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档。 创建SimpleDateFormat对象的代码如： 123456789import java.text.DateFormat;import java.text.SimpleDateFormat;public class Demo02SimpleDateFormat &#123; public static void main(String[] args) &#123; // 对应的日期格式如：2018-01-16 15:06:38 DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); &#125; &#125; 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 format方法使用format方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;/* 把Date对象转换成String*/public class Demo03DateFormatMethod &#123; public static void main(String[] args) &#123; Date date = new Date(); // 创建日期格式化对象,在获取格式化对象时可以指定风格 DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = df.format(date); System.out.println(str); // 2008年1月23日 &#125;&#125; parse方法使用parse方法的代码为： 123456789101112131415import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/* 把String转换成Date对象*/public class Demo04DateFormatMethod &#123; public static void main(String[] args) throws ParseException &#123; DateFormat df = new SimpleDateFormat("yyyy年MM月dd日"); String str = "2018年12月11日"; Date date = df.parse(str); System.out.println(date); // Tue Dec 11 00:00:00 CST 2018 &#125;&#125; 2.3 练习请使用日期时间相关的API，计算出一个人已经出生了多少天。 思路： 1.获取当前时间对应的毫秒值 2.获取自己出生日期对应的毫秒值 3.两个时间相减（当前时间– 出生日期） 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;public class Test4 &#123; public static void main(String[] args) throws ParseException &#123; // 1. 创建一个键盘录入对象 Scanner sc = new Scanner(System.in); // 2. 提示, 并接收用户的输入 System.out.println("亲, 请输入您的出生年月日 : 格式(yyyy-MM-dd)"); String birthday = sc.nextLine(); // 3. 关闭键盘录入对象 sc.close(); // 4. 将接收的日期字符串转换为一个日期对象 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); Date birthdayDate = df.parse(birthday); // 5. 获取当前日期 Date date = new Date(); // 6. 计算两个日期的相差毫秒数 long time = date.getTime() - birthdayDate.getTime(); // 7. 判断 if (time &lt; 0) &#123; System.out.println("亲, 您还没有出生呢."); &#125; else &#123; long day = time / 1000 / 60 / 60 / 24; System.out.println("从出生到此时, 共生活了 " + day + " 天."); &#125; &#125;&#125;输出结果 :亲, 请输入您的出生年月日 : 格式(yyyy-MM-dd)2008-8-8从出生到此时, 共生活了 3609 天. 2.4 Calendar类概念日历我们都见过 java.util.Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下： Calendar静态方法 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 例如： 1234567import java.util.Calendar;public class Demo06CalendarInit &#123; public static void main(String[] args) &#123; Calendar cal = Calendar.getInstance(); &#125; &#125; 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） get/set方法get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示： 1234567891011121314151617181920212223242526272829import java.util.Calendar;public class Test5 &#123; public static void main(String[] args) &#123; // 创建一个 Calendar 对象 Calendar calendar = Calendar.getInstance(); // get 获取方法 : int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH) + 1; int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日."); // set 设置方法 : calendar.set(Calendar.YEAR, 2020); year = calendar.get(Calendar.YEAR); month = calendar.get(Calendar.MONTH) + 1; day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日."); &#125;&#125;输出结果 :2018年6月26日.2020年6月26日. add方法add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如： 12345678910111213141516171819202122232425262728public class Test6 &#123; public static void main(String[] args) &#123; Calendar calendar = Calendar.getInstance(); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH) + 1; int day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日."); // add 方法演示 : // 1. 加两天 calendar.add(Calendar.DAY_OF_MONTH, 2); // 2. 减三年 calendar.add(Calendar.YEAR, -3); year = calendar.get(Calendar.YEAR); month = calendar.get(Calendar.MONTH) + 1; day = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(year + "年" + month + "月" + day + "日."); &#125;&#125;输出结果 :2018年6月26日.2015年6月28日. getTime方法Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。 12345678910111213141516import java.util.Calendar;import java.util.Date;public class Test7 &#123; public static void main(String[] args) &#123; Calendar calendar = Calendar.getInstance(); // getTime() 方法, 返回一个 Date 对象 Date date = calendar.getTime(); System.out.println("date = " + date); &#125;&#125;输出结果 :date = Tue Jun 26 01:00:58 CST 2018 小贴士： ​ 西方星期的开始为周日，中国为周一。 ​ 在Calendar类中，月份的表示是以0-11代表1-12月。 ​ 日期是有大小关系的，时间靠后，时间越大。 第三章 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有： public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 3.1 currentTimeMillis方法实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值 12345678import java.util.Date;public class SystemDemo &#123; public static void main(String[] args) &#123; //获取当前时间毫秒值 System.out.println(System.currentTimeMillis()); // 1516090531144 &#125;&#125; 练习 :验证for循环1-1000000000所需要使用的时间（毫秒） 123456789101112131415161718192021public class Test8 &#123; public static void main(String[] args) &#123; // 1. 记录开始时间毫秒 long start = System.currentTimeMillis(); // 2. 执行循环操作 long sum = 0; for (int i = 0; i &lt; 1000000000; i++) &#123; sum += i; &#125; // 3. 记录结束时间毫秒 long end = System.currentTimeMillis(); // 4. 查看结果 System.out.println("共耗时 : " + (end - start) + " 毫秒."); &#125;&#125;输出结果 :共耗时 : 281 毫秒. 3.2 arraycopy方法 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为： 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 练习将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10] 12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class ArrayCopyTest3 &#123; public static void main(String[] args) &#123; // arraycopy(Object src, int srcPos, Object dest, int destPos, int length) // 1. src -&gt; source 源数据 // 2. dest -&gt; destination 目的地 // 3. pos -&gt; position 位置 // 4. length -&gt; 长度 int[] src = new int[]&#123;1, 2, 3, 4, 5&#125;; int[] dest = new int[]&#123;6, 7, 8, 9, 10&#125;; int[] arr = new int[5]; // &#123;0, 0, 0, 0, 0&#125; System.arraycopy(src, 0, dest, 0, 3); // 查看 src 和 dest 的数据 System.out.println("src = " + Arrays.toString(src)); // &#123;1, 2, 3, 4, 5&#125; System.out.println("dest = " + Arrays.toString(dest)); // &#123;1, 2, 3, 9, 10&#125; // 思考 : System.arraycopy(src, 0, arr, 2, 3); // &#123;0, 0, 1, 2, 3&#125; System.out.println("arr = " + Arrays.toString(arr)); &#125;&#125;输出结果 :src = [1, 2, 3, 4, 5]dest = [1, 2, 3, 9, 10]arr = [0, 0, 1, 2, 3] 第四章 StringBuilder类4.1 字符串拼接问题由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如： 1234567public class StringDemo &#123; public static void main(String[] args) &#123; String s = "Hello"; s += "World"; System.out.println(s); &#125;&#125; 在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。 根据这句话分析我们的代码，其实总共产生了三个字符串，即&quot;Hello&quot;、&quot;World&quot;和&quot;HelloWorld&quot;。引用变量s首先指向Hello对象，最终指向拼接出来的新字符串对象，即HelloWorld 。 由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用java.lang.StringBuilder类。 4.2 StringBuilder概述查阅java.lang.StringBuilder的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。 原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 4.3 构造方法根据StringBuilder的API文档，常用构造方法有2个： public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 123456789public class StringBuilderDemo &#123; public static void main(String[] args) &#123; StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // (空白) // 使用带参构造 StringBuilder sb2 = new StringBuilder("itcast"); System.out.println(sb2); // itcast &#125;&#125; 4.4 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 append方法append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如： 12345678910111213141516171819202122public class Demo02StringBuilder &#123; public static void main(String[] args) &#123; //创建对象 StringBuilder builder = new StringBuilder(); //public StringBuilder append(任意类型) StringBuilder builder2 = builder.append("hello"); //对比一下 System.out.println("builder:"+builder); System.out.println("builder2:"+builder2); System.out.println(builder == builder2); //true // 可以添加 任何类型 builder.append("hello"); builder.append("world"); builder.append(true); builder.append(100); // 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。 // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下 //链式编程 builder.append("hello").append("world").append(true).append(100); System.out.println("builder:"+builder); &#125;&#125; 备注：StringBuilder已经覆盖重写了Object当中的toString方法。 toString方法通过toString方法，StringBuilder对象将会转换为不可变的String对象。如： 123456789public class Demo16StringBuilder &#123; public static void main(String[] args) &#123; // 链式创建 StringBuilder sb = new StringBuilder("Hello").append("World").append("Java"); // 调用方法 String str = sb.toString(); System.out.println(str); // HelloWorldJava &#125;&#125; 第五章 包装类5.1 概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下： 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 5.2 装箱与拆箱基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“： 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例：（看懂代码即可） 基本数值—-&gt;包装对象 12345// 基本数据类型转换为包装对象类型// 方式一 : 使用构造方法Integer i = new Integer(100); // 不推荐使用// 方式二 : 使用 Integer 包装类的静态方法 valueOfInteger i2 = Integer.valueOf(100); 包装对象—-&gt;基本数值 1234// 包装对象类型转换为基本数据类型// 方式一 : 使用 Integer 包装类提供的对象方法 intValueint num = i2.intValue();System.out.println("num = " + num); 5.3自动装箱与自动拆箱由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如： 1234567891011121314151617181920public class test13 &#123; public static void main(String[] args) &#123; // 1. 自动装箱 : 将基本数据类型自动包装为对象类型 // Integer i1 = Integer.valueOf(100); Integer i1 = 100; // 2. 自动拆箱 : 将包装对象类型自动拆解为基本数据类型 // int num = i1.intValue(); int num = i1; // 3. 包装类型和基本数据类型可以直接参数运算 // int sum = i1.intValue() + num; int sum = i1 + num; System.out.println("sum = " + sum); &#125;&#125;输出结果 :sum = 200 5.3 基本类型与字符串之间的转换基本类型转换为String 基本类型转换String总共有三种方式 ： 123456789101112131415public class test14 &#123; public static void main(String[] args) &#123; // 需求 : 将基本数据类型转换为字符串 // 方式一 : 使用基本数据类型直接拼接一个空字符串. (推荐使用) String str1 = 100 + ""; // 方式二 : 使用 Integer 类的静态方法, toString(), 接收一个基本数据类型, 返回一个新字符串 String str2 = Integer.toString(100); // 方式三 : 使用 String 类的静态方法, valueOf(), 接收一个基本数据类型, 返回一个新字符串 String str3 = String.valueOf(100); &#125;&#125; String转换成对应的基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。 public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。 public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。 public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。 代码使用（仅以Integer类的静态方法parseXxx为例）如： 123456789101112131415161718192021222324public class test15 &#123; public static void main(String[] args) &#123; // 需求 : 将一个字符串解析为 `基本数据类型` String str1 = "100"; String str2 = "998"; String str3 = "abc"; // 方式 : 使用 Integer 类提供的 parseInt() 静态方法, 接收一个字符串, 返回一个基本数据类型 int num1 = Integer.parseInt(str1); int num2 = Integer.parseInt(str2); int result = num1 + num2; System.out.println("result = " + result); // 解析二 : NumberFormatException 数字格式化异常, 无法解析成功! int num3 = Integer.parseInt(str3); System.out.println("num3 = " + num3); &#125;&#125;输出结果 :result = 1098Exception in thread "main" java.lang.NumberFormatException: For input string: "abc" ... 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 练习题练习一：Object类equals方法简述String类中的equals方法与Object类中的equals方法的不同点。 答：String类中的equals方法是用来判断两个对象的内容是否相同，而Object类中的equals方法是用来判断两个对象是否是同一个对象，所谓同一个对象指的是内存中的同一块存储空间。 练习二：Object类的toString方法不运行代码，直接说出打印结果，并解释原因。 12345678910111213public class ToStringTest&#123; static int i = 1; public static void main(String args[])&#123; System.out.println("love " + new ToStringTest());//love java ToStringTest a = new ToStringTest(); a.i++; System.out.println("me " + a.i);//me 2 &#125; public String toString()&#123; System.out.print("I ");//I return "java "; &#125;&#125; 运行结果： 12I love java me 2 原因：当执行代码的时候，首先加载静态变量，然后执行main方法，由于main方法内部第一行代码为输出语句，里面new了此类对象，当执行此行代码时会先创建了本类的对象，由于此类重写了toString方法，会先执行toString方法的打印输出，然后返回“java ”，再执行main方法第一行打印输出。在Java中“System.out.println(类对象名);”实际输出的是该对象的toString()方法返回的字符串，即括号中的内容等价于类对象名.toString(),toString方法的好处是在碰到println方法的时候会被自动调用，不用显示的写出来。 练习三：Object类equals方法看下列程序，不运行说结果，写出答案后，并在IntelliJ IDEA中运行看看自己给的答案与运行结果是否正确，并分析原因。 （1） 1234String s1 = new String("abc");String s2 = "abc";System.out.println(s1 == s2); //falseSystem.out.println(s1.equals(s2)); //true （2） 1234String s1 = "abc";String s2 = "abc";System.out.println(s1 == s2); //trueSystem.out.println(s1.equals(s2)); //true （3） 1234String s1 = "a" + "b" + "c";String s2 = "abc";System.out.println(s1 == s2); //trueSystem.out.println(s1.equals(s2)); //true （4） 12345String s1 = "ab";String s2 = "abc";String s3 = s1 + "c";System.out.println(s3 == s2); //falseSystem.out.println(s3.equals(s2)); //true 练习四：StringBuilder类与String类的区别简述StringBuilder类与String类的区别。 答：String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响。 StringBuilder又称为可变字符序列，是JDK5.0中新增加的一个类，它是一个类似于String的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串，并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容，StringBuilder会自动维护数组的扩容。 练习五：Date类的使用请用代码实现:获取当前的日期,并把这个日期转换为指定格式的字符串,如2088-08-08 08:08:08。 123456789101112public class DateTest &#123; public static void main(String[] args) &#123; //获取当前日期对象 now; Date now = new Date(); //创建SimpleDateFormat对象 df,并制定日期格式 SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); //调用df的format(Date date) 方法,传入now; 接收返回的字符串 String datestr = df.format(now); //打印这个字符串 System.out.println(datestr); &#125;&#125; 练习六：DateFormat类方法的使用使用SimpleDateFormat类,把2018-03-04转换为2018年03月04日。 12345678910111213public class DateFormatTest &#123; public static void main(String[] args) throws ParseException &#123; //创建SimpleDateFormat对象df1,指定日期模式为yyyy-MM-dd SimpleDateFormat df1 = new SimpleDateFormat("yyyy-MM-dd"); //调用df1的parse(String str)方法传入2018-03-04,得到对应日期类型 Date date = df1.parse("2018-03-04"); //创建日期格式化对象df2,在获取格式化对象时可以指定风格 DateFormat df2 = new SimpleDateFormat("yyyy年MM月dd日"); //调用df2的format(Date date) 传入刚才转换的日期 String str = df2.format(date); System.out.println(str); &#125;&#125; 练习七：Calendar类方法的使用用程序判断2018年2月14日是星期几。 12345678910111213141516171819202122232425public class CalendarTest01 &#123; public static void main(String[] args) &#123; //创建Calendar对象 Calendar c = Calendar.getInstance(); //将给定的日历字段设置到Calendar对象中 c.set(Calendar.YEAR, 2018); c.set(Calendar.MONTH, 1); c.set(Calendar.DATE, 14); //设置年 int year = c.get(Calendar.YEAR); //设置月 int month = c.get(Calendar.MONTH)+1; //设置日 int date = c.get(Calendar.DATE); //设置星期 char week = getWeek(c.get(Calendar.DAY_OF_WEEK)); //输出结果 System.out.println(year+"年"+month+"月"+date+"日是星期"+week); &#125; //定义方法，获取星期汉字 public static char getWeek(int a)&#123; char[] c = &#123;' ','日','一','二','三','四','五','六'&#125;; return c[a]; &#125;&#125; 练习八：System类arraycopy方法的使用现有一个字符数组{‘i’,’t’,’c’,’a’,’s’,’a’}，请使用System类中的arraycopy()方法在控制台输出“itcast”。（提示：将[1]号数组元素复制到最后位置并覆盖原有元素。） 1234567891011public class ArraycopyTest &#123; public static void main(String[] args) &#123; char[] cha =&#123;'i','t','c','a','s','a'&#125;; //将cha数组中第2个元素，复制到目标数组最后一位数组上 System.arraycopy(cha, 1, cha, 5, 1); //遍历目标数组，在控制台输出字符串 for (int i = 0; i &lt; cha.length; i++) &#123; System.out.print(cha[i]); &#125; &#125;&#125; 练习九：StringBuilder类的使用请使用代码实现： 分别使用String的 += 和StringBuilder的append方法对字符串做100000次拼接，计算String拼接100000次花费时间与StringBuilder拼接100000次所花费时间并打印。 123456789101112131415161718192021222324252627282930313233343536public class StringBuilder01 &#123; public static void main(String[] args) &#123; //使用System的currentTimeMillis()方法获取当前操作系统的毫秒值,作用程序执行的开始时间,使用start变量接收 long start = System.currentTimeMillis(); //需要测试执行性能的代码 //testString(); //消耗时间: 29295毫秒 testStringBuilder();//消耗时间:6毫秒 //使用System的currentTimeMillis()方法获取当前操作系统的毫秒值,作用程序执行的结束时间,使用end变量接收 long end = System.currentTimeMillis(); //计算代码执行花费的时间 end - start,输出代码执行消耗的时间 System.out.println("所花费的时间为:"+(end-start)); &#125; //写一个静态方法: testString(),在该方法中 public static void testString()&#123; //定义一个字符串 str,内容随意 String str = "hello"; //写一个循环100000次for循环,在循环中写上 for(int i = 0; i&lt;100000;i++)&#123; //str +=”随机内容” ; 这里不要写str += (str+”xxx”) 这样会导致堆内存溢出错误. str += "world"; &#125; &#125; //写一个静态方法:testStringBuilder(),在方法中 public static void testStringBuilder()&#123; //创建一个StringBuilder对象sb,初始内容与testString()中的字符串相同 StringBuilder sb = new StringBuilder("hello"); //写一个循环100000次for循环,在循环中写上 for(int i = 0; i&lt;100000;i++)&#123; //调用sb.append()方法,传入的内容与testString()方法中+=后面的内容一样 sb.append("world"); &#125; //循环结束调用sb.toString()方法转换为字符串 String newStr = sb.toString(); &#125;&#125; 练习十：StringBuilder类的使用（reverse()方法）分析以下需求，并用代码实现： (1)定义数字字符串数组{“010”,”3223”,”666”,”7890987”,”123123”}； (2)判断该数字字符串数组中的数字字符串是否是对称(第一个数字和最后一个数字相等，第二个数字和倒数第二个数字是相等的，依次类推)的，并逐个输出； (3)如：010 是对称的，3223 是对称的，123123 不是对称的； (4)最终打印该数组中对称字符串的个数。 注：判断对称可用reverse(),将此字符序列用其反转形式取代。 12345678910111213141516171819202122public class StringBuilderTest02 &#123; public static void main(String[] args) throws IOException &#123; //定义数字字符串数组 String[] str = &#123;"010","3223","666","7890987","123123"&#125;; SBTest(str); &#125; public static void SBTest(String[] str) &#123; int count = 0; //遍历定义的字符串数组 for (String string : str) &#123; //创建StringBuilder对象 StringBuilder sb = new StringBuilder(string); //调用reverse()方法，将遍历的数字进行反转，然后用equals()方法对比是否与原数字相同 if (sb.reverse().toString().equals(string)) &#123; count++; System.out.println(string + "是对称的"); &#125; &#125; System.out.println("总数为" + count); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java经典逻辑编程50题]]></title>
    <url>%2F2019%2F08%2F16%2F2019-08-16-Java%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E7%BC%96%E7%A8%8B50%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文对50道经典的java程序题进行详细讲解，希望可以锻炼到编程的思维和手写代码的能力。 【程序1】兔子问题题目描述： 有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少？ 题目分析： 兔子对数的规律为数列1,1,2,3,5,8,13,21.... 做这种题目，最好的做法就是找出规律，跟高中的数列一样 本题有：a[n]=a[n-1]+a[n-1]，而第一第二项都知道了，后面的值也可以求得。 代码实现： 123456789101112131415161718192021222324252627package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/16 07:13 */public class Interview01 &#123; public static void main(String[] args) &#123; System.out.print("请输入你想知道的兔子对数的月份："); Scanner scanner = new Scanner(System.in); int n = scanner.nextInt();//获取输入的整数 System.out.println("第" + n + "个月兔子总对数为" + fun(n)); scanner.close(); &#125; //求得所需月份的兔子的对数，返回值为兔子的对数 private static int fun(int n) &#123; if (n == 1 || n == 2)&#123; return 1; &#125; else &#123; return fun(n - 1) + fun(n - 2); &#125; &#125;&#125; 运行结果： 12请输入你想知道的兔子对数的月份：3第3个月兔子总对数为：2 【程序2】素数问题题目描述： 判断101-200之间有多少个素数，并输出所有素数。 题目分析： 素数是：只能被1或本身整除的数，如：2,3,5,7,11,13... 判断素数的方法：用一个数分别去除2到sqrt(这个数)，其实用这个数分别去除2到他本身少1的数也可以，但是运算时间增加了；如果能被整除，则表明此数不是素数，反之是素数。 代码实现： 1234567891011121314151617181920212223242526272829package interview50;public class Interview02&#123; public static void main(String[] args) &#123; int sum = 0;//用来存储101到200素数的总个数 System.out.println("101-200之间的所有素数如下："); for(int i=101;i&lt;=200;i++)&#123; if(isRightNum(i))&#123;//如果是素数就输出 System.out.print(i+"\t"); sum++; if(sum%5==0)&#123; System.out.println();//每输出5个换行 &#125; &#125; &#125; System.out.println(); System.out.println("素数的总数："+sum); &#125; //判断一个数是不是素数 public static boolean isRightNum(int n)&#123; for(int j=2;j&lt;=Math.sqrt(n);j++)&#123; if(n%j==0)&#123;////如果能整除，就说明不是素数，可以马上中断，继续对下一个数判断 return false; &#125; &#125; return true; &#125;&#125; 运行结果： 1234567101-200之间的所有素数如下：101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 素数的总数：21 【程序3】水仙花问题题目描述： 打印出100-999所有的”水仙花数”，所谓”水仙花数”是指一个三位数，其各位数字立方和等于该数本身。 例如：153是一个”水仙花数”，因为153=1的三次方＋5的三次方＋3的三次方。 题目分析： 解决这个题目关键是要知道怎么把一个数的各个位上的数拆分出来；利用for循环遍历100-999，每个数分解出个位，十位，百位。 代码实现： 1234567891011121314151617181920212223242526272829package interview50;public class Interview03&#123; public static void main(String[] args) &#123; int sum = 0;//存储水仙花数的总数 System.out.println("100-999之间的所有水仙花数如下："); for(int i=100;i&lt;1000;i++)&#123; if(isRightNum(i))&#123;//如果是水仙花数就输出 System.out.print(i+"\t"); sum++; if(sum%5==0)&#123;//每输出5个换一行 System.out.println(); &#125; &#125; &#125; System.out.println(); System.out.println("总共有水仙花个数："+sum); &#125; private static boolean isRightNum(int i) &#123; int a = i%10;//分解出个位 int b = i/10%10;//分解出十位 int c = i/100;//分解出百位 if(i==(a*a*a+b*b*b+c*c*c))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 运行结果： 123100-999之间的所有水仙花数如下：153 370 371 407 总共有水仙花个数：4 【程序4】分解质因数问题题目描述： 将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。 题目分析： 对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成： （1）如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。 （2）如果n&gt;k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数n,重复执行第一步。 （3）如果n不能被k整除，则用k+1作为k的值,重复执行第一步。 代码实现： 12345678910111213141516171819202122232425262728293031package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/16 07:19 */public class Interview04 &#123; public static void main(String[] args) &#123; System.out.print("请输入一个你要分解的正整数："); Scanner scanner = new Scanner(System.in); int input = scanner.nextInt();//获取输入的数字 System.out.println(); System.out.print(input + "="); for (int i = 2; i &lt; input + 1; i++) &#123;//遍历2-input while (input % i == 0 &amp;&amp; input &gt; i) &#123; System.out.print(i + "*"); input = input / i; &#125; if (input == i) &#123;//上面的都不能整除，说明这是一个质数 System.out.print(i); break; &#125; &#125; scanner.close(); &#125;&#125; 运行结果： 123请输入一个你要分解的正整数：9090=2*3*3*5 【程序5】条件嵌套问题题目描述： 利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。 题目分析： (a&gt;b)?a:b这是条件运算符的基本例子。 代码实现： 123456789101112131415161718192021package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/16 07:19 */public class Interview05 &#123; public static void main(String[] args) &#123; System.out.print("请输入你的分数："); Scanner scanner = new Scanner(System.in); int input = scanner.nextInt();//获取输入 //等级判断 String belong = input &gt;= 90 ? "A" : (input &gt;= 60 ? "B" : "c"); System.out.println(input + "分属于：" + belong); scanner.close(); &#125;&#125; 运行结果： 12请输入你的分数：9393分属于：A 【程序6】最大公约数问题题目描述： 输入两个正整数m和n，求其最大公约数和最小公倍数。 题目分析： 利用辗除法。 这里有一个知识点要记住的，最大公约数和最小公倍数的求法 （1）先求最大公约数bigDivisor （2）就可以很方便获得最小公倍数multiple=input1*input2/bigDIvisor 这里最重要的就是求最大公约数：求法如下 （1）用大的数对小的数求余； （2）把小的数赋值给大的数，把求余获得的结果赋值给小的数； （3）循环上一步的操作，直到求余的结果为零； （4）上一步被求余的数就是我们要的最大公约数。 代码实现： 1234567891011121314151617181920212223242526272829303132333435package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/18 07:19 */public class Interview06 &#123; public static void main(String[] args) &#123; int bigDivisor = 0;//定义最大公约数 int multiple = 0;//定义最小公倍数 System.out.println("请输入两个整数："); Scanner scanner = new Scanner(System.in); int input1 = scanner.nextInt();//获取第一个数 int input2 = scanner.nextInt();//获取第二个数 multiple = input1 * input2;//这个值保存，求公约数后，方便求得最小公倍数 int temp = 1;// 交换用的中间数 if (input2 &gt; input1) &#123;//确保第一个数不小于第二个数 temp = input1; input1 = input2; input2 = temp; &#125; while (temp != 0) &#123; //求余结果不等于零，就一直循环 temp = input1 % input2;//求余结果 input1 = input2;//大的数已经没用了，用小的数替代 input2 = temp;//把求余的结果赋值给小的数 &#125; bigDivisor = input1;//最后一次求余结果为零时，被求余的数 multiple = multiple / bigDivisor; System.out.println("最大公约数是：" + bigDivisor); System.out.println("最小公倍数是：" + multiple); scanner.close(); &#125;&#125; 运行结果： 12345请输入两个整数：410最大公约数是：2最小公倍数是：20 【程序7】统计字符问题题目描述： 输入一行字符，分别统计出其英文字母、空格、数字和其它字符的个数。 题目分析： 这里的需要的知识点: （1）获取一行字符串，nextLine（）； （2）把字符串的每一个字符赋值到一个数值中； （3）对比每一个数值在ASK码的范围，就可以确定它符号的类别； （4）char字符ASK码的范围： 数字0到9： 48~57； 字母A到Z：65到90 a到z：97到122； 空格是32 代码实现： 1234567891011121314151617181920212223242526272829303132333435package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/18 07:19 */public class Interview07 &#123; public static void main(String[] args) &#123; int num = 0;//数字的个数 int letter = 0;//字母的个数 int space = 0;//空格的个数 int others = 0;//其他的个数 System.out.println("请输入一串字符："); Scanner scanner = new Scanner(System.in); String string = scanner.nextLine();//获取一行字符串 //把字符串里面的值赋值给一个字符型数组 char[] arr = string.toCharArray(); //遍历字符串里面的所有值 for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt;= 48 &amp;&amp; arr[i] &lt;= 57) &#123;//字符是数字 num++; &#125; else if ((arr[i] &gt;= 65 &amp;&amp; arr[i] &lt;= 90) || (arr[i] &gt;= 97 &amp;&amp; arr[i] &lt;= 122)) &#123; letter++; &#125; else if (arr[i] == 32) &#123; space++; &#125; else &#123; others++; &#125; &#125; System.out.println("数字：" + num + "个，字母：" + letter + "个，空格：" + space + "个，其他：" + others + "个"); scanner.close(); &#125;&#125; 运行结果： 123请输入一串字符：45 f GGb*数字：2个，字母：4个，空格：2个，其他：1个 【程序8】aaa之和问题题目描述： 求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。输出结果的形式如：2+22+222=246； 题目分析： 关键是计算出每一项的值。 比如获取的数字为：a，出现的项数为：n 总结一下，可以得到一下规律： （1）第一项有一个a,最后一项有n个a （2）第1和第2项相差2*10^1，第2和第三项相差2*10^2，第k和第k+1项相差2*（10^k） 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/18 07:19 * @Description: */public class Interview08 &#123; public static void main(String[] args) &#123; int n = 0, a = 0; Scanner scanner = new Scanner(System.in); System.out.println("请输入a的值:"); a = scanner.nextInt(); System.out.println("请输入n的值："); n = scanner.nextInt(); int[] arr = new int[n];//创建数组长度为输入的项数 int i = 1;//while循环初始化的值 arr[0] = a;//数组的第一个值为2 //把每一项的值赋值给数组里面的数 while (i &lt; n) &#123; a *= 10; arr[i] = a + arr[i - 1]; i++; &#125; //求和 int sum = 0; for (int s : arr) &#123; sum += s;//累加求和 if (s == arr[n - 1]) &#123; System.out.print(s); break;//最后一次只输出结果 &#125; System.out.print(s + "+");//前面的值输出结果，后面还要加一个加号 &#125; System.out.println("=" + sum);//完美结束 &#125;&#125; 运行结果： 12345请输入a的值:2请输入n的值：32+22+222=246 【程序9】完数问题题目描述： 一个数如果恰好等于它的因子之和，这个数就称为”完数”。例如6=1＋2＋3.编程找出1000以内的所有完数。 题目分析： 判断完数的方法： 利用for循环判断所有因数的和是否和输入的值是否相等，相等的话输出。 求因数的方法： （1）两个嵌套循环，并用i%j==0,关于i和j的值范围：i从1到1000逐个遍历，j只需不大于i/2+1即可 比如：48，最大的因数才24,99最大的因数是33，因数不会大于本身数的一半。 （2）j就是我们所求的因数，把所有的j相加，就可以得到因数总和。 （3）因数总和已经包含1了，因为第一次就保存1了 代码实现： 12345678910111213141516171819202122package interview50;/** * @Auther: aimanyeye * @Date: 2019/8/18 07:19 */public class Interview09 &#123; public static void main(String[] args) &#123; System.out.println("1000以内的完数有："); for (int i = 1; i &lt;= 1000; i++) &#123; int sum = 0;//所有因数的总和 for (int j = 1; j &lt;= i / 2; j++) &#123; if (i % j == 0) &#123;//判断范围内的所有j相加，就是因数总和 sum = sum + j; &#125; &#125; if (i == sum) &#123;//遍历完毕才判断相不相等 System.out.print(i + " "); &#125; &#125; &#125;&#125; 运行结果： 121000以内的完数有：6 28 496 【程序10】反弹球问题题目描述： 一球从h米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第n次落地时，共经过多少米？第n次反弹多高？ 题目分析： 第n次反弹的高度：(1/2)^n*h （1）经过的距离：这个可以总结得到：第一次落地经过：h,第二次落地经过：h+(h/2)*2； （2）第三次落地经过：h+(h/2)*2+(h/2/2)*2 （3）那么第n次落地经过： h+(h/2)*2+(h/2/2)*2 +...+h/(2^(n-1))*2 代码实现： 123456789101112131415161718192021222324252627package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/18 07:19 */public class Interview10 &#123; public static void main(String[] args) &#123; System.out.println("请输入小球下落的高度和落地的次数："); Scanner scanner = new Scanner(System.in); float h = scanner.nextFloat(); float n = scanner.nextFloat(); System.out.print("小球下落的高度为："+h+"米，"); float sum = h;//经过的路径总和 h /= 2;//第一次下落是在最高点，sum中不会有两倍的h，所以写在外面，循环从第二次开始 for (int i = 2; i &lt;= n; i++) &#123; //经过的距离的总和 sum += h * 2; //第N次反弹的高度为 h /= 2; &#125; System.out.println("在第"+n+"次落地后，能反弹："+h+"米，经过的距离："+sum+"米"); scanner.close(); &#125;&#125; 运行结果： 1234请输入小球下落的高度和落地的次数：22小球下落的高度为：2.0米，在第2.0次落地后，能反弹：0.5米，经过的距离：4.0米 【程序11】数字组合问题问题题目描述： 有数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？都是多少？ 题目分析： 可填在百位、十位、个位的数字都是1、2、3、4。这里要用3个for循环，用if判断条件是否符合，符合条件的数字打印出来,并计算个数总和。 代码实现： 1234567891011121314151617181920212223242526272829package interview50;public class Interview11 &#123; public static void main(String[] args) &#123; int i, j, k; //分别代表个、十、百位 int num; //用来输出符合要求的三位数 int count = 0; //用来统计符合要求的三位数有多少个 System.out.println("符合要求的三位数有："); for(i = 1; i &lt;= 4; i++)&#123; for(j = 1; j &lt;= 4; j++)&#123; if(i != j) //提前把有重复的部分情况过滤掉，减少运行次数，优化性能 for(k = 1; k &lt;= 4; k++)&#123; if(i != k &amp;&amp; j != k)&#123; num = i + j * 10 + k * 100; System.out.print(num+"\t"); count++; if(count%5==0)&#123; System.out.println(); &#125; &#125; &#125; &#125; &#125; System.out.println(); System.out.println("符合要求的三位数共有" + count + "个"); &#125;&#125; 运行结果： 1234567符合要求的三位数有：321 421 231 431 241 341 312 412 132 432 142 342 213 413 123 423 143 243 214 314 124 324 134 234 符合要求的三位数共有24个 【程序12】提成问题题目描述： 企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？ 题目分析： 请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。 10万以下 10~20万 20~40万 40~60万 60~100万 100万以上 0.1 0.075 0.05 0.03 0.015 0.01 上一区间合计 1 1+0.75=1.75 1.75+1=2.75 2.75+0.6=3.35 3.35+0.6=3.95 代码实现： 1234567891011121314151617181920212223242526272829303132333435package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/19 07:19 */public class Interview12 &#123; public static void main(String[] args) &#123; System.out.println("请输入你创造的利润(单位：万元):"); Scanner scanner = new Scanner(System.in); while (!scanner.hasNextDouble()) &#123; System.out.println("请输入金额数字："); scanner.next(); &#125; double profit = scanner.nextDouble(); double bonus = 0; if (profit &lt;= 10) &#123; bonus = profit * 0.1; &#125; else if (profit &lt;= 20) &#123; bonus = (profit - 10) * 0.075 + 1; &#125; else if (profit &lt;= 40) &#123; bonus = (profit - 10) * 0.05 + 1.75; &#125; else if (profit &lt;= 60) &#123; bonus = (profit - 10) * 0.03 + 2.75; &#125; else if (profit &lt;= 100) &#123; bonus = (profit - 10) * 0.015 + 3.35; &#125; else &#123; bonus = (profit - 100) * 0.01 + 3.95; &#125; System.out.println(profit + "万元利润，可以获得：" + bonus + "万元"); scanner.close(); &#125;&#125; 运行结果： 12345请输入你创造的利润(单位：万元):a请输入金额数字：2020.0万元利润，可以获得：1.75万元 【程序13】完全平方数问题题目描述： 一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？ 题目分析： 在10万以内判断，用for循环判断：先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果再平方后分别和i+100,i+268相等，即是结果。 代码实现： 12345678910111213package interview50;public class Interview13&#123; public static void main(String[] args) &#123; System.out.println("1~100000符合的数有："); for (int i = 0; i &lt; 10000; i++) &#123; int num1 = (int) Math.sqrt(i + 100);//开方，值已固定了 int num2 = (int) Math.sqrt(i + 268); if ((num1 * num1 == (i + 100)) &amp;&amp; (num2 * num2 == (i + 268))) &#123;//符合条件的打印出来 System.out.print(i + "\t"); &#125; &#125; &#125;&#125; 运行结果： 121~100000符合的数有：21 261 1581 【程序14】日期问题题目描述： 输入某年某月某日，判断这一天是这一年的第几天？ 题目分析： 以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。 闰年的条件：year除以400能整除，或者year除以4能整除，但是不能是100的倍数。 代码实现： 123456789101112131415161718192021222324252627282930package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/19 07:19 */public class Interview14 &#123; public static void main(String[] args) &#123; System.out.println("请输入年月日（用空格隔开）："); Scanner scanner = new Scanner(System.in); int year = scanner.nextInt();//获取年份 int month = scanner.nextInt();//获取月份 int day = scanner.nextInt();//获取天数 int sum = 0;//天数总和 //创建一个包含月份天数的数组，先按小年计算，如果是闰年，并且在三月以后再加1 int[] arr = &#123;0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; sum = day;//输入的天数肯定是要加的 for (int i = 1; i &lt; month; i++) &#123; //加上包含的月份天数 sum += arr[i]; &#125; //最后判断是否是闰年，如果是的话再加1，否则sum就是结果了,条件比较长，我就抽出来写了 boolean isRight = (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &amp;&amp; (month &gt; 2); if (isRight) &#123; sum += 1; &#125; System.out.println(year + "年" + month + "月" + day + "日，是这年的第" + sum + "天"); &#125;&#125; 运行结果： 123请输入年月日（用空格隔开）：2000 3 12000年3月1日，是这年的第61天 【程序15】三数比较问题题目描述： 输入三个整数x,y,z，请把这三个数由小到大输出。 题目分析： 我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。最后两个数也使z&gt;y就可以了 。 代码实现： 1234567891011121314151617181920212223242526272829303132333435package interview50;import java.util.Scanner; /** * @Auther: aimanyeye * @Date: 2019/8/19 07:19 */public class Interview15 &#123; public static void main(String[] args) &#123; System.out.println("输入三个整数（用空格隔开）："); Scanner scanner = new Scanner(System.in); int num1 = scanner.nextInt();//获取整数 int num2 = scanner.nextInt(); int num3 = scanner.nextInt(); int temp = 0;//最为一个交换数 if (num1 &gt; num2) &#123;//保证num2&gt;num1 temp = num1; num1 = num2; num2 = temp; &#125; if (num1 &gt; num3) &#123;//保证num3&gt;num1 temp = num1; num1 = num3; num3 = temp; &#125; if (num2 &gt; num3) &#123;//保证num3&gt;num2 temp = num2; num2 = num3; num3 = temp; &#125; System.out.println("这三个数从小到大排列：" + num1 + " " + num2 + " " + num3); scanner.close(); &#125;&#125; 运行结果： 123输入三个整数（用空格隔开）：3 2 1这三个数从小到大排列：1 2 3 【程序16】乘法口诀问题题目描述： 输出9*9口诀。 题目分析： 分行与列考虑，共9行9列，i控制行，j控制列。 表达式： i+&quot;*&quot;+j+&quot;=&quot;+i*j，这里要用两个for循环控制输出和换行。 代码实现： 12345678910111213141516package interview50;/** * @Auther: aimanyeye * @Date: 2019/8/19 07:19 */public class Interview16 &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(i + "*" + j + "=" + i * j + " ");//输出结果 &#125; System.out.println();//换行 &#125; &#125;&#125; 运行结果： 1234567891*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 【程序17】猴子吃桃问题问题题目描述： 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 题目分析： 采取逆向思维的方法，从后往前推断。 123天 数 1 2 3 4 5 。。。10桃子数 1 4 10 22 46 ？ 所以桃子数计算方法：前一天桃子数 * 2+2 代码实现： 123456789101112131415package interview50;/** * @Auther: aimanyeye * @Date: 2019/8/19 07:19 */public class Interview17 &#123; public static void main(String[] args) &#123; int sum = 1;//第一天桃子的数量 for (int i = 2; i &lt;= 10; i++) &#123;//第二天才开始计算 sum = sum * 2 + 2; &#125; System.out.println("猴子摘的桃子数为：" + sum); &#125;&#125; 运行结果： 1猴子摘的桃子数为：1534 【程序18】比赛问题题目描述： 两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。 题目分析： 关键是表达出：a说他不和x比，c说他不和x,z比。 代码实现： 12345678910111213141516171819package interview50;public class Interview18 &#123; public static void main(String[] args) &#123; char i, j, k; //i,j,k分别是a,b,c的对手 for(i = 'X'; i &lt;= 'Z'; i++)&#123; for(j = 'X'; j &lt;= 'Z'; j++)&#123; if(i != j)&#123; for(k = 'X'; k &lt; 'Z'; k++)&#123; if(i != k &amp;&amp; j != k)&#123; if(i != 'X' &amp;&amp; k != 'X' &amp;&amp; k != 'Z') System.out.printf("a -- %c\nb -- %c\nc -- %c", i, j, k); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 运行结果： 123a -- Zb -- Xc -- Y 【程序19】打印菱形问题题目描述： 打印出如下图案（菱形） 1234567 * *** ***** ******* ***** *** * 题目分析： 先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重 for循环，第一层控制行，第二层控制列。 详细分析第一部分图形的规律： （1）这是一个等腰三角形，*的打印次数1、3、5、7等差数列 （2）还要注意空格打印的 次数3、2、1、0逐渐递减 第二部分同理可得！ 代码实现： 123456789101112131415161718192021222324252627282930313233343536package interview50;/** * @Auther: aimanyeye * @Date: 2019/8/19 07:19 */public class Interview19 &#123; public static void main(String[] args) &#123; //打印上面部分： int n = 4; for (int i = 0; i &lt; n; i++) &#123; //控制行 for (int k = 3 - i; k &gt; 0; k--) &#123; //控制*前面空格的输出 System.out.print(" "); &#125; //输出符号，但不要换行 for (int j = 0; j &lt;= 2 * i; j++) &#123; //控制列 System.out.print("*"); &#125; //输出完符号马上换行 System.out.println(); &#125; //打印下面部分 n = 3; for (int i = n; i &gt; 0; i--) &#123; //控制行 for (int k = 3 - i + 1; k &gt; 0; k--) &#123; //控制*前面空格的输出,第一行要加空格 System.out.print(" "); &#125; //输出符号，但不要换行 for (int j = 0; j &lt;= 2 * i - 2; j++) &#123; //控制列 System.out.print("*"); &#125; //输出完符号马上换行 System.out.println(); &#125; &#125;&#125; 运行结果： 1234567 * *** ************ ***** *** * 【程序20】数列和问题题目描述： 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13… 求出这个数列的前20项之和。 题目分析： 请抓住分子与分母的变化规律。分数：fraction （1）第一项是2/1 （2）前面一项分子和分母相加的和，为下一项的分子 （3）前面一项分子，为下一项的分母 代码实现： 12345678910111213141516171819package interview50;public class Interview20&#123; public static void main(String[] args) &#123; float up=2;//分子 float down=1;//分母 float fraction = up/down;//分数 float temp = 0;//交换数 float sum = fraction;//总和 for(int i=1;i&lt;20;i++)&#123;//后面19项 temp = up+down;//先把分子分母的和赋值给一个交换数，不能马上赋值给分子，因为分子的值下面还有用 down = up;//把分子的值赋值给下一下的分母 up = temp;//把交换数的值赋值给下一项分子 fraction = up/down;//下一项的分数值 sum = sum+fraction;//分数相加 &#125; System.out.println(sum); &#125;&#125; 运行结果： 132.660263 【程序21】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序22】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序23】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序24】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序25】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序26】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序27】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序28】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序29】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序30】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序31】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序32】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序33】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序34】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序35】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序36】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序37】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序38】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序39】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序40】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序41】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序42】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序43】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序44】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序45】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序46】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序47】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序48】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序49】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12 【程序50】问题题目描述： 题目分析： 代码实现： 12 运行结果： 12]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>逻辑题</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>逻辑题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-GC垃圾回收算法篇]]></title>
    <url>%2F2019%2F08%2F16%2F2019-08-16-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[从2019年始，互联网公司大规模的缩招，裁员…..缩招不是不招聘，而是招聘更多更加优质的开发工程师，这对我们的要求更高了。这里整理了大厂高频的笔试面试题目。 一、JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots1、什么是垃圾？简单的说就是内存中已经不再使用到的空间就是垃圾。 2、要进行垃圾回收，如何判断一个对象是否可以被回收 （1）引用计数法：java中，引用和对象是由关联的。如果要操作对象则必须用引用进行。 因此很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收，简单说，给对象中添加一个引用计数器，每当有一个地方引用它，计数器加1，每当有一个引用失效时，计数器减1，任何时刻计数器数值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。 但是它很难解决对象之间相互循环引用的问题 JVM一般不采用这种实现方式。 （2）枚举根节点做可达性分析（跟搜索路径） 为了解决引用计数法的循环引用问题，java使用了可达性分析的方法。 所谓GC ROOT或者说Tracing GC的“根集合”就是一组比较活跃的引用。 基本思路就是通过一系列“GC Roots”的对象作为起始点，从这个被称为GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的对象就被判定为存活；没有被遍历到的就被判定为死亡。 3、哪些对象可以作为GC Roots对象 （1）虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中应用的对象。 （2）方法区中的类静态属性引用的对象 （3）方法区中常量引用的对象 （4）本地方法栈中（native方法）引用的对象 二、如何盘点查看JVM系统默认值1、JVM参数类型（1）标配参数 12-version-help 各个版本之间稳定，很少有很大的变化。 （2）x参数（了解） 123-Xint :解释执行-Xcomp：第一次使用就编译成本地代码-Xmixed：混合模式 （3）xx参数 如何解析两个经典参数：-Xms和-Xmx 2、如何查看运行中程序的JVM信息12345jps查看进程信息 jinfo -flag 配置项 进程号 jinfo -flags 进程号 //查看所有配置 （1）jps查看进程信息 （2）jinfo -flags 进程号 （3）jinfo -flag 配置项 进程号 3、查看JVM默认值（1）查看初始默认值 （2）查看修改更新 查看修改后的 ；:=说明是修改过的 （3）查看使用的垃圾回收器 -XX:+PrintCommandLineFlags 三、你平时工作用过的JVM常用基本配置参数有哪些（1）基础回顾： （2）常用参数: 经典参数设置： 1-Xms128m -Xmx4096m -Xss1024K -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC （3）输出详细GC收集日志信息 命令：-XX:+PrintGCDetails 输出：[名称：GC前内存占用-&gt;GC后内存占用(该区内存总大小)] GC Full GC （4）设置新生代中Eden和S0/S1空间的比例 默认-XX:SurvivorRatio=8,Eden:S0:S1=8:1:1 （5）设置年轻代与老年代在堆结构的占比 默认-XX:NewRatio=2 新生代在1，老年代2，年轻代占整个堆的1/3 （6）设置垃圾的最大年龄 默认-XX:MaxTenuringThreshold=15 （7）设置垃圾回收方式 123-XX:+UseSerialGC//串行垃圾回收器-XX:+UseParallelGC//并行垃圾回收器 四、强引用、软引用、弱引用、虚引用作用分别是什么整体架构： 1、强引用 Reference（默认支持模式）当内存不足，JVM开始垃圾回收，对于强引用对象，就算出现了OOM也不会堆该对象进行回收。 强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表面对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，他是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM也不会回收。因此强引用时造成java内存泄漏的主要原因之一。 对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式的将应用（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还是看垃圾收集策略）。 2、软引用 SoftReference软引用是一种相对强引用弱化了一些作用，需要用java.lang.ref.SOftReference类来实现，可以让对象豁免一些垃圾收集。 当系统内存充足时他不会被回收，当内存不足时会被回收。 软引用通常在对内存敏感的程序中，比如高速缓存就有用到软引用，内存足够的时候就保留，不够就回收。 3、弱引用 WeakReference弱引用需要用java.lang.ref.WeakReference类来实现，比软引用的生存期更短。 只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收。 软引用和弱引用的使用场景： 1Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;&gt;(); 谈谈WeakHashMap key是弱引用 4、虚引用PhantomReference弱引用需要用java.lang.ref.PhantomReference类来实现。 顾名思义，就是形同虚设，与其他几种引用不同，虚引用并不会决定对象的生命周期。 如果一个对象持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，他不能单独使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueeu)联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作 换句话说，设置虚引用关联的唯一目的，就是这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。 Java允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 引用队列Reference 创建引用的时候可以指定关联的队列，当gc释放对象内存的时候，会把引用加入到引用队列，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，相当于通知机制。 当关联的引用队列中有数据的时候，意味着引用指向的对内存中的对象被回收。通过这种方式，jvm允许我们在对象被小回收，做一些我们自己想做的事情。 总结： 五、请你谈谈对OOM的认识1、栈空间溢出 ，递归调用卡死java.lang.StackOverflowError 2、堆内存溢出 ， 对象过大java.lang.OutOfMemoryError:Java heap space 3、GC回收时间过长java.lang.OutOfMemoryError:GC overhead limit exceeded 程序在垃圾回收上花费了98%的时间，却收集不回2%的空间，通常这样的异常伴随着CPU的冲高。 1234567891011int i = 0;List&lt;String&gt; list = new ArrayList&lt;&gt;();try&#123; while(true)&#123; list.add(String.valueOf(++i).intern()); &#125;&#125;catch(Throwable e)&#123; System.out.println("********"); e.printStackTrace(); throw e;&#125; 4、执行内存挂了java.lang.OutOfMemoryError:Direct buffer memory 5、应用创建的线程数达到限制java.lang.OutOfMemoryError:unable to create new native thread 服务器级别参数调优： 6、元空间溢出java.lang.OutOfMemoryError:Metaspace 元空间主要存放了虚拟机加载的类的信息、常量池、静态变量、即时编译后的代码。 1234567891011121314151617181920212223static class OOMTest&#123;&#125;public static void main(String[] args)&#123; int i = 0; try&#123; while(true)&#123; i++; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMTest.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor()&#123; @Override public Object intercept(Object o,Method method,Object[] objects, MethodProxy methodProxy)throws Throwable&#123; return methodProxy.invokeSuper(o,args); &#125; &#125;); enhancer.create(); &#125; &#125; catch(Throwable e)&#123; System.out.println(i+"次后发生了异常"); e.printStackTrace(); &#125;&#125; 使用java -XX:+PrintFlagsInitial命令查看本机的初始化参数， XX:MetaspaceSize为21810376B（约20M） 六、GC垃圾回收算法和垃圾收集器的关系？分别是什么GC垃圾回收算法是内存回收的方法论，垃圾回收器就是算法的具体实现。 1、GC算法 引用计数 复制 标记清除 标记整理 2、4种主要垃圾收集器（1）Serial 串行回收：为单线程环境设计，并且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器环境。 （2）Paralle 并行回收：多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理等弱交互场景。 （3）CMS 并发标记清除：用户线程和垃圾回收线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程，互联网公司多用它，适用对响应时间有要求的场景。 （4）G1垃圾回收器：将堆内存分割成不同的区域然后并发的对其进行垃圾回收。 因为目前为止还没有完美的收集器出现，更加没有万能的收集器，只是针对具体应用选择最合适的收集器，进行分代收集。 七、怎么查看服务器默认的垃圾收集器是哪个？生产上如何配置垃圾收集器？1、怎么查看服务器默认的垃圾收集器是哪个？java -XX:+PrintCommandLinedFlags -version 2、默认的垃圾收集器有哪些？有七种：UseSerialGC UseParallelGC UseConcMarkSweepGC UseParNewGC UseParallelOldGC UseG1GC 八、谈谈你对垃圾收集器的理解？1、部分参数说明（1）DefNew：Default New Generation （2）Tenured：Old （3）ParNew：Parallel New Generation （4）PSYoungGen：Parallel Scavenge （5）ParOldGen：Parallel Old Generation 2、Server/Client模式分别是什么意思（1）适用范围：只需要掌握Server模式即可，Client模式基本不会用。 （2）操作系统： 32位Window操作系统，不论硬件如何都默认使用Client的JVM模式 32位其他操作系统，2G内存同时有2个cpu以上用Server模式，低于该配置还是Client模式 64位only server模式 3、新生代（1）串行GC (Serial)/(Serial Copying) （2）并行GC (ParNew) （3）并行回收GC (Parallel)/(Parallel Scavenge) 4、老年代（1）串行回收GC（Serial Old）/（Serial MSC） （2）并行GC（Parallel Old）/（Parallel MSC） （3）并发标记清除GC（CMS） 4步过程： 初始标记（CMS initial mark） 只是标记一下GC Roots能够直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记（CMS concurrent mark） 和用户线程一起，进行GC Roots跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象 重新标记（CMS remark） 为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正 并发清除（CMS concurrent sweep） 和用户线程一起，清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象 由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上看来CMS收集器的内存回收和用户线程是一起并发的执行。 优缺点： 并发收集低停顿 并发执行，cpu资源压力大 由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将出发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。 采用的标记清除算法会导致大量的碎片 标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制堆堆内存进行压缩。CMS也提供了参数==-XX:CMSFullGCsBeForeCompaction==(默认0，即每次都进行内存整理)来制定多少次CMS收集之后，进行一次压缩的FullGC。 5、如何选择垃圾选择器 九、G1垃圾收集器将堆内存分割城不同的区域然后并发的对其进行垃圾回收。 1、其他收集器特点 年轻代和老年代是各自独立且了连续的内存块 年轻代收集使用单eden+S0+S1进行复制算法 老年代收集必须扫描真个老年代区域 都是以尽可能少而快速地执行GC为设计原则 2、G1是什么 特点： 3、底层原理（1）Region区域化垃圾收集器 最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可。 （2）回收步骤 （3）4步过程 4、case案例 5、常用配置参数（了解） 6、和CMS相比优势（1）G1不会产生内存碎片。 （2）可以精确控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每根据允许停顿的时间去收集垃圾最多的区域。 十、对于JDK自带的JVM监控和性能分析工具你用过那些？一般怎么用？]]></content>
      <categories>
        <category>Java面试</category>
        <category>GC垃圾回收算法</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>GC垃圾回收算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode第1号问题-两数之和]]></title>
    <url>%2F2019%2F08%2F13%2F2019-08-13-LeetCode%E7%AC%AC1%E5%8F%B7%E9%97%AE%E9%A2%98-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目来源于 LeetCode 上第 1 号问题：两数之和。题目难度为 Easy，目前通过率为 45.8% 。 题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 题目解析使用查找表来解决该问题。 设置一个 map 容器 record 用来记录元素的值与索引，然后遍历数组 nums。 每次遍历时使用临时变量 complement 用来保存目标值与当前值的差值 在此次遍历中查找 record ，查看是否有与 complement 一致的值，如果查找成功则返回查找值的索引值与当前变量的值 i 如果未找到，则在 record 保存该元素与索引值 i 图解过程 代码实现12345678910111213141516/* *[1]两数之和 */class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer-旋转数组的最小数字]]></title>
    <url>%2F2019%2F08%2F13%2F2019-08-13-%E5%89%91%E6%8C%87Offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目来源于 剑指Offer：旋转数组的最小数字。考点：查找和排序，目前通过率为 32.17%。 题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0，1，2，4，5，6，7] 可能变为 [4，5，6，7，0，1，2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 123输入: [3，4，5，1，2]输出: 1 示例 2: 123输入: [4，5，6，7，0，1，2]输出: 0 题目解析最直接的方法是使用 暴力法：搜索整个数组，找到其中的最小元素，这样的时间复杂度是 O(N)，其中 N 是给定数组的大小。 这道题目可以使用 二分搜索 的思想进行解决。 找到数组的中间元素 mid。 如果中间元素 &gt; =数组第 high 个元素，则在 mid 右边搜索变化点。 如果中间元素 &lt; 数组第 high 个元素，则在 mid 左边搜索变化点。 图解过程 代码实现12345678910111213141516171819202122/* *[1]旋转数组的最小数字 */public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array == null || array.length==0)//给出的所有元素都大于0，若数组大小为0，请返回0。 return 0; int low = 0; int high = array.length - 1; while(low &lt; high)&#123; if(array[low] &lt; array[high]) return array[low]; int mid = (low+high)/2; if(array[mid]&gt;=array[high])&#123;//（1）如果中间元素 &gt;= 数组第 high 个元素， low = mid + 1;//则在 mid 右边搜索变化点。 &#125;else&#123;//（2）如果中间元素 &lt; 数组第 high 个元素， high = mid;//则在 mid 左边搜索变化点。 &#125; &#125; return array[low]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-JUC多线程及并发包篇]]></title>
    <url>%2F2019%2F08%2F13%2F2019-08-13-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-JUC%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%B9%B6%E5%8F%91%E5%8C%85%E7%AF%87%2F</url>
    <content type="text"><![CDATA[从2019年始，互联网公司大规模的缩招，裁员…..缩招不是不招聘，而是招聘更多更加优质的开发工程师，这对我们的要求更高了。这里整理了大厂高频的笔试面试题目。 一、请你谈谈对volatile的理解1、volatile是java虚拟机提供的轻量级的同步机制保证可见性、不保证原子性、禁止指令重排 （1）保证可见性 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。 当不添加volatile关键字时示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.concurrent.TimeUnit;/** * 1验证volatile的可见性 * 1.1 如果int num = 0，number变量没有添加volatile关键字修饰 * 1.2 添加了volatile，可以解决可见性 */public class VolatileDemo &#123; public static void main(String[] args) &#123; visibilityByVolatile();//验证volatile的可见性 &#125; /** * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改 */ public static void visibilityByVolatile() &#123; MyData myData = new MyData(); //第一个线程 new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "\t come in"); try &#123; //线程暂停3s TimeUnit.SECONDS.sleep(3); myData.addToSixty(); System.out.println(Thread.currentThread().getName() + "\t update value:" + myData.num); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;, "thread1").start(); //第二个线程是main线程 while (myData.num == 0) &#123; //如果myData的num一直为零，main线程一直在这里循环 &#125; System.out.println(Thread.currentThread().getName() + "\t mission is over, num value is " + myData.num); &#125;&#125;class MyData &#123; // int num = 0; volatile int num = 0; public void addToSixty() &#123; this.num = 60; &#125;&#125; 输出结果： 123thread1 come inthread1 update value:60//线程进入死循环 当我们加上volatile关键字后，volatile int num = 0;输出结果为： 1234thread1 come inthread1 update value:60main mission is over, num value is 60//程序没有死循环，结束执行 （2）不保证原子性 原子性：不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败。 验证示例（变量添加volatile关键字，方法不添加synchronized）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;/** * 1验证volatile的可见性 * 1.1 如果int num = 0，number变量没有添加volatile关键字修饰 * 1.2 添加了volatile，可以解决可见性 * * 2.验证volatile不保证原子性 * 2.1 原子性指的是什么 * 不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败 */public class VolatileDemo &#123; public static void main(String[] args) &#123;// visibilityByVolatile();//验证volatile的可见性 atomicByVolatile();//验证volatile不保证原子性 &#125; /** * volatile可以保证可见性，及时通知其他线程，主物理内存的值已经被修改 */ //public static void visibilityByVolatile()&#123;&#125; /** * volatile不保证原子性 * 以及使用Atomic保证原子性 */ public static void atomicByVolatile()&#123; MyData myData = new MyData(); for(int i = 1; i &lt;= 20; i++)&#123; new Thread(() -&gt;&#123; for(int j = 1; j &lt;= 1000; j++)&#123; myData.addSelf(); myData.atomicAddSelf(); &#125; &#125;,"Thread "+i).start(); &#125; //等待上面的线程都计算完成后，再用main线程取得最终结果值 try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while (Thread.activeCount()&gt;2)&#123; Thread.yield(); &#125; System.out.println(Thread.currentThread().getName()+"\t finally num value is "+myData.num); System.out.println(Thread.currentThread().getName()+"\t finally atomicnum value is "+myData.atomicInteger); &#125;&#125;class MyData &#123; // int num = 0; volatile int num = 0; public void addToSixty() &#123; this.num = 60; &#125; public void addSelf()&#123; num++; &#125; AtomicInteger atomicInteger = new AtomicInteger(); public void atomicAddSelf()&#123; atomicInteger.getAndIncrement(); &#125;&#125; 执行三次结果为： 12345678910//1.main finally num value is 19580 main finally atomicnum value is 20000//2.main finally num value is 19999main finally atomicnum value is 20000//3.main finally num value is 18375main finally atomicnum value is 20000//num并没有达到20000 （3）禁止指令重排 有序性：在计算机执行程序时，为了提高性能，编译器和处理器常常会对指令做重拍，一般分以下三种： 单线程环境里面能确保程序最终执行结果和代码顺序执行的结果一致. 处理器在进行重排顺序是必须要考虑指令之间的数据依赖性 多线程环境中线程交替执行,由于编译器优化重排的存在,两个线程使用的变量能否保持一致性是无法确定的,结果无法预测 重排代码实例： 声明变量：int a,b,x,y=0 线程1 线程2 x = a; y = b; b = 1; a = 2; 结 果 x = 0 y=0 如果编译器对这段程序代码执行重排优化后，可能出现如下情况： 线程1 线程2 b = 1; a = 2; x= a; y = b; 结 果 x = 2 y=1 这个结果说明在多线程环境下，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。 volatile实现禁止指令重排，从而避免了多线程环境下程序出现乱序执行的现象。 先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，他的作用有两个： 一是保证特定操作的执行顺序 二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性） 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排顺序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。 2、JMM（java内存模型）JMM（Java Memory Model）本身是一种抽象的概念，并不真实存在，他描述的时一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。 JMM关于同步的规定： （1）线程解锁前，必须把共享变量的值刷新回主内存 （2）线程加锁前，必须读取主内存的最新值到自己的工作内存 （3）加锁解锁时同一把锁 由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值) 必须通过主内存来完成,其简要访问过程如下图: （1）可见性 通过上面对JMM的介绍,我们知道 各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的. 这就可能存在一个线程AAA修改了共享变量X的值还未写回主内存中时 ,另外一个线程BBB又对内存中的一个共享变量X进行操作,但此时A线程工作内存中的共享比那里X对线程B来说并不不可见.这种工作内存与主内存同步延迟现象就造成了可见性问题. （2）原子性 number++在多线程下是非线程安全的，如何不加synchronized解决？ 可以用原子类。 （3）有序性 一个重排案例： 123456789101112131415161718public void mySort()&#123; int x=11;//语句1 int y=12;//语句2 x=x+5;//语句3 y=x*x;//语句4&#125;可能顺序：123421341324 问题：请问语句4 可以重排后变成第一条码? 存在数据的依赖性 没办法排到第一个。 3、你在那些地方用过volatile当普通单例模式在多线程情况下： 12345678910111213141516171819202122232425262728public class SingletonDemo &#123; private static SingletonDemo instance = null;////无volatile private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + "\t 构造方法SingletonDemo（）"); &#125; public static SingletonDemo getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; return instance; &#125; public static void main(String[] args) &#123; //构造方法只会被执行一次// System.out.println(getInstance() == getInstance());// System.out.println(getInstance() == getInstance());// System.out.println(getInstance() == getInstance()); //并发多线程后，构造方法会在一些情况下执行多次 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, "Thread " + i).start(); &#125; &#125;&#125; 存在问题：其构造方法在一些情况下会被执行多次 解决方式：DCL （Double Check Lock双端检锁机制）在加锁前和加锁后都进行一次判断 1234567891011121314/** * 双重检测机制 * @return */public static SingletonDemo getInstance()&#123; if(instance==null)&#123; synchronized (SingletonDemo.class)&#123; if(instance==null)&#123; instance=new SingletonDemo(); &#125; &#125; &#125; return instance;&#125; DCL（双端检锁）机制不一定线程安全，原因时有指令重排的存在，加入volatile可以禁止指令重排。 原因在于某一个线程在执行到第一次检测,读取到的instance不为null时,instance的引用对象可能没有完成初始化。 12345instance=new SingletonDem(); 可以分为以下步骤(伪代码)memory=allocate();//1.分配对象内存空间instance(memory);//2.初始化对象instance=memory;//3.设置instance的指向刚分配的内存地址,此时instance!=null 步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的，如果3步骤提前于步骤2，但是instance还没有初始化完成。 123memory=allocate();//1.分配对象内存空间instance=memory;//3.设置instance的指向刚分配的内存地址,此时instance!=null 但对象还没有初始化完.instance(memory);//2.初始化对象 但是指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。 所以当一条线程访问instance不为null时，由于instance示例未必已初始化完成，也就造成了线程安全问题。 即可能出现这样的情况：线程2在线程1完成对象的初始化之前就可能得到了对象的引用。从而可能会造成未知的错误（如：会造成数据丢失的情况。线程B获取的对象中a的值是0，而不是20，因为还没初始化对象） 为解决以上问题，可以将SingletongDemo实例上加上volatile 1private static volatile SingletonDemo instance = null; 二、CAS你知道吗1、什么是CAS? compareAndSet—-比较并交换AtomicInteger.conpareAndSet(int expect, indt update) 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 第一个参数为拿到的期望值，如果期望值没有一致，进行update赋值，如果期望值不一致，证明数据被修改过，返回fasle，取消赋值 例子： 1234567891011121314151617import java.util.concurrent.atomic.AtomicInteger;/** * 1.CAS是什么？ ===&gt; compareAndSet * 1.1比较并交换 */public class CASDemo &#123; public static void main(String[] args) &#123; checkCAS(); &#125; public static void checkCAS()&#123; AtomicInteger atomicInteger = new AtomicInteger(5); System.out.println(atomicInteger.compareAndSet(5, 2019) + "\t current data is " + atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(5, 2014) + "\t current data is " + atomicInteger.get()); &#125;&#125; 输出结果为： 12true current data is 2019false current data is 2019 2、CAS底层原理？如果知道，谈谈你对对Unsafe的理解比较当前工作内存中的值和主内存中的值，如果相同，则执行规定操作，否则继续比较直到主内存和工作内存中的值一致为止。 AtomicInteger.getAndIncrement() 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; （1）ValueOffset是什么？ 变量ValueOffset,便是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的。 （2）UnSafe类是什么? UnSafe类是CAS的核心类 由于Java 方法无法直接访问底层 ,需要通过本地(native)方法来访问,UnSafe相当于一个后面,基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中,其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法. 注意：UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务。 变量value用volatile修饰，保证多线程之间的可见性。 （3）CAS是什么？ CAS全称呼Compare-And-Swap，它是一条CPU并发原语。 它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。 CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。这是一种完全依赖于硬件的功能，通过他实现了原子操作。由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题。 12345678//unsafe.getAndAddIntpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 1234567var1 AtomicInteger对象本身.var2 该对象值的引用地址var4 需要变动的数值var5 是用过var1 var2找出内存中真实的值用该对象当前的值与var5比较如果相同,更新var5的值为var5+var4 并且返回true如果不同,继续取值然后比较,直到更新完成 假设线程A和线程B两个线程同时执行getAndAddInt操作(分别在不同的CPU上): （1）AtomicInteger里面的value原始值为3,即主内存中AtomicInteger的value为3,根据JMM模型,线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存. （2）线程A通过getIntVolatile(var1,var2) 拿到value值3,这时线程A被挂起. （3）线程B也通过getIntVolatile(var1,var2) 拿到value值3,此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存中的值也是3 成功修改内存的值为4 线程B打完收工 一切OK. （4）这是线程A恢复,执行compareAndSwapInt方法比较,发现自己手里的数值和内存中的数字4不一致,说明该值已经被其他线程抢先一步修改了,那A线程修改失败,只能重新来一遍了. （5）线程A重新获取value值,因为变量value是volatile修饰,所以其他线程对他的修改,线程A总是能够看到,线程A继续执行compareAndSwapInt方法进行比较替换,直到成功. 3、CAS缺点（1）循环时间长，开销大 例如getAndAddInt方法执行，有个do while循环，如果CAS失败，一直会进行尝试，如果CAS长时间不成功，可能会给CPU带来很大的开销。 （2）只能保证一个共享变量的原子操作 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。 （3）会引起ABA问题 三、谈谈原子类AtomicInteger的ABA问题？原子更新引用知道吗？1、ABA问题如何产生CAS算法实现一个重要前提需要去取内存中某个时刻的数据并在当下时刻比较并替换，那么在这个时间差内会导致数据的变化。 比如线程1从内存位置V取出A，线程2同时也从内存取出A，并且线程2进行一些操作将值改为B，然后线程2又将V位置数据改成A，这时候线程1进行CAS操作发现内存中的值依然时A，然后线程1操作成功。 尽管线程1的CAS操作成功，但是不代表这个过程没有问题。 2、原子引用原子引用： 123456789101112131415161718192021222324import lombok.AllArgsConstructor;import lombok.Getter;import lombok.ToString;import java.util.concurrent.atomic.AtomicReference;public class AtomicRefrenceDemo &#123; public static void main(String[] args) &#123; User z3 = new User("张三", 22); User l4 = new User("李四", 23); AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;(); atomicReference.set(z3); System.out.println(atomicReference.compareAndSet(z3, l4) + "\t" + atomicReference.get().toString()); System.out.println(atomicReference.compareAndSet(z3, l4) + "\t" + atomicReference.get().toString()); &#125;&#125;@Getter@ToString@AllArgsConstructorclass User &#123; String userName; int age;&#125; 输出结果 12true User(userName=李四, age=23)false User(userName=李四, age=23) 3、时间戳的原子引用ABA问题： 如何解决ABA问题？ 新增机制，修改版本号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.AtomicStampedReference;/** * ABA问题解决 * AtomicStampedReference */public class ABADemo &#123; static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100); static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1); public static void main(String[] args) &#123; System.out.println("=====以下时ABA问题的产生====="); new Thread(() -&gt; &#123; atomicReference.compareAndSet(100, 101); atomicReference.compareAndSet(101, 100); &#125;, "Thread 1").start(); new Thread(() -&gt; &#123; try &#123; //保证线程1完成一次ABA操作 TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(atomicReference.compareAndSet(100, 2019) + "\t" + atomicReference.get()); &#125;, "Thread 2").start(); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("=====以下时ABA问题的解决====="); new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + "\t第1次版本号" + stamp); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(Thread.currentThread().getName() + "\t第2次版本号" + atomicStampedReference.getStamp()); atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1); System.out.println(Thread.currentThread().getName() + "\t第3次版本号" + atomicStampedReference.getStamp()); &#125;, "Thread 3").start(); new Thread(() -&gt; &#123; int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + "\t第1次版本号" + stamp); try &#123; TimeUnit.SECONDS.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1); System.out.println(Thread.currentThread().getName() + "\t修改是否成功" + result + "\t当前最新实际版本号：" + atomicStampedReference.getStamp()); System.out.println(Thread.currentThread().getName() + "\t当前最新实际值：" + atomicStampedReference.getReference()); &#125;, "Thread 4").start(); &#125;&#125; 输出结果： 123456789=====以下时ABA问题的产生=====true 2019=====以下时ABA问题的解决=====Thread 3 第1次版本号1Thread 4 第1次版本号1Thread 3 第2次版本号2Thread 3 第3次版本号3Thread 4 修改是否成功false 当前最新实际版本号：3Thread 4 当前最新实际值：100 四、我们知道ArrayList是线程不安全的，请编写一个不安全的案例并给出解决方案HashSet与ArrayList一致 HashMap HashSet底层是一个HashMap，存储的值放在HashMap的key里，value存储了一个PRESENT的静态Object对象 1、线程不安全123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.List;import java.util.UUID;/** * 集合类不安全问题 * ArrayList */public class ContainerNotSafeDemo &#123; public static void main(String[] args) &#123; notSafe(); &#125; /** * 故障现象 * java.util.ConcurrentModificationException */ public static void notSafe() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 30; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;, "Thread " + i).start(); &#125; &#125;&#125; 报错： 1Exception in thread "Thread 10" java.util.ConcurrentModificationException 2、导致原因并发正常修改导致，一个人正在写入，另一个同学来抢夺，导致数据不一致，并发修改异常。 3、解决方法：CopyOnWriteArrayList123456List&lt;String&gt; list = new Vector&lt;&gt;();//Vector线程安全List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());//使用辅助类List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();//list线程 写时复制，读写分离Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;()); CopyOnWrite容器即写时复制，往一个元素添加容器的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy，复制出一个新的容器Object[] newElements，让后新的容器添加元素，添加完元素之后，再将原容器的引用指向新的容器setArray(newElements),这样做可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 CopyOnWriteArrayList.add方法： 1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 限制不可以使用vector和Collections工具类时候的解决方案： 123List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();//list线程 写时复制，读写分离HashSet&lt;String,String&gt; set = new CopyOnWriteHashSet&lt;&gt;();//set线程 写时复制，读写分离Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;();//map线程 写时复制，读写分离 五、公平锁、非公平锁、可重入锁、递归锁、自旋锁谈谈你的理解？请手写一个自旋锁1、公平锁和非公平锁（1）是什么 公平锁就是先来后到，是指多个线程按照申请锁的顺序来获取锁，类似排队打饭先来后到。 非公平锁就是允许加塞，是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象。 Lock lock = new ReentrantLock(Boolean fair); 默认非公平。 并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁。 （2）两者区别 公平锁：Threads acquire a fair lock in the order in which they requested it 公平锁，就是很公平，在并发环境中，每个线程在获取锁时，会先查看此锁维护的等待队列，如果为空，或者当前线程就是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。 非公平锁：a nonfair lock permits barging: threads requesting a lock can jump ahead of the queue of waiting threads if the lock happens to be available when it is requested. 非公平锁比较粗鲁，上来就直接尝试占有额，如果尝试失败，就再采用类似公平锁那种方式。 对于Java ReentrantLock而言，通过构造函数指定该锁是否公平，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大。 对于synchronized而言，也是一种非公平锁。 2、可重入锁（递归锁）（1）可重入锁（递归锁）是什么 指的时同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。 （2）ReentrantLock/Synchronized 就是一个典型的可重入锁 （3）可重入锁最大的作用是避免死锁 （4）代码示例 例子1： 123456789101112131415161718192021222324252627282930313233343536373839/** * Description: * 可重入锁(也叫做递归锁) * 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码 * 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁 * * 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块 * **/public class ReenterLockDemo &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); new Thread(() -&gt; &#123; try &#123; phone.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "Thread 1").start(); new Thread(() -&gt; &#123; try &#123; phone.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "Thread 2").start(); &#125;&#125;class Phone&#123;//Synchronized 就是一个典型的可重入锁 public synchronized void sendSMS()throws Exception&#123; System.out.println(Thread.currentThread().getName()+"\t -----invoked sendSMS()"); Thread.sleep(3000); sendEmail(); &#125; public synchronized void sendEmail() throws Exception&#123; System.out.println(Thread.currentThread().getName()+"\t +++++invoked sendEmail()"); &#125;&#125; 输出结果： 1234Thread 1 -----invoked sendSMS()Thread 1 +++++invoked sendEmail()Thread 2 -----invoked sendSMS()Thread 2 +++++invoked sendEmail() 例子2： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Description: * 可重入锁(也叫做递归锁) * 指的是同一先生外层函数获得锁后,内层敌对函数任然能获取该锁的代码 * 在同一线程外外层方法获取锁的时候,在进入内层方法会自动获取锁 * * 也就是说,线程可以进入任何一个它已经标记的锁所同步的代码块 * **/public class ReentrantLockDemo &#123; public static void main(String[] args) &#123; Mobile mobile = new Mobile(); new Thread(mobile).start(); new Thread(mobile).start(); &#125;&#125;class Mobile implements Runnable&#123; Lock lock = new ReentrantLock();//ReentrantLock就是一个典型的可重入锁 @Override public void run() &#123; get(); &#125; public void get() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName()+"\t invoked get()"); set(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void set()&#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName()+"\t invoked set()"); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 输出结果： 1234Thread-0 invoked get()Thread-0 invoked set()Thread-1 invoked get()Thread-1 invoked set() 3、自旋锁自旋锁（spinlock） 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 手写一个自旋锁： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package lock;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;/** * 实现自旋锁 * 自旋锁好处，循环比较获取知道成功位置，没有类似wait的阻塞 * * 通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到 */public class SpinLockDemo &#123; public static void main(String[] args) &#123; SpinLockDemo spinLockDemo = new SpinLockDemo(); new Thread(() -&gt; &#123; spinLockDemo.mylock(); try &#123; TimeUnit.SECONDS.sleep(5); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; spinLockDemo.myUnlock(); &#125;, "Thread 1").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; new Thread(() -&gt; &#123; spinLockDemo.mylock(); spinLockDemo.myUnlock(); &#125;, "Thread 2").start(); &#125; //原子引用线程 AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void mylock() &#123; Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + "\t come in"); while (!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; public void myUnlock() &#123; Thread thread = Thread.currentThread(); atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName()+"\t invoked myunlock()"); &#125;&#125; 运行结果： 1234Thread 1 come inThread 2 come inThread 1 invoked myunlock()Thread 2 invoked myunlock() 4、独占锁(写锁)/共享锁(读锁)/互斥锁（1）概念 独占锁：指该锁一次只能被一个线程所持有，对ReentrantLock和Synchronized而言都是独占锁。 共享锁：只该锁可被多个线程所持有ReentrantReadWriteLock其读锁是共享锁，写锁是独占锁。 互斥锁：读锁的共享锁可以保证并发读是非常高效的，读写、写读、写写的过程是互斥的。 （2）代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package lock;import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 多个线程同时读一个资源类没有任何问题，所以为了满足并发量， * 读取共享资源应该可以同时进行。 * 但是 * 如果有一个线程象去写共享资源，就不应该有其他线程可以对资源进行读或写 * 总结 * 读读能共存 * 读写不能共存 * 写写不能共存 */public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); for (int i = 1; i &lt;= 5; i++) &#123; final int tempInt = i; new Thread(() -&gt; &#123; myCache.put(tempInt + "", tempInt + ""); &#125;, "Thread " + i).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; final int tempInt = i; new Thread(() -&gt; &#123; myCache.get(tempInt + ""); &#125;, "Thread " + i).start(); &#125; &#125;&#125;/** * 资源类 */class MyCache &#123; /** * 保证可见性 */ private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); /** * 写操作：原子+独占 * 整个过程必须是一个完整的统一体，中间不许被分割，不许被打断 * * @param key * @param value */ public void put(String key, Object value) &#123; rwLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + "\t正在写入：" + key); TimeUnit.MILLISECONDS.sleep(300);//模拟网络延时 map.put(key, value); System.out.println(Thread.currentThread().getName() + "\t写入完成"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; rwLock.writeLock().unlock(); &#125; &#125; /** * 读 * */ public void get(String key) &#123; rwLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + "\t正在读取：" + key); TimeUnit.MILLISECONDS.sleep(3000);//模拟网络延时 Object result = map.get(key); System.out.println(Thread.currentThread().getName() + "\t读取完成: " + result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; rwLock.readLock().unlock(); &#125; &#125; public void clear() &#123; map.clear(); &#125;&#125; 运行结果： 1234567891011121314151617181920Thread 1 正在写入：1Thread 1 写入完成Thread 3 正在写入：3Thread 3 写入完成Thread 2 正在写入：2Thread 2 写入完成Thread 4 正在写入：4Thread 4 写入完成Thread 5 正在写入：5Thread 5 写入完成Thread 1 正在读取：1Thread 2 正在读取：2Thread 4 正在读取：4Thread 5 正在读取：5Thread 3 正在读取：3Thread 3 读取完成: 3Thread 2 读取完成: 2Thread 1 读取完成: 1Thread 4 读取完成: 4Thread 5 读取完成: 5 六、CountDownLatch/CyclicBarrier/Semaphore使用过吗？1、CountDownLatch（火箭发射倒计时）（1）它允许一个或多个线程一直阻塞等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 （2）CountDownLatch主要有两个方法，当一个或多个线程调用await()方法时，调用线程会被阻塞。其他线程调用countDown()方法会将计数器减1（调用countDown()方法时线程不会阻塞），当计数器的值变为0时，因调用await()方法被阻塞的线程才会被唤醒，继续执行。 （3）代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package conditionThread;/** * Description * 枚举的使用 * **/public enum CountryEnum &#123; /** * */ ONE(1, "齐"), /** * */ TWO(2, "楚"), /** * */ THREE(3, "燕"), /** * */ FOUR(4, "赵"), /** * */ FIVE(5, "魏"), /** * */ SIX(6, "韩"); CountryEnum(Integer code, String name) &#123; this.code = code; this.name = name; &#125; private Integer code; private String name; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public static CountryEnum forEach(int index) &#123; CountryEnum[] countryEnums = CountryEnum.values(); for (CountryEnum countryEnum : countryEnums) &#123; if (index == countryEnum.getCode()) &#123; return countryEnum; &#125; &#125; return null; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package conditionThread;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; closeDoor(); //countDownLatchTest(); &#125; public static void closeDoor() throws InterruptedException&#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+"\t上完自习，离开教室"); countDownLatch.countDown(); &#125;, "Thread--&gt;"+i).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName()+"\t=====班长最后关门走人"); &#125; public static void countDownLatchTest() throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 1; i &lt;= 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName()+"\t被灭"); countDownLatch.countDown(); &#125;, CountryEnum.forEach(i).getName()).start(); &#125; countDownLatch.await(); System.out.println(Thread.currentThread().getName()+"\t=====秦统一"); &#125;&#125; 运行结果： 1234567Thread--&gt;1 上完自习，离开教室Thread--&gt;2 上完自习，离开教室Thread--&gt;3 上完自习，离开教室Thread--&gt;4 上完自习，离开教室Thread--&gt;6 上完自习，离开教室Thread--&gt;5 上完自习，离开教室main =====班长最后关门走人 运行结果： 1234567齐 被灭燕 被灭楚 被灭赵 被灭魏 被灭韩 被灭main =====秦统一 2、CyclicBarrier（集齐七颗龙珠召唤神龙）（1）CycliBarrier CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CycliBarrier的await()方法。 （2）代码示例： 1234567891011121314151617181920212223242526272829package conditionThread;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierDemo &#123; public static void main(String[] args) &#123; cyclicBarrierTest(); &#125; public static void cyclicBarrierTest() &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println("====召唤神龙====="); &#125;); for (int i = 1; i &lt;= 7; i++) &#123; final int tempInt = i; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "\t收集到第" + tempInt + "颗龙珠"); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, "" + i).start(); &#125; &#125;&#125; 运行结果： 123456782 收集到第2颗龙珠3 收集到第3颗龙珠1 收集到第1颗龙珠6 收集到第6颗龙珠5 收集到第5颗龙珠7 收集到第7颗龙珠4 收集到第4颗龙珠====召唤神龙===== 3、Semaphore信号量信号量可以代替Synchronize和Lock。 （1）信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。 （2）代码示例： 12345678910111213141516171819202122232425262728package conditionThread;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class SemaphoreDemo &#123; public static void main(String[] args) &#123; Semaphore semaphore = new Semaphore(3);//模拟三个停车位 for (int i = 1; i &lt;= 6; i++) &#123;//模拟6部汽车 new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + "\t抢到车位"); try &#123; TimeUnit.SECONDS.sleep(3);//停车3s &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "\t停车3s后离开车位"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;, "Car " + i).start(); &#125; &#125;&#125; 运行结果： 123456789101112Car 2 抢到车位Car 3 抢到车位Car 1 抢到车位Car 1 停车3s后离开车位Car 2 停车3s后离开车位Car 3 停车3s后离开车位Car 6 抢到车位Car 4 抢到车位Car 5 抢到车位Car 4 停车3s后离开车位Car 5 停车3s后离开车位Car 6 停车3s后离开车位 七、阻塞队列知道吗？ ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序 LinkedBlockingQueue是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue SynchronousQueue是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue 1、队列和阻塞队列（1）阻塞队列,顾名思义,首先它是一个队列,而一个阻塞队列在数据结构中所起的作用大致如图所示: 线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素。 当阻塞队列是空是，从队列中获取元素的操作会被阻塞。 当阻塞队列是满时，从队列中添加元素的操作会被阻塞。 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。 试图往已满的阻塞队列中添加新元素的线程同样会被阻塞，直到其他的线程从列中移除一个或者多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。 2、为什么用？有什么好处？（1）在多线程领域：所谓阻塞，在某些情况下会挂起线程，一旦满足条件，被挂起的线程又会自动被唤醒。 （2）为什么需要BlockingQueue 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。 在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己控制这些细节，尤其还要兼顾效率和线程安全，而这回给我们程序带来不小的复杂度。 3、BlockingQueue的核心方法 方法类型 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e,time,unit) 移除 remove() poll() take poll(time,unit) 检查 element() peek() 不可用 不可用 方法类型 status 抛出异常 当阻塞队列满时，再往队列中add会抛IllegalStateException: Queue full；当阻塞队列空时，再往队列里remove会抛NoSuchElementException 特殊值 插入方法，成功true失败false；移除方法，成功返回出队列的元素，队列里没有就返回null 一直阻塞 当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞线程知道put数据或响应中断退出；当阻塞队列空时，消费者线程试图从队列take元素，队列会一直阻塞消费者线程知道队列可用。 超时退出 当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出。 4、架构梳理+种类分析（1）种类分析 ArrayBlockingQueue:由数据结构组成的有界阻塞队列。 LinkedBlockingQueue:由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE)阻塞队列。 PriorityBlockingQueue:支持优先级排序的无界阻塞队列。 DelayQueue:使用优先级队列实现的延迟无界阻塞队列。 SychronousQueue:不存储元素的阻塞队列，也即单个元素的队列。 LinkedTransferQueue:由链表结构组成的无界阻塞队列。 LinkedBlockingDeque:由历览表结构组成的双向阻塞队列。 （2）SychronousQueue 理论：SynchronousQueue没有容量，与其他BlockingQueue不同，SychronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package queue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * 阻塞队列SynchronousQueue演示 * ArrayBlockingQueue是一个基于数组结构的有界阻塞队列，此队列按FIFO原则对元素进行排序 * LinkedBlockingQueue是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue * SynchronousQueue是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 * 1.队列 * 2.阻塞队列 * 2.1 阻塞队列有没有好的一面 * 2.2 不得不阻塞，你如何管理 */public class SynchronousQueueDemo &#123; public static void main(String[] args) throws InterruptedException &#123; BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + "\t put 1"); blockingQueue.put("1"); System.out.println(Thread.currentThread().getName() + "\t put 2"); blockingQueue.put("2"); System.out.println(Thread.currentThread().getName() + "\t put 3"); blockingQueue.put("3"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "AAA").start(); new Thread(() -&gt; &#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "\ttake " + blockingQueue.take()); TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "\ttake " + blockingQueue.take()); TimeUnit.SECONDS.sleep(5); System.out.println(Thread.currentThread().getName() + "\ttake " + blockingQueue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, "BBB").start(); &#125;&#125; 运行结果： 123456AAA put 1BBB take 1AAA put 2BBB take 2AAA put 3BBB take 3 5、用在哪里（1）生产者消费者模式 传统版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 一个初始值为零的变量，两个线程对其交替操作，一个加1一个减1，来5轮 * 1. 线程 操作 资源类 * 2. 判断 干活 通知 * 3. 防止虚假唤起机制 */public class ProdConsumer_TraditionDemo &#123; public static void main(String[] args) &#123; ShareData shareData = new ShareData(); for (int i = 1; i &lt;= 5; i++) &#123; new Thread(() -&gt; &#123; try &#123; shareData.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "ProductorA " + i).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; new Thread(() -&gt; &#123; try &#123; shareData.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "ConsumerA " + i).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; new Thread(() -&gt; &#123; try &#123; shareData.increment(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "ProductorB " + i).start(); &#125; for (int i = 1; i &lt;= 5; i++) &#123; new Thread(() -&gt; &#123; try &#123; shareData.decrement(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "ConsumerB " + i).start(); &#125; &#125;&#125;class ShareData &#123;//资源类 private int number = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void increment() throws Exception &#123; lock.lock(); try &#123; //1.判断 while (number != 0) &#123; //等待不能生产 condition.await(); &#125; //2.干活 number++; System.out.println(Thread.currentThread().getName() + "\t" + number); //3.通知 condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void decrement() throws Exception &#123; lock.lock(); try &#123; //1.判断 while (number == 0) &#123; //等待不能消费 condition.await(); &#125; //2.消费 number--; System.out.println(Thread.currentThread().getName() + "\t" + number); //3.通知 condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920ProductorA 1 1ConsumerA 3 0ProductorA 2 1ConsumerA 4 0ProductorA 4 1ConsumerA 2 0ProductorA 5 1ConsumerA 1 0ProductorA 3 1ConsumerA 5 0ProductorB 3 1ConsumerB 2 0ProductorB 5 1ConsumerB 4 0ProductorB 4 1ConsumerB 3 0ProductorB 2 1ConsumerB 5 0ProductorB 1 1ConsumerB 1 0 阻塞队列版: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package queue;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class ProdConsumer_BlockQueueDemo &#123; public static void main(String[] args) &#123; MyResource myResource = new MyResource(new ArrayBlockingQueue&lt;&gt;(10)); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "\t生产线程启动"); try &#123; myResource.myProd(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "Prod").start(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "\t消费线程启动"); try &#123; myResource.myConsumer(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, "Consumer").start(); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("5s后main叫停，线程结束"); try &#123; myResource.stop(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyResource &#123; private volatile boolean flag = true;//默认开启，进行生产+消费 private AtomicInteger atomicInteger = new AtomicInteger();//默认值是0 BlockingQueue&lt;String&gt; blockingQueue = null; public MyResource(BlockingQueue&lt;String&gt; blockingQueue) &#123; this.blockingQueue = blockingQueue; System.out.println(blockingQueue.getClass().getName()); &#125; public void myProd() throws Exception &#123; String data = null; boolean retValue; while (flag) &#123; data = atomicInteger.incrementAndGet() + ""; retValue = blockingQueue.offer(data, 2, TimeUnit.SECONDS); if (retValue) &#123; System.out.println(Thread.currentThread().getName() + "\t插入队列" + data + "成功"); &#125; else &#123; System.out.println(Thread.currentThread().getName() + "\t插入队列" + data + "失败"); &#125; TimeUnit.SECONDS.sleep(1); &#125; System.out.println(Thread.currentThread().getName() + "\t大老板叫停了，flag=false，生产结束"); &#125; public void myConsumer() throws Exception &#123; String result = null; while (flag) &#123; result = blockingQueue.poll(2, TimeUnit.SECONDS); if (null == result || result.equalsIgnoreCase("")) &#123; flag = false; System.out.println(Thread.currentThread().getName() + "\t超过2s没有取到蛋糕，消费退出"); System.out.println(); return; &#125; System.out.println(Thread.currentThread().getName() + "\t消费队列" + result + "成功"); &#125; &#125; public void stop() throws Exception &#123; flag = false; &#125;&#125; 运行结果： 12345678910111213141516java.util.concurrent.ArrayBlockingQueueProd 生产线程启动Consumer 消费线程启动Prod 插入队列1成功Consumer 消费队列1成功Prod 插入队列2成功Consumer 消费队列2成功Prod 插入队列3成功Consumer 消费队列3成功Prod 插入队列4成功Consumer 消费队列4成功Prod 插入队列5成功Consumer 消费队列5成功5s后main叫停，线程结束Prod 大老板叫停了，flag=false，生产结束Consumer 超过2s没有取到蛋糕，消费退出 （2）线程池 （3）消息中间件 6、synchronized和lock有什么区别？用新的lock有什么好处？请举例区别： （1）原始构成 synchronized时关键字属于jvm monitorenter，底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步或方法中才能掉wait/notify等方法 Lock是具体类，是api层面的锁（java.util.） （2）使用方法 sychronized不需要用户取手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。 ReentrantLock则需要用户去手动释放锁若没有主动释放锁，就有可能导致出现死锁现象，需要lock()和unlock()方法配合try/finally语句块来完成。 （3）等待是否可中断 synchronized不可中断，除非抛出异常或者正常运行完成。 ReentrantLock可中断，设置超时方法tryLock(long timeout, TimeUnit unit)，或者lockInterruptibly()放代码块中，调用interrupt()方法可中断。 （4）加锁是否公平 synchronized非公平锁。 ReentrantLock两者都可以，默认公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁。 （5）锁绑定多个条件Condition synchronized没有。 ReentrantLock用来实现分组唤醒需要要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。 lock可绑定多个条件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * synchronized和lock区别 * &lt;p===lock可绑定多个条件=== * 对线程之间按顺序调用，实现A&gt;B&gt;C三个线程启动，要求如下： * AA打印5次，BB打印10次，CC打印15次 * 紧接着 * AA打印5次，BB打印10次，CC打印15次 * 。。。。 * 来十轮 */public class SyncAndReentrantLockDemo &#123; public static void main(String[] args) &#123; ShareData shareData = new ShareData(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; shareData.print5(); &#125; &#125;, "A").start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; shareData.print10(); &#125; &#125;, "B").start(); new Thread(() -&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; shareData.print15(); &#125; &#125;, "C").start(); &#125;&#125;class ShareData &#123; private int number = 1;//A:1 B:2 C:3 private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); public void print5() &#123; lock.lock(); try &#123; //判断 while (number != 1) &#123; condition1.await(); &#125; //干活 for (int i = 1; i &lt;= 5; i++) &#123; System.out.println(Thread.currentThread().getName() + "\t" + i); &#125; //通知 number = 2; condition2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void print10() &#123; lock.lock(); try &#123; //判断 while (number != 2) &#123; condition2.await(); &#125; //干活 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "\t" + i); &#125; //通知 number = 3; condition3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void print15() &#123; lock.lock(); try &#123; //判断 while (number != 3) &#123; condition3.await(); &#125; //干活 for (int i = 1; i &lt;= 15; i++) &#123; System.out.println(Thread.currentThread().getName() + "\t" + i); &#125; //通知 number = 1; condition1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263A 1A 2A 3A 4A 5B 1B 2B 3B 4B 5B 6B 7B 8B 9B 10C 1C 2C 3C 4C 5C 6C 7C 8C 9C 10C 11C 12C 13C 14C 15............//中间省略13次......A 1A 2A 3A 4A 5B 1B 2B 3B 4B 5B 6B 7B 8B 9B 10C 1C 2C 3C 4C 5C 6C 7C 8C 9C 10C 11C 12C 13C 14C 15 八、线程池用过吗？ThreadPoolExecutor谈谈你的理解？1、Callable接口的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445package thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;import java.util.concurrent.TimeUnit;/** * 多线程中，第三种获得多线程的方式 */public class CallableDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //FutureTask(Callable&lt;V&gt; callable) FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new MyThread2()); new Thread(futureTask, "AAA").start(); //new Thread(futureTask, "BBB").start();//复用，直接取值，不要重启两个线程 int a = 100; int b = 0; //b = futureTask.get();//要求获得Callable线程的计算结果，如果没有计算完成就要去强求，会导致堵塞，直到计算完成 while (!futureTask.isDone()) &#123;//当futureTask完成后取值 b = futureTask.get(); &#125; System.out.println("*******Result:" + (a + b)); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; &#125;&#125;class MyThread2 implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()+"Callable come in"); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 1024; &#125;&#125; 运行结果： 12AAACallable come in*******Result:1124 2、为什么使用线程池（1）线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动给这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。 （2）主要特点 线程复用、控制最大并发数、管理线程 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提过响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的客观理想。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 3、线程池如何使用（1）架构说明 Java中的线程池是通过Executor框架实现的，该框架中用到了Executor,Executors,ExecutorService,ThreadPoolExecutor这些类。 （2）编码实现 实现方式有五种，Executors.newScheduledThreadPool()是带时间调度的，java8新推出Executors.newWorkStealingPool(int),使用目前机器上可用的处理器作为他的并行级别。 重点看下面三种： Executors.newFixedThreadPool(int) 执行长期的任务，性能好很多 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue Executors.newSingleThreadExecutor() 一个任务一个任务执行的场景 创建一个单线程话的线程池，他只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行 newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue Executors.newCachedThreadPool() 执行很多短期异步的小程序或负载较轻的服务器 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲县城，若无可回收，则新建线程。 newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE,使用的SynchronousQueue,也就是说来了任务就创建线程运行，当县城空闲超过60s，就销毁线程。 （3）ThreadPoolExecutor 4、线程池的几个重要参数介绍 1234567public ThreadPoolExecutor(int corePoolSize,//线程池中常驻核心线程数 int maximumPoolSize,//线程池能够容纳同时执行的最大线程数，必须大于等于1 long keepAliveTime,//多余的空闲线程的存活时间 TimeUnit unit,//keepAliveTime的单位 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，被提交但未被执行的任务 ThreadFactory threadFactory,//表示生成线程池中工作线程的线程工厂 RejectedExecutionHandler handler//拒绝策略) （1）corePoolSize：线程池中常驻核心线程数 在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务 当线程池的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中 （2）maximumPoolSize：线程池能够容纳同时执行的最大线程数，必须大于等于1 （3）keepAliveTime：多余的空闲线程的存活时间 当前线程池数量超过corePoolSize时，档口空闲时间达到keepAliveTime值时，多余空闲线程会被销毁到只剩下corePoolSize个线程为止 （4）unit：keepAliveTime的单位 （5）workQueue：任务队列，被提交但尚未被执行的任务 （6）threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可 （7）handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runable的策略 5、线程池的底层工作原理 执行流程 （1）在创建了线程池之后，等待提交过来的 人物请求。 （2）当调用execute()方法添加一个请求任务时，线程池会做出如下判断 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务； 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列； 如果此时队列满了且运行的线程数小于maximumPoolSize，那么还是要创建非核心线程立刻运行此任务 如果队列满了且正在运行的线程数量大于或等于maxmumPoolSize，那么启动饱和拒绝策略来执行 （3）当一个线程完成任务时，他会从队列中取下一个任务来执行 （4）当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断： 如果当前运行的线程数大于corePoolSize，那么这个线程会被停掉；所以线程池的所有任务完成后他最大会收缩到corePoolSize的大小 九、线程池用过吗？生产上你如何设置合理参数？1、线程池的拒绝策略（1）什么是线程的拒绝策略 等待队列也已经排满了，再也塞不下新任务了，同时线程池中的max线程也达到了，无法继续为新任务服务。这时我们就需要拒绝策略机制合理的处理这个问题。 （2）JDK内置的拒绝策略 AbortPolicy(默认) 直接抛出RejectedExecutionException异常阻止系统正常运行 CallerRunsPolicy ”调用者运行“一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量 DiscardOldestPolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务 DiscardPolicy 直接丢弃任务，不予任何处理也不抛异常。如果允许任务丢失，这是最好的一种方案 以上内置策略均实现了RejectedExecutionHandler接口。 2、你在工作中单一的/固定数的/可变的三种创建线程池的方法，用哪个多一个都不用，我们生产上只能使用自定义的！！！ 为什么？ 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 线程池不允许使用Executors创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则规避资源耗尽风险。 Executors返回的线程池对象的弊端如下： （1）FixedThreadPool和SingleThreadPool允许请求队列长度为Integer.MAX_VALUE，可能会堆积大量请求，从而导致OOM。（2）CachedThreadPool和ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。 3、你在工作中时如何使用线程池的，是否自定义过线程池使用示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package thread;import java.util.concurrent.*;/** * 第四种获得java多线程的方式--线程池 */public class MyThreadPoolDemo &#123; public static void main(String[] args) &#123; ExecutorService threadPool = new ThreadPoolExecutor( 2, 5, 1L, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(3), Executors.defaultThreadFactory(), //默认抛出异常 //new ThreadPoolExecutor.AbortPolicy() //回退调用者 //new ThreadPoolExecutor.CallerRunsPolicy() //处理不来的不处理 //new ThreadPoolExecutor.DiscardOldestPolicy() new ThreadPoolExecutor.DiscardPolicy() ); //模拟10个用户来办理业务 没有用户就是来自外部的请求线程. try &#123; System.out.println("======调用内置线程池======"); for (int i = 1; i &lt;= 10; i++) &#123; threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "\t 办理业务"); &#125;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; System.out.println("======调用自定义线程池======"); threadPoolInit();//调用自定义线程池 &#125; private static void threadPoolInit() &#123; /** * 一池5个处理线程 */ //ExecutorService threadPool= Executors.newFixedThreadPool(5); /** * 一池一线程 */ //ExecutorService threadPool= Executors.newSingleThreadExecutor(); /** * 一池N线程 */ ExecutorService threadPool = Executors.newCachedThreadPool(); //模拟10个用户来办理业务 没有用户就是来自外部的请求线程. try &#123; for (int i = 1; i &lt;= 10; i++) &#123; threadPool.execute(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + "\t 办理业务"); &#125;); try &#123; TimeUnit.MICROSECONDS.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; threadPool.shutdown(); &#125; &#125;&#125; 运行结果： 123456789101112131415161718192021======调用内置线程池======pool-1-thread-2 办理业务pool-1-thread-1 办理业务pool-1-thread-2 办理业务pool-1-thread-2 办理业务pool-1-thread-1 办理业务pool-1-thread-3 办理业务pool-1-thread-2 办理业务pool-1-thread-5 办理业务pool-1-thread-4 办理业务======调用自定义线程池======pool-2-thread-1 办理业务pool-2-thread-1 办理业务pool-2-thread-1 办理业务pool-2-thread-1 办理业务pool-2-thread-2 办理业务pool-2-thread-1 办理业务pool-2-thread-1 办理业务pool-2-thread-1 办理业务pool-2-thread-1 办理业务pool-2-thread-1 办理业务 4、合理配置线程池你是如何考虑的？（1）CPU密集型 CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。 CPU密集任务只有在真正多核CPU上才可能得到加速（通过多线程） 而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。 CPU密集型任务配置尽可能少的线程数量： 一般公式：CPU核数+1个线程的线程池 （2）IO密集型 由于IO密集型任务线程并不是一直在执行任务，则应配置经可能多的线程，如CPU核数 * 2 IO密集型，即该任务需要大量的IO，即大量的阻塞。 在单线程上运行IO密集型的任务会导致浪费大量的 CPU运算能力浪费在等待。 所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。 IO密集型时，大部分线程都阻塞，故需要多配置线程数： 参考公式：CPU核数/（1-阻塞系数） 阻塞系数在0.8~0.9之间 八核CPU：8/（1-0，9）=80 十、死锁编码及定位分析1、死锁是什么死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。 2、产生死锁的主要原因 系统资源不足 进程运行推进的顺序不合适 资源分配不当 3、死锁示例1234567891011121314151617181920212223242526272829303132333435363738394041package thread;import java.util.concurrent.TimeUnit;/** * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去， */public class DeadLockDemo &#123; public static void main(String[] args) &#123; String lockA = "lockA"; String lockB = "lockB"; new Thread(new HoldThread(lockA,lockB),"Thread-AAA").start(); new Thread(new HoldThread(lockB,lockA),"Thread-BBB").start(); &#125;&#125;class HoldThread implements Runnable &#123; private String lockA; private String lockB; public HoldThread(String lockA, String lockB) &#123; this.lockA = lockA; this.lockB = lockB; &#125; @Override public void run() &#123; synchronized (lockA) &#123; System.out.println(Thread.currentThread().getName() + "\t自己持有：" + lockA + "\t尝试获得：" + lockB); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lockB) &#123; System.out.println(Thread.currentThread().getName() + "\t自己持有：" + lockB + "\t尝试获得：" + lockA); &#125; &#125; &#125;&#125; 运行结果： 123Thread-BBB 自己持有：lockB 尝试获得：lockAThread-AAA 自己持有：lockA 尝试获得：lockB//程序没有停止 Thread-AAA 和 Thread-BBB一直在互相等待 4、死锁定位分析（1）jps命令定位进程编号 （2）jstack找出死锁查看信息]]></content>
      <categories>
        <category>Java面试</category>
        <category>JUC多线程及并发包</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>JUC多线程及并发包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法的实现与比较]]></title>
    <url>%2F2019%2F08%2F11%2F2019-08-11-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[排序就是将一组对象按照某种逻辑顺序重新排列的过程。比如，订单按照日期排序的——这种排序很可能使用了某种排序算法。在计算时代早期，大家普遍认为30% 的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。现在计算机的广泛使用使得数据无处不在，而整理数据的第一步通常就是进行排序。几乎所有的计算机系统都实现了各种排序算法以供系统和用户使用。 1. 冒泡排序冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较少的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。 优化：因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过比较，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。 冒泡排序过程： 冒泡排序规则： （1）一共进行（ 数组的大小-1） 次 大的循环 （2）每一趟排序比较的次数（数组的大小-趟次）在逐渐的减少 （3） 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化 代码实现： 123456789101112131415161718192021222324//冒泡排序private static void bubbleSort(int[] arr)&#123; int temp = 0;//临时变量 boolean flag = false;//标识变量，表示是否进行过交换 for(int i=0; i &lt; arr.length-1; i++)&#123;//(1) 一共进行（ 数组的大小-1） 次 大的循环 for(int j=0;j &lt; arr.length-1-i; j++)&#123;//(2)每一趟排序的次数（数组的大小-趟次）在逐渐的减少 if(arr[j] &gt; arr[j+1])&#123;//如果前面的数比后面的数大，则交换 flag = true; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print("第"+ (i+1) + "轮结果："); System.out.println(Arrays.toString(arr)); if(!flag)&#123;//（3）在某一趟排序中，一次交换也没有发生，可以提前结束排序 break; &#125;else&#123; flag = false;//重置flag！！！进行下次判断 &#125; &#125;&#125; 2.选择排序选择排序（select sorting）也是一种简单的排序算法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…，第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 选择排序过程： 选择排序规则： （1）一共进行（ 数组的大小-1） 次 大的循环 （2）每一趟（k）排序从arr[k-1]~arr[n-1]中选取最小值，与arr[k-1]交换 （3）如果第一个元素（arr[k-1]）就是最小元素，那么不用进行交换 代码实现： 1234567891011121314151617//选择排序private static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length-1; i++) &#123;//(1) 一共进行（ 数组的大小-1） 次 大的循环 int minIndex = i;//最小值下标 默认值为0 int min = arr[minIndex];//最小值 默认值为0 for (int j = i+1; j &lt; arr.length; j++) &#123;//(2)每一趟（i）排序从`arr[i-1]~arr[n-1]`中选取最小值，与`arr[i-1]`交换 if(min&gt;arr[j])&#123; minIndex=j;//找到最小值下标 min=arr[minIndex];//找到最小值 &#125; &#125; if(minIndex!=i)&#123;//如果第一个元素不是最小元素，进行交换 arr[minIndex]=arr[i]; arr[i]=min; &#125; &#125;&#125; 3.插入排序插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 插入排序过程： 插入排序规则： （1）一共进行（ 数组的大小-1） 次 大的循环 （2）对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 （3）如果第一个元素（insertIndex+1==i）就是合适的位置，那么不用进行交换 代码实现： 123456789101112131415161718192021222324252627282930//插入排序private static void insertSort(int[] arr) &#123; int insertVal = 0;//插入的值 默认值为0 int insertIndex = 0;//插入的下标 默认值为0 for (int i = 1; i &lt; arr.length; i++) &#123;//从未排序数据中遍历 insertVal = arr[i];//定义待插入的数 insertIndex = i-1;//即arr[i]的前面这个数的下标 /* * 给insertVal找到插入的位置insertIndex * 1.insertIndex &gt;= 0 保证在给insertVal找插入的位置，不越界 * 2.insertVal&lt;arr[insertIndex]待插入的数，代表还没找到插入的位置 * 3.就需要将arr[insertIndex]后移一位 */ while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex])&#123; arr[insertIndex+1] = arr[insertIndex];//将arr[insertIndex]后移一位 insertIndex--;//从后向前找 &#125; /* * 当退出while循环时，说明插入的位置找到了，insertIndex+1 * 如果第一个元素（`insertIndex+1==i`）就是合适的位置，那么不用进行交换 */ if(insertIndex+1!=i)&#123; arr[insertIndex+1]=insertVal;//把插入值插入到正确的位置 &#125; &#125;&#125; 4.希尔排序希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序过程： 希尔排序规则： （1）把记录按下标的一定增量分组，对每组使用直接插入排序算法排序 （2）增量逐渐减少（gap=gap/2）,当整个文件恰被分成一组，算法结束 代码实现： 1234567891011121314151617181920212223242526272829303132//插入排序 采用移位方式private static void shellSort(int[] arr) &#123; int len = arr.length;//数组的长度 int gap = len/2;//增量gap,并逐步的缩小增量 int currentValue;//组内待排序的数据 while(gap&gt;0)&#123;//当整个文件恰被分成一组，算法结束 for(int i =gap;i&lt;len;i++)&#123;//从第gap个元素开始，逐个对其所在的组进行直接插入排序 currentValue = arr[i];//定义待插入的数 int preIndex = i - gap;//即该组arr[i]前面这个数的下标 /* * 给currentValue找到插入的位置preIndex * 1.preIndex &gt;= 0 保证在给currentValue找插入的位置，不越界 * 2.currentValue &lt; arr[preIndex],代表还没找到插入的位置 * 3.就需要将arr[preIndex]后移gap位 */ while(preIndex&gt;=0&amp;&amp;currentValue&lt;arr[preIndex])&#123; arr[preIndex+gap] = arr[preIndex];//将arr[preIndex]后移gap位 preIndex = preIndex - gap;//从后往前找 &#125; /* * 当退出while循环时，说明插入的位置找到了，preIndex+gap * 如果第一个元素（preIndex+gap==i）就是合适的位置，那么不用进行交换 */ if(preIndex+gap!=i)&#123; arr[preIndex+gap] = currentValue;//把插入值插入到正确的位置 &#125; &#125; gap = gap / 2;//逐步的缩小增量 &#125;&#125; 5.归并排序归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 归并排序过程： 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤 归并排序规则： （1）先将数组划分为左右两个子表 （2）然后继续左右两个子表拆分；对最后的拆分的子表，两两进行排序 （3）对有序的子表进行排序和比较合并 （4）对合并后的子表继续比较合并 代码实现： 1234567891011121314151617181920212223242526//归并排序 分+合方法private static int[] mergeSort(int[] arr) &#123; if(arr.length &lt; 2) return arr;//分到一个就可以返回了 int mid = arr.length/2;//切分的位置 int[] left = Arrays.copyOfRange(arr, 0, mid);//左子表 int[] right = Arrays.copyOfRange(arr, mid, arr.length);//右子表 return merge(mergeSort(left),mergeSort(right));//先向左递归分解， 再向右递归分解， 最后合并左右子表&#125;//合并private static int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length+right.length];//定义一个返回结果数组 for(int index=0,leftIndex=0,rightIndex=0;index&lt;result.length;index++)&#123; if(leftIndex&gt;=left.length)&#123;//（1）如果左子表，已经遍历完了 result[index] = right[rightIndex++];//把右子表剩余的元素加入到表中 &#125;else if(rightIndex&gt;=right.length)&#123;//（2）如果右子表，已经遍历完了 result[index] = left[leftIndex++];//把左子表剩余的元素加入到表中 &#125;else if(left[leftIndex]&gt;right[rightIndex])&#123;//（3）如果左子表大于右子表 result[index] = right[rightIndex++];//把右子表的元素加入到表中 &#125;else&#123;//(4)否则左子表小于等于右子表 result[index] = left[leftIndex++];//把左子表的元素加入到表中 &#125; &#125; return result;//返回结果&#125; 6.快速排序快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 快速排序过程： 随机选择数组的一个数，比如48为基准，切分数组 同时引入一个分割指示器，这个分割指示器初始值是数组头元素下标减一，这里就是-1。同时交换基准数和数组尾元素 。 进行数组的遍历，将数组中的元素和基准数进行比较，为了满足所有比基准数小的数都放到基准数前面，所有比基准数大的数都放到基准数后面，我们需要遵循着这样的规则： （1）当前元素小于等于基准数时，分割指示器右移一位 ，当前元素下标小于等于分割指示器时当前元素保持不动，当前元素下标大于分割指示器时，当前元素和分割指示器所指元素交换； （2）当前元素大于基准数，分割指示器保持不变 ，元素也无需交换。 所以接下来随着数组的遍历，其中元素的变动情况是： 快速排序规则： （1）找个数做基准数，把小于它的数移到它左边，把大于它的数移到它右边 （2）让基准数左边的重复上面的步骤，让基准数右边的再重复上面的步骤，递归。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 递归的数据结构就是栈 * @param arr 待排序数组 * @param left 数组起点 * @param right 数组终点 * @return */private static void quickSort(int[] arr, int left, int right) &#123; //已经不满足条件就代表可以不用递归了 if (left &gt; right) &#123; return; &#125; int partitionIndex = partition(arr,left,right);//分区指示器 if(partitionIndex&gt;left)&#123; quickSort(arr,left,partitionIndex-1);//左子表递归 &#125; if(partitionIndex&lt;right)&#123; quickSort(arr,partitionIndex+1,right);//右子表递归 &#125;&#125; /** * 把小于基准的数移到它左边，把大于基准的数移到它右边 */private static int partition(int[] arr, int left, int right) &#123; int pivot = (int)(left+Math.random()*(right-left+1));//随机选取一个数作为基准 //System.out.println(pivot); int index = left-1;//index指向小于基准的最右边数 swap(arr,pivot,right);//交换基准数和尾元素 for(int i=left;i&lt;=right;i++)&#123; if(arr[i]&lt;=arr[right])&#123;//对所有小于等于基准的数进行处理 index++; if(i&gt;index)&#123;//当i和index不同时，才交换位置 swap(arr,i,index); &#125; &#125; &#125; return index;//返回基准归位的位置&#125;/** * 交换数组内两个元素 */private static void swap(int[] arr, int i, int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 排序算法总结 名词解释 （1）算法的稳定性 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； （2）时间复杂度 一个算法执行所耗费的时间。 （3）空间复杂度 对一个算法在运行过程中临时占用存储空间大小的量度。 常见复杂度 在各种不同算法中，若算法中语句执行次数(占用空间)为一个常数，则复杂度为O(1)； 当一个算法的复杂度与以2为底的n的对数成正比时，可表示为O(log n)；当一个算法的复杂度与n成线性比例关系时，可表示为O (n)，依次类推。 由小到大：O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) 排序算法时间复杂度助记 冒泡、选择、插入排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n^2)（外循环找元素O(n)，内循环找位置O(n)） 快速、归并、希尔、堆基于分治思想，log以2为底，平均时间复杂度往往和O(nlogn)（外循环找元素O(n)，内循环找位置O(logn)）相关 基数排序时间复杂度为O（N*M），其中N为数据个数，M为数据位数 快速排序的优势 从平均时间来看，快速排序是效率最高的： 快速排序中平均时间复杂度O(nlog n)，这个公式中隐含的常数因子很小，比归并排序的O(nlog n)中的要小很多，所以大多数情况下，快速排序总是优于合并排序的。 而堆排序的平均时间复杂度也是O(nlog n)，但是堆排序存在着重建堆的过程，它把根节点移除后，把最后的叶子结点拿上来，是为了重建堆，但是，拿上的值是要比它的两个叶子结点要差很多的，它要比较很多次，才能回到合适的位置。堆排序就会有很多的时间耗在堆调整上。 虽然快速排序的最坏情况为排序规模（n）的平方关系，但是这种最坏情况取决于每次选择的基准， 对于这种情况，已经提出了很多优化的方法，比如三取样划分和Dual-Pivot快排。 同时，当排序规模较小时，划分的平衡性容易被打破，而且频繁的方法调用超过了O(nlog n)为O(n^2)省出的时间，所以一般排序规模较小时，会改用插入排序或者其他排序算法。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-Java基础篇]]></title>
    <url>%2F2019%2F08%2F10%2F2019-08-10-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-Java%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[网上收集了一些Java常考的知识点。 1. 面向对象的特性有哪些？封装、继承和多态（应要多算一个那就是抽象） （1）封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露出该对象的功能。最常见的例子 private + getter/setter （2）继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。 继承的缺点： 继承是一种强耦合关系，父类变子类也必须变； 继承破坏了封装，对于父类而言，它的实现细节对子类来说都是透明的。 （3）多态简而言之就是同一个行为具有多个不同表现形式或形态的能力。 比如说，有一杯水，我不知道它是温的、冰的还是烫的，但是我一摸我就知道了，我摸水杯的这个动作，对于不同温度的水，就会得到不同的结果，这就是多态。 多态的条件：1）继承；2）重写；3）向上转型。 多态的好处：当把不同的子类对象都当作父类类型来看，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。 （4）抽象是指从特定的角度出发，从已经存在的一些事物中抽取我们所关注的特性、行为，从而形成一个新的事物的思维过程，是一种从复杂到简洁的思维方式。 2.面向对象和面向过程的区别？面向过程是一种站在过程的角度思考问题的思想，强调的是功能行为，功能的执行过程，即先干啥，后干啥。 面向过程的设计：最小的程序单元是函数，每个函数负责完成某一个功能，用以接受输入数据，函数对输入数据进行处理，然后输出结果数据。整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。 面向过程的缺陷：向过程的设计,是采用置顶而下的设计方式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块有细分为更小的子模块，如此类推，直到将模块细化为一个个函数。 问题： 1）设计不够直观，与人类的习惯思维不一致； 2）系统软件适应性差，可扩展性差，维护性低。 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。 面向对象是一种基于面向过程的新的编程思想，是一种站在对象的角度思考问题的思想，我们把多个功能合理的放到不同对象里，强调的是具备某些功能的对象。 面向对象更加符合我们常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。 注意： 不要粗浅的认为面向对象一定就优于面向过程的设计 3.JDK 和 JRE 的区别是什么？Java 运行时环境（JRE-Java Runtime Environment），它包括 Java 虚拟机、Java 核心类库和支持文件，但并不包含开发工具（JDK-Java Development Kit）——编译器、调试器和其他工具。 Java 开发工具包（JDK）是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具（比如 JavaDoc， Java 调试器），可以让开发者开发、编译、执行 Java 应用程序。 4.Java 中覆盖和重载是什么意思？覆盖（Override）是指子类对父类方法的一种重写，只能比父类抛出更少的异常，访问权限不能比父类的小，被覆盖的方法不能是 private 的，否则只是在子类中重新定义了一个新方法。 重载（Overload）表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同。 问：构成重载的条件有哪些？ 答：参数类型不同、参数个数不同、参数顺序不同。 问：函数的返回值不同可以构成重载吗？为什么？ 答：不可以，因为 Java 中调用函数并不需要强制赋值。 5.抽象类和接口的区别有哪些？ （1）抽象类中可以没有抽象方法；接口中的方法必须是抽象方法； （2）抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化,接口中只有常量，没有变量。 （3）抽象类只能单继承，接口可以继承多个父接口； （4）Java 8 中接口中会有 default 方法，即方法可以被实现。 抽象类和接口如何选择？ （1）如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。 （2）如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。 6.static关键字是什么意思？static 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中是否可以覆盖(override)一个 private 或者是 static 的方法？ Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。 7.Java 是值传递还是引用传递？值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 这是一个很经典的例子，我们希望在调用了 swap() 方法之后交换 arg1 和 arg2 的值，但事实上并没有，为什么会这样？ 这就是因为 Java 是值传递的，也就是说，我们在调用一个需要传递参数的函数时，传递给函数的参数并不是我们传递进去的参数本身，而是它的一个副本，我们改变了数据其实只是改变了副本的数据而已，并不会对原来的参数有任何的改变。 我们自己定义了一个内部类 Person ，该类只有一个 int 类型的 age 属性，然后有 getter/setter ，我们希望通过 changeAge() 函数来改变 Person 对象的 age 属性，为什么这次成功了呢？ 你依然可以理解为，主函数将 person 复制了一份到 changeAge 函数中去，最终还是只改变了 changeAge 中复制的那一份参数的值，而原本的参数并没有改变，但 changeAge 中的那一份和原本的参数指向了同一个内存区域！ 8.JDK 中常用的包有哪些？java.lang、java.util、java.io、java.net、java.sql。 9.Integer 的缓存机制 第一个返回true很好理解，就像上面讲的，a和b指向相同的地址。 第二个返回false是为什么呢？这是因为 Integer 有缓存机制，在 JVM 启动初期就缓存了 -128 到 127 这个区间内的所有数字。 第三个返回false是因为用了new关键字来开辟了新的空间，i和j两个对象分别指向堆区中的两块内存空间。 因为你只需要知道这是 Java 的一个缓存机制。Integer 类的内部类缓存了 -128 到 127 的所有数字。 10.下述两种方法分别创建了几个 Sring 对象？1234// 第一种：直接赋一个字面量String str1 = "ABCD";// 第二种：通过构造器创建String str2 = new String("ABCD"); String str1 = &quot;ABCD&quot;;最多创建一个String对象,最少不创建String对象.如果常量池中,存在”ABCD”,那么str1直接引用,此时不创建String对象.否则,先在常量池先创建”ABCD”内存空间,再引用. String str2 = new String(&quot;ABCD&quot;);最多创建两个String对象，至少创建一个String对象。new关键字绝对会在堆空间创建一块新的内存区域，所以至少创建一个String对象。 当执行第一句话的时候，会在常量池中添加一个新的ABCD字符，str1指向常量池的ABCD 当执行第二句话的时候，因为有new操作符，所以会在堆空间新开辟一块空间用来存储新的String对象，因为此时常量池中已经有了ABCD字符，所以堆中的String对象指向常量池中的ABCD，而str2则指向堆空间中的String对象。 11.i++ 与 ++i 到底有什么不同？解析：对于这两个的区别，熟悉的表述是：前置++是先将变量的值加 1，然后使用加 1 后的值参与运算，而后置++则是先使用该值参与运算，然后再将该值加 1 .但事实上，前置++和后置++一样，在参与运算之前都会将变量的值加 1 实际上，不管是前置 ++，还是后置 ++，都是先将变量的值加 1，然后才继续计算的。二者之间真正的区别是：前置 ++ 是将变量的值加 1 后，使用增值后的变量进行运算的，而后置 ++ 是首先将变量赋值给一个临时变量，接下来对变量的值加 1，然后使用那个临时变量进行运算。 12.交换变量的三种方式 第一种：通过一个第三变量 1234567891011121314151617181920212223242526272829303132333435363738public class Test&#123; public static void main(String[] args) &#123; int x = 5; int y = 10; swap(x,y); System.out.println(x); System.out.println(y); Value v = new Value(5,10); swap(v); System.out.println(v.x); System.out.println(v.y); &#125; // 无效的交换：形参的改变无法反作用于实参 public static void swap(int x,int y) &#123; int temp = x; x = y; y = temp; &#125; // 有效的交换：通过引用（变量指向一个对象）来修改成员变量 public static void swap(Value value) &#123; int temp = value.x; value.x = value.y; value.y = temp; &#125;&#125;class Value&#123; int x; int y; public Value(int x,int y) &#123; this.x = x; this.y = y; &#125;&#125; 12345输出的结果：510105 事实上，其实如果把基础类型int改成对应的包装类的话其实可以更加简单的完成这个操作，不过需要付出更多的内存代价。 第二种：通过通过相加的方式（相同的 Value 类不再重复展示） 123456789101112131415public class Test&#123; public static void main(String[] args) &#123; Value v1 = new Value(5,10); swap(v1); System.out.println("v1交换之后的结果为："); System.out.println(v1.x); System.out.println(v1.y); &#125; public static void swap(Value v) &#123; v.x = v.x + v.y;// 把v.x与v.y的和存储在v.x中 v.y = v.x - v.y;// v.x减掉v.y本来的值即为v.x v.x = v.x - v.y;// v.x减掉v.y的值也就是以前x.y的值 &#125;&#125; 1234输出的结果：v1的交换结果：105 这样就可以不通过临时变量，来达到交换两个变量的目的，该方法不太容易理解，但并不推荐这种做法，原因在于当数值很大的时候，16进制的求和运算可能造成数据的溢出，虽然最后的结果依然会是我们所期望的那样，但仍然不是十分可取。 第三种：通过异或的方式： 位异或运算符（^）有这样的一个性质，就是两个整型的数据x与y，有：（x ^ y ^ y） == x这说明，如果一个变量x异或另外一个变量y两次，结果为x。通过这一点，可以实现交换两个变量的值： 123456789101112131415public class Test&#123; public static void main(String[] args) &#123; Value v1 = new Value(5,10); swap(v1); System.out.println("v1交换之后的结果为："); System.out.println(v1.x); System.out.println(v1.y); &#125; public static void swap(Value v) &#123; v.x = v.x ^ v.y; v.y = v.x ^ v.y; v.x = v.x ^ v.y; &#125;&#125; 1234输出的结果：v1交换之后的结果为：105 跟上面相加的方式过程几乎类似，只不过运算的方式不同而已。异或的方法比相加更加可取的地方在于，异或不存在数据溢出。 13.Java 对象初始化顺序？不考虑静态成员的初始化，调用一个对象的构造函数时，程序先调用父类的构造函数（可以通过super关键字指定父类的构造函数，否则默认调用无参的构造函数，并且需要在子类的构造函数的第一行调用），之后静态成员变量的初始化函数和静态初始化块则按照在代码当中的顺序执行，成员变量如果没有指定值的话则赋予默认值，即基本数据类型为0或false等，对象则为null；最后调用自身构造函数。 我们可以写一段程序来对初始化顺序进行一个简单的验证： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Derive extends Base&#123; private Member m1 = new Member("Member 1"); &#123; System.out.println("Initial Block()"); &#125; public Derive() &#123; System.out.println("Derive()"); &#125; private Member m2 = new Member("Member 2"); private int i = getInt(); private int getInt() &#123; System.out.println("getInt()"); return 2; &#125; public static void main(String[] args) &#123; new Derive(); &#125;&#125;class Base&#123; public Base() &#123; System.out.println("Base()"); &#125;&#125;class Member&#123; public Member(String m) &#123; System.out.println("Member() "+m); &#125;&#125; 1234567程序的输出结果是：Base()Member() Member 1Initial Block()Member() Member 2getInt()Derive() 14.true、false 与 null 是关键字吗？不是。true、false 是布尔类型的字面常量，null 是引用类型的字面常量。 那 goto 与 const 呢？ 是。goto 与 const 均是 Java 语言保留的关键字，即没有任何语法应用。 15.exception 和 error 有什么区别？exception 和 error都是 Throwable 的子类。exception 用于用户程序可以捕获的异常情况；error 定义了不期望被用户程序捕获的异常。 exception 表示一种设计或设计的问题，也就是说只要程序正常运行，从不会发生的情况；而 error 表示回复不是不可能但是很困难的情况下的一种严重问题，比如内存溢出，不可能指望程序处理这样的情况。 16.throw 和 throws 有什么区别？throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。 17.生产者-消费者问题这绝对是属于重点了，不管是考察对于该重要模型的理解还是考察代码能力，这都是一道很好的考题，所以很有必要的，我们先来回顾一下什么是生产者-消费者问题； 该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。 几种实现方式 上面说到该问题的关键是：如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据；解决思路可以简单概括为： 生产者持续生产，直到缓冲区满，满时阻塞；缓冲区不满后，继续生产； 消费者持续消费，直到缓冲区空，空时阻塞；缓冲区不空后，继续消费； 生产者和消费者都可以有多个； 那么在 Java 语言中，能达到上述要求的，自然而然的就会有如下的几种写法，但是问题的核心都是能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用： wait()/notify()方式； await()/signal()方式； BlockingQueue阻塞队列方式； PipedInputStream/PipedOutputStream方式； 手写代码，我们着重掌握上面对应的第一种和第三种写法就足够了； （1）wait()/notify()方式实现 生产者代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Producer implements Runnable &#123; private volatile boolean isRunning = true; private final Vector sharedQueue; // 内存缓冲区 private final int SIZE; // 缓冲区大小 private static AtomicInteger count = new AtomicInteger(); // 总数，原子操作 private static final int SLEEPTIME = 1000; public Producer(Vector sharedQueue, int SIZE) &#123; this.sharedQueue = sharedQueue; this.SIZE = SIZE; &#125; @Override public void run() &#123; int data; Random r = new Random(); System.out.println("start producer id = " + Thread.currentThread().getId()); try &#123; while (isRunning) &#123; // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 当队列满时阻塞等待 while (sharedQueue.size() == SIZE) &#123; synchronized (sharedQueue) &#123; System.out.println("Queue is full, producer " + Thread.currentThread().getId() + " is waiting, size：" + sharedQueue.size()); sharedQueue.wait(); &#125; &#125; // 队列不满时持续创造新元素 synchronized (sharedQueue) &#123; data = count.incrementAndGet(); // 构造任务数据 sharedQueue.add(data); System.out.println("producer create data:" + data + ", size：" + sharedQueue.size()); sharedQueue.notifyAll(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupted(); &#125; &#125; public void stop() &#123; isRunning = false; &#125;&#125; 有了上面的提到的解决思路，应该很容易实现，但是这里主要提一下一些细节和重点： 创造数据：生产者-消费者解决的问题就是数据在多线程间的共享，所以我们首要关心的问题就应该是数据，我们这里采用的是使用一个AtomicInteger类来为我们创造数据，使用它的好处是该类是一个保证原子操作的类，我们使用其中的incrementAndGet()方法不仅能够保证线程安全，还可以达到一个计数的效果，所以是一个既简单又实用的选择，当然也可以使用其他的数据来代替，这里注意的是要保证该类在内存中只存在一份，使用static修饰； 内存缓冲区：要保证在多线程环境下内存缓冲区的安全，所以我们考虑使用简单的Vector类来作为我们的内存缓冲区，并且使用final修饰保证内存缓冲区的唯一，然后的话我们需要判断队列是否满，需要手动添加一个标识缓冲区大小的变量SIZE，注意也是final修饰； 模拟延迟：这里主要模拟的是一个网络延迟，我们首先定义了一个SLEEPTIME的延迟范围，注意使用的是static final修饰，然后使用Random()类的nextInt()方法来随机选取一个该范围内的值来模拟网络环境中的延迟； 停止方法：首先需要知道在Thread类中有一个弃用的stop()方法，我们自己增加一个标志位isRunning来完成我们自己的stop()功能，需要注意的是使用volatile来修饰，保证该标志位的可见性； 错误处理：当捕获到错误时，我们应该使用Thread类中的interrupted()方法来终止当前的进程； 消息提示：我们主要是要在控制台输出该生产者的信息，包括当前队列的状态，大小，当前线程的生产者信息等，注意的是信息格式的统一(后面的消费者同样的)； 消费者代码 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Consumer implements Runnable &#123; private final Vector sharedQueue; // 内存缓冲区 private final int SIZE; // 缓冲区大小 private static final int SLEEPTIME = 1000; public Consumer(Vector sharedQueue, int SIZE) &#123; this.sharedQueue = sharedQueue; this.SIZE = SIZE; &#125; @Override public void run() &#123; Random r = new Random(); System.out.println("start consumer id = " + Thread.currentThread().getId()); try &#123; while (true) &#123; // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 当队列空时阻塞等待 while (sharedQueue.isEmpty()) &#123; synchronized (sharedQueue) &#123; System.out.println("Queue is empty, consumer " + Thread.currentThread().getId() + " is waiting, size：" + sharedQueue.size()); sharedQueue.wait(); &#125; &#125; // 队列不空时持续消费元素 synchronized (sharedQueue) &#123; System.out.println("consumer consume data：" + sharedQueue.remove(0) + ", size：" + sharedQueue.size()); sharedQueue.notifyAll(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125;&#125; 跟生产者相同的，你需要注意内存缓冲区/ 模拟延迟/ 错误处理/ 消息提示这些方面的细节问题，总体来说消费者就是持续不断的消费，也比较容易实现； 主线程代码 有了我们的消费者和生产者代码，我们需要来验证一下它们的正确性，照常理来说我们直接创建一些消费者和生产者的线程让它们执行就可以了啊，但是为了“加分”考虑呢，我们还是使用线程池吧..也不是特别复杂： 123456789101112131415161718192021222324252627282930public static void main(String args[]) throws InterruptedException &#123; // 1.构建内存缓冲区 Vector sharedQueue = new Vector(); int size = 4; // 2.建立线程池和线程 ExecutorService service = Executors.newCachedThreadPool(); Producer prodThread1 = new Producer(sharedQueue, size); Producer prodThread2 = new Producer(sharedQueue, size); Producer prodThread3 = new Producer(sharedQueue, size); Consumer consThread1 = new Consumer(sharedQueue, size); Consumer consThread2 = new Consumer(sharedQueue, size); Consumer consThread3 = new Consumer(sharedQueue, size); service.execute(prodThread1); service.execute(prodThread2); service.execute(prodThread3); service.execute(consThread1); service.execute(consThread2); service.execute(consThread3); // 3.睡一会儿然后尝试停止生产者 Thread.sleep(10 * 1000); prodThread1.stop(); prodThread2.stop(); prodThread3.stop(); // 4.再睡一会儿关闭线程池 Thread.sleep(3000); service.shutdown();&#125; 大家可以自行去看看运行的结果，是没有问题的，不会出现多生产或者多消费之类的多线程问题，运行一段时间等生产者都停止之后，我们可以观察到控制台三个消费者都在等待数据的情况： 123Queue is empty, consumer 17 is waiting, size：0Queue is empty, consumer 15 is waiting, size：0Queue is empty, consumer 16 is waiting, size：0 （2）BlockingQueue阻塞队列方式实现 该方式对比起上面一种方式实现起来要简单一些，因为不需要手动的去通知其他线程了，生产者直接往队列中放数据直到队列满，消费者直接从队列中获取数据直到队列空，BlockingQueue会自动帮我们完成阻塞这个动作，还是先来看看代码 生产者代码 123456789101112131415161718192021222324252627282930313233343536373839public class Producer implements Runnable &#123; private volatile boolean isRunning = true; private BlockingQueue&lt;Integer&gt; queue; // 内存缓冲区 private static AtomicInteger count = new AtomicInteger(); // 总数，原子操作 private static final int SLEEPTIME = 1000; public Producer(BlockingQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int data; Random r = new Random(); System.out.println("start producer id = " + Thread.currentThread().getId()); try &#123; while (isRunning) &#123; // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 往阻塞队列中添加数据 data = count.incrementAndGet(); // 构造任务数据 System.out.println("producer " + Thread.currentThread().getId() + " create data：" + data + ", size：" + queue.size()); if (!queue.offer(data, 2, TimeUnit.SECONDS)) &#123; System.err.println("failed to put data：" + data); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupted(); &#125; &#125; public void stop() &#123; isRunning = false; &#125;&#125; 跟上面一种方式没有很大的差别，倒是代码更加简单通透，不过需要注意的是对阻塞队列添加失败的错误处理； 消费者代码 12345678910111213141516171819202122232425262728293031323334353637public class Consumer implements Runnable &#123; private BlockingQueue&lt;Integer&gt; queue; // 内存缓冲区 private static final int SLEEPTIME = 1000; public Consumer(BlockingQueue&lt;Integer&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; int data; Random r = new Random(); System.out.println("start consumer id = " + Thread.currentThread().getId()); try &#123; while (true) &#123; // 模拟延迟 Thread.sleep(r.nextInt(SLEEPTIME)); // 从阻塞队列中获取数据 if (!queue.isEmpty()) &#123; data = queue.take(); System.out.println("consumer " + Thread.currentThread().getId() + " consume data：" + data + ", size：" + queue.size()); &#125; else &#123; System.out.println("Queue is empty, consumer " + Thread.currentThread().getId() + " is waiting, size：" + queue.size()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125; &#125;&#125; 主线程代码 1234567891011121314151617181920212223242526272829public static void main(String args[]) throws InterruptedException &#123; // 1.构建内存缓冲区 BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingDeque&lt;&gt;(); // 2.建立线程池和线程 ExecutorService service = Executors.newCachedThreadPool(); Producer prodThread1 = new Producer(queue); Producer prodThread2 = new Producer(queue); Producer prodThread3 = new Producer(queue); Consumer consThread1 = new Consumer(queue); Consumer consThread2 = new Consumer(queue); Consumer consThread3 = new Consumer(queue); service.execute(prodThread1); service.execute(prodThread2); service.execute(prodThread3); service.execute(consThread1); service.execute(consThread2); service.execute(consThread3); // 3.睡一会儿然后尝试停止生产者 Thread.sleep(10 * 1000); prodThread1.stop(); prodThread2.stop(); prodThread3.stop(); // 4.再睡一会儿关闭线程池 Thread.sleep(3000); service.shutdown();&#125; 因为队列中添加和删除的操作比较频繁，所以这里使用LinkedBlockingQueue来作为阻塞队列，所以这里除了内存缓冲区有所不同以外，其他的都差不多…当然你也可以指定一个队列的大小； 总结 生产者-消费者模式很好地对生产者线程和消费者线程进行解耦，优化了系统整体的结构，同时由于缓冲区的作用，允许生产者线程和消费者线程存在执行上的性能差异，从一定程度上缓解了性能瓶颈对系统性能的影响；上面两种写法都是非常常规的写法，只能说能起码能在及格的基础上加个那么点儿分数，如果想要得高分可以去搜索搜搜 Disruptor 来实现一个无锁的生产者-消费者模型….这里就不提及了.. 18.单例设计模式单例设计模式是软件开发中最常用的设计模式之一。单：唯一，例：实例。即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。 例如：代表JVM运行环境的Runtime类 要点： （1）某个类只能有一个实例 含有一个该类类型的静态变量来保存这个唯一的实例 （2）它必须自行创建这个实例 构造器私有化 （3）它必须自行向整个系统提供这个实例 对外提供获取该实例对象的方式：（1）直接暴露（2）用静态变量的get方法获取 几种常见形式 （1）饿汉式：直接创建对象，不存在线程安全问题 直接实例化饿汉式（简洁直观） 枚举式（最简洁） 静态代码块饿汉式（适合复杂实例化） （2）懒汉式：延迟创建对象 线程不安全（适用于单线程） 线程安全（适用于多线程） 静态内部类形式（适用于多线程） 饿汉式： 直接实例化饿汉式（简洁直观）: 1234567891011121314151617181920212223242526272829package 单例设计模式;/** * @Describe 直接实例化饿汉式（简介直观） * 直接创建实例对象的饿汉式，不管你是否需要这个对象都会创建 * * （1）构造器私有化 * （2）自行创建，并且静态变量保存 * （3）向外提供实例 * （4）强调这是一个单例，我们可以用final关键字修饰 */public class Singleton1 &#123; public static final Singleton1 INSTANCE = new Singleton1(); private Singleton1()&#123; &#125;&#125;package 单例设计模式;/** * @Describe Singleton1测试类 */public class TestSingleton1 &#123; public static void main(String[] args) &#123; Singleton1 s = Singleton1.INSTANCE; System.out.println(s); &#125;&#125; 枚举式（最简洁）: 1234567891011121314151617181920212223package 单例设计模式;/** * @Describe 枚举式（最简洁） * 枚举类型：表示该类型的对象是有限个 * 我们可以设定为1个，即成为了单例 * 枚举默认即为private */public enum Singleton2 &#123; INSTANCE&#125;package 单例设计模式;/** * @Describe Singleton2测试类 */public class TestSingleton2 &#123; public static void main(String[] args) &#123; Singleton2 s = Singleton2.INSTANCE; System.out.println(s); &#125;&#125; 静态代码块饿汉式（适合复杂实例化）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package 单例设计模式;import java.io.*;import java.util.Properties;/** * @Describe 静态代码块饿汉式（适合复杂实例化） * */public class Singleton3 &#123; public static final Singleton3 INSTANCE; private String info; //饿汉式，直接创建对象，不存在线程安全问题 static &#123; Properties properties = new Properties(); try &#123; String path = System.getProperty("user.dir")+"/src/main/resources/singleton.properties"; properties.load(new InputStreamReader(new FileInputStream(path))); INSTANCE = new Singleton3(properties.getProperty("info")); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; @Override public String toString() &#123; return "Singleton3&#123;" + "info='" + info + '\'' + '&#125;'; &#125; private Singleton3(String info)&#123; this.info = info; &#125;&#125;package 单例设计模式;/** * @Describe Singleton3测试类 */public class TestSingleton3 &#123; public static void main(String[] args) &#123; Singleton3 s = Singleton3.INSTANCE; System.out.println(s); &#125;&#125; 懒汉式： 线程不安全（适用于单线程）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package 单例设计模式;/** * @Describe 懒汉式1 * 线程不安全（适合于单线程） * 延迟创建实例对象,存在线程安全问题 * * （1）构造器私有化 * （2）用一个静态变量保存这个唯一的实例 * （3）提供一个静态方法，获取这个实例对象 */public class Singleton4 &#123; private static Singleton4 instance; private Singleton4()&#123; &#125; public static Singleton4 getInstance()&#123; if (instance == null)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; instance = new Singleton4(); &#125; return instance; &#125;&#125;package 单例设计模式;import java.util.Collection;import java.util.List;import java.util.concurrent.*;/** * @Describe Singleton4测试类 */public class TestSingleton4 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; /*//单线程情况下 Singleton4 s1 = Singleton4.getInstance(); Singleton4 s2 = Singleton4.getInstance(); System.out.println(s1 == s2); System.out.println(s1); System.out.println(s2);*/ //多线程情况下 Callable&lt;Singleton4&gt; c = new Callable&lt;Singleton4&gt;() &#123; @Override public Singleton4 call() throws Exception &#123; return Singleton4.getInstance(); &#125; &#125;; //创建线程池 ExecutorService es = Executors.newFixedThreadPool(2); Future&lt;Singleton4&gt; f1 = es.submit(c); Future&lt;Singleton4&gt; f2 = es.submit(c); Singleton4 s3 = f1.get(); Singleton4 s4 =f2.get(); System.out.println(s3 == s4); System.out.println(s3); System.out.println(s4); es.shutdown(); &#125;&#125; 线程安全（适用于多线程）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package 单例设计模式;/** * @Describe 懒汉式2 * 线程安全（适合于多线程） */public class Singleton5 &#123; private static Singleton5 instance; private Singleton5()&#123; &#125; public static Singleton5 getInstance()&#123; if (instance == null) &#123; synchronized (Singleton5.class) &#123; if (instance == null) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; instance = new Singleton5(); &#125; &#125; &#125; return instance; &#125;&#125;package 单例设计模式;import java.util.concurrent.*;/** * @Describe Singleton5测试类 */public class TestSingleton5 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //多线程情况下 Callable&lt;Singleton5&gt; c = new Callable&lt;Singleton5&gt;() &#123; @Override public Singleton5 call() throws Exception &#123; return Singleton5.getInstance(); &#125; &#125;; //创建线程池 ExecutorService es = Executors.newFixedThreadPool(2); Future&lt;Singleton5&gt; f1 = es.submit(c); Future&lt;Singleton5&gt; f2 = es.submit(c); Singleton5 s3 = f1.get(); Singleton5 s4 =f2.get(); System.out.println(s3 == s4); System.out.println(s3); System.out.println(s4); es.shutdown(); &#125;&#125; 静态内部类形式（适用于多线程）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package 单例设计模式;/** * @Describe 懒汉式3 * 静态内部类形式（适合多线程） * 在内部类被加载和初始化时，才创建INSTANCE对象 * 静态内部类不会自动随着外部类的加载和初始化而初始化，它是要单独去加载和初始化的。 * 因为是在内部类加载和初始化时，创建的，因此线程是安全的 */public class Singleton6 &#123; private Singleton6()&#123; &#125; private static class Inner&#123; private static final Singleton6 INSTANCE = new Singleton6(); &#125; public static Singleton6 getInstance()&#123; return Inner.INSTANCE; &#125;&#125;package 单例设计模式;import java.util.concurrent.*;/** * @Describe Singleton6测试类 */public class TestSingleton6 &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; /*//单线程情况下 Singleton6 s1 = Singleton6.getInstance(); Singleton6 s2 = Singleton6.getInstance(); System.out.println(s1 == s2); System.out.println(s1); System.out.println(s2);*/ //多线程情况下 Callable&lt;Singleton6&gt; c = new Callable&lt;Singleton6&gt;() &#123; @Override public Singleton6 call() throws Exception &#123; return Singleton6.getInstance(); &#125; &#125;; //创建线程池 ExecutorService es = Executors.newFixedThreadPool(2); Future&lt;Singleton6&gt; f1 = es.submit(c); Future&lt;Singleton6&gt; f2 = es.submit(c); Singleton6 s3 = f1.get(); Singleton6 s4 =f2.get(); System.out.println(s3 == s4); System.out.println(s3); System.out.println(s4); es.shutdown(); &#125;&#125; 总结： 如果是饿汉式，枚举形式最简单 如果是懒汉式，静态内部类形式最简单 19.有n步台阶，一次只能上1步或2步，共有多少种走法？递归分析： 递归实现代码： 12345678910111213141516171819202122232425262728293031package 递归与迭代;import org.junit.jupiter.api.Test;/** * @Describe 递归实现 * 有n阶台阶，1次只能上一步或者2步，有多少种走法 * 递归 * 迭代 */public class TestStep &#123; @Test public void test() &#123; long start = System.currentTimeMillis(); System.out.println(f(40)); //165580141 long end = System.currentTimeMillis(); System.out.println(end - start); //641ms &#125; //递归实现f(n)：求n步台阶，一共有几种走法 public int f(int n) &#123; if (n &lt; 1) &#123; throw new IllegalArgumentException(n + "不能小于1"); &#125; if (n == 1 || n == 2) &#123; return n; &#125; return f(n - 1) + f(n - 2); &#125;&#125; 运行结果： 迭代分析： 12345678910111213141516171819202122232425262728293031323334353637383940package 递归与迭代;import org.junit.jupiter.api.Test;/** * @Describe 迭代实现 * 有n阶台阶，1次只能上一步或者2步，有多少种走法 * 递归 * 迭代 */public class TestStep2 &#123; @Test public void test() &#123; long start = System.currentTimeMillis(); System.out.println(loop(40)); //165580141 long end = System.currentTimeMillis(); System.out.println(end - start); //&lt;1ms &#125; public int loop(int n) &#123; if (n &lt; 1) &#123; throw new IllegalArgumentException(n + "不能小于1"); &#125; if (n == 1 || n == 2) &#123; return n; &#125; int one = 2; //走到第二级台阶的初始化值 int two = 1; //走到第一级台阶的初始化值 int sum = 0; //最后跨两步+最后跨一步的走法 for (int i = 3; i &lt;= n; i++) &#123; sum = two + one; two = one; one = sum; &#125; return sum; &#125;&#125; 运行结果： . 总结： 方法调用自身成为递归，利用变量的原值推出新值称为迭代。 递归 优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好； 缺点：递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。 迭代 优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销； 缺点：代码不如递归简介，可读性好。 20.多线程练习问题： 请按要求编写多线程应用程序，模拟多个人通过一个山洞： 这个山洞每次只能通过一个人，每个人通过山洞的时间为5秒； 随机生成10个人，同时准备过此山洞，并且定义一个变量用于记录通过隧道的人数。显示每次通过山洞人的姓名，和通过顺序； 操作步骤描述 1.定义一个隧道类，实现Runnable接口： ​ 1.1 定义一个变量，用来记录通过隧道的人数； ​ 1.2 重写Runnable的run方法； ​ 1.3 定义一个同步方法，模拟每个人通过隧道需要5秒钟： ​ 1.3.1 子线程睡眠5秒钟，模拟每个人通过隧道需要5秒钟； ​ 1.3.2 改变通过的人次； ​ 1.3.3 打印线程名称及其通过隧道的顺序，模拟人通过隧道及其顺序； ​ 1.4 调用通过隧道的方法； 2.定义一个测试类： ​ 2.1 在main方法中创建一个隧道类对象； ​ 2.2 在main方法中，循环创建10个子线程对象，通过构造方法把隧道对象和线程名（作为人的姓名）传递进去，并开启子线程； 操作步骤答案 12345678910111213141516171819202122232425262728293031323334/* * 1.定义一个隧道类，实现Runnable接口 */public class Tunnel implements Runnable &#123; // 1.1 定义一个变量，用来记录通过隧道的人数 private int crossNum = 0; /* * 1.2 重写Runnable的run方法 */ @Override public void run() &#123; // 1.4 调用通过隧道的方法 cross(); &#125; /* * 1.3 定义一个同步方法，模拟每个人通过隧道需要5秒钟 */ public synchronized void cross() &#123; // 1.3.1 子线程睡眠5秒钟，模拟每个人通过隧道需要5秒钟 try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 1.3.2 改变通过的人次 crossNum++; // 1.3.3 打印线程名称及其通过隧道的顺序，模拟人通过隧道及其顺序 System.out.println(Thread.currentThread().getName() + "已经通过隧道，TA是第" + crossNum + "通过的！"); &#125;&#125; 1234567891011121314151617/* * 2.定义一个测试类 */public class TunnelDemo &#123; public static void main(String[] args) &#123; // 2.1 在main方法中创建一个隧道类对象 Tunnel tul = new Tunnel(); // 2.2 在main方法中，循环创建10个子线程对象，通过构造方法把隧道对象和// 线程名（作为人的姓名）传递进去，并开启子线程 for (int i = 1; i &lt;= 10; i++) &#123; Thread t = new Thread(tul, "p" + i); t.start(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java面试</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-Java集合篇]]></title>
    <url>%2F2019%2F08%2F09%2F2019-08-09-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-Java%E9%9B%86%E5%90%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[集合的概念：是一种工具类，可以存储任意数量、任意类型的对象（所以后面需要用到泛型，以约束集合中元素的类型） 1. 说说常见的集合有哪些吧？Map接口和Collection接口是所有集合框架的父接口： Collection接口的子接口包括：Set接口和List接口 Map接口的实现类主要有：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap以及Properties等 Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等 List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等 2. HashMap与HashTable的区别？ HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的； HashMap允许K/V都为null；后者K/V都不允许为null； HashMap、HashTable都是Map接口的实现类，但是hashMap类继承自抽象类AbstractMap类，hashTable继承自Dictionary类 3.HashMap的put方法的具体流程？源码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i; // 1.如果table为空或者长度为0，即没有元素，那么使用resize()方法扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 2.计算插入存储的数组索引i，此处计算方法同 1.7 中的indexFor()方法 // 如果数组为空，即不存在Hash冲突，则直接插入数组 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 3.插入时，如果发生Hash冲突，则依次往下判断 else &#123; HashMap.Node&lt;K,V&gt; e; K k; // a.判断table[i]的元素的key是否与需要插入的key一样，若相同则直接用新的value覆盖掉旧的value // 判断原则equals() - 所以需要当key的对象重写该方法 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // b.继续判断：需要插入的数据结构是红黑树还是链表 // 如果是红黑树，则直接在树中插入 or 更新键值对 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是链表，则在链表中插入 or 更新键值对 else &#123; // i .遍历table[i]，判断key是否已存在：采用equals对比当前遍历结点的key与需要插入数据的key // 如果存在相同的，则直接覆盖 // ii.遍历完毕后任务发现上述情况，则直接在链表尾部插入数据 // 插入完成后判断链表长度是否 &gt; 8：若是，则把链表转换成红黑树 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 对于i 情况的后续操作：发现key已存在，直接用新value覆盖旧value&amp;返回旧value if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 插入成功后，判断实际存在的键值对数量size &gt; 最大容量 // 如果大于则进行扩容 if (++size &gt; threshold) resize(); // 插入成功时会调用的方法（默认实现为空） afterNodeInsertion(evict); return null;&#125; 图解： 4.HashMap的扩容操作是怎么实现的？通过分析源码我们知道了HashMap通过resize()方法进行扩容或者初始化的操作，下面是对源码进行的一些简单分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 该函数有2中使用情况：1.初始化哈希表；2.当前数组容量过小，需要扩容 */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table;// 扩容前的数组（当前数组） int oldCap = (oldTab == null) ? 0 : oldTab.length;// 扩容前的数组容量（数组长度） int oldThr = threshold;// 扩容前数组的阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 针对情况2：若扩容前的数组容量超过最大值，则不再扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 针对情况2：若没有超过最大值，就扩容为原来的2倍（左移1位） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 针对情况1：初始化哈希表（采用指定或者使用默认值的方式） else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每一个bucket都移动到新的bucket中去 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; （1）如果老表的容量大于0，判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表（此时oldCap 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大）；将新表的容量赋值为老表的容量2，如果新容量小于最大容量并且老容量不小于16，则直接将新的阈值设置为原来的两倍。 （2）如果老表的容量为0，老表的阈值大于0，这种情况是传了容量的new方法创建的空表，将新表的容量设置为老表的阈值（这种情况发生在新创建的HashMap第一次put时，该HashMap初始化的时候传了初始容量，由于HashMap并没有capacity变量来存放容量值，因此传进来的初始容量是存放在threshold变量上（查看HashMap(int initialCapacity, float loadFactor)方法），因此此时老表的threshold的值就是我们要新创建的HashMap的capacity，所以将新表的容量设置为老表的阈值。 （3）如果老表的容量为0，老表的阈值为0，这种情况是没有传容量的new方法创建的空表，将阈值和容量设置为默认值。 （4）如果新表的阈值为空，则通过新的容量 * 负载因子获得阈值（这种情况是初始化的时候传了初始容量，跟第2点相同情况，或者初始容量设置的太小导致老表的容量没有超过16导致的）。 （5）将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将当前的表设置为新定义的表。 （6）如果老表不为空，则需遍历所有节点，将节点赋值给新表。 （7）将老表上索引为j的头结点赋值给e节点，并将老表上索引为j的节点设置为空。 （8）如果e的next节点为空，则代表老表的该位置只有1个节点，通过hash值计算新表的索引位置，直接将该节点放在新表的该位置上。 （9）如果e的next节点不为空，并且e为TreeNode，则调用split方法进行hash分布。 （10）如果e的next节点不为空，并且e为普通的链表节点，则进行普通的hash分布。 （11）如果e的hash值与老表的容量（为一串只有1个为2的二进制数，例如16为0000 0000 00010000）进行位与运算为0，则说明e节点扩容后的索引位置跟老表的索引位置一样（见例子1），进行链表拼接操作：如果loTail为空，代表该节点为第一个节点，则将loHead赋值为该节点；否则将节点添加在loTail后面，并将loTail赋值为新增的节点。 （12）如果e的hash值与老表的容量（为一串只有1个为2的二进制数，例如16为0000 0000 00010000）进行位与运算为1，则说明e节点扩容后的索引位置为：老表的索引位置＋oldCap（见例子1），进行链表拼接操作：如果hiTail为空，代表该节点为第一个节点，则将hiHead赋值为该节点；否则将节点添加在hiTail后面，并将hiTail赋值为新增的节点。 （13）老表节点重新hash分布在新表结束后，如果loTail不为空（说明老表的数据有分布到新表上原索引位置的节点），则将最后一个节点的next设为空，并将新表上原索引位置的节点设置为对应的头结点；如果hiTail不为空（说明老表的数据有分布到新表上原索引+oldCap位置的节点），则将最后一个节点的next设为空，并将新表上索引位置为原索引+oldCap的节点设置为对应的头结点。 （14）返回新表。 5.HashMap是怎么解决哈希冲突的？在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行。 什么是哈希？ Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 什么是哈希冲突？ 当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。 HashMap的数据结构 在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突： 这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化 hash()函数 上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）&#125; 这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）； JDK1.8新增红黑树 通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)； 简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的： （1）使用链地址法（使用散列表）来链接拥有相同hash值的数据； （2）使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均； （3）引入红黑树进一步降低遍历的时间复杂度，使得遍历更快； 6.HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置； 那怎么解决呢？ （1）HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均； （2）在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题； 为什么数组长度要保证为2的幂次方呢？ 只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率； 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 那为什么是两次扰动呢？ 这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的； 7.HashMap在JDK1.7和JDK1.8中有哪些不同？ 不同 JDK 1.7 JDK 1.8 存储结构 数组 + 链表 数组 + 链表 + 红黑树 初始化方式 单独函数：inflateTable() 直接集成到了扩容函数resize()中 hash值计算方式 扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算 扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算 存放数据的规则 无冲突时，存放数组；冲突时，存放链表 无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树 插入数据方式 头插法（先讲原位置的数据移到后1位，再插入数据到该位置） 尾插法（直接插入到链表尾部/红黑树） 扩容后存储位置的计算方式 全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)） 按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量） 8.为什么HashMap中String、Integer这样的包装类适合作为K？String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率 （1）都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况 （2）内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况； 如果我想要让自己的Object作为K应该怎么办呢？ 重写hashCode()和equals()方法 （1）重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞； （2）重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性； 9.ConcurrentHashMap和Hashtable的区别？ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 ConcurrentHashMap的具体实现知道吗？ 在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下： （1）该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色； （2）Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。 在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下： 插入元素过程： （1）如果相应位置的Node还没有初始化，则调用CAS插入相应的数据； 1234else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin&#125; （2）如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点； 12345678910111213141516171819if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125;&#125; （3）如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值； （4）如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount； 10.Java集合的快速失败机制 “fail-fast”？Fail-fast 机制是 java 集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。 例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改如增删改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。 使用CopyOnWriteArrayList来替换ArrayList 补充：采用安全失败（Fail-Safe）机制的集合容器,在遍历时不是直接在集合内容上访问的，而是先copy原有集合内容,在拷贝的集合上进行遍历。java.util.concurrent包下的容器都是Fail-Safe的,可以在多线程下并发使用,并发修改。 11.ArrayList 和 Vector 的区别？这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引来取出某个元素，并且其中的数据是允许重复的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。 ArrayList 与 Vector 的区别主要包括两个方面： 同步性： Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 数据增长： ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 2 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 (0.5 倍 + 1) 个空间。 12.ArrayList和LinkedList的区别？ LinkedList 实现了 List 和 Deque 接口，一般称为双向链表；ArrayList 实现了 List 接口，动态数组； LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高； LinkedList 比 ArrayList 需要更多的内存； 13.Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？ Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 Array 大小是固定的，ArrayList 的大小是动态变化的。 ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 14.HashSet是如何保证数据不可重复的？HashSet的底层其实就是HashMap，只不过我们HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存，我们可以看到源码： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值&#125; 由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。 15.BlockingQueue是什么？Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。]]></content>
      <categories>
        <category>Java面试</category>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-Java IO篇]]></title>
    <url>%2F2019%2F08%2F06%2F2019-08-06-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-Java%20IO%E7%AF%87%2F</url>
    <content type="text"><![CDATA[目录 什么是IO? Java中的IO类库的基本架构 Java访问磁盘文件 Java序列化技术 网络IO工作机制 1. 什么是IO？IO即输入Input 输出Output的缩写，最容易让人联想到的就是屏幕这样的输出设备以及键盘鼠标这一类的输入设备， IO技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。 我们可以从定义上看到问题的核心就是：数据/ 输入/ 输出，在Java中，主要就是涉及到磁盘 IO 和网络 IO 两种了。 Java程序中，对于数据的输入/输出操作以 流(stream) 的方式进行。 简单理解Java 流（Stream） 通常我们说 IO 都会涉及到诸如输入流、输出流这样的概念，那么什么是流呢？流是一个抽象但形象的概念，你可以简单理解成一个数据的序列，输入流表示从一个源读取数据，输出流则表示向一个目标写数据，在Java程序中，对于数据的输入和输出都是采用 “流” 这样的方式进行的，其设备可以是文件、网络、内存等。 流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。 可以将流想象成一个水流管道，水流就在这管道中形成了，自然就出现了方向的概念。 2. Java中的IO类库的基本架构I/O 问题是任何编程语言都无法回避的问题，因为 I/O 操作是人机交互的核心，是机器获取和交换信息的主要渠道，所以如何设计 I/O 系统变成了一大难题，特别是在当今大流量大数据的时代，I/O 问题尤其突出，很容易称为一个性能的瓶颈，也正因为如此，在 I/O 库上也一直在做持续的优化，例如JDK1.4引入的 NIO，JDK1.7引入的 NIO 2.0，都一定程度上的提升了 I/O 的性能。 Java的 I/O 操作类在包 java.io下，有将近80个类，这些类大概可以分成如下 4 组： 基于字节操作的 I/O 接口：InputStream 和 OutputStream； 基于字符操作的 I/O 接口：Writer 和 Reader； 基于磁盘操作的 I/O 接口：File； 基于网络操作的 I/O 接口：Socket； 前两组主要是传输数据的数据格式，后两组主要是传输数据的方式，虽然Socket类并不在java.io包下，但这里仍然把它们划分在了一起；I/O 只是人机交互的一种手段，除了它们能够完成这个交互功能外，我们更多的应该是关注如何提高它的运行效率。 2.1 基于字节的 I/O 操作接口基于字节的 I/O 操作的接口输入和输出分别对应是 InputStream 和 OutputStream，InputStream 的类层次结构如下图： 输入流根据数据类型和操作方式又被划分成若干个子类，每个子类分别处理不同操作类型。 OutputStream 输出流的类层次结构也是类似，如下图所示： 这里就不详细解释每个子类如何使用了，如果感兴趣可以自己去看一下JDK的源码，而且的话从类名也能大致看出一二该类是在处理怎样的一些东西..这里需要说明两点： （1）操作数据的方式是可以组合使用的： 1OutputStream out = new BufferedOutputStream(new ObjectOutputStream(new FileOutputStream("fileName"); （2）必须要指定流最终写到什么地方： 要么是写到磁盘，要么是写到网络中，但重点是你必须说明这一点，而且你会发现其实SocketOutputStream是属于FileOutputStream下的，也就是说写网络实际上也是写文件，只不过写网络还有一步需要处理，就是让底层的操作系统知道我这个数据是需要传送到其他地方而不是本地磁盘上的。 2.2 基于字符的 I/O 操作接口不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以 I/O 操作的都是字节而不是字符，但是在我们日常的程序中操作的数据几乎都是字符，所以为了操作方便当然要提供一个可以直接写字符的 I/O 接口。而且从字符到字节必须经过编码转换，而这个编码又非常耗时，还经常出现乱码的问题，所以 I/O 的编码问题经常是让人头疼的问题。 下图是写字符的I/O 操作接口涉及到的类，Writer 类提供了一个抽象方法 write(char cbuf[], int off, int len) 由子类去实现： Read读字符的操作接口也有类似的类结构，如下图所示： 读字符的操作接口中也是 int read(char cbuf[], int off, int len)，返回读到的 n 个字节数，不管是 Writer 还是 Reader 类它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘和网络的工作机制。 2.3 字节与字符的转化接口另外数据持久化或网络传输都是以字节进行的，所以必须要有字符到字节或字节到字符的转化。字符到字节需要转化，其中读的转化过程如下图所示： InputStreamReader 类是字节到字符的转化桥梁，InputStream 到 Reader 的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。StreamDecoder 正是完成字节到字符的解码的实现类。也就是当你用如下方式读取一个文件时： 123456789try &#123; StringBuffer str = new StringBuffer(); char[] buf = new char[1024]; FileReader f = new FileReader("file"); while(f.read(buf)&gt;0)&#123; str.append(buf); &#125; str.toString(); &#125; catch (IOException e) &#123;&#125; FileReader 类就是按照上面的工作方式读取文件的，FileReader 是继承了 InputStreamReader 类，实际上是读取文件流，然后通过 StreamDecoder 解码成 char，只不过这里的解码字符集是默认字符集。 写入也是类似的过程如下图所示： 通过 OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程。 3. Java访问磁盘文件我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是 Java 中通常的 File 并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。 何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream 类都是操作一个文件的接口，注意到在创建一个 FileInputStream 对象时，会创建一个 FileDescriptor 对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过 getFD() 方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用 FileDescriptor.sync() 方法将操作系统缓存中的数据强制刷新到物理磁盘中。 下面以上文读取文件的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示： 当传入一个文件路径，将会根据这个路径创建一个 File 对象来标识这个文件，然后将会根据这个 File 对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符 FileDescriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要 StreamDecoder 类将 byte 解码为 char 格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。至于操作系统是如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答，至于文件系统的相关细节可以参考另外的文章。 4. Java序列化技术Java序列化就是将一个对象转化成一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化的目的（如用于网络传输或保存到磁盘上）。需要持久化，对象必须继承 java.io.Serializable 接口。 4.1 一个实际的序列化例子第一步：创建一个用于序列化的对象 为了具体说明序列化在Java中是如何运作的，我们来写一个实际的例子，首先我们来写一个用于序列化的对象，然后实现上述的接口： 123456789101112131415/** * 用于演示Java中序列化的工作流程... * * @author: @aimanyeye * @create: 2019-08-06-下午 14:37 */public class People implements Serializable&#123; public String name; public transient int age; public void sayHello() &#123; System.out.println("Hello,My Name is " + name); &#125;&#125; 注意：一个类的对象想要序列化成功，必须满足两个条件 ①实现上述的接口； ②保证该类的所有属性必须都是可序列化的，如果不希望某个属性序列化（例如一些敏感信息），可以加上transient关键字； 第二步：序列化对象 如下的代码完成了实例化一个 People 对象并其序列化到D盘的根目录下的一个操作，这里呢按照 Java 的标准约定将文件的后缀写成 .ser 的样子，你也可以写成其他的… 1234567891011121314People people = new People();people.name = "aimanyeye";people.age = 21;try &#123; FileOutputStream fileOutputStream = new FileOutputStream("D:/people.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOutputStream); out.writeObject(people); out.close(); fileOutputStream.close(); System.out.println("Serialized data is saved in D:/");&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 第三步：反序列化对象 下面的程序完成了对刚才我们序列化的文件还原成一个People对象的过程，并获取了其中的参数，但是注意，由于我们希望 age 属性是短暂的加入了transient关键字， 所以我们无法获取到序列化时 People 的 age 属性： 123456789101112131415161718People people = null;try &#123; FileInputStream fileIn = new FileInputStream("D:/people.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); people = (People) in.readObject(); in.close(); fileIn.close();&#125; catch (IOException i) &#123; i.printStackTrace(); return;&#125; catch (ClassNotFoundException c) &#123; System.out.println("People class not found"); c.printStackTrace(); return;&#125;System.out.println("Deserialized People...");System.out.println("Name: " + people.name);System.out.println("Age: " + people.age); 输出结果如下： 123Deserialized People...Name: aimanyeyeAge: 0 serialVersionUID的作用 上述的例子中我们完成了对一个 People 对象序列化和反序列化的过程，我们现在来做一点简单的修改，例如把age字段的transient关键字去掉： 123456789public class People implements Serializable &#123; public String name; public int age; public void sayHello() &#123; System.out.println("Hello,My Name is " + name); &#125;&#125; 然后我们再运行我们刚才反序列化的代码，会发现，这个时候程序竟然报错了，说是serialVersionUID不一致： 事实上，如果你经常看别人的代码的话，或许会有留意到诸如这样的代码： 1private static final long serialVersionUID = 876323262645176354L; 就这一长串的东西也不知道是在干嘛的，但这其实是为了保证序列化版本的兼容性，即在版本升级后序列化仍保持对象的唯一性；我们通过上述的修改也感受到了其中的一二，但是问题是：我们并没有在需要序列化的对象中写任何关于这个UID的代码呀？ 这是个有趣的问题，通常情况下，如果我们实现了序列化接口，但是没有自己显式的声明这个UID的话，那么JVM就会根据该类的类名、属性名、方法名等自己计算出一个独一无二的变量值，然后将这个变量值一同序列化到文件之中，而在反序列化的时候同样，会根据该类计算出一个独一无二的变量然后进行比较，不一致就会报错。 不显式声明的缺点：一旦写好了某一个类，那么想要修改就不行了，所以我们最好自己显式的去声明； 显式声明的方式：①使用默认的1L作用UID；②根据类名、接口名等生成一个64位的哈希字段，现在的编译器如IDEA、Eclipse都有这样的功能，大家感兴趣去了解下； 4.2 序列化用来干什么？虽然我们上面的程序成功将一个对象序列化保存到磁盘，然后从磁盘还原，但是这样的功能到底可以应用在哪些场景？到底可以干一些什么样的事情呢？下面举一些在实际应用中的例子： Web服务器中保存Session对象，如Tomcat会在服务器关闭时把session序列化存储到一个名为session.ser的文件之中，这个过程称为session的钝化； 网络上传输对象，如分布式应用等； 关于序列化的一些细节 如果一个类没有实现Serializable接口，但是它的父类实现了，那么这个类也是可以序列化的； 相反，如果一个类实现了Serializable接口，但是它的父类没有实现，那么这个类还是可以序列化（Object是所有类的父类），但是序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，会发现该变量数值与序列化时的数值不同（一般为null或者其他默认值），而且这个父类里面必须有无参的构造方法，不然子类反序列化的时候会报错。 5. 网络IO工作机制数据从一台主机发送到网络中的另一台主机需要经过很多步骤，首先双方需要有沟通的意向，然后要有能够沟通的物理渠道（物理链路），其次，还要保障双方能够正常的进行交流，例如语言一致的问题、说话顺序的问题等等等。 5.1 Socket 的工作机制看到有地方说：网络 I/O 的实质其实就是对 Socket 的读取；那Socket 这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把 Socket 比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket 也一样，也有多种。大部分情况下我们使用的都是基于 TCP/IP 的流套接字，它是一种稳定的通信协议。 下图是典型的基于 Socket 的通信的场景： 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。 5.2 建立通信链路当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。 与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。 5.3 数据传输传输数据是我们建立连接的主要目的，如何通过 Socket 传输数据，下面将详细介绍。 当连接已经建立成功，服务端和客户端都会拥有一个 Socket 实例，每个 Socket 实例都有一个 InputStream 和 OutputStream，正是通过这两个对象来交换数据。同时我们也知道网络 I/O 都是以字节流传输的。当 Socket 对象创建时，操作系统将会为 InputStream 和 OutputStream 分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到 OutputStream 对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端 InputStream 的 RecvQ 队列中，如果这时 RecvQ 已经满了，那么 OutputStream 的 write 方法将会阻塞直到 RecvQ 队列有足够的空间容纳 SendQ 发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络 I/O 与磁盘 I/O 在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁，在后面 NIO 部分将介绍避免这种情况。 5.4 BIO阻塞IOBIO 即阻塞 I/O，不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时都有可能会阻塞。一旦有线程阻塞将会失去 CPU 的使用权，这在当前的大规模访问量和有性能要求情况下是不能接受的。 虽然当前的网络 I/O 有一些解决办法，如一个客户端一个处理线程，出现阻塞时只是一个线程阻塞而不会影响其它线程工作。 还有为了减少系统线程的开销，采用线程池的办法来减少线程创建和回收的成本。 但是有一些使用场景仍然是无法解决的。如当前一些需要大量 HTTP 长连接的情况，像淘宝现在使用的 Web 旺旺项目，服务端需要同时保持几百万的 HTTP 连接，但是并不是每时每刻这些连接都在传输数据，这种情况下不可能同时创建这么多线程来保持连接。即使线程的数量不是问题，仍然有一些问题还是无法避免的。如这种情况，我们想给某些客户端更高的服务优先级，很难通过设计线程的优先级来完成，另外一种情况是，我们需要让每个客户端的请求在服务端可能需要访问一些竞争资源，由于这些客户端是在不同线程中，因此需要同步，而往往要实现这些同步操作要远远比用单线程复杂很多。以上这些情况都说明，我们需要另外一种新的 I/O 操作方式。 5.5 NIO非阻塞IO很多人都把NIO翻译成New IO，但我更觉得No-Block IO更接近它的本意，也就是非阻塞式IO，它虽然是非阻塞式的，但它是同步的，我们先看一下 NIO 涉及到的关联类图，如下： 上图中有两个关键类：Channel 和 Selector，它们是 NIO 中两个核心概念。我们还用前面的城市交通工具来继续比喻 NIO 的工作方式，这里的 Channel 要比 Socket 更加具体，它可以比作为某种具体的交通工具，如汽车或是高铁等，而 Selector 可以比作为一个车站的车辆运行调度系统，它将负责监控每辆车的当前运行状态：是已经出战还是在路上等等，也就是它可以轮询每个 Channel 的状态。这里还有一个 Buffer 类，它也比 Stream 更加具体化，我们可以将它比作为车上的座位，Channel 是汽车的话就是汽车上的座位，高铁上就是高铁上的座位，它始终是一个具体的概念，与 Stream 不同。Stream 只能代表是一个座位，至于是什么座位由你自己去想象，也就是你在去上车之前并不知道，这个车上是否还有没有座位了，也不知道上的是什么车，因为你并不能选择，这些信息都已经被封装在了运输工具（Socket）里面了，对你是透明的。 NIO 引入了 Channel、Buffer 和 Selector 就是想把这些信息具体化，让程序员有机会控制它们，如：当我们调用 write() 往 SendQ 写数据时，当一次写的数据超过 SendQ 长度是需要按照 SendQ 的长度进行分割，这个过程中需要有将用户空间数据和内核地址空间进行切换，而这个切换不是你可以控制的。而在 Buffer 中我们可以控制 Buffer 的 capacity，并且是否扩容以及如何扩容都可以控制。 理解了这些概念后我们看一下，实际上它们是如何工作的，下面是典型的一段 NIO 代码： 12345678910111213141516171819202122232425262728293031323334public void selector() throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); Selector selector = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.configureBlocking(false);//设置为非阻塞方式 ssc.socket().bind(new InetSocketAddress(8080)); ssc.register(selector, SelectionKey.OP_ACCEPT);//注册监听的事件 while (true) &#123; Set selectedKeys = selector.selectedKeys();//取得所有key集合 Iterator it = selectedKeys.iterator(); while (it.hasNext()) &#123; SelectionKey key = (SelectionKey) it.next(); if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123; ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel(); SocketChannel sc = ssChannel.accept();//接受到服务端的请求 sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_READ); it.remove(); &#125; else if ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123; SocketChannel sc = (SocketChannel) key.channel(); while (true) &#123; buffer.clear(); int n = sc.read(buffer);//读取数据 if (n &lt;= 0) &#123; break; &#125; buffer.flip(); &#125; it.remove(); &#125; &#125; &#125;&#125; 调用 Selector 的静态工厂创建一个选择器，创建一个服务端的 Channel 绑定到一个 Socket 对象，并把这个通信信道注册到选择器上，把这个通信信道设置为非阻塞模式。然后就可以调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey，通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据，而这里读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器。 在上面的这段程序中，是将 Server 端的监听连接请求的事件和处理请求的事件放在一个线程中，但是在实际应用中，我们通常会把它们放在两个线程中，一个线程专门负责监听客户端的连接请求，而且是阻塞方式执行的；另外一个线程专门来处理请求，这个专门处理请求的线程才会真正采用 NIO 的方式，像 Web 服务器 Tomcat 和 Jetty 都是这个处理方式。 下图是描述了基于 NIO 工作方式的 Socket 请求的处理过程： 上图中的 Selector 可以同时监听一组通信信道（Channel）上的 I/O 状态，前提是这个 Selector 要已经注册到这些通信信道中。选择器 Selector 可以调用 select() 方法检查已经注册的通信信道上的是否有 I/O 已经准备好，如果没有至少一个信道 I/O 状态有变化，那么 select 方法会阻塞等待或在超时时间后会返回 0。上图中如果有多个信道有数据，那么将会将这些数据分配到对应的数据 Buffer 中。所以关键的地方是有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连接请求。 5.6 Buffer 的工作方式上面介绍了 Selector 将检测到有通信信道 I/O 有数据传输时，通过 selelct() 取得 SocketChannel，将数据读取或写入 Buffer 缓冲区。下面讨论一下 Buffer 如何接受和写出数据？ Buffer 可以简单的理解为一组基本数据类型的元素列表，它通过几个变量来保存这个数据的当前位置状态，也就是有四个索引。如下表所示： 索引 说明 capacity 缓冲区数组的总长度 position 下一个要操作的数据元素的位置 limit 缓冲区数组中不可操作的下一个元素的位置，limit&lt;=capacity mark 用于记录当前 position 的前一个位置或者默认是 0 在实际操作数据时它们有如下关系图： 我们通过 ByteBuffer.allocate(11) 方法创建一个 11 个 byte 的数组缓冲区，初始状态如上图所示，position 的位置为 0，capacity 和 limit 默认都是数组长度。当我们写入 5 个字节时位置变化如下图所示： 这时底层操作系统就可以从缓冲区中正确读取这 5 个字节数据发送出去了。在下一次写数据之前我们在调一下 clear() 方法。缓冲区的索引状态又回到初始位置。 这里还要说明一下 mark，当我们调用 mark() 时，它将记录当前 position 的前一个位置，当我们调用 reset 时，position 将恢复 mark 记录下来的值。 还有一点需要说明，通过 Channel 获取的 I/O 数据首先要经过操作系统的 Socket 缓冲区再将数据复制到 Buffer 中，这个的操作系统缓冲区就是底层的 TCP 协议关联的 RecvQ 或者 SendQ 队列，从操作系统缓冲区到用户缓冲区复制数据比较耗性能，Buffer 提供了另外一种直接操作操作系统缓冲区的的方式即 ByteBuffer.allocateDirector(size)，这个方法返回的 byteBuffer 就是与底层存储空间关联的缓冲区，它的操作方式与 linux2.4 内核的 sendfile 操作方式类似。 上面从 NIO 中引入了一些概念，下面我们对这些概念再来进行简单的复述和补充： 缓冲区Buffer：缓冲区是一个对象，里面存的是数据，NIO进行通讯，传递的数据，都包装到Buffer中，Buffer是一个抽象类。子类有ByteBuffer、CharBuffer等，常用的是字节缓冲区，也就是ByteBuffer； 通道Channel：channel是一个通道，通道就是通流某种物质的管道，在这里就是通流数据，他和流的不同之处就在于，流是单向的，只能向一个方向流动，而通道是一个管道，有两端，是双向的，可以进行读操作，也可以写操作，或者两者同时进行； 多路复用器Selector：多路复用器是一个大管家，他管理着通道，通道把自己注册到Selector上面，Selector会轮询注册到自己的管道，通过判断这个管道的不同的状态，来进行相应的操作； NIO 工作机制的核心思想就是：客户端和服务器端都是使用的通道，通道具有事件，可以将事件注册到多路复选器上，事件有就绪和非就绪两种状态，就绪的状态会放到多路复选器的就绪键的集合中，起一个线程不断地去轮询就绪的状态，根据不同的状态做不同的处理。 5.7 NIO 和 IO 的主要区别（1）面向流与面向缓冲 Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。 （2）阻塞与非阻塞IO Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 （3）选择器（Selectors） Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 5.8 Java AIO 简单了解AIO就是异步非阻塞IO，A就是asynchronous的意思，因为NIO1.0虽然面向缓冲，利用多路复选器实现了同步非阻塞IO，可是在NIO1.0中需要使用一个线程不断去轮询就绪集合，开销也是比较大的，所以在jdk1.7中扩展了NIO，称之为NIO2.0，NIO2.0中引入了AIO，此外NIO2.0中还引入了异步文件通道，那么究竟是怎么实现异步的呢？ AIO 有三个特点，它的特点也可以说明它是如何完成异步这样的操作的： ①读完了再通知我； ②不会加快 I/O，只是在读完后进行通知； ③使用回调函数，进行业务处理； AIO 的核心原理就是：对客户端和服务器端的各种操作进行回调函数的注册（通过实现一个CompletionHandler接口，其中定义了一个completed的成功操作方法和一个fail的失败方法）。在完成某个操作之后，就会自己去调用该注册到该操作的回调函数，达到异步的效果。 BIO/ NIO/ AIO 的简单理解 我们在这里假设一个烧了一排开水的场景， BIO（同步阻塞IO）的做法就是，叫一个线程停留在一个水壶那，直到这个水壶烧开我再去处理下一个水壶； NIO（准备好再通知我，同步非阻塞IO）的做法就是叫一个线程不断地去询问每个水壶的状态，看看是否有水壶的状态发生了变化，变化则再去做相应的处理； AIO（读完了再通知我，异步非阻塞IO）的做法是在每个水壶上都安装一个装置，当水壶烧开之后就会自动通知我水壶烧开了让我做相应的处理。 同步与异步 同步与异步的概念, 关注的是 消息通信机制 同步是指发出一个请求, 在没有得到结果之前该请求就不返回结果, 请求返回时, 也就得到结果了. 比如洗衣服, 把衣服放在洗衣机里, 没有洗好之前我们一直看着, 直到洗好了才拿出来晾晒. 异步是指发出一个请求后, 立刻得到了回应, 但没有返回结果. 这时我们可以再处理别的事情(发送其他请求), 所以这种方式需要我们通过状态主动查看是否有了结果, 或者可以设置一个回调来通知调用者. 比如洗衣服时, 把衣服放到洗衣机里, 我们就可以去做别的事情, 过会儿来看看有没有洗好(通过状态查询); 或者我们设置洗衣机洗完后响铃来通知我们洗好了(回调通知) 阻塞与非阻塞 阻塞与非阻塞很容易和同步与异步混淆, 但两者关注点是不一样的. 阻塞与非阻塞关注的是 程序在等待调用结果时的状态 阻塞是指请求结果返回之前, 当前线程会被挂起(被阻塞), 这时线程什么也做不了 非阻塞是指请求结果返回之前, 当前线程没有被阻塞, 仍然可以做其他事情. 阻塞有个明显的特征就是线程通常是处于BLOCKED状态(BIO中的read()操作时, 线程阻塞是JVM配合OS完成的, 此时Java获取到线程的状态仍是RUNNABLE但它确实已经被阻塞了) 如果要拿同步来做比较的话, 同步通信方式中的线程在发送请求之后等待结果这个过程中应该处于RUNNABLE状态, 同步必须一步一步来完成, 就像是代码必须执行完一行才能执行下一行, 所以必须等待这个请求返回之后才可进行下一个请求, 即使等待结果的时间长, 也是在执行这个请求的过程中. 而异步则不用等上一条执行完, 可以先执行别的代码, 等请求有了结果再来获取结果. IO模型对比Java中的IO操作是JVM配合操作系统来完成的. 对于一个IO的读操作, 数据会先被拷贝到操作系统内核的缓冲区中, 然后从操作系统内核的缓冲区拷贝到应用程序的地址空间. 所以整个过程可分为两个阶段: 等待I/O数据准备好. 这取决于IO目标返回数据的速度, 如网络IO时看网速和数据本身的大小. 数据从内核缓冲区拷贝到进程内. 根据这两个阶段, 产生了常见的几种不同的IO模型: BIO, NIO, IO多路复用和AIO. BIO BIO即Blocking I/O(阻塞 I/O), BIO整个过程如下图: 程序发送请求给内核, 然后由内核去进行通信, 在内核准备好数据之前这个线程是被挂起的, 所以在两个阶段程序都处于挂起状态. BIO的特点就是在IO执行的两个阶段都被block了 NIO NIO即Non-Blocking I/O(非阻塞 I/O), NIO整个过程如下图: 与BIO的明显区别是, 发起第一次请求后, 线程并没有被阻塞, 它反复检查数据是否准备好, 把原来大块不能用的阻塞时间分成了许多”小阻塞”(检查), 所以进程不断有机会被执行. 这个检查有没有准备好数据的过程有点类似于”轮询”. NIO的特点就是程序需要不断的主动询问内核数据是否准备好。第一个阶段非阻塞, 第二个阶段阻塞 IO多路复用 IO多路复用(I/O Multiplexing)有select, poll, epoll等不同方式, 它的优点在于单个线程可以同时处理多个网络IO. NIO中轮询操作是用户线程进行的, 如果把这个任务交给其他线程, 则用户线程就不用这么费劲的查询状态了. IO多路复用调用系统级别的select或poll模型, 由系统进行监控IO状态. select轮询可以监控许多socket的IO请求, 当有一个socket的数据准备好时就可以返回. select: 注册事件由数组管理, 数组是有长度的, 32位机上限1024, 64位机上限2048. 轮询查找时需要遍历数组. poll: 把select的数组采用链表实现, 因此没了最大数量的限制 epoll方式: 基于事件回调机制, 回调时直接通知进程, 无须使用某种方式来查看状态. 多路复用IO过程图: 用户线程有一段时间是阻塞的, 从上图来看, 与NIO很像, 但与NIO不一样的是, select不是等到所有数据准备好才返回, 而是只要有一个准备好就返回, 它的优势在于可以同时处理多个连接. 若连接不是很多的话, 它的效率不一定高, 可能还会更差. Java 1.4开始支持NIO(New IO), 就是采用了这种方式, 在套接字上提供selector选择机制, 当发起select()时会阻塞等待至少一个事件返回. 多路复用IO的特点是用户进程能同时等待多个IO请求, 系统来监控IO状态, 其中的任意一个进入读就绪状态, select函数就可以返回. AIO AIO即Asynchronous I/O(异步 I/O), 这是Java 1.7引入的NIO 2.0中用到的. 整个过程中, 用户线程发起一个系统调用之后无须等待, 可以处理别的事情. 由操作系统等待接收内容, 接收后把数据拷贝到用户进程中, 最后通知用户程序已经可以使用数据了, 两个阶段都是非阻塞的. AIO整个过程如下图: AIO属于异步模型, 用户线程可以同时处理别的事情, 我们怎么进一步加工处理结果呢? Java在这个模型中提供了两种方法: 一种是基于”回调”, 我们可以实现CompletionHandler接口, 在调用时把回调函数传递给对应的API即可 另一种是返回一个Future. 处理完别的事情, 可以通过isDone()可查看是否已经准备好数据, 通过get()方法等待返回数据. 上面这几种模式, BIO整个过程都等待返回, NIO和IO多路复用在第二个阶段等待返回, 因此从整个过程来看, 这三个模式都属于同步方式. AIO在整个过程中没有等待返回, 属于异步方式. BIO、NIO、AIO适用场景分析 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。]]></content>
      <categories>
        <category>Java面试</category>
        <category>Java IO</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-Java Web篇]]></title>
    <url>%2F2019%2F08%2F05%2F2019-08-05-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-Java%20Web%E7%AF%87%2F</url>
    <content type="text"><![CDATA[目录 J2EE相关知识点 框架相关知识点 1. J2EE相关知识点1.1 Servlet 的生命周期？在 Web 容器中，Servlet 主要经历 4 个阶段，如下图： （1）加载 Servlet：当 Tomcat 第一次访问 Servlet 的时候，Tomcat 会负责创建 Servlet 的实例。 （2）初始化 Servlet：当 Servlet 被实例化之后，Tomcat 会调用 init() 方法来初始化这个对象。 （3）处理服务：当浏览器访问 Servlet 的时候，Servlet 会调用 service() 方法处理请求。 （4）销毁：当 Tomcat 关闭或者检测到 Servlet 要从 Tomcat 删除的时候，会自动调用 destroy() 方法，让该实例所占用的资源释放掉。一个 Servlet 如果长时间不被使用的话，也会被 Tomcat 自动销毁。 简单总结：只要访问 Servlet ，就会调用其对应的 service() 方法，init() 方法只会在第一次访问 Serlvet 的时候才会被调用。 1.2 Servlet 的请求流程？ （1）浏览器发出请求： http://localhost:80/xxx1/xxx2 （80端口可以默认不写，因为这是http协议默认的端口，平时我们访问https://www.baidu.com/ 时其实访问的是https://www.baidu.com:80/） （2）服务器解析请求信息： 12345http:协议名称localhost:访问的是互联网中的哪一台计算机80:从主机当中找到对应 80 端口的程序 （这里即为 Tomcat 服务器）/xxx1:当前项目的上下文路径 （即在 server.xml 中配置主机时配置的 path属性）/xxx2:当前请求的资源名 （3）解析 Tomcat 服务器根目录下的 /config/server.xml 文件： 12345&lt;Context docBase=&quot;D:\javaPros\test\webapp&quot; path=&quot;xxx1&quot; /&gt;... 判断哪一个&lt;Context /&gt;元素的 path属性 属性为 xxx1?若找不到，则返回 404错误若找到了，则解析该&lt;Context /&gt;元素，得到docBase属性，获取当前访问 Web 项目的跟的绝对路径：D:\javaPros\test\webapp （4） 从D:\javaPros\test\webapp下的 WEB-INF 下找到 web.xml 文件 123判断 web.xml 文件中是否有 &lt;url-pattern&gt; 的文本内容为 /xxx2?若找不到，则返回 404错误若找到了，则继续获取该资源对应 Servlet 类的全限名称： xxx.xxx （5） 判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象 123456789101112Map&lt;String,Servlet&gt; cache = ......(Tomcat提供的); key:存Servlet类的全限定名称 value:该Servlet类的对象.Servlet obj = cache.get("xxx.xxx"); if(obj==null)&#123; //Servlet实例缓存中没有该类的对象,第一次. GOTO 6: &#125;else&#123; //有对象,非第一次. GOTO 8: &#125;&#125; （6）使用反射调用构造器，创建对应的对象 123obj = Class.forName("xxx.xxx").newInstance();//把当前创建的 Servlet 对象，存放在缓存之中，供给下一次的使用.cache.put("xxx.xxx",obj); （7）创建 ServletConfig 对象，并调用 init() 方法 1obj.init(config); （8）创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法 1obj.service(req,resp); （9）在 service() 方法中对浏览器作出响应操作。 1.3 Servlet 是单例的吗？为什么？Servlet 是单例的，浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。 1.4 GET和POST的区别首先GET 和 POST 都是请求方式。 GET： 浏览器器地址栏：http://localhost/test.html?name=aimanyeye&amp;sex=male 这里提交了两个参数，一个是name属性值为aimanyeye，另一个是sex属性值为male，这是一种直接的请求方式，在请求资源后面跟上 ? 符号与参数连接，其他的参数使用 &amp; 符号连接。 缺点： 暴露请求信息，不安全 请求信息不能超过1kb，可传输的信息有限，不能上传图片。 POST： 浏览器地址栏：http://localhost/test.html# 优点： 隐藏了请求信息，较安全（但仍可以通过相关工具访问到数据） POST 方式没有限制请求的数据大小，可以做图片的上传 1.5 Tomcat 中如何解决中文乱码问题？在 Tomcat 服务器中，接受请求的时候，默认的编码方式为 ISO-8859-1，而该编码方式只占一个字节，不支持中文（两个字节），所以当我们做请求的时候，会出现乱码的问题。 解决方案： （1）对乱码使用 ISO-8859-1 解码，转换成byte数组，恢复为二进制 byte[] data = name.getBytes(&quot;ISO-8859-1&quot;); （2）对byte数组重新进行 UTF-8 编码： name = new String(data,&quot;UTF-8&quot;);但是这样会出现一个问题，那就是当表单数据太多的时候，这样反复解码-编码，会很繁琐。 终极解决方案： 对于 POST 请求： 设置请求的编码方式：request.setCharacterEncoding(&quot;UTF-8&quot;);注意：必须在获取第一个参数之前设置，并且该方式只对 POST 方式有效。 对于 GET 请求： 重新设置 Tomcat 的编码方式，修改 Tomcat 的配置文件:Tomcat根目录/conf/server.xml(修改端口的那一行) 1.6 forward 与 redirect 的区别 请求转发（forward） 又叫做直接转发方式，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。 比如：从 AServlet 请求转发到 BServlet 语法： 12//参数： path，要跳转到的资源路径：上下文路径 / 资源路径request.getRequestDispatcher(path).forward(request, response); 特点： （1）地址栏中的地址【不会】改变，通常看作是服务端的跳转 （2）只有一个请求 （3）资源是共享的 也就是说在两个 Servlet 中可以共享请求的资源，可以通过request.setAttribute(String var1,Object var2)设置要共享的数据资源，并通过request.getAttribute(String var1);来获取传递的资源。 （4）【可以】访问 WEB-INF 中的资源 WEB-INF 文件夹是 Java Web 应用的默认安全目录，即客户端无法直接访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 注意：在实际的开发中，可以把不希望用户直接访问到（通过浏览器输入地址栏）的网页放在文件夹中通过此方式访问。 （5）请求转发【不能】跨域访问 所谓的同域，是指域名，协议，端口均相同 URl 重定向（redirect） 又叫做间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 比如：从AServlet重定向到BServlet 语法： 12//参数：location，转发到的资源路径response.sendRedirect(String location); 特点： （1）地址栏中的地址【会】发生改变，通常看作是客户端跳转。 （2）有两个请求 （3）在两个 Servlet 中不可以共享请求中的数据 （4）最终的响应由 BServlet 来决定，和 AServlet 没有关系 （5）【不可以】访问 WEB-INF 中的资源 （6）请求转发【能】跨域访问 就像是在网页中点开了新的链接一样 总结：URL 重定向相当于是将重定向的资源路径，重新复制到浏览器地址栏中按下回车一样，重新发送一次新的请求。 1.7 JSP 的执行原理？当访问一个 JSP 页面时，该页面请求将会讲给服务器中的 JSP 引擎去处理，它负责解释和执行 JSP 页面，每个 JSP 页面在第一次被访问时，JSP 引擎就会将它翻译成一个继承自 org.apache.jasper.runtime.HttpJspBase类的 Servlet 源程序，接着再编译成 class 类文件，再由 Web 容器像调用普通 Servlet 程序一样的方式来装载和解释执行这个由 JSP 页面翻译成的 Servlet 程序。 1.8 request.getAttribute() 和 request.getParameter() 有何区别？ request.getParameter() 通常用来接收接收表单的get或者post提交过来的参数；而request.getAttribute()一般和setAttribute()搭配使用，只有先set之后才能通过get方法获取到Object类型的数据。 getAttribute 返回的是对象，而getParameter 返回的是字符串。 getAttribute 和 setAttribute 只是在 web 容器内流转，仅仅是请求处理阶段；而 getParameter 取到的数据是通过容器来获取的。 1.9 JSP 与 Servlet 的区别？ JSP 实质上就是一个 Servlet。可以理解为，JSP 是编译后的 “Servlet 类”。 JSP 由 HTML 代码和 JSP 标签组成，更擅长页面显示；而 Servlet 更擅长流程控制； JSP 感觉像是 HTML 中嵌入 Java 代码，而 Servlet 有些像 Java 中嵌入 HTML 代码的意思。 1.10 JSP 静态包含和动态包含的区别？（1）静态包含：编译指令包含 1&lt;%@include file=&quot;被包含的页面的路径&quot;%&gt; 包含的时机：在 JSP 文件被翻译的时候合并在一起，最终翻译得到一个 class文件 （2）动态包含：动作指令包含 1&lt;jsp:include page=&quot;被包含页面的路径&quot;&gt;&lt;/jsp:include&gt; 包含的时机：在运行阶段合并代码，最终得到两个 class 文件 （3）动态包含和静态包含的选择 如果被包含的页面如果是静态页面,那么使用静态包含； 如果被包含的如果是动态页面,那么使用动态包含。 1.11 JSP 有哪些内置对象？作用分别是什么？JSP 共有以下 9 个内置的对象： 123456789request：用户端请求，此请求会包含来自 GET/POST 请求的参数；response：表示一次响应对象；pageContext：表示当前的 JSP 对象；session：表示一次会话对象；application：表示当前应用对象；out：表示一个输出流对象；config：表示当前 JSP 的配置对象；page：表示当前页面；exception：表示异常对象。 1.12 JSTL 是什么？优点有哪些？JSTL（JSP StandardTagLibrary，JSP标准标签库)是一个不断完善的开放源代码的JSP标签库，由四个定制标记库（core、format、xml和sql）和一对通用标记库验证器（ScriptFreeTLV和PermittedTaglibsTLV）组成。优点有： （1）在应用程序服务器之间提供了一致的接口，最大程序地提高了WEB应用在各应用服务器之间的移植。 （2）简化了JSP和WEB应用程序的开发。 （3）以一种统一的方式减少了JSP中的scriptlet代码数量，可以达到没有任何scriptlet代码的程序。在我们公司的项目中是不允许有任何的scriptlet代码出现在JSP中。 （4）允许JSP设计工具与WEB应用程序开发的进一步集成。相信不久就会有支持JSTL的IDE开发工具出现。 1.13 什么是 Cookie？Session 和 Cookie 有什么区别？Cookie 技术 Cookie 是一种会话技术，用于将用户的信息保存在客户端上。Cookie 英文直接翻译过来就是小甜品，Cookie 的作用呢，通俗的说就是当一个用户通过 HTTP 访问一个服务器时，这个服务器会将一些 Key/Value 键值对返回给客户端浏览器，并给这些数据加上一些限制条件，在条件符合时这个用户下次访问这个服务器时，数据又被完整地带回给服务器。 这个作用就像是你去超市购物时，第一次给你办了一张购物卡，在这个购物卡里存放了一些你的个人信息，下次你再来这个超市的时候，你就只需要带上你的购物卡，直接购物就好了。 Session 技术 Session：会话，从浏览器打开开始，直到浏览器关闭结束，无论在这个网站中访问了多少页面，点击了多少链接，都属于同一个会话。Session 也可以称为会话 Cookie 特点：服务端技术，将数据保存在服务器 Cookie 与 Session 的区别 Cookie 的数据是存放在客户的浏览器上，Session 数据放在服务器上； Cookie 不是很安全，别人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗，如果考虑安全问题则应当使用 Session； Session 会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的资源，所以如果考虑性能问题，则应当使用 Cookie； 单个 Cookie 在客户端的限制是 3k ，就是说一个站点在客户端存放的 Cookie 不能超过 3k。 总结： 将登录信息等重要信息存放为 Session；其他信息如果需要保留，可以存放在 Cookie 中。 1.14 什么是过滤器？过滤器就是 Servlet 的高级特性之一，就是一个具有拦截/过滤功能的一个东西，在生活中过滤器可以是香烟滤嘴，滤纸，净水器，空气净化器等，在 Web 中仅仅是一个实现了 Filter 接口的 Java 类而已。 特点：双向，拦截请求，拦截响应 作用：过滤器可以对所有的请求或者响应做拦截操作 1.15 为什么在 Web 开发中需要用到过滤器？为什么非得使用过滤器，我直接在 Servlet 中作判断不行吗？ 开发遵循的原则： （1）DRY原则（Don’t Reeat Yourself，不要重复你自己）：重复，意味着维护的成本很高。 （2）责任分离原则：谁擅长什么功能就做什么功能，Servlet 擅长的是逻辑而不是处理请求。 举一个实际的例子：（处理 POST 请求中文编码的问题） Web 中过滤器的作用： （1）可以在请求资源之前设置请求的编码 （2）可以进行登录校验 （3）可以进行请求参数的内容的过滤 （4）数据压缩 / 数据加密 / 数据格式的转换 （5）可以设置浏览器相关的数据 1.16 MVC 模式？MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）： Controller——负责转发请求，对请求进行处理 View——负责界面显示 Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现 在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示： （1）Web浏览器发送HTTP请求到服务端，被Controller(Servlet)获取并进行处理（例如参数解析、请求转发） （2）Controller(Servlet)调用核心业务逻辑——Model部分，获得结果 （3）Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容 （4）动态生成的HTML内容返回到浏览器显示。 MVC模式在Web开发中的好处是非常明显，它规避了JSP与Servlet各自的短板，Servlet只负责业务逻辑而不会通过out.append()动态生成HTML代码；JSP中也不会充斥着大量的业务代码。这大大提高了代码的可读性和可维护性。 2. 框架相关知识点2.1 什么是框架？框架是指完成一定功能的半成品。 框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 2.2 什么是SpringSpring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发。 Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 2.3 什么是非侵入式设计？从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 2.4 Spring 有什么优势？ 低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） 2.5 Spring IoC 和 DI 分别是什么？Spring IoC IoC：Inverse of Control（控制反转），读作 “反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 正控：若要使用某个对象，需要自己去负责对象的创建 反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架 好莱坞法则：Don’t call me ,I’ll call you 为了便于理解我们这里举一个鲜明的例子： 在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己“主动”创造的过程，也就是说一杯橙汁需要你自己创造。 然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。 请注意你并没有“主动”去创造橙汁，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。 总结： 这就是一种控制反转的理念，上述的例子已经很好的说明了问题，我们再来描述一下控制反转的概念：控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。 好处： ① 降低对象之间的耦合； ② 我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿） DI Dependency Injection（依赖注入）：指 Spring 创建对象的过程中，将对象依赖属性（简单值，集合，对象）通过配置设值给该对象。 两者的区别 IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，明确描述了 “被注入对象依赖 IoC 容器配置依赖对象”。你也可以简单的理解为：IoC 是目的，是一种思想，而 DI 是手段，是一种设计模式。 2.6 BeanFactory 和 ApplicationContext 的区别BeanFactory： 是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。在应用中，一般不使用 BeanFactory，而推荐使ApplicationContext（应用上下文），原因如下。 ApplicationContext： （1）继承了 BeanFactory，拥有了基本的 IoC 功能； （2）除此之外，ApplicationContext 还提供了以下功能： ① 支持国际化； ② 支持消息机制； ③ 支持统一的资源加载； ④ 支持AOP功能； 注意： ApplicationContext 和 BeanFactory 相比，最主要的区别在于 BeanFactory 是延迟加载，举个例子：如果 Bean 没有完全注入，BeanFactory 加载后，会在你第一次调用 getBean 方法才会抛出异常；而 ApplicationContext 会在初始化的时候就加载并且检查，这样的好处是可以及时检查依赖是否完全注入；所以通常我们会选择 ApplicationContext。 2.7 IoC 是如何实现的最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎： （1）读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名。 （2）使用反射的API，基于类名实例化对应的对象实例。 （3）将对象实例，通过构造函数或者 setter，传递给 JuiceMaker。 我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！ 2.8 Spring 配置 Bean 有几种方式？在 Spring 中提供了 3 种方法进行配置： 在 XML 文件中显式配置 在 Java 的接口和类中实现配置 隐式 Bean 的发现机制和自动装配原则 方式选择的原则 在现实的工作中，这 3 种方式都会被用到，并且在学习和工作之中常常混合使用，所以这里给出一些关于这 3 种优先级的建议： （1）最优先：通过隐式 Bean 的发现机制和自动装配的原则。 基于约定优于配置的原则，这种方式应该是最优先的。 好处：减少程序开发者的决定权，简单又不失灵活。 （2）其次：Java 接口和类中配置实现配置 在没有办法使用自动装配原则的情况下应该优先考虑此类方法。 好处：避免 XML 配置的泛滥，也更为容易。 典型场景：一个父类有多个子类，比如学生类有两个子类，一个男学生类和女学生类，通过 IoC 容器初始化一个学生类，容器将无法知道使用哪个子类去初始化，这个时候可以使用 Java 的注解配置去指定。 （3）最后：XML 方式配置 在上述方法都无法使用的情况下，那么也只能选择 XML 配置的方式。 好处：简单易懂（当然，特别是对于初学者） 典型场景：当使用第三方类的时候，有些类并不是我们开发的，我们无法修改里面的代码，这个时候就通过 XML 的方式配置使用了。 2.9 介绍一下 Spring AOPAOP 即 Aspect Oriented Program 面向切面编程，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。 所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务 所谓的周边功能，比如性能统计，日志，事务管理等等 周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面 在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫 AOP。 一个鲜明的例子： 在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 AOP 的一个思想：让关注点代码与业务代码分离！ 2.10 Spring 中 Bean 的作用域在默认的情况下，Spring IoC 容器只会对一个 Bean 创建一个实例，但有时候，我们希望能够通过 Spring IoC 容器获取多个实例，我们可以通过 @Scope 注解或者 &lt;bean&gt; 元素中的 scope 属性来设置，例如： 1234// XML 中设置作用域&lt;bean id="" class="" scope="prototype" /&gt;// 使用注解设置作用域@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) Spring 提供了 5 种作用域，它会根据情况来决定是否生成新的对象： 作用域类别 描述 singleton(单例) 在Spring IoC容器中仅存在一个Bean实例 （默认的scope） prototype(多例) 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时 ，相当于执行new XxxBean()：不会在容器启动时创建对象 request(请求) 用于web开发，将Bean放入request范围 ，request.setAttribute(“xxx”) ， 在同一个request 获得同一个Bean session(会话) 用于web开发，将Bean 放入Session范围，在同一个Session 获得同一个Bean globalSession(全局会话) 一般用于 Porlet 应用环境 , 分布式系统存在全局 session 概念（单点登录），如果不是 porlet 环境，globalSession 等同于 Session 在开发中主要使用 scope=&quot;singleton&quot;、scope=&quot;prototype&quot;，对于MVC中的Action使用prototype类型，其他使用singleton，Spring容器会管理 Action 对象的创建,此时把 Action 的作用域设置为 prototype. 2.11 Spring MVC 的请求流程每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程： 第一站：DispatcherServlet 从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。 12345678910servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;!-- 拦截所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。 第二站：处理器映射（HandlerMapping） 问题：典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？ 所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理： 12345678910&lt;bean id="simpleUrlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt; &lt;prop key="/hello"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id="helloController" class="controller.HelloController"&gt;&lt;/bean&gt; 第三站：控制器 一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息： 1234public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; // 处理逻辑 ....&#125; 第四站：返回 DispatcherServlet 当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP。 控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。 123456public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; // 处理逻辑 .... // 返回给 DispatcherServlet return mav;&#125; 第五站：视图解析器 这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。 DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP。 第六站：视图 既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了。 它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。 1234&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false"%&gt;&lt;h1&gt;$&#123;message&#125;&lt;/h1&gt; 2.12 Spring MVC 的架构为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案： 传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）。在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在业务层上还允许我们访问 NoSQL ，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。 特点： 结构松散，几乎可以在 Spring MVC 中使用各类视图 松耦合，各个模块分离 与 Spring 无缝集成 2.13 什么是 ORM？对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术； 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用XML或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成Java对象，其本质上就是将数据从一种形式转换到另外一种形式。 2.14 为什么要使用 MyBatis ？在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 2.15 MyBatis 中占位符 # 和 `### 的区别区别如下： #符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号 #符号存在预编译的过程，，对问号赋值，防止SQL注入。 $符号将传入的数据直接显示生成SQL中。 $符号是直译的方式，一般用在order by {列名} 语句中。 能用#号就不要用$符号 2.16 MyBatis 缓存结构 在 Web 系统中，最重要的操作就是查询数据库中的数据。但是有些时候查询数据的频率非常高，这是很耗费数据库资源的，往往会导致数据库查询效率极低，影响客户的操作体验。于是我们可以将一些变动不大且访问频率高的数据，放置在一个缓存容器中，用户下一次查询时就从缓存容器中获取结果。 MyBatis 拥有自己的缓存结构，可以用来缓解数据库压力，加快查询速度。 MyBatis 一级缓存是一个 SqlSession 级别，同一个 SqlSession 只能访问自己的一级缓存的数据 二级缓存是跨sqlSession，是 mapper 级别的缓存，对于 mapper 级别的缓存不同的sqlsession是可以共享的。 2.17 Mybatis添加记录，返回主键idRole.java实体类 1234567891011121314151617181920212223public class Role implements Serializable &#123; private String roleId; private String name; private Integer status; public String getRoleId() &#123; return roleId; &#125; public void setRoleId(String roleId) &#123; this.roleId = roleId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125;&#125; SysRoleDao.java 123public interface SysRoleDao &#123; public int addRole(SysRole role);&#125; mapper-role.xml 123456789&lt;insert id="addRole" parameterType="SysRole" useGeneratedKeys="true" keyProperty="roleId" keyColumn="role_id"&gt; insert into t_sys_role( name,status ) values( #&#123;name,jdbcType=VARCHAR&#125;, #&#123;status,jdbcType=VARCHAR&#125;, )&lt;/insert&gt; 注意： 添加记录能够返回主键的关键点在于需要在&lt;insert&gt;标签中添加以下三个属性&lt;insert useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot;&gt;&lt;/insert&gt;。useGeneratedKeys：必须设置为true，否则无法获取到主键id。keyProperty：设置为POJO对象的主键id属性名称。keyColumn：设置为数据库记录的主键id字段名称 mapper接口返回值依然是成功插入的记录数，新添加主键id并不是在执行添加操作时直接返回的，而是在执行添加操作之后将新添加记录的主键id字段设置为POJO对象的主键id属性。 另一种是数据库（如Oracle）不支持auto-generated key field的。需要使用selectKey操作将操作查询结果赋值到insert元素的parameterType的入参实例下对应的属性中。并提供给insert语句使用。 TestDao.java 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:config/spring-core.xml","classpath:config/spring-web.xml"&#125;)public class TestDao&#123; @Autowired SysRoleDao roleDao; @Test public void test() &#123; SysRole role=new SysRole(); role.setName("admin10"); role.setStatus(1); System.out.println("返回结果:"+roleDao.addRole(role)); System.out.println("主键id:"+role.getRoleId()); &#125;&#125; 打印结果: 12返回结果:1主键id:12 2.18 什么是 Spring Boot ？ 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架。 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 2.19 使用 Spring Boot 有什么好处？回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： （1）配置 web.xml，加载 spring 和 spring mvc （2）配置数据库连接、配置日志文件 （3）配置加在配置文件的读取，开启注解 （4）配置mapper文件 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 好处：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 2.20 分页功能分页功能在网页中是非常常见的一个功能，其作用也就是将数据分割成多个页面来进行显示。 使用场景： 当取到的数据量达到一定的时候，就需要使用分页来进行数据分割。 当我们不使用分页功能的时候，会面临许多的问题： 客户端的问题： 如果数据量太多，都显示在同一个页面的话，会因为页面太长严重影响到用户的体验，也不便于操作，也会出现加载太慢的问题。 服务端的问题： 如果数据量太多，可能会造成内存溢出，而且一次请求携带的数据太多，对服务器的性能也是一个考验。 分页的分类 分页的实现分为真分页和假分页两种，也就是物理分页和逻辑分页。 （1）真分页（物理分页）： 实现原理： SELECT * FROM xxx [WHERE...] LIMIT #{param1}, #{param2} 第一个参数是开始数据的索引位置 第二个参数是要查询多少条数据 优点： 不会造成内存溢出 缺点： 翻页的速度比较慢 （2）假分页（逻辑分页）： 实现原理： 一次性将所有的数据查询出来放在内存之中，每次需要查询的时候就直接从内存之中去取出相应索引区间的数据 优点： 分页的速度比较快 缺点： 可能造成内存溢出 传统的分页方式 对于假分页的实现方式很简单，只需要准备一个集合保存从数据库中取出的所有数据，然后根据当前页面的码数，取出对应范围的数据显示就好了，我们这里基于物理分页来实现。 分页的原理 页面中的数据有： 1结果集：通过 SQL 语句查询得来的——List&lt;Student&gt; 分页条中的数据有： 1234567当前页：用户传递到后台——currentPage总页数：计算的来——totalPage上一页：计算的来——prePage下一页：计算的来——nextPage尾页：计算的来（总页数）——lastPage页面大小（即每一页显示的条数）：用户传递到后台——count总条数：通过 SQL 语句查询得来的——totalCount 可以发现页面功能中需要用到的数据有两个是需要通过 SQL 语句查询得来的： 12一个是页面中显示的数据 List&lt;Student&gt;，另一个是数据的总条数 totalCount 分别对应以下两条 SQL 语句： 12SELECT * FROM student LIMIT #&#123;param1&#125;, #&#123;param2&#125;SELECT COUNT(*) FROM student 通过计算得到的数据有： 1234567891011总页数：totalPage总页数 = 总条数 % 页面大小 == 0 ? 总条数 / 页面大小 : 总条数 / 页面大小 + 1上一页：prePage上一页 = 当前页 - 1 &gt; = 1 ? 当前页 - 1 : 1下一页：nextPage下一页 = 当前页 + 1 &lt;= totalPage ? 当前页 + 1 : totalPage尾页：lastPage尾页 = 总条数 % 页面大小 == 0 ？ 总条数 - 页面大小 : 总条数 - 总条数 % 页面大小 用户传递的数据： 12当前页：currentPage页面大小：count 创建一个 Page 工具类备用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Page &#123; int start; // 开始数据的索引 int count; // 每一页的数量 int total; // 总共的数据量 /** * 提供一个构造方法 * @param start * @param count */ public Page(int start, int count) &#123; super(); this.start = start; this.count = count; &#125; /** * 判断是否有上一页 * @return */ public boolean isHasPreviouse()&#123; if(start==0) return false; return true; &#125; /** * 判断是否有下一页 * @return */ public boolean isHasNext()&#123; if(start==getLast()) return false; return true; &#125; /** * 计算得到总页数 * @return */ public int getTotalPage()&#123; int totalPage; // 假设总数是50，是能够被5整除的，那么就有10页 if (0 == total % count) totalPage = total /count; // 假设总数是51，不能够被5整除的，那么就有11页 else totalPage = total / count + 1; if(0==totalPage) totalPage = 1; return totalPage; &#125; /** * 计算得到尾页 * @return */ public int getLast()&#123; int last; // 假设总数是50，是能够被5整除的，那么最后一页的开始就是45 if (0 == total % count) last = total - count; // 假设总数是51，不能够被5整除的，那么最后一页的开始就是50 else last = total - total % count; last = last&lt;0?0:last; return last; &#125; /* getter and setter */&#125; 前台实现分页设计 首先我们在前台需要完成我们分页条的设计，这里可以直接引入 Bootstrap 来完成： 简单版本的分页条 首页超链：指向了 start 为 0 的首页 12345&lt;li&gt; &lt;a href="?page.start=0"&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 上一页超链： 12345&lt;li &gt; &lt;a href="?page.start=$&#123;page.start-page.count&#125;"&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 下一页超链： 12345&lt;li &gt; &lt;a href="?page.start=$&#123;page.start+page.count&#125;"&gt; &lt;span&gt;›&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 最后一页超链：指向了最后一页 12345&lt;li &gt; &lt;a href="?page.start=$&#123;page.last&#125;"&gt; &lt;span&gt;»&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 中间页： 12345&lt;c:forEach begin="0" end="$&#123;page.totalPage-1&#125;" varStatus="status"&gt; &lt;li&gt; &lt;a href="?page.start=$&#123;status.index*page.count&#125;" class="current"&gt;$&#123;status.count&#125;&lt;/a&gt; &lt;/li&gt;&lt;/c:forEach&gt; 所以写完看起来会是这样子的： 1234567891011121314151617181920212223242526272829303132&lt;nav&gt; &lt;ul class="pagination"&gt; &lt;li&gt; &lt;a href="?page.start=0"&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &gt; &lt;a href="?page.start=$&#123;page.start-page.count&#125;"&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;c:forEach begin="0" end="$&#123;page.totalPage-1&#125;" varStatus="status"&gt; &lt;li&gt; &lt;a href="?page.start=$&#123;status.index*page.count&#125;" class="current"&gt;$&#123;status.count&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:forEach&gt; &lt;li &gt; &lt;a href="?page.start=$&#123;page.start+page.count&#125;"&gt; &lt;span&gt;›&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li &gt; &lt;a href="?page.start=$&#123;page.last&#125;"&gt; &lt;span&gt;»&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 存在的问题： ① 没有边界判断，即在首页仍然可以点击前一页，不符合逻辑也影响用户体验 ② 会显示完所有的分页，即如果 totalPage 有50页，那么分页栏将会显得特别长，影响体验 改良版本的分页条 （1）写好头和尾 12345&lt;nav class="pageDIV"&gt; &lt;ul class="pagination"&gt; ..... &lt;/ul&gt;&lt;/nav&gt; （2）写好« ‹这两个功能按钮 使用 &lt;c:if&gt;标签来增加边界判断，如果没有前面的页码了则设置为disable状态 1234567891011&lt;li &lt;c:if test="$&#123;!page.hasPreviouse&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?page.start=0"&gt; &lt;span&gt;«&lt;/span&gt; &lt;/a&gt;&lt;/li&gt;&lt;li &lt;c:if test="$&#123;!page.hasPreviouse&#125;"&gt;class="disabled"&lt;/c:if&gt;&gt; &lt;a href="?page.start=$&#123;page.start-page.count&#125;"&gt; &lt;span&gt;‹&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; （3）再通过 JavaScrip 代码来完成禁用功能： 1234567&lt;script&gt; $(function () &#123; $("ul.pagination li.disabled a").click(function () &#123; return false; &#125;); &#125;);&lt;/script&gt; （4）完成中间页码的编写 12345678910&lt;c:forEach begin="0" end="$&#123;page.totalPage-1&#125;" varStatus="status"&gt; &lt;c:if test="$&#123;status.count*page.count-page.start&lt;=30 &amp;&amp; status.count*page.count-page.start&gt;=-10&#125;"&gt; &lt;li &lt;c:if test="$&#123;status.index*page.count==page.start&#125;"&gt;class="disabled"&lt;/c:if&gt; &lt;a href="?page.start=$&#123;status.index*page.count&#125;" &lt;c:if test="$&#123;status.index*page.count==page.start&#125;"&gt;class="current"&lt;/c:if&gt;&gt; $&#123;status.count&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt;&lt;/c:forEach&gt; 从 0 循环到 page.totalPage - 1 ，varStatus 相当于是循环变量 status.count 是从1开始遍历 status.index 是从0开始遍历 要求：显示当前页码的前两个和后两个就可，例如当前页码为3的时候，就显示 1 2 3(当前页) 4 5 的页码 理解测试条件：-10 &lt;= 当前页*每一页显示的数目 - 当前页开始的数据编号 &lt;= 30 后台中的分页 首页在项目中引入上面提到的 Page 工具类，然后我们在 DAO 类中使用 LIMIT 关键字来查询数据库中的信息： 123456789101112131415161718192021public List&lt;Student&gt; list() &#123; return list(0, Short.MAX_VALUE);&#125;public List&lt;Student&gt; list(int start, int count) &#123; List&lt;Student&gt; students = new ArrayList&lt;&gt;(); String sql = "SELECT * FROM student ORDER BY student_id desc limit ?,?"; try (Connection c = DBUtil.getConnection(); PreparedStatement ps = c.prepareStatement(sql)) &#123; ps.setInt(1, start); ps.setInt(2, count); // 获取结果集... &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return students;&#125; 在 Servlet 中获取分页参数并使首页显示的 StudentList 用 page 的参数来获取： 123456789101112131415161718// 获取分页参数int start = 0;int count = 10;try &#123; start = Integer.parseInt(req.getParameter("page.start")); count = Integer.parseInt(req.getParameter("page.count"));&#125; catch (Exception e) &#123;&#125;Page page = new Page(start, count);List&lt;Student&gt; students = studentDAO.list(page.getStart(), page.getCount());....// 共享数据req.setAttribute("page", page);req.setAttribute("students", students); 以上即可完成分页功能，但这是基于 Servlet 的版本。 SSM 中的分页 在 SSM 项目中，我们可以使用 MyBatis 的一款分页插件： PageHelper 来帮助我们更加简单的完成分页的需求，官网在这里： PageHelper 第一步：添加相关 jar 依赖包 PageHelper 需要依赖两个 jar 包，我们直接在 pom.xml 中增加两个 jar 包依赖： 12345678910111213&lt;!-- pageHelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2-beta&lt;/version&gt;&lt;/dependency&gt;&lt;!--jsqlparser--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 第二步：配置相关环境 在 MyBatis 的 SessionFactory 配置中新增加一个属性名 plugins 的配置： 123456789101112131415161718192021&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="cn.wmyskxz.entity"/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt; &lt;!-- 让MyBatis支持PageHelper插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 第三步：重构项目 首先我们把 LIMIT 关键字从映射文件中干掉： 1234&lt;!-- 查询从start位置开始的count条数据--&gt;&lt;select id="list" resultMap="student"&gt; SELECT * FROM student ORDER BY student_id desc&lt;/select&gt; 然后注释掉查询数据总条数的 SQL 语句： 1234&lt;!--&amp;lt;!&amp;ndash; 查询数据条目 &amp;ndash;&amp;gt;--&gt;&lt;!--&lt;select id="getTotal" resultType="int"&gt;--&gt; &lt;!--SELECT COUNT(*) FROM student--&gt;&lt;!--&lt;/select&gt;--&gt; 在 Dao 类和 Service 类中修改相应的地方： 然后修改掉 StudentController 中的方法： 123456789101112131415161718192021222324252627@RequestMapping("/listStudent")public String listStudent(HttpServletRequest request, HttpServletResponse response) &#123; // 获取分页参数 int start = 0; int count = 10; try &#123; start = Integer.parseInt(request.getParameter("page.start")); count = Integer.parseInt(request.getParameter("page.count")); &#125; catch (Exception e) &#123; &#125; Page page = new Page(start, count); // 使用 PageHelper 来设置分页 PageHelper.offsetPage(page.getStart(),page.getCount()); List&lt;Student&gt; students = studentService.list(); // 使用 PageHelper 来获取总数 int total = (int) new PageInfo&lt;&gt;(students).getTotal(); page.setTotal(total); request.setAttribute("students", students); request.setAttribute("page", page); return "listStudent";&#125; 重启服务器，能看到也能够正确的使用分页功能。 2.21 JSON使用什么是JSON JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 这里有意思的是，JSON本来是用来表示 JavaScript 对象的一种数据文本格式，但由于它轻量级、易于解析/操作（JavaScript原生支持）的一些特点，渐渐的被很多语言支持也就成了一种标准。 JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是轻量级的文本数据交换格式 JSON 独立于语言 JSON 具有自我描述性，更易理解 为什么使用JSON 在JSON之前，我们通常在网络传输中使用的格式是XML，在我们的印象之中，XML具有很好的可读性，并且格式统一，解析起来也相对比较简单，为什么摒弃掉XML而逐渐的使用起JSON呢？ 主要原因在于：JSON比XML更小、更快、更易解析。 JavaScript原生支持JSON，解析速度相较XML会更快； XML解析成DOM对象的时候，浏览器之间会产生差异【例如IE和FireFox】； JSON有很多强大的库能够帮助我们更快更简单的完成工作 XML与JSON实例比较 我们通过一个实例的比较来真实的说明一下XML与JSON的区别： （1）使用XML表示中国部分省市的数据如下： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;country&gt; &lt;name&gt;中国&lt;/name&gt; &lt;province&gt; &lt;name&gt;黑龙江&lt;/name&gt; &lt;citys&gt; &lt;city&gt;哈尔滨&lt;/city&gt; &lt;city&gt;大庆&lt;/city&gt; &lt;/citys&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;广东&lt;/name&gt; &lt;citys&gt; &lt;city&gt;广州&lt;/city&gt; &lt;city&gt;深圳&lt;/city&gt; &lt;city&gt;珠海&lt;/city&gt; &lt;/citys&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;台湾&lt;/name&gt; &lt;citys&gt; &lt;city&gt;台北&lt;/city&gt; &lt;city&gt;高雄&lt;/city&gt; &lt;/citys&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;新疆&lt;/name&gt; &lt;citys&gt; &lt;city&gt;乌鲁木齐&lt;/city&gt; &lt;/citys&gt; &lt;/province&gt;&lt;/country&gt; （2）使用JSON中国部分省市数据如下： 12345678910var country = &#123; name: "中国", provinces: [ &#123; name: "黑龙江", citys: &#123; city: ["哈尔滨", "大庆"]&#125; &#125;, &#123; name: "广东", citys: &#123; city: ["广州", "深圳", "珠海"]&#125; &#125;, &#123; name: "台湾", citys: &#123; city: ["台北", "高雄"]&#125; &#125;, &#123; name: "新疆", citys: &#123; city: ["乌鲁木齐"]&#125; &#125; ] &#125; 从编码的可读性来说，XML有明显的优势，毕竟人类的语言更贴近这样的说明结构。而JSON读起来更像是一个数据块，读起来比较费解，不过我们读起来费解的语言，恰恰是适合机器于都的，所以通过JSON是的索引contry.provinces[0].name就可以读取到“黑龙江”这个值 从编码的手写难度来说，XML还是更简单一些，好读也就意味着好写；不过JSON写出来的字符明显就少很多；去掉空白制表以及换行的话，JSON就是密密麻麻的有用数据，而XML却包含很多重复的标记字符。 JSON相比XML的不同之处 没有结束标签 更短 读写的速度更快 能够使用内建的 JavaScript eval() 方法进行解析 使用数组 不使用保留字 对于AJAX应用程序员来说，JSON比XML更快更易使用： 使用XML： 读取XML文档 使用XML DOM来循环遍历文档 读取值并存储在变量中 使用JSON： 读取JSON字符串 用 eval() 处理JSON字符串 JSON语法 客户端与服务器交换的数据无非就是两种： 数组或者是对象，JSON所表示的数据也就是这两种了 JSON语法是JavaScript语法的子集，在JavaScript中用[]中括号来表示数组，用{}大括号来表示对象，JSON也是这样 JSON数组： []中括号里面的内容有些像ArrayList，是一个列表一样的东西 12345var employees = [ &#123; "firstName":"Bill" , "lastName":"Gates" &#125;, &#123; "firstName":"George" , "lastName":"Bush" &#125;, &#123; "firstName":"Thomas" , "lastName": "Carter" &#125;]; JSON对象： {}大括号里面的东西有些像Map，是一对一对的键值对 123456789var obj = &#123; age:20, str:"aimanyeye", method:function() &#123; alert("我爱学习"); &#125;&#125;; 注意：[]中括号和{}大括号之间是可以相互嵌套的 解析JSON 在解析JSON对象之前，我们需要首先地来创造一个JSON对象： 123&lt;script&gt; var JASONObject = &#123;"name": "艾曼爷爷", "age": 21&#125;;&lt;/script&gt; 使用HTML解析 在HTML中我们可以直接使用.点号来直接访问JSON对象的属性： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSON学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; Name:&lt;span id="name"&gt;&lt;/span&gt;&lt;br&gt; Age:&lt;span id="age"&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;script&gt; var JASONObject = &#123;"name": "艾曼爷爷", "age": 21&#125;; document.getElementById("name").innerHTML = JASONObject.name; document.getElementById("age").innerHTML = JASONObject.age;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开网页我们能正确看到如下效果： 但通常情况中，我们拿到和上传的并不是一个真正的JSON对象，而是一串由JSON转换得来的字符串，我们同样在HTML中模拟解析一下： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSON学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; Name:&lt;span id="name"&gt;&lt;/span&gt;&lt;br&gt; Age:&lt;span id="age"&gt;&lt;/span&gt;&lt;br&gt;&lt;/p&gt;&lt;script&gt; var txt = '&#123;"students":[' + '&#123;"name":"艾曼爷爷0","age":21&#125;,' + '&#123;"name":"艾曼爷爷1","age":21 &#125;]&#125;'; var obj = eval("(" + txt + ")"); document.getElementById("name").innerHTML = obj.students[1].name; document.getElementById("age").innerHTML = obj.students[1].age;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开网页即可看到如下正确效果： 从前端发送JSON数据到后台 我们这里演示使用AJAX请求的方式来提交JSON数据到后台： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;JSON学习&lt;/title&gt; &lt;!-- 因为不想手动引感觉挺麻烦，引了个菜鸟教程的 --&gt; &lt;script src="http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; id：&lt;input type="text" id="id" value="123"/&gt;&lt;br/&gt; 名称：&lt;input type="text" id="name" value="category xxx"/&gt;&lt;br/&gt; &lt;input type="button" value="提交" id="sender"&gt;&lt;/form&gt;&lt;div id="messageDiv"&gt;&lt;/div&gt;&lt;script&gt; $('#sender').click(function () &#123; var id = document.getElementById('id').value; var name = document.getElementById('name').value; var category = &#123;"name": name, "id": id&#125;; var jsonData = JSON.stringify(category); var page = "category"; $.ajax(&#123; type: "put", url: page, data: jsonData, dataType: "json", contentType: "application/json;charset=UTF-8", success: function (result) &#123; &#125; &#125;); alert("提交成功，请在springboot控制台查看服务端接收到的数据"); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 在上面的例子中，我们使用了 JSON.stringify() 来将一个JSON对象转换成了一串字符串，并且在AJAX中，我们设置了 dataType 和 contentType 来告知后台我们传输的是一个JSON数据。 简单写一个Controller来验证一下吧： 1234@PutMapping("/category")public void addCategory(@RequestBody Category category) throws Exception &#123; System.out.println("springboot接受到浏览器以JSON格式提交的数据：" + category.getId() + category.getName());&#125; 12-----------控制台打印信息：----------springboot接受到浏览器以JSON格式提交的数据：123 category xxx JSON库介绍 在后台有许多支持解析JSON的库，目前对于Java开源的JSON类库有许多，下面我们介绍三种比较常用的JSON库，并进行比对说明，它们分别是： （1）Gson（项目地址：https://github.com/google/gson) Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。 （2）FastJson（项目地址：https://github.com/alibaba/fastjson） Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 （3）Jackson（项目地址：https://github.com/FasterXML/jackson） 相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。而且Jackson社区相对比较活跃，更新速度也比较快。Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式。 到底使用哪一个JSON库呢？ FastJson在复杂类型的Bean转换Json上会出现一些问题，但是在解析JSON时却是最快的。 总结如下： FastJson的API设计的最简单，最方便使用，直接使用JSON的两个静态方法即可完成四种操作；而Gson和Jackson都需要new一个对象； 数据量大时，使用Jackson; 如果有性能要求可以使用Gson/Jackson将bean转换json确保数据的正确性，使用FastJson将Json转换成Bean 三种JSON库简要使用说明 在使用之前，我们先来建设一些基础类，用于支持JSON库的使用： 123456789101112public class Person &#123; private String name; private Integer age; /* getter and setter */ @Override public String toString() &#123; return "名字为" + name + ",年龄" + age; &#125;&#125; Gson库使用简要说明 （1）Maven依赖： 123456&lt;!-- Gson库 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; （2）使用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Testpublic void tester() &#123; Gson gson = new Gson(); /* —————————————————— 准备测试数据 —————————————————— */ Person person1 = new Person(); person1.setName("艾曼爷爷1"); person1.setAge(21); Person person2 = new Person(); person2.setName("艾曼爷爷2"); person2.setAge(21); Person person3 = new Person(); person3.setName("艾曼爷爷3"); person3.setAge(21); List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(person1); list.add(person2); list.add(person3); /* —————————————————— 简单的Bean转为JSON —————————————————— */ String jsonString = gson.toJson(person1); System.out.println("简单的Bean转为JSON：" + jsonString); /* —————————————————— JSON转为简单Bean —————————————————— */ Person personFromJson = gson.fromJson(jsonString, Person.class); System.out.println("JSON转为简单Bean：" + personFromJson.toString()); /* —————————————————— 带泛型的List转JSON —————————————————— */ String jsonStringFromList = gson.toJson(list); System.out.println("带泛型的List转JSON：" + jsonStringFromList); /* —————————————————— JSONz转为带泛型的List —————————————————— */ List&lt;Person&gt; retList = gson.fromJson(jsonStringFromList, new TypeToken&lt;List&lt;Person&gt;&gt;() &#123; &#125;.getType()); for (Person tempPerson : retList) &#123; System.out.println(tempPerson.toString()); &#125;&#125;------------------结果如下------------------简单的Bean转为JSON：&#123;"name":"艾曼爷爷1","age":21&#125;JSON转为简单Bean：名字为艾曼爷爷1,年龄21带泛型的List转JSON：[&#123;"name":"艾曼爷爷1","age":21&#125;,&#123;"name":"艾曼爷爷2","age":21&#125;,&#123;"name":"艾曼爷爷3","age":21&#125;]名字为艾曼爷爷1,年龄21名字为艾曼爷爷2,年龄21名字为艾曼爷爷3,年龄21 FastJson库简要使用说明 （1）Maven依赖： 123456&lt;!-- FastJson库 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; （2）使用示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void tester() &#123; /* —————————————————— 准备测试数据 —————————————————— */ Person person1 = new Person(); person1.setName("艾曼爷爷1"); person1.setAge(21); Person person2 = new Person(); person2.setName("艾曼爷爷2"); person2.setAge(21); Person person3 = new Person(); person3.setName("艾曼爷爷3"); person3.setAge(21); List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(person1); list.add(person2); list.add(person3); /* —————————————————— 简单的Bean转为JSON —————————————————— */ String jsonString = JSON.toJSONString(person1); System.out.println("简单的Bean转为JSON：" + jsonString); /* —————————————————— JSON转为简单Bean —————————————————— */ Person personFromJson = JSON.parseObject(jsonString, Person.class); System.out.println("JSON转为简单Bean：" + personFromJson.toString()); /* —————————————————— 带泛型的List转JSON —————————————————— */ String jsonStringFromList = JSON.toJSONString(list); System.out.println("带泛型的List转JSON：" + jsonStringFromList); /* —————————————————— JSONz转为带泛型的List —————————————————— */ List&lt;Person&gt; retList = JSON.parseObject(jsonStringFromList, new TypeReference&lt;List&lt;Person&gt;&gt;() &#123; &#125;); for (Person tempPerson : retList) &#123; System.out.println(tempPerson.toString()); &#125;&#125;------------------结果如下------------------简单的Bean转为JSON：&#123;"age":21,"name":"艾曼爷爷1"&#125;JSON转为简单Bean：名字为艾曼爷爷1,年龄21带泛型的List转JSON：[&#123;"age":21,"name":"艾曼爷爷1"&#125;,&#123;"age":21,"name":"艾曼爷爷2"&#125;,&#123;"age":21,"name":"艾曼爷爷3"&#125;]名字为艾曼爷爷1,年龄21名字为艾曼爷爷2,年龄21名字为艾曼爷爷3,年龄21 Jackson库使用简要说明 1）Maven依赖： 稍微麻烦一点的是Jackson需要依赖三个包 12345678910111213141516&lt;!-- jackson库 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt; （2）使用示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Testpublic void tester() throws IOException &#123; /* —————————————————— 准备测试数据 —————————————————— */ Person person1 = new Person(); person1.setName("艾曼爷爷1"); person1.setAge(21); Person person2 = new Person(); person2.setName("艾曼爷爷2"); person2.setAge(21); Person person3 = new Person(); person3.setName("艾曼爷爷3"); person3.setAge(21); List&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(person1); list.add(person2); list.add(person3); /* ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现的 */ ObjectMapper mapper = new ObjectMapper(); /* —————————————————— 简单的Bean转为JSON —————————————————— */ String jsonString = mapper.writeValueAsString(person1); System.out.println("简单的Bean转为JSON：" + jsonString); /* —————————————————— JSON转为简单Bean —————————————————— */ Person personFromJson = mapper.readValue(jsonString, Person.class); System.out.println("JSON转为简单Bean：" + personFromJson.toString()); /* —————————————————— 带泛型的List转JSON —————————————————— */ String jsonStringFromList = mapper.writeValueAsString(list); System.out.println("带泛型的List转JSON：" + jsonStringFromList); /* —————————————————— JSONz转为带泛型的List —————————————————— */// List&lt;LinkedHashMap&lt;String, Person&gt;&gt; retList = mapper.readValue(jsonStringFromList, List.class);// for (int i = 0; i &lt; retList.size(); i++) &#123;// Map&lt;String, Person&gt; map = retList.get(i);// Set&lt;String&gt; set = map.keySet();// for (Iterator&lt;String&gt; it = set.iterator(); it.hasNext();) &#123;// String key = it.next();// System.out.println(key + ":" + map.get(key));// &#125;// &#125; /* —————————————————— JSONz转为Array数组 —————————————————— */ Person[] retList = mapper.readValue(jsonStringFromList, Person[].class); for (int i = 0; i &lt; retList.length; i++) &#123; System.out.println(retList[i].toString()); &#125;&#125;------------------结果如下------------------简单的Bean转为JSON：&#123;"name":"艾曼爷爷1","age":21&#125;JSON转为简单Bean：名字为艾曼爷爷1,年龄21带泛型的List转JSON：[&#123;"name":"艾曼爷爷1","age":21&#125;,&#123;"name":"艾曼爷爷2","age":21&#125;,&#123;"name":"艾曼爷爷3","age":21&#125;]名字为艾曼爷爷1,年龄21名字为艾曼爷爷2,年龄21名字为艾曼爷爷3,年龄21 注意： 由于Jackson底层代码抛出了IOEception，所以我们在调用的时候也需要抛出； Jackson所有的操作都是基于ObjectMapper 在框架中使用JSON SpingMVC和SpringBoot一样，都能通过注解的方式获取并返回一串JSON格式的数据，我们使用SpringBoot的一段实例程序来实际说明一下： 12345@RequestMapping("/jsonCategory")@ResponseBody // 该注解表示我们的请求不再交给springmvc处理，而是结合JSON包，将对象解析成JSON字符串public Category jsonCategory() &#123; return new Category(123, "艾曼爷爷");&#125; 我们在浏览器中访问地址：localhost:8080/jsonCategory，会得到以下JSON数据： 我们也可以使用 @RequestBody 来获取一串JSON数据： 1234@PutMapping("/category")public void addCategory(@RequestBody Category category) &#123; System.out.println("springboot接受到浏览器以JSON格式提交的数据：" + category.getId() + category.getName());&#125; 我们在前台使用的是上面用过的用于提交JSON数据的页面，运行能够成功得到结果： 注意： Spring4 之后新加入了 @RestController 注解，是@ResponseBody和@Controller的组合注解，用于返回JSON数据。 2.22 使用RESTful风格什么是RESTful风格？ REST是REpresentational State Transfer的缩写（一般中文翻译为表述性状态转移），REST 是一种体系结构，而 HTTP 是一种包含了 REST 架构属性的协议，为了便于理解，我们把它的首字母拆分成不同的几个部分： 表述性（REpresentational）： REST 资源实际上可以用各种形式来进行表述，包括 XML、JSON 甚至 HTML——最适合资源使用者的任意形式； 状态（State）： 当使用 REST 的时候，我们更关注资源的状态而不是对资源采取的行为； 转义（Transfer）： REST 涉及到转移资源数据，它以某种表述性形式从一个应用转移到另一个应用。 简单地说，REST 就是将资源的状态以适合客户端或服务端的形式从服务端转移到客户端（或者反过来）。在 REST 中，资源通过 URL 进行识别和定位，然后通过行为(即 HTTP 方法)来定义 REST 来完成怎样的功能。 实例说明: 在平时的 Web 开发中，method 常用的值是 GET 和 POST，但是实际上，HTTP 方法还有 PATCH、DELETE、PUT 等其他值，这些方法又通常会匹配为如下的 CRUD 动作: CRUD 动作 HTTP 方法 Create POST Read GET Update PUT 或 PATCH Delete DELETE 尽管通常来讲，HTTP 方法会映射为 CRUD 动作，但这并不是严格的限制，有时候 PUT 也可以用来创建新的资源，POST 也可以用来更新资源。实际上，POST 请求非幂等的特性(即同一个 URL 可以得到不同的结果)使其成一个非常灵活地方法，对于无法适应其他 HTTP 方法语义的操作，它都能够胜任。 在使用 RESTful 风格之前，我们如果想要增加一条商品数据通常是这样的: 1/addCategory?name=xxx 但是使用了 RESTful 风格之后就会变成: 1/category 这就变成了使用同一个 URL ，通过约定不同的 HTTP 方法来实施不同的业务，这就是 RESTful 风格所做的事情了，为了有一个更加直观的理解，引用一下来自how2j.cn的图: SpringBoot 中使用 RESTful RESTful API 具体设计如下： User实体定义： 123456789public class User &#123; private Long id; private String name; private Integer age; // 省略setter和getter &#125; 实现对User对象的操作接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RestController @RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下 public class UserController &#123; // 创建线程安全的Map static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @RequestMapping(value="/", method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; // 处理"/users/"的GET请求，用来获取用户列表 // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @RequestMapping(value="/", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; // 处理"/users/"的POST请求，用来创建User // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 users.put(user.getId(), user); return "success"; &#125; @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; // 处理"/users/&#123;id&#125;"的GET请求，用来获取url中id值的User信息 // url中的id可通过@PathVariable绑定到函数的参数中 return users.get(id); &#125; @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; // 处理"/users/&#123;id&#125;"的PUT请求，用来更新User信息 User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; // 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User users.remove(id); return "success"; &#125; &#125; 总结 我们仍然使用 @RequestMapping 注解，但不同的是，我们指定 method 属性来处理不同的 HTTP 方法，并且通过 @PathVariable 注解来将 HTTP 请求中的属性绑定到我们指定的形参上。 事实上，Spring 4.3 之后，为了更好的支持 RESTful 风格，增加了几个注解：@PutMapping、@GetMapping、@DeleteMapping、@PostMapping，从名字也能大概的看出，其实也就是将 method 属性的值与 @RequestMapping 进行了绑定而已，例如，我们对UserController中的deleteUser方法进行改造： 123456789101112131415-----------改造前-----------@RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE)public String deleteUser(@PathVariable Long id) &#123; // 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User users.remove(id); return "success";&#125;-----------改造后-----------@DeleteMapping("/&#123;id&#125;")public String deleteUser(@PathVariable Long id) &#123; // 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User users.remove(id); return "success";&#125; 使用Swagger2构造RESTful API文档 RESTful 风格为后台与前台的交互提供了简洁的接口API，并且有利于减少与其他团队的沟通成本，通常情况下，我们会创建一份RESTful API文档来记录所有的接口细节，但是这样做有以下的几个问题： 由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 Swagger2的出现就是为了解决上述的这些问题，并且能够轻松的整合到我们的SpringBoot中去，它既可以减少我们创建文档的工作量，同时说明内容又可以整合到代码之中去，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明，这太酷了，另外Swagger2页提供了强大的页面测试功能来调试每个RESTful API，具体效果如下： 第一步：添加Swagger2依赖： 在 pom.xml 中加入Swagger2的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 第二步：创建Swagger2配置类 1234567891011121314151617181920212223242526@Configuration//让Spring来加载该配置类@EnableSwagger2//启动Swagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123;//创建 Docket 的Bean return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo())//创建该API的基本信息（这些基本信息会展现在文档页面中） .select()//返回一个 ApiSelectorBuilder 实例用来控制哪些接口暴露给Swagger来展现 //Swagger会扫描该包下所有的Controller定义的API，并产生文档内容 .apis(RequestHandlerSelectors.basePackage("cn.aimanyeye.springboot")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("原文地址链接：http://blog.didispace.com/springbootswagger2/") .termsOfServiceUrl("http://blog.didispace.com/") .contact("@艾曼爷爷") .version("1.0") .build(); &#125;&#125; 如上面的代码所示，通过 @Configuration 注解让Spring来加载该配置类，再通过 @EnableSwagger2 注解来启动Swagger2； 再通过 createRestApi 函数创建 Docket 的Bean之后，apiInfo() 用来创建该API的基本信息（这些基本信息会展现在文档页面中），select() 函数返回一个 ApiSelectorBuilder 实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有的Controller定义的API，并产生文档内容（除了被 @ApiIgnore 指定的请求） 第三步：添加文档内容 在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@RestController@RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value="获取用户列表", notes="") @RequestMapping(value=&#123;""&#125;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @ApiOperation(value="创建用户", notes="根据User对象创建用户") @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") @RequestMapping(value="", method=RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return "success"; &#125; @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long"), @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") &#125;) @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return "success"; &#125;&#125; 完成上述代码添加之后，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html，就能看到前文展示的RESTful API的页面，我们可以点开具体的API请求，POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示： API文档访问与调试 在上图请求的页面中，我们可以看到一个Value的输入框，并且在右边的Model Schema中有示例的User对象模板，我们点击右边黄色的区域Value框中就会自动填好示例的模板数据，我们可以稍微修改修改，然后点击下方的 “Try it out!” 按钮，即可完成一次请求调用，这太酷了。 总结对比之前用文档来记录RESTful API的方式，我们通过增加少量的配置内容，在原有代码的基础上侵入了忍受范围内的代码，就可以达到如此方便、直观的效果，可以说是使用Swagger2来对API文档进行管理，是个很不错的选择！]]></content>
      <categories>
        <category>Java面试</category>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-数据库篇]]></title>
    <url>%2F2019%2F08%2F04%2F2019-08-04-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87%2F</url>
    <content type="text"><![CDATA[目录 数据库架构相关知识 索引相关知识 锁相关知识 关键语法 理论范式 关系型数据库主要考点： 架构部分是考察你对数据库有没有整体的了解。 索引部分和锁部分是最重要的考点。 实用的工作中用到的语法。 数据库纯理论部分，如范式1列的不可再分，范式2的要有主键，范式3的去除传递依赖等等。 1. 数据库架构相关知识1.1 题目分析如何设计一个关系型数据库？ 设计一个数据库，就跟设计一款软件差不多，也是将其分解成很多模块。 此题主要考察面试者的模块划分能力以及对数据库的了解。 记忆一个东西的最佳方式，就是站在设计者的角度去设计。能回答出这个问题，则对数据库的基本功能有了一个全面的了解。 1.2 数据库的设计、认识及模块划分1.2.1 数据库总体划分 数据库的最主要功能就是存储数据，因此会有一个存储模块来负责存储我们的数据。存储模块就类似我们的OS文件系统，将数据最终持久化存入磁盘中。如存入机械硬盘或者SSD亦或者它们的磁盘阵列矩阵中。 但仅有存储是不行的，我们还需要组织并且用到这些数据，因此我们需要有程序实例，用逻辑结构来映射出物理结构。并且在程序中提供获取以及管理数据的方式，还有必要的问题追踪机制。 1.2.2 程序模块 首先我们需要对数据的格式以及文件的分隔进行统一的管理，即把物理数据通过逻辑的形式给组织和表示出来。于是便涉及到了程序的存储管理模块。 如何优化存储效能？处理数据不可能在磁盘上做，而肯定是让程序加载到程序空间所在的内存里去做，而磁盘I/O速率往往是程序执行速度的主要瓶颈。例如机械硬盘，通过马达的驱动、盘面的转动以及磁头的移动来查找数据，这样的速度远差于内存的查找效率。即便是通过电流驱动的固态硬盘，虽然拥有比机械硬盘更快的I/O速度，但是跟内存比起来仍不是同一个量级。因此为了执行效率，我们要尽可能的减少IO。就存储管理功能而言，如果按照逐行去查找并返回，那么这频繁的I/O会使数据库的执行效率极慢。因为一次I/O读取多条数据和单条数据花费的时间相差无几，所以我们可以一次性的去读取多行，以提升I/O效能，所以行失去了它的意义。实际上数据库也是把逻辑存储单位用块或者页来表示，每个块或者页中会存放多行数据。这样读取的时候可以将多个块一起加载进内存当中。 需要引入缓存机制，把取出来的数据块存放在缓存里。下次需要时直接从内存返回而不用发生I/O。需要补充的是，刚刚谈到的一次性加载多个模块或者页，这些块里包含的数据行有相当一部分并不是我们本次查询所需要的行，但是根据一旦某行数据被访问了，那么它周围的数据也极有可能被访问的经验，我们缓存的非本次数据也能起到优化访问效率的作用。例如一次加载进来的块中有A、B、C三条数据，我们只需要A数据，但B、C也被加载到了内存当中。按照经验来说，下次B和C被访问到的几率非常大，也就是它也能提升我们的访问性能。如何管理缓存有很多的方法，如LRU等，没有最好的方法，不同方法适用于某个具体的场景。 我们需要能提供给外界指令来操作数据库，即可读的SQL语言，于是我们需要一个SQL的解析模块，将SQL编译解析转换成机器可识别的指令。为了进一步提升SQL执行效率，可以将SQL缓存到缓存里，编译好的SQL方便下次来了能够直接进行解析。我们设计程序的时候，要先实现功能，接着再去考虑优化，周而复始。同时，我们的缓存也不宜过大，且算法中需要有淘汰机制，淘汰掉一些之后不常用的数据。 此外我们做的SQL操作需要记录下来，方便我们做数据库的主从同步或者灾难恢复。因此我们需要有日志管理办法去记录我们的操作记录。有时间可以了解下这个binlog的记录方式，面试时偶尔会问到。 再者，我们还需要提供给用户管理数据的私密空间，即权限划分。通俗的讲就是让老板能够看到员工的数据，而员工只能看到自己该看到的数据。权限划分是DBA该做的事情，通常不需要我们过多的关心。 设计系统的时候除了考虑正常的功能，还要考虑异常的情况。于是我们需要引入异常机制，即容灾机制。当数据库挂掉该如何恢复，恢复到什么程度，这些都需要设计。 为了进一步提升查询数据的速度以及让数据库支持并发，我们还需要引入最能够突出数据库特点的两个模块：索引管理模块以及锁模块。 1.3 题目解答要设计一个关系型数据库，我们首先要将其划分成两大部分。 一个是存储部分（类似一个文件系统），来将数据持久化到存储设备当中。 还需要有程序实例模块来对存储进行逻辑上的管理，程序实例分别又可以分为八个模块： ①存储管理模块：将数据的逻辑关系转换为物理存储关系。②缓存机制模块：优化执行效率。③SQL解析模块：解析SQL语句。④日志管理模块：记录操作。⑤权限划分模块：进行多用户管理。⑥容灾机制模块：灾难恢复。⑦索引管理模块：优化数据查询效率。⑧锁管理模块：使得数据库支持并发操作。 数据库的开发其实跟我们做的项目一样，考虑设计的模块也都非常类似，其架构堪称经典，所以对我们的程序开发以及设计很有借鉴意义。 2. 索引相关知识2.1 面试常见问题 为什么要使用索引 什么样的信息能成为索引 索引的数据结构 密集索引和稀疏索引的区别 2.2 为什么要使用索引2.2.1 查询数据的方式①全表扫描 即将整张表的数据全部或者分批次加载到内存当中。存储的最小单位是块或者页，它们是由多行数据来组成的。我们将这些块都加载进来，然后逐个块或者页去轮询，找到我们要的目标并返回。这种方式普遍被认为是非常慢的，但是当仅有少量的数据（如几十行时），那么直接加载到内存中进行全表扫描，肯定比我们后面要说的通过索引查询的方式要快。 ②索引扫描 当然要在数据量很大的表里进行查询，该方法不再适用。因此在很多情况下，我们都要避免全表扫描的情况发生。所以我们的数据库要引入一种更高效的机制，这便是索引。索引的灵感来自于字典，在字典中只要我们把一些关键信息组织起来，比如偏旁部首、拼音这些，查询时依据这些信息的指引，就能够查到我们想要的页面，很快便能定位到我们要查的字了。而这些关键信息以及查找数据的方式，便组成了我们的索引。通过索引来大幅提升查询速度，便是问题的答案。 2.3 什么样的信息能成为索引能把该记录限定在一定查找范围内的字段，即我们刚刚所提到的关键信息，我们的主键便是一个很好的索引切入点。当然其他键位，包括唯一键以及普通键等也可以作为索引。 2.4 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立B树结构进行查找 生成索引，建立B+树结构进行查找（MySQL索引的实现形式） 生成索引，建立Hash结构进行查找 2.5 优化你的索引2.5.1 利用B树①特征： 根节点至少包括两个孩子 树中每个节点最多含有m个孩子（m &gt;= 2）(m阶树的含义，m取决于节点容量以及相关配置)。 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子 所有叶子节点都位于同一层。 假设每个非终端节点中包含有n个关键字信息，其中a) Ki(i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt;Kib) 关键字的个数n必须满足：[ceil(m / 2) - 1] &lt;= n &lt;= m - 1c) 非叶子结点的指针：P[1]，P[2]，…，P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M - 1]的子树，其他P[i]指向关键字属于(K[i - 1], K[i])的子树。 查找效率O(logN)，当B树中数据发生改变时，通过合并、分裂、上移下移节点，来保持B树的5个特征，B树比二叉树要矮的多。 2.5.2 利用B+树①特征： B+树是B树的变体，其定义基本与B树相同，除了： 非叶子节点的子树指针与关键字个数相同 非叶子结点的子树指针P[i]，指向关键字值[K[i], K[i + 1]]的子树 非叶子节点只用来做索引，数据都保存在叶子节点中 所有叶子节点均有一个链指针指向下一个叶子节点（支持范围统计） ②B+树更适合用来做存储索引： B+树的磁盘读写代价更低 B+树的查询效率更加稳定，稳定O(logN) B+树更有利于对数据库的扫描 2.5.3 利用Hash以及BitMapHash索引 Hash索引，根据Hash函数的运算，只需经过一次定位就可以找到所需数据所在的桶。 B+Tree索引，根节点–&gt;非叶子节点–&gt;叶子节点（稳定查询） 理论上Hash索引比B+Tree快 基于MyISAM和InnoDB的MySQL不显式支持Hash ①缺点 只满足=，IN 不能使用范围查询 不能被用来避免数据的排序（因为hash索引中存放的是hash运算之后的值，hash值大小关系不一定和运算前的键值完全一样[不同key可能相同hash(key)]，数据库无法利用索引的数据来避免任何排序运算） 不能利用部分索引键做查询 不能避免表扫描（[不同key可能相同hash(key)]，也就是说索引可能对应多个记录。这些记录仍然需要进行扫描） 遇到大量Hash值相等的情况后性能不一定比B-Tree索引高（极端情况所有key都对应同一个hash(key)就变成线性的了） BitMap(位图)索引 当表中的某个字段仅有固定几种值的时候，例如性别包括男和女。已知主流支持BitMap索引的数据库是Oracle数据库。 位图索引结构类似于B+树，只需要存放是与否，因此只需要一个比特位来存放，因此一个叶子块可以存放很多的Bit位来表示不同的行，因此用来做统计时是很快的。 位图索引的锁力度很大，对数据进行增删改查的时候，通常与之在同一个位图的数据都会被锁住（某行位置可能会发生改变）。所以它不适合高并发的联机事务处理系统（OLTP系统），适用于并发较少且统计运算较多的系统（OLAP系统）。 2.6 密集索引和稀疏索引的区别2.6.1 区别 密集索引文件中的每个搜索码值都对应一个索引值 稀疏索引文件只为索引码的某些值建立索引项 2.6.2 对于MySQL 主要有两种存储引擎：MyISAM和InnoDB。 MyISAM不管是主键索引、唯一键索引或者普通索引，其索引均属于稀疏索引。 InnoDB必须有且仅有一个密集索引。①若一个主键被定义，该主键则作为密集索引②若没有主键被定义，该表的第一个唯一非空索引则作为密集索引③若不满足以上条件，InnoDB内部会生成一个隐藏主键(密集索引)，此隐藏主键是一个6字节的列，该列的值会随着数据的插入而自增。④非主键索引（稀疏索引）存储相关键位和其对应的主键值，包含两次查找 InnoDB的索引和对应的数据是保存在同一个文件当中的，MyISAM的索引和数据是分开存储的。 2.7 索引模块衍生问题2.7.1 如何定位并优化慢查询Sql 根据慢日志定位慢查询sql 使用explain等工具分析sql 修改sql或者尽量让sql走索引 a）慢日志 慢日志就是用来记录一些我们执行的比较慢的一些sql。 利用show variables like ‘%quer%’;来查询MySQL的一些系统变量。其中slow_query_log代表慢日志是否开启，slow_query_log_file表示慢日志的存放地址，long_query_time表示运行时间超过该值（单位为秒）的sql会被记录到慢日志中。 利用show status like ‘%slow_queries%’;来查询一些MySQL的系统状态。此处是查询慢查询的数量（本次会话，断开连接清零）。 设置系统变量的方式。例如使用set global slow_query_log = on;打开慢日志（立即生效）；使用set global long_query_time = 1;设置慢查询sql的运行时长为超过1秒。（此设定需要重新连接客户端才能生效）。但此种方式仅为暂时设置，重启MySQL后会被还原，若需要永久设置，则需要修改mysql的配置文件(Linux下my.cnf，Windows下my.ini)。 数据定义语言DDL，如alter table等，用来操作表结构的语句，不会进入慢日志。而用来操作数据，对数据进行增删改查的语句DML，才可能进入慢日志中。 b）Explain 一般放在select查询语句的前面，用于描述MySQL如何执行查询操作，以及MySQL成功返回结果集需要执行的行数。 id标明sql的执行顺序，id越大越先执行。对于复合查询来说，里面的语句是最先执行的，因此id较大。 key表示的是我们用的哪一个键的索引。 重点字段：type、Extra。 ①type是指MySQL找到需要的数据行的方式，从左往右性能越来越差。其中index和all表明本次查询走的是全表扫描。因此当语句是慢查询语句且type为index或all时，则语句需要优化。 ②extra中可能需要优化的情景： c）修改sql或尽量让sql走索引 当业务逻辑可以替代时，修改sql中无索引的字段为有索引的字段。 给相应无索引字段添加索引 例如： 1alter table person_info_large add index idx_name(name); d）查询优化器对索引的选择 1explain select count(id) from person_info_large; 该语句走的是索引acount，而没有走主键索引。 强制语句走主键索引： 1explain select count(id) from person_info_large force index (primary); 实际结果表明走主键索引不一定比走其他索引要快，但MySQL查询优化器运算选择的结果也不一定是最优的，我们可以通过force index来选择不同的索引，来测试sql语句的执行效率。 2.7.2 联合索引的最左匹配原则的成因a）联合索引 联合索引：多列形成的索引 如果创建一个索引alter table 表名 add index index_A_B(A,B); 如果同时查询where a= and b =或者查询where a=都会使用这个索引， 但是只查b就不会用这个索引。 b）最左前缀匹配原则 mysql会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如a = 3 and b = 4 and c &gt; 5 and d = 6。如果建立(a,b,c,d)顺序的索引，d是用不到索引的；如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3建立(a, b, c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 c）成因 联合索引是按索引顺序进行了排序的，第一个字段绝对有序，第二个字段则无序。因此必须按序查找时才能用上B+树的索引。 2.7.3 索引是建立越多越好吗？答案是否定的。 数据量小的表不需要建立索引，建立会增加额外的索引开销。 数据变更需要维护索引，因此更多的索引意味着更多的维护成本。 更多的索引也意味着需要更多的空间。 3. 锁相关知识3.1 面试常见问题 MyISAM与InnoDB关于锁方面的区别是什么 数据库事务的四大特性 事务隔离级别以及各级别下的并发访问问题 InnoDB可重复读隔离级别下如何避免幻读 RC、RR级别下的InnoDB的非阻塞读如何实现 3.2 MyISAM与InnoDB关于锁方面的区别3.2.1 答案 MyISAM默认用的是表级锁，不支持行级锁。 InnoDB默认用的是行级锁，也支持表级锁。 3.2.2 分析a）MyISAM ①简介 MyISAM不支持事务。当表进行查询的时候，MyISAM会对表加上一个表锁，它会锁住这张表并阻止其他的会话对该表进行更新。 对于MyISAM来说，当对数据进行select的时候，它会自动为我们加上一个表级的读锁；而对数据增删改的时候它会为我们操作表加上一个表级别的写锁。当读锁未被释放的时候，另外一个会话想对这张表加上一个写锁，它就会被阻塞，直到所有的读锁都被释放为止。 ②手动加锁释放锁的方式 1234//加锁lock tables person_info_myisam read | write;//释放锁unlock tables; 读锁又被称之为共享锁。在对表进行范围查找的时候（加了读锁），我们依然能对表里的数据进行读操作。 写锁又被称之为排他锁。当上了写锁，再想上读锁是不可能的，需要等待写锁的释放；当上了写锁，再想上写锁也是不可能的。 在select语句后面加入一个for update可以给select语句上排它锁。 ③总结 MyISAM支持表级锁，不支持行级锁。表级锁会锁住整张表。 锁按级别可以划分为共享锁和排他锁。上了共享锁之后依然支持上共享锁，不支持上排它锁。要是先上排它锁，那么另外的读写都不被允许。共享锁和排它锁的情况也同样适用于支持行级锁的InnoDB引擎。 b）InnoDB ①简介 InnoDB支持事务，我们可以通过会话获取锁暂时不自动提交的方式，模拟并发访问的过程。 MySQL是默认提交事务的。InnoDB使用的是二段锁，加锁和解锁分为两个步骤来进行。即先对同一个事务里的一批操作分别进行加锁，到commit的时候再对事务中加上的锁进行统一的解锁。因为当前是自动提交的，所以看起来和InnoDB没有什么区别。 ②设置不自动提交（测试同一行数据的加锁） 123456//显示系统变量自动提交的情况show variables like &quot;autocommit&quot;;//关闭自动提交(仅针对当前Session)set autocommit = 0;//手动提交commit; 若不进行设置，则可以显式调用begin transaction，再在后面执行相关sql语句，也可以达到相同的效果。 12begin transactionsql; InnoDB对select进行了改进，有的select并不会对数据上锁，所以会出现select的同时仍然可以进行update的情况，称之为非阻塞select。 在sql后面加上lock in share mode就可以给sql语句手动加上读锁。此时当前行加入共享锁之后，其他sql无法再对该行数据加排它锁了。 1select * from person_info_large where id = 3 lock in share mode; ③测试行级锁 在InnoDB中，当对某一条数据加共享锁之后，对另一条数据进行更新并不会被阻塞。因此InnoDB默认是支持行级锁的。 在InnoDB中，对同一行加共享锁，两个共享锁不会起冲突。 先写后读的情况在nnoDB中和MyISAM中也是基本一致的。 c）表级锁和行级锁 用表级锁的时候，只要操作表里的数据均会上表锁，因此表级锁和索引无关。 当不走索引的时候，整张表就会被锁住，即此时查询用到的是表级锁；因此InnoDB在sql没有用到索引的时候用的是表级锁；而sql用到索引的时候用到的是行级锁或者gap锁（走普通非唯一索引时用到的）。InnoDB除了支持这些行级锁之外，还支持表级的意向锁，意向锁也分为共享读锁IS和排他写锁IX。 d）共享锁和排斥锁的兼容性 MyISAM默认使用的是表级锁，不支持行级锁；InnoDB默认使用的是行级锁，也支持表级锁。无论是表锁还是行锁均分为共享锁和排它锁。关系如下所示： 锁的力度越细代价越高，相比表级锁在表的头部直接加锁来讲，行级锁还要在扫描到某行的时候对其上锁，代价较大。InnoDB支持事务的同时也相比MyISAM引擎带来了更大的开销。MyISAM在纯检索引擎中，也就是增删改很少的系统中，其性能要好于InnoDB。 3.2.3 MyISAM与InnoDB适用场景a）MyISAM MyISAM用一个变量保存了每个表的行数，count速度很快。 频繁执行全表count语句 对数据进行增删改的频率不高，查询非常频繁 没有事务 b）InnoDB 数据增删改查都相当频繁 可靠性要求比较高，要求支持事务 3.2.4 数据库锁的分类 InnoDB对行级上锁的时候会先上一种表级别的意向锁，不常用的BDB引擎支持页级锁（表级和行级之间的锁，逻辑块，锁定位于同一个存储页的相邻几行数据）。 意向锁、MyISAM的表锁以及update、insert、delete的时候加上的锁就是自动锁，而select… for update、lock in share mode这些我们显式去加的锁就是显式锁。 对数据进行操作上的锁就是DML锁（数据增删改查），而对表结构进行变更的，如altertable这些语句加上的锁为DDL锁。 悲观锁指的是对数据被外界（本系统当前的其他事务以及来自外部系统的事务处理）的修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现往往需要数据库层提供的锁机制，也只有数据库层提供的锁机制才能真正保证数据访问的排他性。否则即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据，全程用排它锁锁定正是一种悲观锁的实现。悲观并发控制实际上是一种先取锁，再访问的一种保守策略，为数据处理的安全提供了保证。但在效率方面处理加锁的机制会让数据库产生额外的开销，增加产生死锁的机会。另外在只读型事务处理中，由于不会产生冲突，也没必要使用锁，如果上锁会增加系统负担，同时还会降低并行性。一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以去处理。乐观锁认为数据在一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式的对数据的冲突与否进行检测，若发现冲突则返回用户错误信息。相对于悲观锁，乐观锁并不会使用数据库提供的锁机制，一般实现乐观锁的方式就是记录数据版本（版本号、时间戳）。 3.3 数据库事务的四大特性数据库事务是指作为单个逻辑工作单元执行的一系列操作，要么完全执行要么全部都不执行。 ACID： 原子性：事务包含的全部操作要么全部执行，要么全部失败回滚。 一致性：事务应确保数据库的状态从一个一致状态转变为另外一个一致的状态。一致性的含义是指数据库中的数据应满足完整性约束。 隔离性：多个事务并发执行时，一个事务的执行应该不影响其他事务的执行。 持久性：一个事务一旦提交，它对数据库的修改应该永久保存在数据库中。持久性意味着当系统或者介质发生故障时，确保已提交事务的更新不能丢失，即对已提交事务的更新能够恢复。一旦一个事务被提交，DBMS（数据库管理软件）必须保证提供适当的冗余，使其耐得住系统的故障，持久性主要在于DBMS的恢复性能。InnoDB会将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作。这个文件就是redo_log_file。redo_log文件保证了InnoDB的持久性。 模拟A向B账号转账的场景 12345678910111213141516/* * 我们来模拟A向B账号转账的场景 * A和B账户都有1000块，现在我让A账户向B账号转500块钱 * **///JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题//A账户减去500块String sql = "UPDATE a SET money=money-500 ";preparedStatement = connection.prepareStatement(sql);preparedStatement.executeUpdate();//B账户多了500块String sql2 = "UPDATE b SET money=money+500";preparedStatement = connection.prepareStatement(sql2);preparedStatement.executeUpdate(); 从上面看，我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下 1234567891011// A账户减去500块String sql = "UPDATE a SET money=money-500 ";preparedStatement = connection.prepareStatement(sql);preparedStatement.executeUpdate();// 这里模拟出现问题int a = 3 / 0;String sql2 = "UPDATE b SET money=money+500";preparedStatement = connection.prepareStatement(sql2);preparedStatement.executeUpdate(); 显然，上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。 我们可以通过事务来解决上面出现的问题： 12345678910111213141516171819202122232425262728293031try &#123; // A账户减去500块 String sql = "UPDATE a SET money=money-500 "; preparedStatement = connection.prepareStatement(sql); preparedStatement.executeUpdate(); // 在转账过程中出现问题 int a = 3 / 0; // B账户多500块 String sql2 = "UPDATE b SET money=money+500"; preparedStatement = connection.prepareStatement(sql2); preparedStatement.executeUpdate(); // 如果程序能执行到这里，没有抛出异常，我们就提交数据 connection.commit(); // 关闭事务【自动提交】 connection.setAutoCommit(true);&#125; catch(SQLException e) &#123; try &#123; // 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】 connection.rollback(); // 关闭事务【自动提交】 connection.setAutoCommit(true); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125;&#125; 上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。 注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。 3.4 事务并发访问产生的问题及事务隔离机制3.4.1 事务并发访问引起的问题及如何避免12345678//查看事务的隔离级别select @@tx_isolation;//设置当前Session的事务隔离级别为最低级别“读未提交”set session transaction isolation level read uncommitted;//开始一个事务start transaction;//回滚rollback; 隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是： 读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题。 读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题。 可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。 序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。 事务的并发问题有哪几种？ 更新丢失(lost update)，即一个事务的更新覆盖了另一个事务的更新，MySQL所有事务隔离级别在数据库层面上均可避免。 脏读（dirty read），一个事务读到另一个事务未提交的更新数据。该问题可以在已提交读(READ-COMMITTED)事务隔离级别以上去避免。 不可重复读（Non-Repeatable-Read），事务A多次读取同一数据，事务B在事务A读取的过程中对数据做了更新并提交，导致事务A多次读取同一数据时结果不一致。可该问题可以在重复读（REPEATABLE-READ）事务隔离级别以上去避免。（如何避免可重复读带来的问题？） 幻读（Phantom Read），事务A读取与搜索条件相匹配的若干行，事务B以插入或删除行的方式来修改事务A的结果集，导致事务A在看起来像出现幻觉一样。可该问题可以在串行化（SERIALIZABLE，最高的事务隔离级别，所有sql都会加锁）事务隔离级别以上去避免。 总结 可重复读级别理论上不能避免幻读，而是InnoDB通过某种巧妙的方式避免了幻读。 不可重复读侧重于对同一数据的修改，而幻读而侧重于新增或删除。 事务隔离级别越高，安全性越高，串行化执行越严重，这样降低了数据库的并发度。Oracle默认为READ-COMMITTED，而MySQL默认为REPEATABLE-READ。 3.5 InnoDB可重复读隔离级别下如何避免幻读3.5.1 概述 表象：快照读（非阻塞读）——伪MVCC 内在：next-key锁（行锁+gap锁） 3.5.2 当前读和快照读 12select * from account_innodb lock in share mode;update account_innodb set balance = 1000; //update也是当前读操作 当前读便是加了锁的增删改查语句（不管是共享锁还是排它锁），当前读的含义是它读取的是当前记录的最新版本。并且读取之后还需要保证其他并发事务不能修改当前记录，对读取的记录加锁。 除去lock in share mode加的是共享锁之外，其他当前读操作加的都是排它锁。 RDBMS即关系数据库管理系统，主要由两大部分组成：程序实例和存储。 update和delete操作类似，均会触发当前读操作，获取数据的最新版本；insert操作稍有不同，insert操作困难会触发唯一键的冲突检查，会进行一个当前读。 快照读即简单的select操作，不加锁，此不加锁的条件是在事务隔离级别不为SERIALIZABLE时。在SERIALIZABLE下由于是串行读，所以此时快照读select也退化成当前读，即select …lock in share mode模式。快照读的出现是为了提升并发性能，快照读的实现是基于多版本并发控制，即MVCC。可以认为MVCC是行级锁的一个变种，但是他在很多情况下避免了加锁操作，因此开销更低。因为是基于多版本，所以快照读有可能读到的不是数据的最新版本，可能是之前的历史版本。 在READ-COMMITTED隔离级别下，快照读和当前读读到的数据版本是一样的。 在REPEATABLE-READ隔离级别下，快照读有可能读到数据的历史版本，也有可能读到最新的版本。在REPEATABLE-READ下，事务首次调用快照读的地方很关键，创建快照的时机决定了读取数据的版本。 3.5.3 next-key锁（行锁[Record Lock]+gap锁） Gap就是索引树中插入新纪录的空隙，Gap lock（间隙锁）即锁定一个范围，但不包括记录本身。Gap锁的目的是为了防止同一事务的两次当前读出现幻读的情况。Gap锁在READ-COMMITTED及更低事务隔离级别下是没有的。在REPEATABLE-READ及SERIALIZABLE级别下默认都支持Gap锁。 REPEATABLE-READ下Gap锁出现的场景。①无论删改查，当前读若用到主键或唯一键，若where条件全部命中（精确查询时所有记录都有），则不会用Gap锁，只会加记录锁。②如果where条件部分命中（范围查询及精确查询非全部命中）或者全不命中，则会加Gap锁。 3.5.4 Gap锁会用在非唯一索引或者不走索引的当前读当中a）非唯一索引 非唯一索引，均为左开右闭区间。Gap锁是用来防止插入的。 12345(negative infinity, 10](10, 11](11, 13](13, 20](20, positive infinity] 主键值在其中也起到了一定的作用。 b）不走索引 当前值不走索引的时候，它会对所有的Gap都上锁，这里类似于锁表。 这种情况通常需要避免，影响MySQL的性能。 3.6 RC、RR级别下的InnoDB的非阻塞读（快照读）如何实现 数据行里除了存储数据外，还有额外的的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段。①DB_TRX_ID字段用来标识最近一次对本行记录做修改的事务标识符，即最后一次修改本行记录的事务ID。②DB_ROLL_PTR字段用来回滚指针，指写入回滚段Rolllback-Segment的undo日志记录，如果一行记录被更新，则Undo_Log_Recalled包含重建该行记录被更新之前内容所必须的信息③DB_ROW_ID字段，表示行号，包含一个随着新行插入而单调递增的行id，当由InnoDB自动产生聚集索引时，聚集索引会包括行id的值，否则此行id不会出现在任何索引中。④还有DELETED字段，删除语句其实也是一次update操作，操作DELETED字段。 undo日志。当我们对数据做了变更操作时，就会产生undo记录，undo记录中存储的是老版数据。当一个旧事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。undo log分为insert undo log和update undo log。insert undo log表示的是事务对insert新纪录产生的undo log，只在事务回滚时需要，并且在事务提交后就可以立即丢弃；update undo log是事务对记录进行delete或者update操作时产生的undo log，不仅在事务回滚时需要，快照读也需要，因此不能随便删除。只有在数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被Purge线程删除。 简易版实现： read view（快照），用来做可见性判断，当我们执行快照读select时，会针对我们查询的数据创建出一个read view来决定当前事务能看到的是哪个版本的事务。其遵循一个可见性算法。将要修改数据的DB_TRX_ID取出来与系统其他活跃事务ID作对比，如果大于或等于这些ID，就通过DB_ROW_PTR指针去取出undo log上一层的DB_TRX_ID，直到小于这些活跃事务ID为止。这样就保证了我们获取到数据版本是当前可见的最稳定的版本。正是因为生成时机的不同，造成了RC、RR两种隔离级别的不同可见性：①在REPEATABLE-READ级别下，Session在start transaction之后第一条快照读会创建一个快照，即read view，将当前系统中活跃的其他事务记录起来。此后在调用快照读的时候，用的还是同一个read view。②而在READ-COMMITTED级别下，事务中每条select语句（即每次调用快照读）时，都会创建一个新的快照。这就是我们之前在RC下能用快照读看到别的事务对表记录的增删改。③在REPEATABLE-READ级别下，如果首次使用快照读，是在别的事务对数据做出增删改并提交之前。此后即便别的事务对数据做了增删改并提交，还是读不到数据变更的原因，对于RR来讲，首次事务select的时机是相当重要的。 正是因为以上的三个因子，才使得InnoDB在RR或者RC级别支持非阻塞读。而读取数据时的非阻塞，就是所谓的MVCC。而InnoDB的非阻塞读机制，实现了仿照版的MVCC。MVCC即Multi-Version Concurrency Control，多版本并发控制，读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大地增加了系统的并发性能。伪MVCC是因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。 4. 关键语法4.1 概述 GROUP BY HAVING 统计相关：COUNT、SUM、MAX、MIN、AVG 4.2 GROUP BYGROUP BY作用是根据给定数据列的每个成员，对查询结果进行分组统计，最终得到一个分组汇总表。 满足SELECT子句中的列名必须为分组列或列函数（该条件只针对同一张表成立），即group by里出现某个表的字段，select里面的列要么是该group by里面出现的列，要么是别的表的列或者带有函数的列。 列函数对于GROUP BY子句定义的每个组各返回一个结果（GROUP BY过程中会用到临时表[Using temporary]，详见explain） 123456789101112131415161718#查询所有同学的学号、选课数、总成绩#分为子语句进行分析编写然后组合group by student_idselect student_id,count(course_id),sum(score)from score#组合结果select student_id,count(course_id),sum(score)from scoregroup by student_id；#查询所有同学的学号、姓名、选课数、总成绩select s.student_id,stu.name,count(s.course_id),sum(s.score)from score s, student stuwhere s.student_id = stu.student_idgroup by s.student_id； 注意：在一个sql语句内，where一定要写在group by前面。 4.3 HAVING HAVING通常与GROUP BY子句一起使用，我们可以应用它在GROUP BY子句之后指定过滤的条件。若省略了GROUP BY子句，HAVING子句的行为就跟WHERE一样，HAVING支持所有WHERE操作符。 WHERE用来过滤行，HAVING用来过滤组。 出现在同一sql中的顺序：WHERE&gt;GROUP BY&gt;HAVING 123456789101112131415161718192021#查询平均成绩大于60分的同学的学号和平均成绩select student_id, avg(score)from scoregroup by student_idhaving avg(score)&gt;60;#取出student_id为1的学生的成绩情况select * from score where student_id = 1;select * from score having student_id = 1; //和where效果完全一致#查询没有学全所有课的同学的学号、姓名select stu.student_id,stu.namefrom student stu, score swhere stu.student_id = s.student_idgroup by student_idhaving count(*) &lt;( select count(*) from course) 4.4 总结一个完整的SQL语句如下： 123456789101112select xxxxfrom xxxxwhere xxxxgroup by xxxxhaving xxxxorder by xxxx 以上关键字的顺序不能变，严格遵守以上语句的执行顺序： from 将硬盘上的表文件加载到内存 where:将符合条件的数据行摘取出来。生成一张新的临时表 group by :根据列中的数据种类，将当前临时表划分成若干个新的临时表 having : 可以过滤掉group by生成的不符合条件的临时表 select : 对当前临时表进行整列读取 order by : 对select生成的临时表，进行重新排序，生成新的临时表 limit : 对最终生成的临时表的数据行，进行截取。 5. 理论范式设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 数据库设计一般满足第三范式就够了，三范式归纳起来就三句话： 1NF:字段不可分; 2NF:有主键，非主键字段依赖主键; 3NF:非主键字段不能相互依赖; 解析： 1NF:原子性 字段不可再分,否则就不是关系数据库; 2NF:唯一性 一个表只说明一个事物; 3NF:每列都与主键有直接关系，不存在传递依赖; 5.1 第一范式（无重复的列）定义：数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性。 通俗解释：一个字段只存储一项信息。 eg：班级：高三年1班，应改为2个字段，一个年级、一个班级，才满足第一范式 不满足第一范式： 学号 姓名 班级 0001 小红 高三年1班 应该改为： 学号 姓名 年级 班级 0001 小红 高三年 1班 5.2 第二范式（属性完全依赖于主键）定义：满足第一范式前提，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。 通俗解释：任意一个字段都只依赖表中的同一个字段 eg：学生证信息和借书证信息混在一起。 不符合第二范式： 学生证 名称 学生证号 学生证办理时间 借书证名称 借书证号 借书证办理时间 应改成2张表： 学生证表 学生证 学生证号 学生证办理时间 借书证表 借书证 借书证号 借书证把你拉时间 5.3 第三范式（属性不能传递依赖于主属性）定义：满足第二范式前提，如果某一属性依赖于其他非主键属性，而其他非主键属性又依赖于主键，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。 通俗理解：一张表最多只存2层同类型信息 eg：爸爸信息表有女儿的小熊信息。 不满足第三范式： 爸爸 儿子 女儿 女儿的小熊 女儿的海绵宝宝 应该改为： 爸爸信息表： 爸爸 儿子 女儿 女儿信息表： 女儿 女儿的小熊 女儿的海绵宝宝]]></content>
      <categories>
        <category>Java面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试知识点总结-计算机网络篇]]></title>
    <url>%2F2019%2F08%2F03%2F2019-08-03-Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[目录 网路基础知识 TCP与UDP HTTP相关知识 Socket相关知识 网络知识总结 1. 网路基础知识当前市面上分别存在四层、五层、七层协议。国际标准化组织ISO制定的OSI七层协议模型，是业界提出来的概念型框架。 1.1 OSI开放式互联参考模型OSI是一个定义良好的协议规范基，并由许多可选部分完成类似的任务，它定义了开放系统的层次结构，层次之间的相互关系，以及各层所包括的可能的任务。是作为一个框架来协调和组织各层所提供的服务。 OSI参考模型并没有提供一个可以实现的方法，而是描述了一些概念，用来协调进程间通信标准的制定。即OSI参考模型并不是一个标准，而是一个在自定义标准时所使用的概念型框架。 1.1.1 物理层 首先要解决两台物理机之间的通讯需求，机器A往机器B发送比特流，而机器B可以接受到这些比特流。 物理层主要定义了物理设备的标准，如网线的类型、光纤的接口类型、各种传输介质的传输速率等。 它的主要作用是传输比特流，即“0101”二进制数据。将它们转换为电流强弱来进行传输，到达目的地之后，在转化为“0101”的机器码，即我们常说的数模转换与模数转换。 物理层的数据叫做比特。 网卡工作在物理层。 1.1.2 数据链路层 在传输比特流的过程中，会产生错传、数据传输不完整的可能，因此数据链路层应运而生。 数据链路层定义了如何格式化数据以进行传输，以及如何控制对物理介质的访问。 数据链路层通常还提供错误检测和纠正，以确保数据传输的可靠性。 数据链路层将比特数据组成帧。 交换机工作在数据链路层，对帧解码，并根据帧中包含的信息，把数据发送到正确的接收方。 1.1.3 网络层 随着网络节点的不断增加，点对点通信时要通过多个节点，如何找到目标节点，如何选择最佳路径便成为了首要需求。此时，便有了网络层。 网络层的主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。 网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的话费，来决定从一个网络中的节点A到另一个网络中的节点B的最佳路径。 由于网络层处理并智能指导数据传送，路由器连接于网络各段，所以路由器属于网络层。 网络层的数据称之为数据包。 网络层我们主要关注的协议是IP协议。 1.1.4 传输层 随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输等，可能需要很长时间，而网络在通信的过程中会中断好多次。此时为了保证传输大量文件时的准确性，需要对发出去的数据进行切分，切割为一个一个的段落(Segment)进行发送。其中一个段落丢失后是否需要重传，每个段落是否需要按照顺序到达，是传输层需要考虑的问题。 传输层解决了主机间的数据传输，数据间的传输可以是不同网络的。 传输层解决了传输质量的问题，该层被称之为OSI模型中最重要的一层。 传输层传输协议同时进行流量控制，或是基于接收方可接收数据的快慢程度，规定适当的发送速率。 传输层按照网络能处理的最大尺寸，将较长的数据包进行强制分割，例如以太网无法接收大于1500字节的数据包。发送方节点的传输层，将数据分割成较小的数据片，同时对每一个数据片安排一个序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程称之为排序。 传输层中需要关注的协议有TCP协议、UDP协议。 1.1.5 会话层 传输层过后我们已经可以保证给正确的计算机发送正确的封装过后的信息。但是用户级别的体验不好，肯定不能每次都调用TCP去打包，调用IP协议去找路由，自己去发送。所以我们要建立一个自动收发包、自动寻址的功能，于是发明了会话层。 会话层的作用就是建立和管理应用程序之间的通信。 1.1.6 表示层 会话层之后能够保证应用程序自动收发包和寻址了。但若要跨系统发包，例如在linux系统给windows系统发包，两系统语法不一致，例如安装包exe不能再linux系统上执行，shell在windows下也不能直接运行。于是需要表示层。 表示层帮我们解决不同系统之间的通信语法问题。 在表示层数据将按照网络能理解的方案进行格式化，这种格式化也因所使用网络类型的不同而不同。 1.1.7 应用层 表示层之后发送方虽然知道自己发送的是什么东西，转换成字节数组之后有多长，但接收方肯定不知道，所以应用层网络协议诞生了。 应用层规定发送方和接收方必须使用一个固定长度的消息头。消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，以方便接收方能够正确的解析发送方发送的数据。 应用层旨在让你更方便的应用从网络中接收到的数据。至于数据的传递，没有该层，也可以在两台电脑间进行传递，只不过传递的是1和0组成的字节数组。 应用层需要重点关注的是HTTP协议。 网络数据处理流程从应用层开始，都会对要传输的数据头部进行处理，加上本层的一些信息。最终由物理层通过以太网电缆等介质，将数据解析成比特流，在网络中传输。数据传输到目标地址，并自底而上的将先前对应层的头部给解析分离出来。 1.2 TCP/IP参考模型 OSI模型的实现：TCP/IP四层架构参考模型 TCP/IP参考模型是首先由ARPANET所使用的网络体系结构，后来该结构被美国国防部用来作为计算机网络的标准，市面上绝大多数的厂商也已该标准为主，用以商用。 TCP/IP协议并不完全符合OSI的七层参考模型，但我们依然可以理解为它是OSI的一种实现。 在很多情况下，TCP/IP只是利用IP进行通信时，所必须用到的协议群的统称。例如：IP、ICMP、TCP、UDP、Talnet、FTP以及HTTP都属于TCP/IP协议。他们与TCP或IP的关系紧密，是互联网必不可少的组成部分。TCP/IP协议泛指这些协议，因此有时也称TCP/IP为网际协议群。 TCP/IP在分层模块上与OSI稍有区别，TCP/IP中的应用层可以约等于OSI模型中的会话层、表示层、应用层；OSI中的物理层和数据链路层被归并为链路层。 OSI模型注重通信协议必要的功能是什么，而TCP/IP协议则更强调在计算机上实现协议，应该开发哪种程序。 和OSI一样，TCP/IP的每个分层中，都会对所发送的数据附加一个头部。在这个头部中，包含了该层所必要的信息，如发送的目标地址，以及协议相关的信息。通常为协议提供的信息为报头的首部，所要发送的内容为数据。从下一层角度上看，数据被传送到接收端之后，再层层解套出来。 2. TCP与UDP2.1 TCP的三次握手2.1.1 IP协议IP协议是无连接的通信协议，它不会占用两个正在通信的计算机之间的通信线路。这样IP就降低了对网络线路的需求，每条线可以同时满足许多不同的计算机之间的通讯需要。通过IP，消息或者其他数据会被分割为较小的独立的包，并通过因特网在计算机之间传送。IP负责将每个包路由至它的目的地，但IP协议没有做任何事情来确认数据包是否按顺序发送，或者包是否被破坏，所以IP数据包是不可靠的。需要由它的上层协议来做出控制。 2.1.2 TCP协议TCP（传输控制协议）是属于传输层的协议 TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。 数据传输时应用层向TCP发送数据流，TCP将数据流分割成适当长度的报文段，报文段长度通常受该计算机连接的网络的数据链路层的最大传输单元（即MTU）的限制。之后TCP把结果包传给IP层，由它来通过网络将包传送给目标节点的TCP层。 TCP为了保证不丢失包，就给每个包一个序号，即Sequence Number，同时序号也保证了传送到目标节点的包的按序处理。接收端实体对已成功接收到的包发回一个相应的确认，即ACK确认。如果发送端实体在合理的往返时延（即RTT）内未收到确认，那么对应的数据包就会被假设为已丢失，并且将会对其进行重传。 TCP用一个奇偶校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和。 2.1.3 TCP报文头部 Source Port和Destination Port分别表示源端口和目的端口，各占两个字节。TCP和UDP的数据包都是不包含IP地址信息的，那是IP层的事情。但是TCP和UDP均会有源端口和目的端口。 两个进程在计算机内部进行通信：用 ①管道②内存共享③信号量④消息队列 等方法进行通信。而两个进程如果需要进行通信，最基本的一个前提是能够唯一的标识一个进程。通过该唯一标识，找到对应的进程。在本地进程通信中，我们可以使用PID，即我们的进程标识符（进程号），来唯一标识一个进程。但PID只在本地唯一，如果把两个进程放到了不同的两台计算机，它们要进行通讯的话，PID已经不足够，这时就需要另外的手段。解决这个问题的方法，就是在传输层中使用协议端口号。IP地址可以唯一标识主机，而TCP协议和端口号可以唯一标识主机中的一个进程，这样我们可以利用“IP地址+协议+端口号”这个唯一标识去标识网络中的一个进程。在一些场合也将这种唯一标识的模式称之为套接字（即socket）。即是说虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由TCP来完成。 Sequence Number表示序列号，它占据了4个字节，TCP连接中传送的字节流中的每个字节，都按顺序去编号。例如一段报文的序号字段值为107，而携带的数据共有100个字段；那么如果有下一个报文段的话，其序号应该是从107+100=207开始。 Acknowledgment Number（ACK确认号），同样占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如B收到A发送来的报文，其序列号字段为301，而数据长度是200字节，这表明B正确收到了A发送的到序号500为止的数据。因此B期望收到A的下一个数据序号是501，于是B在发送给A的确认报文段中，会把ACK确认号，置为501。 Offset（数据偏移），由于头部有可选字段，长度不固定，因此它指出TCP报文的数据距离TCP报文的起始处有多远。 Reserved是保留域，保留今后使用的，但目前都被标为0。 TCP flags（控制位），主要由八个标志位来组成，每一个标志位表示一个控制功能。 ①URG: 紧急指针标志，当其为1时表示紧急指针有效，为0则忽略紧急指针。②ACK: 确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。Acknowledgment Number是否有效就是通过该位控制的。③PSH: push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。④RST（即reset），即重置链接标志，用于重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求。⑤SYN，同步序列号，用于建立链接过程。在链接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域；而链接应答捎带一个确认，即SYN=1和ACK=1。⑥FIN，即finish标志，用于释放链接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。 Window窗口，指的是滑动窗口的大小，用来告知发送端接收端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。 CheckSum，检验和，指的是奇偶校验，此校验和是对整个的TCP报文段，包括TCP头部和TCP数据，以16位进行计算所得，由发送端计算和存储，并由接收端进行验证。 Urgent Pointer，即紧急指针，只有当TCP flag中的URG为1时才有效，指出本报文段中的紧急数据的字节数。 TCP Options，可选项，其长度可变，定义一些其他的可选参数。 2.1.4 三次握手当应用程度希望通过TCP与另一个应用程序通讯时，它会发送一个通讯请求，这个请求必须被送到一个确切的地址，在双方“握手”之后，TCP将在两个应用之间建立一个全双工（A可以给B发送信息，与此同时B也可以给A发送信息）的通信。这个全双工的通信，将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。此处所说的“握手”即TCP的三次握手。 （1）过程：假设A和B首次进行通信 一开始客户端和服务器均处于CLOSED状态，假设客户端主动打开连接，服务端被动打开连接。 刚开始时，TCP服务器进程先创建传输控制块TCB，时刻准备接受其他客户进程发送过来的连接请求，此时服务端进入了LISTEN，即监听的状态。 TCP客户端进程创建一个传输控制块TCB，向服务器发出连接请求报文，TCP flags中的同步序号SYN=1，同时选择一个初始序号seq=x（任意正整数值），此时TCP客户端进程就进入了SYN-SENT的同步已发送的状态。此时发送过去的数据包（即报文段）会被称为SYN报文段，其不能携带数据，但是要消耗掉一个序号，这便是第一次握手。 服务器接收到请求报文之后，如果同意连接，则发出确认报文，确认报文中包含了TCP flags中的两个位的字段，一个是ACK=1，另一个是SYN=1，它的确认号ack=x+1（原因是我们在SYN报文中指定了seq，那作为回应它要回应跟x相关的信息，并且由于上面的一个报文消耗掉了一个序号，因此ack=x+1），同时为自己的缓存初始化一个序列号，即seq=y。此时，服务器就进入到了SYN-RCVD，即同步收到的状态，此报文也不能携带数据，并且同样需要消耗一个序号，这便是第二次握手。 当TCP客户进程收到确认报文之后，还要向服务器给出一个确认，确认报文的ACK=1,ack=y+1(原因是因为刚刚服务器给客户端发送了一个seq=y，同时此报文也需要消耗掉一个序号，因此作为回应，ack=y+1)，同时因为服务器告知客户端序号seq已经加1了，因此自己的序号就是seq=x+1。此时TCP连接建立，客户端就进入了ESTABLISHED状态，即已建立连接的状态。TCP规定，这个ack报文段可以携带数据，前两个均不允许携带，当然其也可以不携带数据，如果不携带数据就不会消耗序号。这便是第三次握手。 当服务器收到客户端的确认后，也会进入到ESTABLISHED状态，此后，双方就可以开始通信了。 （2）为什么需要三次握手才能建立起连接，两次不可以么？①为了初始化Sequence Number的初始值，通信的双方要互相通知对方自己的初始化的Sequence Number，即上述的x和y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，即TCP会用该序号来拼接数据。因此服务器在回发它的Sequence Number，即第二次握手之后，还需要发送确认报文给服务器，告知服务器客户端已经收到服务器的初始化的Sequence Number了。 ②为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。 正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。 现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。 （3）首次握手的隐患——SYN超时问题起因分析： ①Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认（Client掉线），此时这个连接就会处于一个中间状态，即没有成功也没有失败。②Server端在一定时间内没有收到客户端的回执，则Server会不断重发SYN-ACK直至超时，在Linux下，默认重试次数为5次。重试的时间从1s开始，每次都翻倍，总共为31s。在第五次发出之后，还需要等待32s才能够被判定为超时，所以总共63s之后，TCP才会断开此连接。 造成问题： 可能会使服务器遭到SYN-Flood攻击的风险，恶意程序会给服务器发一个SYN报文，发之后下线，于是服务器需要默认等63s才会断开此连接。这样攻击者就可以把服务器SYN连接的队列耗尽，让正常的连接请求不能处理。 针对SYN-Flood的防护措施： ①在Linux下会通过tcp_syncoodies参数来应对。当SYN队列满时，TCP会通过目标地址端口、源地址端口和时间戳打造出一个特别的Sequence Number回发回去，这个Sequence Number简称SYN Cookie。②如果是攻击者，则不会有相应；如果是正常连接，则Client会回发SYN Cookie，服务端可以通过这个Cookie建立连接。③通过SYN Cookie，即便此时SYN队列满了，本次连接请求不在队列中，依然能够建立连接，进而解决了该问题的发生。 （4）建立连接后，Client出现故障怎么办TCP设有保活机制 在一段时间（称之为保活时间）内，连接处于非活动状态，开启保活功能的一端将向对方发送一个保活探测报文。如果发送端没有收到响应报文，那么经过一个提前配置好的保活时间间隔，将继续发送保活探测报文。 当发送探测报文的次数达到保活探测数，这时对方主机将被确认为不可达，连接也将被中断。 2.2 TCP的四次挥手 所谓四次挥手，即终止TCP连接。就是指断开一个TCP连接时，需要客户端和服务端总共发出4个包，已确认连接的断开。 在Socket编程中，这个过程由客户端或服务端任一方执行CLOSED来触发。 假设由客户端主动触发CLOSED，流程图如下： （1）过程 数据传送完毕之后，双方都可释放连接。最开始客户端和服务端都处于ESTABLISHED的状态，客户端主动关闭，服务器被动关闭。 首先客户端进程发出连接释放报文，并且停止发送数据。在该数据报的报头中，TCP flags中的FIN=1，这时假设客户端定义的序列号seq=u（该值等于前面ESTABLISHED状态下数据最后一次发送时，已经传送过来的数据的最后一个字节的序号再加1）。此时客户端就进入了FIN-WAIT-1这样一个终止等待1的状态。TCP规定，即使FIN报文段不携带任何数据，也要消耗掉一个序号，即回执时u会加1。 当服务器收到连接释放报文时，也要发出确认报文。即ACK=1，这里作为回应，ack=u+1，并且携带上了自己的序列号seq=v。此时服务端就进入了CLOSE-WAIT这样一个关闭等待的状态（重要）。TCP服务器通知高层的应用进程客户端要释放与TCP通信的连接了，这时候会处于半关闭的状态。即客户端已经没有数据要发送了，但服务器若要发送数据，客户端仍然能够接收。这个状态要持续一段时间，该时间等于整个CLOSE-WAIT状态所持续的时间。 客户端收到服务器的确认请求后，也就是第二次挥手时，客户端就进入了FIN-WAIT-2，即终止等待2状态。等待服务器发送释放连接报文，即等待它发送第三次挥手的请求。因此在这段时间内，客户端有可能还需要接收服务器发送的最后的数据。 服务器将最后的数据发送完毕后，就会向客户端发送连接释放报文。这里FIN=1，ACK=1，ack=u+1。由于在半关闭的状态，服务器很可能又发送了一些数据，假定此时的序号seq=w。此时服务器就进入了LAST-ACK，即最后确认状态，等待客户端的最后确认。 客户端在收到服务器的连接释放报文之后，必须发出确认，即ACK=1,将服务器发来的w变为ack=w+1回发回去，自己的序号此时为seq=u+1(按照之前的报文加1)。此时客户端就进入了TIME-WAIT，即时间等待的状态，注意此时客户端的TCP连接还没有释放。必须经过2*MSL(最长报文段寿命，RFC-793定义了MSL的值为2分钟，而Linux设置成了30秒)的时间后，我们的连接才会真正的释放，才进入到CLOSED的状态。 服务器收到了客户端发出的确认后，立即就进入了CLOSED的状态。因此服务器结束TCP连接的时间要比客户端稍早一些。 （2）为什么会有TIME-WAIT状态 TIME-WAIT状态是用来保证有足够的时间让对端收到ACK包，如果被动关闭方没有收到ACK，就会触发被动端重发FIN包，一来一去刚好是2*MSL的时间。 有足够的时间让这个连接不会跟后面的连接混在一起，因为有些路由器会缓存IP数据包。如果连接被重用了，那么这些延迟收到的包就有可能跟新连接混在一起。 （3）为什么需要四次挥手来中断连接 全双工的意思，是允许数据在两个方向上同时传输。即在同一时间，服务器可以发送数据给客户端，客户端也可以发送数据给服务器。 因为TCP是全双工的，所以发送方和接收方都需要FIN报文和ACK报文。也就是说发送方和接收方，各自需要两次挥手，只不过有一方是被动的。所以看上去就成了所谓的四次挥手。 （4）服务器出现大量CLOSE-WAIT状态的原因①原因 问题的其中一个表现是客户端一直在请求，但是返回给客户端的信息是异常的，服务端压根没有收到请求。 服务器保持大量的CLOSE-WAIT的情况是，在对方发送FIN报文之后，程序这边没有进一步发送ACK报文或者FIN报文以确认。换言之，就是在对方关闭socket连接后，程序中没有检测到，或者程序忘记了此时需要关闭连接，于是资源一直被程序占用着。（我方忙于读或写，没有及时关闭连接） ②处理方式 多数可能是程序里有bug，通常是某些连接没有及时释放导致。 或者某些配置，如线程池中的线程数之类的配置不合理，此时需要我们结合实际业务区排查。 （5）查看网络机器状况的指令12345netstat -n | awk &apos;/^tcp/&#123;++S[$NF]&#125;END&#123;for (a in S) print(a,S[a])&#125;&apos;TIME_WAIT 1507CLOSE_WAIT 588FIN_WAIT2 5ESTABLISHED 413 当CLOSE-WAIT数量很多时，比如几千，就需要我们去排查问题了。因为对于Linux服务器来说，会为每个用户分配有限的文件句柄数，而我们的连接也是和文件句柄一一对应的。而CLOSE-WAIT状态如果一直被保持，意味着对应数目的通道一直被占用着，一旦达到了上限，则新的请求就无法被处理。接着就是大量的too many open files异常，有可能会造成软件服务器的崩溃，即有可能让我们的Tomcat、Nginx或者Apache崩溃。 2.3 TCP和UDP的区别2.3.1 UDP简介UDP（User Datagram Protocol，即用户数据报协议） 2.3.2 UDP报文结构 相比TCP报文，UDP报文的域少了很多，简单了很多。由源端口、目标端口、数据包长度、奇偶校验值以及用户数据来组成。 2.3.3 UDP特点简单的报文结构也就意味着UDP不像TCP那样支持错误重传、滑动窗口等精细控制。 面向非连接：UDP是一个非连接的协议，传输数据之前，源端和终端不建立连接。当它想传送时，就简单的去抓取来自应用程序的数据，并尽可能快的把它扔到网络上。在发送端UDP传送数据的速度，仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制。在接收端，UDP把每个消息段放在队列中，应用程序每次在队列中读取一个消息段。 不维护连接状态：由于传输数据不建立连接，因此不需要维护连接状态，包括收发状态等。因此一台服务器可同时向多个客户端传输相同的消息。 开销较少：UDP信息包的报头很短，只有8个字节，相对于TCP报头的20个字节的信息包，额外开销小很多。 吞吐量：吞吐量不收拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽以及源端和终端主机性能的限制。 不需要维护状态：UDP尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。 面向报文：UDP是面向报文的，发送方的UDP对应用程序交下来的报文，在添加首部后，就向下交付给IP层，既不拆分也不合并，而是保留这些报文的边界。因此应用程序需要选择合适的报文大小，也就是说UDP将绝大多数的控制交由上层去解决。 2.3.4 TCP和UDP的区别TCP和UDP是OSI模型中的运输层中的协议，TCP提供可靠的通信传输，而UDP则常被用于让网络和细节交给应用层的通信传输。 是否连接：TCP面向连接，而UDP面向无连接。TCP有三次握手的连接过程，UDP适合消息的多播发布，由单个点向多个点传输信息。 可靠性：TCP是可靠的，TCP通过握手、确认和重传机制，提供了可靠性保证。UDP则可能会丢失，不知道到底有没有被接收。 有序性：TCP通过序列号保证了消息报的顺序交付，到达可能无序，但TCP最终会排序；而UDP不具备有序性。 速度：TCP速度较慢（因为要创建连接，保证消息的可靠性和有序性等，需要做额外的很多事情）。UDP则更适合对速度比较敏感的应用，比如在线视频媒体、电视广播、多人在线游戏等。 量级：TCP属于重量级，UDP属于轻量级。体现在源数据的头部大小，TCP头部20个字节，UDP头部仅有8个字节。 2.4 TCP的滑动窗口2.4.1 RTT和RTO RTT：发送一个数据包到收到对应的ACK，所花费的时间。简言之，即我发送一个数据包，对端回一个ACK所经过的时间。 RTO：重传时间间隔。TCP在发送一个数据包之后，会启动一个重传定时器，RTO就是这个定时器的重传时间。我一开始预先算一个定时器时间，如果你回复了ACK，那么重传定时器就自动失效，也就是说不用重传了。如果没有回复给我ACK，然而RTO定时器的时间又到了，我就重传。由于RTO是本次发送当前数据包所预估的超时时间，那么RTO就需要一个很好的算法来统计，来更好的预测这次的超时时间。RTO不是固定写死的配置，而是经过RTT计算出来的。有了RTT，才能计算出RTO。基于RTO我们便有了重传机制，才能支撑起接下来的滑动窗口。 2.4.2 滑动窗口①背景： TCP会将数据拆分成段进行发送，出于效率和传输速度的考虑，我们不可能等一段一段数据去发送，等到上一段数据被确认之后再发送下一段数据，这个效率是非常低的。我们需要实现对数据的批量发送。TCP必须要解决可靠传输以及包乱序的问题。所以TCP需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。TCP使用滑动窗口做流量控制与乱序重排。 ②作用： TCP的滑动窗口主要有两个作用： 提供TCP的可靠性 提供TCP的流控特性。 TCP报文头部中的Window字段，用于接收方通知发送方自己还有多少缓冲区可以接收数据。发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，这就是流量控制。同时滑动窗口机制还体现了面向字节流的设计思路。 ③窗口数据的计算过程 如图所示，左图是TCP协议的发送端缓冲区，右图是接收端缓冲区，左边往右边发数据。两图中下面的长方形表示要发送的数据流，里面假设装满了数据，并且需要按照顺序从左向右发送或者接受。我们假设对应的数据段位置序号也是从左到右去增长的。 对于发送方来讲，LastByteAcked指向收到的连续最大的ack的位置。也就是从左端算起，连续已经被接收端的程序发送ACK回执确认已收到的Sequence Number。LastByteSent指向已发送的最后一个字节的位置，该位置只是发送，但是还没有收到ACK回应。而LastByteWritten，指向上层应用已写完的最后一个字节的位置，即当前程序已经准备好的需要发送的最新的一个数据段。LastByteAcked~LastByteSent之间是发送出去但是还没有收到确认的，LastByteAcked之前的是已经发送出去并已经收到接收端确认的。从LastByteAcked到LastByteWritten都没有出现间隔的，都是连续的。 对于接收方来讲，LastByteRead指向上层应用已经读完的最后一个字节的位置，即收到了发送方的数据，并且已经处理并回执的最后一个位置。而NextByteExpected指向收到的连续最大的Sequence的位置，即LastByteRead~NextByteExpected是已经收到了，但是还没有发送回执的。而LastByteRcvd，指向已收到的最后一个字节的位置。可以看到NextByteExpected和LastByteRcvd中间，有一些Sequence还没有到达，对应为空白区域。此时我们可以根据上面的数值，计算出接收方的AdvertisedWindow的大小，之后回发给发送方，让发送方计算出发送方剩余可发送的数据大小，即EffectiveWindow大小。 AdvertisedWindow = MacRcvBuffer(接收方能接收的最大数据量，也可以理解为接收端缓存池的大小) - (LastByteRcvd - LastByteRead)(表示接收方已为接收到的数据，或者还没有接收到的预定的数据留出来的空间，当前空间已经占据了一定的缓存) 发送方在接收到AdvertisedWindow后，要保证LastByteSent-LastByteAcked&lt;=AdvertisedWindow，即已发送且待确认的数据量要小于接收方的Window大小。 EffectiveWindow(窗口内剩余可发送的数据大小) = AdvertisedWindow - (LastByteSent-LastByteAcked)(待确认的数据量)。这样才能保证接收方可以处理后面发送的数据。 ④滑动窗口的基本原理 TCP会话的发送方： 依次分为，已经发送并得到对端回应的，已经发送但还没收到对端回应的，未发送但对端允许发送的，以及未发送且由于达到了Window的大小对端不允许发送的数据。其中中间两部分组成的连续空间被称之为发送窗口。 当收到接收方新的ACK，对于发送窗口中后续字节的确认时，窗口就会进行滑动，滑动原理如上图所示。 示例：对于原滑动窗口，假设原先滑动窗口的边界是从32~51。我们假设已发送但未被确认的序号是32~40，而41~51为未发送但对端允许发送的。此时只有收到对端大于32的序号的ACK，即收到32~40之间的某个ACK序号回执时，我们的滑动窗口才会发生移动。而此时序号大于或等于52的数据，即窗口外的数据，是不能发送的。这里我们假设收到了对端序号为36的ACK回执，则滑动窗口会向右移动四位到36处。进而我们的程序就能发送序号为52~55的数据了。 TCP会话的接收方： 对于TCP的接收方来讲，在某一时刻在其接收缓存内会存在三种状态：已接收并且已发送回执单状态、未接收但是可以接收（即准备接收）的状态、未接受并且不能接收的状态（因为达到了窗口的阈值，因此不能接收）。由于ACK直接由TCP这样回复，默认没有应用延迟，不存在已接收但是未回复ACK的状态。 未接受但准备接收的这一段空间被称为接收窗口。接收窗口的滑动机制和前面发送方的一致。 总结： TCP最基本的传输可靠性来源于确认重传机制，TCP的滑动窗口的可靠性也是建立在确认重传基础上的。发送窗口只有收到接收端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界；接收窗口只有在前面所有的段都确认的情况下，才会移动左边界。当在前面还有字节未接收，但收到后面字节的情况下，窗口是不会移动的，并不对后续字节确认，以此确保对端会对这些数据进行重传。以上便是滑动窗口的基本原理。 滑动窗口的大小可以依据一定的策略动态调整，应用会根据自身处理能力的变化，通过本端TCP接收窗口大小的控制，来实现对发送端的发送窗口进行流量限制。 3. HTTP相关知识1.1 概述 HTTP，即超文本传输协议，是属于应用层的协议。它是一个基于请求与响应模式的无状态的应用层的协议，常基于TCP的连接方式。 HTTP/1.1中给出一种持续连接的机制，Keep-Alive。 、绝大多数的Web开发都是构建在HTTP协议之上的Web应用。 1.2 主要特点 支持客户/服务器模式。HTTP协议工作于客户端——服务端架构之上，浏览器通过HTTP客户端通过URL向HTTP服务端，即Web服务器发送所有请求。Web服务器根据接收到的请求，向客户端发送响应信息。 简单快速。客户端向服务器请求服务时，只需传送请求方法和路径，请求方法常用的有GET、HEAD、POST、PUT等。每种方法决定了客户与服务器联系的类型不同，由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活。HTTP允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。 无连接。无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并受到客户的应答之后，就断开连接。采用这种方式可以节省传输时间，从HTTP/1.1起默认使用了长连接，即服务器需要等待一定时间后，才断开连接，以保证连接特性。虽然目前的一些技术，如keep-alive，使用了长连接优化效率，但这些都是属于HTTP请求之外的。也就是在每个独立的HTTP请求中，你是无法知道当前的HTTP是否处于长连接的状态。你始终都要认为，HTTP请求在结束后，连接就会关闭，这是HTTP的特性。至于下层实现是否在结束请求后关闭连接，都不会改变这个特性。长连接可以理解为下层实现对上层透明。 无状态。HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态，意味着如果后续处理需要前面的信息，则必须被重传。这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时，它的应答较快。HTTP协议目前正处于多个版本共存的情况，包括仍被广泛采用的1.0，主流应用广泛的1.1，还有应用较少但更新较大的2.0。1.1和1.0最明显的区别是引入了Keep-Alive这项长连接技术，2.0虽然更合理更先进，但是因为1.1完全能够满足目前的应用，并且升级上2.0的成本太大所以推广不广泛。 1.3 HTTP的请求响应模型1.3.1 HTTP的请求结构 主要由请求行、请求头部、空行以及数据（即请求正文）这四个部分组成。 请求行中包括三个部分。第一部分为请求方法，如GET、HEAD、POST、PUT等等，第二部分为URL，第三部分为协议版本号，包括HTTP/1.0、HTTP/1.1、HTTP/2.0。之后跟一个回车换行标志。 请求头部由若干个报头组成，每个报头的结构都是名字加冒号再加空格再加值的形式组成。其中名字大小写无关，这些报头用来设置HTTP请求的一些参数，例如Host表示被请求资源的主机和端口号。其他字段例如Content-Type等等。 数据体只在POST请求里面用到，表示要上传的数据，数据体和头部直接存在一个空行（必须的）。即使请求数据为空，也必须有空行。浏览器发送一个空白行来通知服务器它已经结束了该头信息的发送。 发送请求报文后，正常情况下能收到其相应报文。 1.3.2 HTTP的响应结构 服务器接收并处理客户端发过来的请求后，会返回一个HTTP的响应消息，即我们的响应报文。响应报文主要包括三个部分，第一个为状态行，第二个是响应头部，第三个是响应正文。 状态行主要由协议版本、状态码以及状态码描述这三个部分来组成。 响应报头是用来说明客户端要使用的一些附加信息，例如Date用来生成响应的日期和时间，Content-Type就指定了内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码。 1.3.3 总结HTTP协议定义了Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求响应模型，客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和相应数据。 1.3.4 请求/响应步骤 客户端连接到Web服务器。一个HTTP客户端通常是浏览器与Web服务器的HTTP端口，默认端口号是80，建立一个TCP套接字连接。 发送HTTP请求。即通过TCP套接字，客户端向Web服务器发送一个文本的请求报文。 服务器接收到客户端的请求并返回HTTP响应，Web服务器解析该请求，定位请求资源，服务器将资源副本写到TCP套接字，由客户端读取。 释放TCP连接。若我们的连接模式为Close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若模式为Keep-Alive，则该连接会保持一段时间，在该时间内，可以继续接收请求。 客户端浏览器拿到了HTML请求，并进行解析。客户端浏览器首先去解析状态行，查看表明请求是否成功的状态代码，然后解析每一个响应头部，响应头告知以下为若干字节的HTML文档以及文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法，对其进行格式化，并在浏览器窗口中显示。 1.4 在浏览器地址栏输入URL，按下回车之后经历的流程 DNS解析：首先浏览器会依据URL，逐层查询DNS服务器缓存，解析URL中的域名所对应的IP地址。DNS缓存由近到远依次是：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存。从哪个缓存找到对应的ip，则直接返回，不再查询后面的缓存。 TCP连接：找到ip地址之后，会根据该ip地址和对应端口（默认是80端口）和服务器建立TCP连接。（结合三次握手来讲解） 发送HTTP请求：浏览器会发出读取文件的HTTP请求，该请求将发送给服务器（前面HTTP部分提及的内容）。 服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应并把对应的带有HTML文本的HTTP响应报文发送给浏览器。 浏览器解析渲染页面：浏览器收到HTML，并在显示窗口内去渲染页面。 连接结束：浏览器释放TCP连接（该步骤即前面所提到的四次挥手过程）。 其中渲染页面和释放TCP连接可以视为是同时发生的，哪一步在前没有特别的要求。 1.5 HTTP状态码 当程序返回200这个状态码时，证明信息是正常返回的。在工作中我们需要通过状态码来判定大致出现问题的原因。 状态码由三位数来组成，第一个数字定义了响应的类别，主要有五种类型： 常见状态码： 1.6 GET请求和POST请求的区别 HTTP报文层面：GET请求方式将请求信息放在URL后面，请求信息和URL直接以问号?隔开，请求信息的格式为键值对。而POST请求方式则将请求信息放置在报文体中，想获得请求信息必须解析报文，因此安全性较GET方式要高一些。事实上要获得报文体中的请求信息也很容易，因此安全性上两者并没有太多的区别。具体解决传输过程中的安全性问题，还要靠HTTPS。因为GET中的请求信息是放置在URL中的，因此是有长度限制的。因为这样URL本身是没有长度限制的，但是浏览器，如Chrome或者FireFox等会对URL的长度做出限制。POST的请求信息是放置在报文体当中的，因此对数据的长度没有限制。 数据库层面：GET请求方式符合幂等性和安全性，POST不符合。幂等性的定义是对数据库的一次操作和多次操作获得的结果是一致的，则认为符合幂等性。安全性的定义就是对数据库的操作没有改变数据库中的数据，则认为符合安全性。GET请求是做查询操作的，因此不会改变数据库中原有的数据，大致上可以认为是符合安全性和幂等性。POST请求方式是既不幂等、又不安全的。首先POST请求方式会往数据库中提交数据，因此会改变数据库中的数据；其次，POST请求方式每次获得的结果都有可能不一样，因为POST请求是作用在上一级的URL上的，则每一次请求都会添加一份新资源，这也是POST和PUT方式的最大区别。PUT方式是幂等的。 其他层面：GET请求能够被缓存，GET请求会保存在浏览器的浏览记录中，以GET请求的URL能够保存为浏览器书签；而POST方式不具备上述功能。缓存也是GET请求被广泛应用的根本。 在现在网络上，每天产生的请求数目是巨大的，并且其中绝大部分的请求均为只读请求，如果所有这些请求都要交由Web服务器直接处理，这无疑是巨大的资源浪费。从数据库层面知道，GET表达的是一种幂等的、安全的，因此绝大部分GET请求（通常差不多90%）都直接被CDN（内容分发网络）缓存了，这能大大减少Web服务器的负担。而POST是非幂等的，有副作用的操作，所以必须交由Web服务器处理。 1.7 Cookie和Session的区别因为HTTP是无状态的，也就意味着我们每次访问某个有登陆需求的页面时，都要不厌其烦的输入账号密码。现实生活中没有出现这种情况，是因为我们引入了某些机制，让HTTP具备了状态，其中的两个便是Cookie和Session。 1.7.1 Cookie简介 Cookie技术是客户端的解决方案。Cookie就是由服务器发送给客户端的特殊信息，而这些信息以文本文件的形式存放在客户端。客户端每次向服务器发送请求的时候，都会带上这些特殊的信息。具体为，当用户使用浏览器访问一个支持Cookie的网站时，用户会提供包括用户名在内的个人信息，并且提交至服务器。紧接着服务器在向客户端回传响应的超文本的同时，也会发回这些个人信息。当然这些信息并不是存放在HTTP响应体，即Response Body中的，而是存放在HTTP响应头，即Response Header中的。当用户端接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置。 客户端再次向服务器发送请求的时候，都会把响应的Cookie再次发回到服务器中。而这次Cookie信息则存放在HTTP请求头里面了。 有了Cookie这样的技术实现，服务器在接收到来自浏览器的请求之后，就能够通过分析存放于请求头的Cookie，得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常我们可以在很多网站的登录界面中看到“请记住我”这样的选项，如果勾选了它，之后再登录。那么在下一次访问该网站的时候，就不需要进行重复和繁琐的登录动作了。此功能就是通过Cookie来实现的。 1.7.2 Cookie的设置及发送过程 客户端发送一个HTTP请求到服务端。 服务端发送一个HTTP响应到客户端，其中包括了一个Set-Cookie的头部。 客户端再发送一个HTTP请求到服务端，其中包括了Cookie头部。 服务端发送一个HTTP响应到客户端。 1.7.3 Session简介 Session机制是一种服务器端的机制，服务器使用了一种类似散列表的结构来保存信息。 当程序需要为某个客户端的请求创建一个Session的时候，服务器首先检查客户端的请求中是否已包含了一个Session标识（称为Session id）。如果已包含一个Session id，则说明以前已经为此客户端创建了Session，服务器就按照Session id把这个Session检索出来使用，如果检索不到就可能新建一个。如果客户端请求不包含Session id，则为此客户端创建一个Session，并且生成一个与此Session相关的Session id，Session id的值应该是一个既不会重复，又不容易被找到规律以防捏造的字符串。这个Session id将会在本次响应中被回发给客户端进行保存。 1.7.4 Session实现方式主要有两种： 使用Cookie来实现。服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。当客户端发起新的请求时，将在Cookie头中携带此JSESSIONID，这样服务器能够找到客户端对应的Session。 使用URL回写来实现。URL回写是指服务器在发送给浏览器的所有连接中，都携带JSESSIONID的参数，这样客户端点击任何一个连接，都会把JSESSIONID带回服务器。如果直接在浏览器输入服务端资源的URL来请求该资源，那么Session是匹配不到的。Tomcat对Session的实现是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写。如果发现Cookie被禁用，就一直使用URL回写。 1.7.5 Cookie和Session的区别 Cookie数据存放在客户的浏览器上，Session数据存放在服务器上。 Cookie不是很安全，别人可以分析存放在本地的Cookie并执行Cookie欺骗，考虑到安全应当使用Session。 Session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面的开销，应当使用Cookie。 1.8 HTTP和HTTPS的区别1.8.1 HTTPS简介HTTPS，即超文本传输安全协议，其是一种以计算机网络安全通信为目的的传输协议。在HTTP下面，加入了一个SSL层，从而具有了保护交换数据隐私以及完整性，还有提供对网站服务器身份认证的功能。简单来说，HTTPS就是安全版的HTTP。 1.8.2 SSLSSL（Security Sockets Layer，安全套接层） 为网络通信提供安全及数据完整性的一种安全协议 SSL位于TCP与各应用层之间，是操作系统对外提供的API。SSL3.0后更名为TLS SSL采用身份验证和数据加密两种手段来保证网络通信的安全和数据的完整性 HTTPS并不是一个新兴的协议，Google很早就开始启用了，初衷是为了保证数据安全。近两年Google、Baidu、Facebook等互联网巨头，不谋而合的开始大力推行HTTPS。国内外的大型互联网公司也都启用了全站HTTPS，这也是未来互联网发展的趋势。在HTTP中，不管是GET还是POST，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输在互联网上。客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端而不被客户端察觉，这便是所谓的劫持。 1.8.3 加密的方式我们都知道https能够加密信息，以免敏感信息被第三方获取与篡改，所以很多网站或电子邮箱等安全级别较高的服务都会采用https协议，关于加密与解密，首先我们要了解加密方式。 对称加密：加密和解密都使用同一个密钥，效率比之非对称加密要高很多。 非对称加密：加密使用的密钥和解密使用的密钥是不同的，分别称为公钥和私钥。公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。例如区块链技术很多就是用到了非对称加密。 哈希算法：将任意长度的信息转化为固定长度的值，算法不可逆，常见的有MD5算法。 数字签名：签名就是在信息的后面加上一段内容，这些内容是经过哈希后的值，可以证明信息没有被修改过。哈希值一般都会加密后，也就是签名之后，再和信息一起发送。以保证哈希值不被修改。 在实际的执行中发现，仅使用其中的某种加密方式，并不能满足生产要求。要么非对称加密性能过低，要么对称密钥容易泄露。因此HTTPS使用的是证书配合各种加密手段的方式，进行相对安全的组合加密。 1.8.4 HTTPS数据传输流程HTTPS在进行数据传输之前，会与网站服务器和Web浏览器进行一次握手。在握手时，确定双方的加密密码信息，具体过程： Web浏览器将支持的加密算法信息发送给网站服务器。例如本地仅支持AES对称加密、ECC非对称加密之类的。即告诉服务器我仅支持这类加密，使服务器回发时选用这类加密算法。 服务器依据浏览器提供的支持加密的方式，在自己支持的加密方式中，选出一套加密算法和哈希算法，将验证身份的信息以证书的形式发送给Web浏览器。证书里面的信息包含了证书发布的CA机构、证书有效期、公钥、证书所有者以及签名等等。CA机构是具备证书颁发资格的权威机构，就好比全国大学英语四六级考试委员会颁发给自己英语四六级证书一样，是具有权威的。 当浏览器收到证书之后，首先要验证证书的合法性，如果证书受到浏览器信任，则在浏览器地址栏会有标志显示，否则就会显示不受信的标识。当证书受信之后，Web浏览器会随机生成一串密码，并使用证书中的公钥加密。之后就是使用约定好的哈希算法握手消息，并生成随机数对消息进行加密，再将之前生成的信息回发给服务器。 当网站服务器接收到浏览器发送过来的数据后，会使用网站本身的私钥将信息解密确定密码，然后通过密码解密Web浏览器发送过来的握手信息，并验证哈希是否与Web浏览器一致。然后服务器会使用密码加密新的握手信息，发送给浏览器。 客户端浏览器解密并计算经过哈希算法加密的握手消息，如果与服务器发送过来的哈希值一致，则此握手过程结束后，服务器与浏览器会使用之前浏览器生成的随机密码和对称加密算法进行加密，然后交换数据。 1.8.5 HTTP和HTTPS的区别 证书：HTTPS协议需要到CA去申请证书*，一般免费证书较少，因而需要一定的费用（必要的验证费），HTTP不需要。 明文密文：HTTP是超文本传输协议，信息是明文传输的；HTTPS则是具有安全性的SSL加密传输协议，因此它是密文传输的。 端口号：HTTPS使用的是完全不同的连接方式，与HTTP所使用的端口也不同。HTTP默认使用的是80端口，而HTTPS默认使用的是443端口。 安全性：HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，SSL是有状态的。HTTPS=HTTP+加密+认证+完整性保护，因此HTTPS比HTTP协议更安全。 1.8.6 HTTPS真的很安全么当网站传输协议从HTTP转换到HTTPS之后，数据传输也不见得会安全。 由于用户习惯，通常准备访问某个网站时，在浏览器中只会输入一个域名，不会在域名前面加上“http://”或者“https://”，而是由浏览器自动填充。当前所有浏览器默认填充的都是“http://”，一般情况网站管理员会采用301、302跳转的方式，由HTTP跳转到HTTPS。但这个过程中会使用到HTTP，再经过HTTP转发到HTTPS上面，因此很容易发生劫持，受到第三方的攻击。 可以使用HSTS（HTTP Strict Transport Security，即HTTP严格安全传输）优化。由于HSTS目前正在推行中，并未成为主流，面试里很少被问到。 4. Socket相关知识4.1 Socket简介 两个进程如果需要进行通信，最基本的前提是能够唯一的标识一个进程。在本地的进程通信中，我们可以使用PID来唯一标识一个进程。但PID只在本地唯一，网络中的两个进程PID冲突的几率是有的，于是需要另辟蹊径。IP层的IP地址，可以唯一标识一个主机。而TCP协议和端口号可以唯一标识主机的一个进程，这样我们可以用IP地址+协议+端口号来唯一标识网络中的一个进程。能够唯一标识网络中的进程后，它们就可以利用Socket进行通信了。 Socket跟TCP/IP协议没有必然的联系，Socket编程接口在设计的时候就希望能适应其他的网络协议。所以Socket的出现只是使得程序员更方便的使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了一些我们知道的最基本的函数接口，比如Create、Listen、Connect、Accept、Send、Read、Write等等。Socket起源于Unix，而Unix是遵从一切皆文件的哲学。Socket是基于一种从打开，到读和写，再到关闭的模式去实现的。服务器和客户端各自维护一个文件，在建立连接打开后，可以向自己文件写入内容，供对方读取或者读取对方内容。在通信结束时，就会关闭文件。 4.2 Socket通信流程 服务器首先先创建socket。 为socket绑定ip地址和端口号。 服务器的socket就会监听端口号的请求，随时准备接收客户端发来的连接。这时服务器的socket只是listen，并没有打开。此时我们假设客户端创建了socket，然后打开了socket，并根据服务器的ip地址和端口号尝试去连接服务器的socket。 服务器的socket接收到客户端的socket请求，被动打开，开始接收客户端的请求，直到客户端返回连接信息。这时服务器的socket进入到阻塞状态，所谓阻塞是指accept()方法需要一直等待客户端返回连接信息后才返回。同时开始接收下一个客户端的连接请求。 客户端在连接成功之后，就会向服务器发送连接状态信息。 服务器端在接收到客户端的连接信息之后，就会将accept()方法返回，并提示连接成功。 之后客户端就可以向socket中写入信息了。 服务器就能收到并且读取相关的信息。 在发送完数据后，客户端就会关闭socket，紧接着服务端也需要关闭socket。 4.3 Socket相关的面试题题目：编写一个网络程序，有客户端与服务端，客户端向服务端发送一个字符串，服务器收到该字符串后将其打印到命令行上，然后向客户端返回该字符串的长度，最后，客户端输出服务端返回的该字符串长度，分别用TCP和UDP两种方式去实现。 4.3.1 TCP实现①TCPServer 12345678910111213141516import java.net.ServerSocket;import java.net.Socket;public class TCPServer &#123; public static void main(String[] args) throws Exception &#123; //创建socket，并将socket绑定到65000端口 ServerSocket ss = new ServerSocket(65000); //死循环，使得socket一直等待并处理客户端发送过来的请求 while (true) &#123; //监听65000端口，直到客户端返回连接信息后才返回 Socket socket = ss.accept(); //获取客户端的请求信息后，执行相关业务的逻辑 new LengthCalculator(socket).start(); &#125; &#125;&#125; ②TCPClient 123456789101112131415161718192021222324252627import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class TCPClient &#123; public static void main(String[] args) throws Exception &#123; //创建socket，并指定连接的是本机的端口号为65000的服务器socket Socket socket = new Socket("127.0.0.1", 65000); //获取输出流 OutputStream os = socket.getOutputStream(); //获取输入流 InputStream is = socket.getInputStream(); //将要传递给server的字符串参数转换成byte数组，并将数组写入到输出流中 os.write(new String("hello world").getBytes()); int ch = 0; byte[] buff = new byte[1024]; //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取数组的长度 ch = is.read(buff); //将接收流的byte数组转换成字符串，这里是从服务端回发回来的字符串参数的长 String content = new String(buff, 0 , ch); System.out.println(content); //不要忘记关闭输入输出流以及socket is.close(); os.close(); socket.close(); &#125;&#125; ③功能实现LengthCalculator线程类 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class LengthCalculator extends Thread &#123; //以socket为成员变量 private Socket socket; public LengthCalculator() &#123; &#125; public LengthCalculator(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; //获取socket的输入流 OutputStream os = socket.getOutputStream(); //获取socket的输入流 InputStream is = socket.getInputStream(); int ch = 0; byte[] buff = new byte[1024]; //buff主要用来读取输入的内容，存成byte数组，ch主要用来获取读取 ch = is.read(buff); //将接收流的byte数组转换成字符串，这里获取的内容是客户端发送过 String content = new String(buff, 0, ch); System.out.println(content); //往输入流里写入获得的字符串的长度，回发给客户端 os.write(String.valueOf(content.length()).getBytes()); //不要忘记关闭输入输出流以及socket is.close(); os.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ④效果 4.3.2 UDP实现①UDPServer 12345678910111213141516171819202122232425import java.net.DatagramPacket;import java.net.DatagramSocket;public class UDPServer &#123; public static void main(String[] args) throws Exception &#123; //服务端接受客户端发送的数据报 DatagramSocket socket = new DatagramSocket(65001); //监听的端口号 byte[] buff = new byte[100]; //存储从客户端接收到的内容 DatagramPacket packet = new DatagramPacket(buff, buff.length); //接收客户端发送过来的内容，并将内容封装进DatagramPacket对象中 socket.receive(packet); byte[] data = packet.getData(); //从DatagramPacket对象中获取到真正存储的数据 //将数据从二进制转换成字符串形式 String content = new String(data, 0, packet.getLength()); System.out.println(content); //将要发送给客户端的数据转换成二进制 byte[] sendedContent = String.valueOf(content.length()).getBytes(); //服务端给客户端发送数据报 //从DatagramPacket对象中获取到数据的来源地址与端口号 DatagramPacket packetToClient = new DatagramPacket(sendedContent, sendedContent.length, packet.getAddress(), packet.getPort()); socket.send(packetToClient); //发送数据给客户端 &#125;&#125; ②UDPClient 1234567891011121314151617181920212223242526272829303132import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class UDPClient &#123; public static void main(String[] args) throws Exception &#123; // 客户端发数据报给服务端 DatagramSocket socket = new DatagramSocket(); // 要发送给服务端的数据 byte[] buf = "Hello World".getBytes(); // 将IP地址封装成InetAddress对象 InetAddress address = InetAddress.getByName("127.0.0.1"); // 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号 DatagramPacket packet = new DatagramPacket(buf, buf.length, address, 65001); // 发送数据给服务端 socket.send(packet); // 客户端接受服务端发送过来的数据报 byte[] data = new byte[100]; // 创建DatagramPacket对象用来存储服务端发送过来的数据 DatagramPacket receivedPacket = new DatagramPacket(data, data.length); // 将接受到的数据存储到DatagramPacket对象中 socket.receive(receivedPacket); // 将服务器端发送过来的数据取出来并打印到控制台 String content = new String(receivedPacket.getData(), 0, receivedPacket.getLength()); System.out.println(content); &#125;&#125; ③效果 5. 网络知识总结 问题：IP协议相关的IPV4和IPV6的区别以及他们对地址的定义？ （1）报文 IPv6报头占40字节，相对于IPv4报头（变长的24字节）看似长。其实，IPv6报头的结构比IPv4简单， IPv6报头中去掉了了IPv4报头中许多不常用的域，放入了可选项和报头扩展，其可选项有更严格的定义。IPv6报头中有6个域和2个地址空间，相对于IPv4中的10个固定长度的域、2个地址空间和若干个选项的结构来说IPV6更简单。 （2）地址 IPv6协议的地址长度是128位，全部可分配地址数为2的128次方（2^128）个，不再存在地址匮乏问题。同时，IPv6地址表示方式和IPv4也不同：IPv4地址表示为点分十进制格式，32位的地址分成4个8位分组，每个8位以十进制数显式，中间用点号分隔。而IPv6采用的是十六进制格式，既128位地址是以16位为一分组，每个16位分组写成4个十六进制数，中间用冒号分十六进制格式。当然IPv6的地址还有其他简化表示方法，此处不再赘述。 （3）地址配置 有人问：IPV6这么多地址分配起来得多麻烦？其实是多虑了，IPv6协议支持地址自动配置，这是一种即插即用的机制。IPv6节点通过地址自动配置得到IPv6地址和网关地址。IPv6支持无状态地址自动配置和状态地址自动配置两种地址自动配置方式。它会给配置128位的地址带来很大的方便，特别是无状态地址自动配置。至于如何实现，简单一说：“即插即用”是指无需人为干涉，将一个节点插入IPv6网络并在网络中启动，IPv6使用了两种不同的机制来支持即插即用网络连接：启动协议（BOOTstrap Protocol，BOOTP）和动态主机配置协议（DHCP）。 这两种机制允许IP节点从特殊的BOOTP服务器或DHCP服务器获取配置信息。这些协议采用“状态自动配置”（Stateful Autoconfiguration），即服务器必须保持每个节点的状态信息，并管理这些保存的信息。 （4）域名解析 IPv6中的DNS与IPv4的在体系结构上相同，都采用树型结构域名空间。IPv4和IPv6共同拥有统一的域名空间。IPv6可以自动发现提供解析服务的DNS，有两种方式：(1) 无状态的DNS服务器发现；(2) 有状态的DNS服务器发现。有状态的DNS服务器发现方式是通过类似DHCP的服务器把DNS服务器地址、域名和搜索路径等DNS信息告知节点。无状态DNS服务器自动发现有多种方式，有兴趣的朋友建议您找相关资料阅读，比如《IPV6技术白皮书》等。 （5）网上邻居 任何设备单独工作是没意义的。同样，IPv6定义了邻居发现协议NDP，它使用一系列IPv6控制信息报文（ICMPv6）来实现相邻节点（同一链路上的节点）的交互管理，并在一个子网中保持网络层地址和链路层地址之间的映射。 （6）路由技术 IPv6主要使用三种路由协议：RIPv6（路由信息协议）、OSPFv6（开放最短路径优先）和IDRPv2（域间路由协议），以及可能的EIGRP和双层的IS-IS。而IPv4可路由的协议有IP、IPX等，不可路由的主要有DEC，NETBIOS等。针对现在无线网络的强势，移动IPv6协议为用户提供可移动的IP数据服务，让用户可以在世界各地都使用同样的IPv6地址。 （7）安全问题 IP安全（IP Security，IPSec）协议用于保护IP通信的安全。它既可以用于IPv4也可用于IPv6。在IPv6中IPSec是的一个组成部分，而IPv4中只是一个可选扩展协议。它更好的支持了IPv6，使我们有机会在将网络转换到这种新型协议的同时发展端到端安全性。]]></content>
      <categories>
        <category>Java面试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何从无序链表中移除重复项]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08-02-%E5%A6%82%E4%BD%95%E4%BB%8E%E6%97%A0%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[目录 题目描述 分析与解答 方法一：顺序删除 方法二：递归法 1. 题目描述给定一个没有排序的链表，去掉其重复项，并保留原顺序， 如链表1--&gt;3--&gt;1--&gt;5--&gt;5--&gt;7， 去掉重复项后变为1--&gt;3--&gt;5--&gt;7。 2. 分析与解答3. 方法一：顺序删除主要思路：通过双重循环直接在链表上执行删除操作。外层循环用一个指针从第一个结点开始遍历整个链表，然后内层循环用另外一个指针遍历其余结点，将与外层循环遍历到的指针所指结点的数据域相同的结点删除，如下图所示。 假设外层循环从outerCur开始遍历，当内层循环指针innerCur遍历到上图实线所示的位置（outerCur.data==innerCur.data）时，此时需要把innerCur指向的结点删除。具体步骤如下： （1）用tmp记录待删除的结点的地址。 （2）为了能够在删除tmp结点后继续遍历链表中其余的结点，使innerCur指针指向它的后继结点：innerCur=innerCur.next。 （3）从链表中删除tmp结点。 实现代码如下： 12345//结点类public class LNode &#123; int data; //数据域 LNode next; //下一个结点的引用&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 第2题 如何从无序链表中移除重复项 * * 题目描述： * 给定一个没有排序的链表，去掉其重复项，并 保留原顺序。 * 如链表 1--&gt;3--&gt;--1--&gt;5--&gt;5--&gt;7， * 去掉重复项后变为 1--&gt;3--&gt;5--&gt;7。 * * @author aimanyeye * */public class RemoveDupRecursionTest &#123; /* * 方法功能：对带头节点的单链表删除重复结点 * 输入参数：head：链表头结点 */ private static void removeDup(LNode head) &#123; if(head==null||head.next==null) return; LNode outerCur = head.next;//用于外层循环，指向链表第一个结点 LNode innerCur = null; //用于内层循环，用来遍历outerCur后面的结点 LNode innerPre = null; //innerCur的前驱结点 while (outerCur!=null) &#123; innerPre = outerCur; innerCur = outerCur.next; while (innerCur != null) &#123; //找到重复的结点并删除 if(outerCur.data == innerCur.data)&#123; innerPre.next = innerCur.next; &#125;else&#123; innerPre = innerCur; &#125; innerCur = innerCur.next; &#125;//内循环结束 outerCur = outerCur.next; &#125; &#125; public static void main(String[] args) &#123; int i = 1; // 链表头结点 LNode head = new LNode(); head.next = null; LNode tmp = null; LNode cur = head; //构造单链表 for(;i&lt;7;i++) &#123; tmp=new LNode(); if(i%2==0) tmp.data=i+1; else if(i%3==0) tmp.data=i-2; else tmp.data=i; tmp.next=null; cur.next=tmp; cur=tmp; &#125; System.out.println("删除重复结点前："); for(cur=head.next;cur!=null;cur=cur.next) &#123; System.out.print(cur.data+" "); &#125; removeDup(head);//删除重复结点 System.out.println("\n删除重复结点后："); for(cur=head.next;cur!=null;cur=cur.next) &#123; System.out.print(cur.data+" "); &#125; &#125;&#125; 程序的运行结果为： 1234删除重复结点前：1 3 1 5 5 7 删除重复结点后：1 3 5 7 算法性能分析：由于这种方法采用双重循环对链表进行遍历，因此，时间复杂度为O(N^2)。其中，N为链表的长度。在遍历链表的过程中，使用了常量个额外的指针变量来保存当前遍历的结点、前驱结点和被删除的结点，因此，空间复杂度为O(1)。 4. 方法二：递归法主要思路为：对于结点cur，首先递归地删除以cur.next为首的子链表中重复的结点，接着从以cur.next为首的子链表中找出与cur有着相同数据域的结点并删除。实现代码如下：123456789101112131415161718192021222324252627282930313233343536private static LNode removeDupRecursion(LNode head) &#123; if(head==null) return head; LNode pointer = null; LNode cur = head; //对以head.next为首的子链表删除重复的结点 head.next = removeDupRecursion(head.next); pointer = head.next; //找出以head.next为首的子链表中与head结点相同的结点并删除 while(pointer!=null) &#123; if(head.data == pointer.data) &#123; cur.next = pointer.next; pointer = cur.next; &#125;else &#123; pointer=pointer.next; cur=cur.next; &#125; &#125; return head;&#125;/* * 方法功能：对带头节点的单链表删除重复结点 * 输入参数：head：链表头结点 */private static void removeDup(LNode head) &#123; if(head==null) return; head.next = removeDupRecursion(head.next); &#125; 程序的运行结果为： 1234删除重复结点前：1 3 1 5 5 7 删除重复结点后：1 3 5 7 算法性能分析：这种方法与方法一类似，从本质上而言，由于这种方法需要对链表进行双重遍历，因此，时间复杂度为O(N^2)。其中，N为链表的长度。由于递归法会增加许多额外的函数调用，因此，从理论上讲，该方法效率比方法一低。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现链表的逆序]]></title>
    <url>%2F2019%2F08%2F01%2F2019-08-01-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%9A%84%E9%80%86%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[目录 题目描述 分析与解答 方法一：就地逆序 方法二：插入法 1. 题目描述给定一个带有头结点的单链表，请将其逆序。 即如果单链表原来为head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;6--&gt;7， 则逆序后变为head--&gt;7--&gt;6--&gt;5--&gt;4--&gt;3--&gt;2--&gt;1。 2. 分析与解答由于单链表与数组不同，单链表中每个结点的地址都存储在其前驱结点的指针域中，因此，对单链表中任何一个结点的访问只能从链表的头指针开始进行遍历。在对链表的操作过程中，需要特别注意在修改结点指针域的时候，记录下后继结点的地址，否则会丢失后继结点。 3. 方法一：就地逆序主要思路：在遍历链表时，修改当前结点的指针域的指向，让其指向它的前驱结点。为此，需要用一个指针变量来保存前驱结点的地址。此外，为了在调整当前结点指针域的指向后还能找到后继结点，还需要另外一个指针变量来保存后继结点的地址，在所有的结点都被保存好以后就可以直接完成指针的逆序了。除此之外，还需要特别注意对链表首尾结点的特殊处理。具体实现方式如下图所示。 在上图中，假设当前已经遍历到cur结点，由于它所有的前驱结点都已经完成了逆序操作，因此，只需要使cur.next=pre即可完成逆序操作。在此之前，为了能够记录当前结点的后继结点的地址，需要用一个额外的指针next来保存后继结点的信息，通过上图（1）~（4）四步把实线的指针调整为虚线的指针就可以完成当前结点的逆序；当前结点完成逆序后，通过向后移动指针来对后继的结点用同样的方法进行逆序操作。算法实现如下： 12345//结点类public class LNode &#123; int data; //数据域 LNode next; //下一个结点的引用&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 第1题 如何实现链表的逆序 * * 题目描述： * 给定一个带头节点的单链表，将其逆序。 * 即如果单链表原来为 head--&gt;1--&gt;2--&gt;--4--&gt;5--&gt;6--&gt;7， * 则逆序后变为head--&gt;7--&gt;--&gt;6--&gt;5--&gt;4--&gt;3--&gt;2--&gt;1。 * * @author aimanyeye * */public class ReverseTest &#123; /* 就地逆序法 * 方法功能：对单链表进行逆序 * 输入参数：head：链表头结点 */ private static void Reverse(LNode head) &#123; // 判断链表是否为空 if(head==null||head.next==null) return; LNode pre = null; //前驱结点 LNode cur = null; //当前结点 LNode next = null; //后继结点 //将链表首结点变为尾结点 cur = head.next; next = cur.next; cur.next = null; pre = cur; cur = next; //把当前遍历到结点cur指向其前驱结点 while(cur.next!=null) &#123; next = cur.next;//(1) cur.next = pre;//(2) pre = cur;//(3) cur = next;//(4) &#125; //结点最后一个结点指向倒数第二个结点 cur.next = pre; //链表的头结点指向原来链表的尾结点 head.next = cur; &#125; public static void main(String[] args) &#123; // 链表头结点 LNode head = new LNode(); head.next = null; LNode tmp = null; LNode cur = head; //构造单链表 for(int i=1;i&lt;8;i++) &#123; tmp = new LNode(); tmp.data = i; tmp.next = null; cur.next = tmp; cur = tmp; &#125; System.out.println("逆序前："); for(cur=head.next;cur!=null;cur=cur.next)//打印链表 &#123; System.out.print(cur.data+" "); &#125; System.out.println("\n逆序后："); Reverse(head);//对链表进行逆序 for(cur=head.next;cur!=null;cur=cur.next)//打印链表 &#123; System.out.print(cur.data+" "); &#125; &#125; &#125; 程序的运行结果为： 1234逆序前：1 2 3 4 5 6 7 逆序后：7 6 5 4 3 2 1 算法性能分析：以上这种方法只需要对链表进行一次遍历，因此，时间复杂度为O(N)。其中，N为链表的长度。但是需要常数个额外的变量来保存当前结点的前驱结点与后继结点，因此，空间复杂度为O(1)。 4. 方法二：插入法主要思路：从链表的第二个结点开始，把遍历到的结点插入到头节点的后面，直到遍历结束。假定原链表为head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;6--&gt;7，在遍历到 2 时，将其插入到头节点后，链表变为head--&gt;2--&gt;1--&gt;3--&gt;4--&gt;5--&gt;6--&gt;7，同理将后续遍历到的所有结点都插入到头节点head后，就可以实现链表的逆序。1234567891011121314151617181920212223/* 插入法 * 方法功能：对单链表进行逆序 * 输入参数：head：链表头结点*/ private static void Reverse(LNode head) &#123; // 判断链表是否为空 if(head==null||head.next==null) return; LNode cur = null; //当前结点 LNode next = null; //后继结点 cur = head.next.next; //设置链表第一个结点为尾结点 head.next.next = null; //把遍历到结点插入到头结点的后面 while(cur!=null) &#123; next = cur.next; cur.next = head.next;//插入到头结点head后面 head.next = cur; cur = next; &#125;&#125; 程序的运行结果为： 1234逆序前：1 2 3 4 5 6 7 逆序后：7 6 5 4 3 2 1 算法性能分析：以上这种方法也只需要对链表进行一次遍历，因此，时间复杂度为O(N)。其中，N为链表的长度。与方法一相比，这种方法不需要保存前驱结点的地址。]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2019%2F06%2F20%2F2019-06-20-SSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[目录 环境准备 整合步骤 1. 环境准备1.1 创建数据库和表结构123456create database ssm;create table account( id int primary key auto_increment, name varchar(100), money double(7,2),); 1.2 创建Maven工程创建父工程： 12345创建子模块： ssm_domain jar ssm_dao jar ssm_service jar ssm_web war 1.3 导入坐标并建立依赖注意 MyBatis 和 和 Spring 的版本对应关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;ssm&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;modules&gt; &lt;module&gt;ssm_domain&lt;/module&gt; &lt;module&gt;ssm_dao&lt;/module&gt; &lt;module&gt;ssm_service&lt;/module&gt; &lt;module&gt;ssm_web&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 1.4 编写实体类12345678910111213141516171819202122232425262728293031323334/*** 账户的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", name=" + name + ", money=" + money + "]"; &#125;&#125; 1.5 编写业务层接口123456789101112131415161718/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户 * @param account */ void saveAccount(Account account); /** * 查询所有账户 * @return */ List&lt;Account&gt; findAllAccount();&#125; 1.6 编写持久层接口123456789101112131415161718/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存 * @param account */ void save(Account account); /** * 查询所有 * @return */ List&lt;Account&gt; findAll();&#125; 2. 整合步骤2.1 保证Spring框架在web工程中独立运行2.1.1 第一步:编写Spring配置文件并导入约束123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt; &lt;!--制定扫包规则，不扫描@Controller 注解的 JAVA 类，其他的还是要扫描 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 2.1.2 第二步：使用注解配置业务层和持久层123456789101112131415161718/*** 账户的业务层实现类*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; @Override public void saveAccount(Account account) &#123; accountDao.saveAccount &#125;&#125; 持久层实现类代码：此时不要做任何操作，就输出一句话。目的是测试 spring框架搭建的结果。 123456789101112131415/*** 账户的持久层实现类*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Override public List&lt;Account&gt; findAllAccount() &#123; System.out.println("查询了所有账户"); return null; &#125; @Override public void saveAccount(Account account) &#123; System.out.println("保存了账户"); &#125;&#125; 2.1.3 第三步：测试Spring能否独立运行12345678910111213/*** 测试 spring 环境搭建是否成功* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Test01Spring &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.findAllAccount(); &#125;&#125; 运行结果： 2.2 保证 SpringMVC 在 在 web 工程中独立运行2.2.1 第一步：在web.xml中配置核心控制器（DispatcherServlet）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns="http://java.sun.com/xml/ns/javaee"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"version="2.5"&gt;&lt;display-name&gt;ssm_web&lt;/display-name&gt; &lt;!-- 配置 spring mvc 的核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvcDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取 springmvc 的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。取值只能是非 0 正整数，表示启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvcDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置 springMVC 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 过滤所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 2.2.2 第 二 步：编写 SpringMVC的配置文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置创建 spring 容器要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt; &lt;!-- 制定扫包规则 ,只扫描使用@Controller 注解的 JAVA 类 --&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 2.2.3 第三写步：编写 Controller 和 和 jsp页面jsp代码： 12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;主页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="account/findAllAccount"&gt;访问查询账户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 控制器代码： 123456789101112131415/*** 账户的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("accountController")@RequestMapping("/account")public class AccountController &#123; @RequestMapping("/findAllAccount") public String findAllAccount() &#123; System.out.println("执行了查询账户"); return "success"; &#125;&#125; 运行结果： 2.3 整合Spring和SpringMVC2.3.1 第一步：配置监听器实现启动服务创建容器123456789101112&lt;!-- 配置 spring 提供的监听器，用于启动服务时加载容器 。该间监听器只能加载 WEB-INF 目录中名称为 applicationContext.xml 的配置文件 --&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 手动指定 spring 配置文件位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 2.4 保证 MyBatis 框架在 web 工程中独立运行2.4.1 第一步：编写 AccountDao 映射配置文件注意： 我们使理 用代理 dao 的方式来操作持久层，所以此处 Dao 的实现类就是多余的了。 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 查询所有账户 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.Account"&gt; select * from account &lt;/select&gt; &lt;!-- 新增账户 --&gt; &lt;insert id="save" parameterType="com.itheima.domain.Account"&gt; insert into account(name,money) values(#&#123;name&#125;,#&#123;money&#125;); &lt;/insert&gt;&lt;/mapper&gt; 2.4.2 第二步：编写SqlMapConfig 配置文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="pooled"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/itheima/dao/AccountDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; properties 文件中的内容： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=1234 2.4.3 第三步：测试运行结果测试类代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 测试 MyBatis 独立使用* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Test02MyBatis &#123; /** * 测试保存 * @param args * @throws Exception */ @Test public void testSave() throws Exception &#123; Account account = new Account(); account.setName("test"); account.setMoney(5000f); InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session= factory.openSession(); IAccountDao aDao = session.getMapper(IAccountDao.class); aDao.save(account); session.commit(); session.close(); in.close(); &#125; /** * 测试查询 * @param args * @throws Exception */ @Test public void testFindAll() throws Exception&#123; InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session= factory.openSession(); IAccountDao aDao = session.getMapper(IAccountDao.class); List&lt;Account&gt; list = aDao.findAll(); System.out.println(list); session.close(); in.close(); &#125;&#125; 2.5 整合Spring和MyBatis整合思路：把 mybatis 配置文件（SqlMapConfig.xml）中内容配置到 spring 配置文件中同时，把 mybatis 配置文件的内容清掉。 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 注意：由于我们使用的是代理 Dao的模式，Dao具体实现类由 MyBatis 使用代理方式创建，所以此时 mybatis配置文件不能删。当我们整合 spring 和 mybatis 时，mybatis 创建的 Mapper.xml 文件名必须和 Dao 接口 文件名一致。 2.5.1 第一步：Spring 接管 MyBatis 的 的 Session 工厂123456789101112131415161718&lt;!-- 加载配置文件 --&gt;&lt;context:property-placeholder location="classpath:jdbcConfig.properties" /&gt;&lt;!-- 配置 MyBatis 的 Session 工厂 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载 mybatis 的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml" /&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 2.5.2 第二步：配置自动扫描所有 Mapper 接口和文件1234&lt;!-- 配置 Mapper 扫描器 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.itheima.dao"/&gt;&lt;/bean&gt; 2.5.3 第三步：配置 spring 的事务1234567891011121314151617181920&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置 aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))" id="pt1"/&gt; &lt;!-- 建立通知和切入点表达式的关系 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt;&lt;/aop:config&gt; 2.5.4 第三步：测试整合结果123456789101112131415161718192021222324252627/*** 测试 spring 整合 mybatis* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:applicationContext.xml"&#125;)public class Test03SpringMabatis &#123; @Autowired private IAccountService accountService; @Test public void testFindAll() &#123; List list = accountService.findAllAccount(); System.out.println(list); &#125; @Test public void testSave() &#123; Account account = new Account(); account.setName("测试账号"); account.setMoney(1234f); accountService.saveAccount(account); &#125;&#125; 2.6 测试SSM整合结果2.6.1 编写测试jsp请求发起页面： 123456789101112131415161718&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="account/findAllAccount"&gt;访问查询账户&lt;/a&gt;&lt;hr/&gt;&lt;form action="account/saveAccount" method="post"&gt; 账户名称：&lt;input type="text" name="name"/&gt;&lt;br/&gt; 账户金额：&lt;input type="text" name="money"&gt;&lt;br/&gt;&lt;input type="submit" value=" 保存 "/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 响应结果页面： 1234567891011121314151617181920212223242526&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;账户的列表页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" width="300px"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;账户名称&lt;/th&gt; &lt;th&gt;账户金额&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;accounts&#125;" var="account" varStatus="vs"&gt; &lt;tr&gt; &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;account.money &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2.6.2 修改控制器中的方法12345678910111213141516171819202122232425262728293031323334353637/*** 账户的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("accountController")@RequestMapping("/account")public class AccountController &#123; @Autowired private IAccountService accountService; /** * 查询所有账户 * @return */ @RequestMapping("/findAllAccount") public ModelAndView findAllAccount() &#123; List&lt;Account&gt; accounts = accountService.findAllAccount(); ModelAndView mv = new ModelAndView(); mv.addObject("accounts", accounts); mv.setViewName("accountlist"); return mv; &#125; /** * 保存账户 * @param account * @return */ @RequestMapping("/saveAccount") public String saveAccount(Account account) &#123; accountService.saveAccount(account); return "redirect:findAllAccount"; &#125;&#125; 2.6.3 测试运行结果]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的拦截器]]></title>
    <url>%2F2019%2F06%2F19%2F2019-06-19-SpringMVC%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目录 拦截器的作用 自定义拦截器的步骤 拦截器的细节 正常流程测试 中断流程测试 拦截器的简单案例（验证用户是否登录） 1. 拦截器的作用Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 谈到拦截器，还要向大家提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 说到这里，可能大家脑海中有了一个疑问，这不是我们之前学的过滤器吗？是的它和过滤器是有几分相似，但是也有区别，接下来我们就来说说他们的区别： 1234过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 它也是 AOP 思想的具体应用。我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。 2. 自定义拦截器的步骤2.1 第一步：编写一个普通类实现 HandlerInterceptor 接口123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("preHandle 拦截器拦截了"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler,ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion 方法执行了"); &#125;&#125; 2.2 第二步：配置拦截器12345678&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 2.3 测试运行结果: 3. 拦截器的细节3.1 拦截器的放行放行的含义是指，如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个，则执行控制器中的方法。 3.2 拦截器中方法的说明12345678910111213141516171819202122232425262728293031323334353637383940public interface HandlerInterceptor &#123; /** * 如何调用： * 按拦截器定义顺序调用 * 何时调用： * 只要配置了都会调用 * 有什么用： * 如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去 * 进行处理，则返回 true。 * 如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。 */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * 如何调用： * 按拦截器定义逆序调用 * 何时调用： * 在拦截器链内所有拦截器返成功调用 * 有什么用： * 在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用， * 在该方法中对用户请求 request 进行处理。 */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable ModelAndView modelAndView) throws Exception &#123; &#125; /** * 如何调用： * 按拦截器定义逆序调用 * 何时调用： * 只有 preHandle 返回 true 才调用 * 有什么用： * 在 DispatcherServlet 完全处理完请求后被调用， * 可以在该方法中进行一些资源清理的操作。 */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable Exception ex) throws Exception &#123; &#125;&#125; 思考：如果有多个拦截器，这时拦截器 1 的 preHandle 方法返回 true，但是拦截器 2 的 preHandle 方法返回 false，而此时拦截器 1 的 afterCompletion 方法是否执行？ 3.3 拦截器的作用路径作用路径可以通过在配置文件中配置。 123456789&lt;!-- 配置拦截器的作用范围 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;mvc:exclude-mapping path=""/&gt;&lt;!-- 用于指定排除的 url--&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 3.4 多个拦截器的执行顺序多个拦截器是按照配置的顺序决定的。 4. 正常流程测试4.1 配置文件：12345678910111213&lt;!-- 配置拦截器的作用范围 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean id="handlerInterceptorDemo2" class="com.itheima.web.interceptor.HandlerInterceptorDemo2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 4.2 拦截器1的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 1：preHandle 拦截器拦截了"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 1：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 1：afterCompletion 方法执行了"); &#125;&#125; 4.3 拦截器2的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo2 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 2：preHandle 拦截器拦截了"); return true;&#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 2：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 2：afterCompletion 方法执行了"); &#125;&#125; 4.4 运行结果： 5. 中断流程测试5.1 配置文件：12345678910111213&lt;!-- 配置拦截器的作用范围 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean id="handlerInterceptorDemo2" class="com.itheima.web.interceptor.HandlerInterceptorDemo2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 5.2 拦截器1的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 1：preHandle 拦截器拦截了"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 1：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 1：afterCompletion 方法执行了"); &#125;&#125; 5.3 拦截器2的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo2 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 2：preHandle 拦截器拦截了"); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 2：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 2：afterCompletion 方法执行了"); &#125;&#125; 5.4 运行结果： 6. 拦截器的简单案例（验证用户是否登录）6.1 实现思路123456781、有一个登录页面，需要写一个 controller 访问页面2、登录页面有一提交表单的动作。需要在 controller 中处理。 2.1、判断用户名密码是否正确 2.2、如果正确 向 session 中写入用户信息 2.3、返回登录成功。3、拦截用户请求，判断用户是否登录 3.1、如果用户已经登录。放行 3.2、如果用户未登录，跳转到登录页面 6.2 控制器代码123456789101112131415161718192021//登陆页面@RequestMapping("/login")public String login(Model model)throws Exception&#123; return "login";&#125;//登陆提交//userid：用户账号，pwd：密码@RequestMapping("/loginsubmit")public String loginsubmit(HttpSession session,String userid,String pwd)throwsException&#123; //向 session 记录用户身份信息 session.setAttribute("activeUser", userid); return "redirect:/main.jsp";&#125;//退出@RequestMapping("/logout")public String logout(HttpSession session)throws Exception&#123; //session 过期 session.invalidate(); return "redirect:index.jsp";&#125; 6.3 拦截器代码123456789101112131415161718192021public class LoginInterceptor implements HandlerInterceptor&#123; @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //如果是登录页面则放行 if(request.getRequestURI().indexOf("login.action")&gt;=0)&#123; return true; &#125; HttpSession session = request.getSession(); //如果用户已登录也放行 if(session.getAttribute("user")!=null)&#123; return true; &#125; //用户没有登录挑战到登录页面 request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request,response); return false; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的异常处理]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-18-SpringMVC%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[目录 异常处理的思路 实现步骤 1. 异常处理的思路系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端控制器交由异常处理器进行异常处理，如下图： 2. 实现步骤2.1 编写异常类和错误页面123456789101112131415161718/*** 自定义异常* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class CustomException extends Exception &#123; private String message; public CustomException(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125;&#125; jsp页面： 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;执行失败&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 执行失败！ $&#123;message &#125; &lt;/body&gt;&lt;/html&gt; 2.2 自定义异常处理器123456789101112131415161718192021222324252627/*** 自定义异常处理器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class CustomExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ex.printStackTrace(); CustomException customException = null; //如果抛出的是系统自定义异常则直接转换 if(ex instanceof CustomException)&#123; customException = (CustomException)ex; &#125;else&#123; //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。 customException = new CustomException("系统错误，请与系统管理 员联系！"); &#125; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("message", customException.getMessage()); modelAndView.setViewName("error"); return modelAndView; &#125;&#125; 2.3 配置异常处理器123&lt;!-- 配置自定义异常处理器 --&gt;&lt;bean id="handlerExceptionResolver" class="com.itheima.exception.CustomExceptionResolver"/&gt; 2.4 运行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC实现文件上传]]></title>
    <url>%2F2019%2F06%2F13%2F2019-06-13-SpringMVC%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[目录 文件上传的回顾 SpringMVC传统方式的文件上传 SpringMVC跨服务器方式的文件上传 1. 文件上传的回顾1.1 文件上传的必要前提12345A form 表单的 enctype 取值必须是：multipart/form-data (默认值是:application/x-www-form-urlencoded) enctype:是表单请求正文的类型B method 属性取值必须是 PostC 提供一个文件选择域&lt;input type=”file” /&gt; 1.2 文件上传的原理分析当 form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。 当enctype=”application/x-www-form-urlencoded”时，form 表单的正文内容是：key=value&amp;key=value&amp;key=value 当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成： 每一部分都是 MIME 类型描述的正文 123456789-----------------------------7de1a433602ac 分界符Content-Disposition: form-data; name=&quot;userName&quot; 协议头aaa 协议的正文-----------------------------7de1a433602acContent-Disposition: form-data; name=&quot;file&quot;;filename=&quot;C:\Users\zhy\Desktop\fileupload_demofile\b.txt&quot;Content-Type: text/plain 协议的类型（MIME 类型）bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb-----------------------------7de1a433602ac-- 1.3 借助第三方组件实现文件上传使用 Commons-fileupload 组件实现文件上传，需要导入该组件相应的支撑 jar 包：Commons-fileupload 和commons-io。commons-io 不属于文件上传组件的开发 jar 文件，但Commons-fileupload 组件从 1.1 版本开始，它工作时需要 commons-io 包的支持。 2. SpringMVC传统方式的文件上传2.1 说明传统方式的文件上传，指的是我们上传的文件和访问的应用存在于同一台服务器上。并且上传完成之后，浏览器可能跳转。 2.2 实现步骤2.2.1 第一步：拷贝文件上传的jar包到工程的lib目录 2.2.2 第二步：编写jsp页面12345&lt;form action="/fileUpload" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"/&gt;&lt;br/&gt; 图片：&lt;input type="file" name="uploadFile"/&gt;&lt;br/&gt; &lt;input type="submit" value=" 上传 "/&gt;&lt;/form&gt; 2.2.3 第三步：编写控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 文件上传的的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("fileUploadController")public class FileUploadController &#123; /** * 文件上传 */ @RequestMapping("/fileUpload") public String testResponseJson(String picname,MultipartFile uploadFile,HttpServletRequest request) throws Exception&#123; //定义文件名 String fileName = ""; //1.获取原始文件名 String uploadFileName = uploadFile.getOriginalFilename(); //2.截取文件扩展名 String extendName = uploadFileName.substring(uploadFileName.lastIndexOf(".")+1, uploadFileName.length()); //3.把文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace("-", "").toUpperCase(); //4.判断是否输入了文件名 if(!StringUtils.isEmpty(picname)) &#123; fileName = uuid+"_"+picname+"."+extendName; &#125;else &#123; fileName = uuid+"_"+uploadFileName; &#125; System.out.println(fileName); //2.获取文件路径 ServletContext context = request.getServletContext(); String basePath = context.getRealPath("/uploads"); //3.解决同一文件夹中文件过多问题 String datePath = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); //4.判断路径是否存在 File file = new File(basePath+"/"+datePath); if(!file.exists()) &#123; file.mkdirs(); &#125; //5.使用 MulitpartFile 接口中方法，把上传的文件写到指定位置 uploadFile.transferTo(new File(file,fileName)); return "success"; &#125;&#125; 2.2.4 第四步：配置文件解析器12345678&lt;!-- 配置文件上传解析器 --&gt;&lt;bean id="multipartResolver" &lt;!-- id 的值是固定的--&gt; class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为 5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 注意：器 文件上传的解析器 id 是固定的，不能起别的名称，否则无法实现请求参数的绑定。（不光是文件，其他字段也将无法绑定） 3. SpringMVC跨服务器方式的文件上传3.1 分服务器的目的在实际开发中，我们会有很多处理不同功能的服务器。例如：应用服务器：负责部署我们的应用数据库服务器：运行我们的数据库缓存和消息服务器：负责处理大并发访问的缓存和消息文件服务器：负责存储用户上传文件的服务器。分服务器处理的目的是让服务器各司其职，从而提高我们项目 的运行效率。 3.2 准备两个tomcat服务器，并创建一个用于存放图片的web工程 在文件服务器的 tomcat 配置中加入，允许读写操作。文件位置： 加入内容： 加入此行的含义是：接收文件的目标服务器可以支持写入操作。 3.3 拷贝jar包在我们负责处理文件上传的项目中拷贝文件上传的必备 jar 包 3.4 编写控制器实现上传图片1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 响应 json 数据的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("fileUploadController2")public class FileUploadController2 &#123; public static final String FILESERVERURL ="http://localhost:9090/day06_spring_image/uploads/"; /** * 文件上传，保存文件到不同服务器 */ @RequestMapping("/fileUpload2") public String testResponseJson(String picname,MultipartFile uploadFile) throws Exception&#123; //定义文件名 String fileName = ""; //1.获取原始文件名 String uploadFileName = uploadFile.getOriginalFilename(); //2.截取文件扩展名 String extendName = uploadFileName.substring(uploadFileName.lastIndexOf(".")+1, uploadFileName.length()); //3.把文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace("-", "").toUpperCase(); //4.判断是否输入了文件名 if(!StringUtils.isEmpty(picname)) &#123; fileName = uuid+"_"+picname+"."+extendName; &#125;else &#123; fileName = uuid+"_"+uploadFileName; &#125; System.out.println(fileName); //5.创建 sun 公司提供的 jersey 包中的 Client 对象 Client client = Client.create(); //6.指定上传文件的地址，该地址是 web 路径 WebResource resource = client.resource(FILESERVERURL+fileName); //7.实现上传 String result = resource.put(String.class,uploadFile.getBytes()); System.out.println(result); return "success"; &#125;&#125; 3.5 编写jsp页面12345&lt;form action="fileUpload2" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"/&gt;&lt;br/&gt; 图片：&lt;input type="file" name="uploadFile"/&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt;&lt;/form&gt; 3.6 配置解析器12345678&lt;!-- 配置文件上传解析器 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为 5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven高级]]></title>
    <url>%2F2019%2F06%2F11%2F2019-06-11-Maven%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[目录 回顾 maven构建SSM工程 分模块构建工程 maven私服 把第三方jar包放入本地仓库或私服 1. 回顾1.1 Maven的好处1234节省磁盘空间可以一键构建可以跨平台应用在大型项目时可以提高开发效率 1.2 安装配置maven1注意：3.3+版本需要 jdkj.7+以上的支持 1.3 三种仓库123本地仓库远程仓库（私服）中央仓库 1.4 常见的命令123456CompileTestPackageInstallDeployClean 1.5 坐标的书写规范123groupId 公司或组织域名的倒序artifactId 项目名或模块名version 版本号 1.6 如何添加坐标121、在本地仓库中搜索2、互联网上搜，推荐网址 http://www.mvnrepository.com/ 1.7 依赖范围1234CompileTestRuntimeProvided 2. maven构建SSM工程2.1 需求实现 SSM 工程构建，规范依赖管理。场景：根据 id展示商品信息 2.2 准备数据库导入以下语句 1234567891011121314151617181920212223SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `items`-- ----------------------------DROP TABLE IF EXISTS `items`;CREATE TABLE `items` ( `id` int(10) NOT NULL auto_increment, `name` varchar(20) default NULL, `price` float(10,0) default NULL, `pic` varchar(40) default NULL, `createtime` datetime default NULL, `detail` varchar(200) default NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;-- ------------------------------ Records of items-- ----------------------------INSERT INTO `items` VALUES (&apos;1&apos;, &apos;传智播客&apos;, &apos;1000&apos;, null, &apos;2018-03-13 09:29:30&apos;, &apos;带我走上人生巅峰&apos;);INSERT INTO `items` VALUES (&apos;2&apos;, &apos;黑马310&apos;, null, null, &apos;2018-03-28 10:05:52&apos;, &apos;插入测试&apos;);INSERT INTO `items` VALUES (&apos;3&apos;, &apos;黑马307&apos;, &apos;199&apos;, null, &apos;2018-03-07 10:08:04&apos;, &apos;插入测试&apos;);INSERT INTO `items` VALUES (&apos;7&apos;, &apos;插入测试&apos;, null, null, null, null);INSERT INTO `items` VALUES (&apos;8&apos;, &apos;插入测试&apos;, null, null, null, null); 2.3 创建一个 maven 工程1.新建一个 ssm_maven 项目,使用下图选中的骨架 2.填写坐标 3.查看是否使用的自己的私服 4.在 main 目录下新建 java 和 resources文件夹 5.把 java 和 resources文件夹转成source root 6.修改编译版本，在 pom.xml 文件中添加 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;!-- 设置编译版本为 1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version &gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.4 知识点准备2.4.1 什么是依赖传递先添加 springmvc的核心依赖的坐标 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 会发现出现除了 spring-webmvc 以外的其他 jar。因为我们的项目依赖 spring-webmv.jar，而spring-webmv.jar 会依赖spring-beans.jar 等等，所以 spring-beans.jar 这些 jar 包也出现在了我们的 maven 工程中，这种现象我们称为依赖传递。从下图中可看到他们的关系：（请注意spring-beans 的版本） 2.4.2 依赖冲突的解决接着添加一个依赖 我们会发现这两个 jar 包同时都依赖了 spring-beans 但是spring-webmvc 依赖 spirng-beans-4.2.4，spring-context 依赖 spring-beans-5.0.2，但是发现spirng-beans-4.2.4 加入到工程中 而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。解决依赖冲突有以下原则： 2.4.3 依赖调解原则maven 自动按照下边的原则调解： 1.第一声明者优先原则 在 pom 文件定义依赖，先声明的依赖为准。 1234测试：如果将上边 spring-webmvc 和 spring-context 顺序颠倒，系统将导入 spring-beans-5.0.2。分析：由于 spring-webmvc 在前边以 spring-webmvc 依赖的 spring-beans-5.0.2 为准，所以最终spring-beans-5.0.2 添加到了工程中。 2.路径近者优先原则 例如：还是上述情况，spring-contex 和 spring-webmvc 都会传递过来 spirng-beans，那如果直接把 spring-beans 的依赖直接写到 pom 文件中，那么项目就不会再使用其他依赖传递来的 spring-beans，因为自己直接在 pom 中定义 spring-beans要比其他依赖传递过来的路径要近。 在本工程中的 pom 中加入 spirng-beans-5.0.2 的依赖，根据路径近者优先原则，系统将导入spirng-beans-5.0.2： 2.4.4 排除依赖上边的问题也可以通过排除依赖方法辅助依赖调解，如下：比如在依赖 spring-webmvc 的设置中添加排除依赖，排除 spring-beans，下边的配置表示：依赖 spring-webmvc，但排除 spring-webmvc 所依赖的 spring-beans。 2.4.5 锁定版本面对众多的依赖，有一种方法不用考虑依赖路径、声明优化等因素可以采用直接锁定版本的方法确定依赖构件的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中，此方法在企业开发中常用。 如下的配置是锁定了 spring-beans 和 spring-context 的版本： 还可以把版本号提取出来，使用标签设置成变量。 注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加&lt;dependencies&gt;&lt;/dependencies&gt;标签，如下： 上边添加的依赖并没有指定版本，原因是已在&lt;dependencyManagement&gt;中锁定了版本，所以在&lt;dependency&gt;下不需要再指定版本。 2.5 定义pom.xmlmaven 工程首先要识别依赖，web 工程实现 SSM 整合，需要依赖 spring-webmvc5.0.2、spring5.0.2、mybatis3.4.5等，在 pom.xml 添加工程如下依赖： （在实际企业开发中会有架构师专门来编写 pom.xml） 分两步： （1）锁定依赖版本 （2）添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.ssm_maven&lt;/groupId&gt; &lt;artifactId&gt;ssm_maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;springmvc.version&gt;5.0.2.RELEASE&lt;/springmvc.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;!--锁定依赖版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--添加依赖--&gt; &lt;dependencies&gt; &lt;!-- Mybatis 和 mybatis 与 spring 的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC 核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- junit 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 设置编译版本为 1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version &gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.6 Dao层在 src/main/java中定义 dao接口，实现根据 id 查询商品信息： 2.6.1 pojo模型类在 src/main/java创建模型类 12345678910public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; ………&#125; 2.6.2 dao层代码 2.6.3 配置文件注意配置文件的位置 内容如下 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="cn.itcast.ssm.dao.ItemsMapper" &gt; &lt;select id="findById" parameterType="int" resultType="items"&gt; select * from items where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在 src/main/resources 创建applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!-- 驱动 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- url --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/maven" /&gt; &lt;!-- 用户名 --&gt; &lt;property name="username" value="root" /&gt; &lt;!-- 密码 --&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;!-- mapper 配置 --&gt; &lt;!-- 让 spring 管理 sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="typeAliasesPackage" value="cn.itcast.ssm.pojo"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- mapper 扫描器 ：用来产生代理对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.itcast.ssm.dao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在 src/main/resources 配置 log4j.properties 123456789101112### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to&apos;debug&apos; ####在开发阶段日志级别使用 debuglog4j.rootLogger=debug, stdout### 在日志中输出 sql 的输入参数 ###log4j.logger.org.hibernate.type=TRACE 2.6.4 单元测试在 src/test/java 创建单元测试类 12345678910111213public class ItemsMapperTest &#123; @Test public void testFindItemsById() &#123; //获取 spring 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); //获取 Mapper ItemsMapper itemsMapper = applicationContext.getBean(ItemsMapper.class); //调用 Mapper 方法 Items items = itemsMapper.findById(1); System.out.println(items); &#125;&#125; 2.7 Service层2.7.1 代码1234567891011@Service@Transactionalpublic class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsMapper itemsMapper; @Override public Items findById(int itemId) &#123; return itemsMapper.findById(itemId); &#125;&#125; 2.7.2 配置文件在 applicationContext.xml中配置 service 1&lt;context:component-scan base-package="cn.itcast.ssm.service"/&gt; 2.8 Web层2.8.1 代码12345678910111213@Controller@RequestMapping("/items/")public class ItemsController &#123; @Autowired private ItemsService itemsService ; // 展示商品信息页面 @RequestMapping("/showItem") public String showItem(int id,Model model)&#123; Items items = itemsService.findById(id); model.addAttribute("item", items); return "viewItem"; &#125;&#125; 2.8.2 配置文件springmvc.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd"&gt; &lt;context:component-scan base-package="cn.itcast.ssm.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器的前缀和后缀 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 加载 spring容器，配置 springmvc前端控制器 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns="http://java.sun.com/xml/ns/javaee"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID"version="2.5"&gt; &lt;!-- 前端控制器 加载springmvc容器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 监听器 加载 spring 容器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 2.9 jsp/WEB-INF/jsp/viewItem.jsp 如下： 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;商品信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;table width="100%" border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt; $&#123;item.name &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt; $&#123;item.price &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;生成日期&lt;/td&gt; &lt;td&gt; &lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品简介&lt;/td&gt; &lt;td&gt;$&#123;item.detail&#125; &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.10 运行与调试添加 tomcat7插件，双击右侧tomcat7 运行 运行结果如下： 3. 分模块构建工程基于上边的三个工程分析继承：创建一个 parent 工程将所需的依赖都配置在 pom 中聚合：聚合多个模块运行。 3.1 需求1234将 SSM 工程拆分为多个模块开发： ssm_dao ssm_service ssm_web 理解继承和聚合 通常继承和聚合同时使用。 何为继承？ 继承是为了消除重复，如果将 dao、service、web 分开创建独立的工程则每个工程的 pom.xml文件中的内容存在重复，比如：设置编译版本、锁定 spring的版本的等，可以将这些重复的配置提取出来在父工程的 pom.xml 中定义。 何为聚合？ 项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如：dao、service、web 三个工程最终会打一个独立的war 运行。 3.2 案例实现3.2.1 maven-parent父模块3.2.1.1 创建父工程1.选择骨架创建父工程 2.填写坐标 3.确认使用的是本地仓库 4.注意代码所在的路径（默认） 5.设置项目的打包方式 3.2.1.2 定义 pom.xml在父工程的 pom.xml 中抽取一些重复的配置的，比如：锁定 jar 包的版本、设置编译版本等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;springmvc.version&gt;5.0.4.RELEASE&lt;/springmvc.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.2.1.3 将父工程发布至仓库父工程创建完成执行 install 将父工程发布到仓库方便子工程继承： 3.2.2 ssm_dao 子模块3.2.2.1 创建dao子模块1.在父工程上右击创建 maven 模块： 2.选择“跳过骨架选择”： 3.填写模块名称 4.下一步，确定项目的目录 5.打包方式是 jar 3.2.2.2 定义 pom.xml只添加到层的 pom，mybatis 和 spring 的整合相关依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;dependencies&gt; &lt;!-- Mybatis 和mybatis 与 spring 的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.2.3 dao代码把文件夹转成 sources root 将 ssm_maven 工程中的 dao接口、映射文件及 pojo 类拷贝到 src/main/java 中： 3.2.2.4 配置文件将 applicationContext.xml拆分出一个applicationContext-dao.xml，此文件中只配置 dao 相关 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!-- 驱动 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- url --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/maven" /&gt; &lt;!-- 用户名 --&gt; &lt;property name="username" value="root" /&gt; &lt;!-- 密码 --&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;!-- mapper 配置 --&gt; &lt;!-- 让 spring 管理 sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="typeAliasesPackage" value="cn.itcast.ssm.pojo"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- mapper 扫描器 ：用来产生代理对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.itcast.ssm.dao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.2.2.5 单元测试1.首先在 dao 模块的 pom.xml添加 junit 的依赖，添加时 Scope 选择 test 2.编写 junit 测试代码 12345678910111213public class ItemsMapperTest &#123; @Test public void testFindItemsById() &#123; //获取 spring 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext-dao.xml"); //获取 Mapper ItemsMapper itemsMapper = applicationContext.getBean(ItemsMapper.class); //调用 Mapper 方法 Items items = itemsMapper.findById(1); System.out.println(items); &#125;&#125; 3.2.2.6 把 dao 模块 install 到本地仓库调过测试，install 到本地仓库 3.2.3 ssm_service 子模块3.2.3.1 创建 service 子模块方法同 ssm_dao 模块创建方法，模块名称为 ssm_service。 3.2.3.2 定义 pom.xmlssm_service 模块的 pom.xml 文件中需要继承父模块，ssm_service 依赖 ssm_dao 模块，添加spring相关的依赖： 1234567891011121314151617&lt;dependencies&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- dao 层的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.3.3 service 接口将 ssm_maven 工程中的service接口拷贝到 src/main/java中： 3.2.3.4 配置文件创建 applicationContext-service.xml，此文件中定义的service。 1&lt;context:component-scan base-package="cn.itcast.ssm"/&gt; 3.2.3.5 依赖范围对传递依赖的影响（了解）问题描述 当在写 junit 测试时发现，代码报出没有找不到类的错误信息： 是因为没有 junit.jar 引起的!为什么会这样呢？我们 ssm_dao 模块中有 junit 依赖而ssm_service 模块依赖了 ssm_dao，难道 junit 不应该传递过来吗？ 依赖范围对传递依赖的影响 是因为依赖会有依赖范围，依赖范围对传递依赖也有影响，例如有 A、B、C，A 依赖 B、B依赖 C，C可能是 A的传递依赖，如下图： 最左边一列为直接依赖，理解为 A 依赖 B 的范围，最顶层一行为传递依赖，理解为 B依赖 C 的范围，行与列的交叉即为 A传递依赖 C的范围。 举例 1：比如 A 对 B 有 compile 依赖，B 对 C 有 runtime 依赖，那么根据表格所示 A 对 C 有runtime 依赖。 ssm_dao依赖 junit，scop为 testssm_service 依赖 ssm_dao.查看下图红色框内所示传递依赖范围： 所以 ssm_dao工程所依赖的 junit 的 jar 没有加入到 ssm_service 工程。 举例 2：如果修改 ssm_dao 工程依赖 junit 的 scop 为 compile，ssm_dao 工程所依赖的 junit的 jar 包会加入到 ssm_service 工程中，符合上边表格所示，查看下图红色框内所示： 3.2.3.6 单元测试遇到依赖没有传递过来的问题我们通常的解决方案是在本工程中直接添加依赖：把如下依赖添加到 ssm_service的工程中： 再看测试代码也不报错了 3.2.3.7 Install 到本地仓库 3.2.4 ssm_web 子模块3.2.4.1 创建 web 子模块1.选择骨架创建web 子模块 2.确认使用自己的本地仓库 3.填写模块名称 使用骨架创建 web 项目会花费些时间，请耐心等待 4.创建 java 和 resources 文件夹，转成source root 5.添加打包方式war 3.2.4.2 定义 pom.xmlssm_web 模块的 pom.xml 文件中需要继承父模块，ssm_web 依赖 ssm_service 模块,和springmvc 的依赖 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ssm_parent&lt;/artifactId&gt; &lt;groupId&gt;cn.itcast.ssm&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ssm_web&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 依赖service --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.4.3 controller将 ssm_web 工程中的controller 代码拷贝到src/main/java 中： 3.2.4.4 配置文件拷贝 ssm_web 工程中如下配置文件： 3.2.5 运行调试方法 1：在ssm_web 工程的 pom.xml 中配置 tomcat 插件运行运行 ssm_web 工程它会从本地仓库下载依赖的 jar 包，所以当 ssm_web 依赖的 jar 包内容修改了必须及时发布到本地仓库，比如：ssm_web 依赖的 ssm_service 修改了，需要及时将ssm_service 发布到本地仓库。 方法 2：在父工程的 pom.xml 中配置 tomcat插件运行，自动聚合并执行推荐方法2，如果子工程都在本地，采用方法2则不需要子工程修改就立即发布到本地仓库，父工程会自动聚合并使用最新代码执行。 注意：如果子工程和父工程中都配置了tomcat 插件，运行的端口和路径以子工程为准。 3.3 分模块构建工程- 依赖整合每个模块都需要 spring 或者 junit 的 jar，况且最终 package 打完包最后生成的项目中的jar 就是各个模块依赖的整合，所以我们可以把项目中所需的依赖都可以放到父工程中,模块中只留模块和模块之间的依赖，那父工程的 pom.xml 可以如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;properties&gt;&lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;springmvc.version&gt;5.0.2.RELEASE&lt;/springmvc.version&gt;&lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!-- Mybatis 和mybatis 与 spring 的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring 相关 事务相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4. maven私服4.1 需求123正式开发，不同的项目组开发不同的工程。ssm_dao工程开发完毕，发布到私服。ssm_service 从私服下载 dao 4.2 分析公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内部的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接私服服务器，员工将自己开发的项目打成 jar 并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件（jar）。 私服还充当一个代理服务器，当私服上没有 jar 包会从互联网中央仓库自动下载，如下图： 4.3 搭建私服环境4.3.1 下载nexusNexus 是 Maven 仓库管理器，通过 nexus 可以搭建 maven 仓库，同时 nexus 还提供强大的仓库管理功能，构件搜索功能等。 下载 Nexus， 下载地址：http://www.sonatype.org/nexus/archived/ 下载：nexus-2.12.0-01-bundle.zip 4.3.2 安装 nexus解压 nexus-2.12.0-01-bundle.zip，本教程将它解压在 F 盘，进入 bin目录： cmd进入 bin目录，执行 nexus.bat install 安装成功在服务中查看有 nexus 服务： 4.3.3 卸载 nexuscmd进入 nexus 的 bin目录，执行：nexus.bat uninstall 查看 window 服务列表 nexus 已被删除。 4.3.4 启动 nexus方法 1：cmd 进入 bin目录，执行 nexus.bat start 方法 2： 直接启动 nexus 服务 查看 nexus 的配置文件conf/nexus.properties 12345678# Jetty sectionapplication-port=8081 # nexus 的访问端口配置application-host=0.0.0.0 # nexus 主机监听配置(不用修改)nexus-webapp=$&#123;bundleBasedir&#125;/nexus # nexus 工程目录nexus-webapp-context-path=/nexus # nexus 的 web 访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus # nexus 仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus 运行程序目录 访问：http://localhost:8081/nexus/ 使用 Nexus 内置账户admin/admin123 登陆：点击右上角的 Log in，输入账号和密码 登陆 登陆成功： 4.3.5 仓库类型查看 nexus 的仓库： nexus 的仓库有 4 种类型： hosted，宿主仓库，部署自己的 jar 到这个类型的仓库，包括 releases 和 snapshot 两部分，Releases公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 proxy，代理仓库，用于代理远程的公共仓库，如 maven 中央仓库，用户连接私服，私服自动去中央仓库下载 jar 包或者插件。 group，仓库组，用来合并多个 hosted/proxy 仓库，通常我们配置自己的 maven 连接仓库组。 virtual(虚拟)：兼容 Maven1 版本的 jar 或者插件 nexus 仓库默认在 sonatype-work 目录中： central ：代理仓库，代理中央仓库 apache-snapshots ：代理仓库存储 snapshots 构件，代理地址 https://repository.apache.org/snapshots/central-m1 ：virtual 类型仓库，兼容 Maven1 版本的 jar 或者插件releases ： 本地仓库，存储 releases 构件。snapshots ： 本地仓库，存储 snapshots 构件。thirdparty ：第三方仓库public：仓库组 4.4 将项目发布到私服4.4.1 需求企业中多个团队协作开发通常会将一些公用的组件、开发模块等发布到私服供其它团队或模块开发人员使用。 本例子假设多团队分别开发 ssm_dao、ssm_service、ssm_web，某个团队开发完在ssm_dao会将 ssm_dao 发布到私服供 ssm_service团队使用，本例子会将 ssm_dao 工程打成jar 包发布到私服。 4.4.2 配置第一步： 需要在客户端即部署 ssm_dao工程的电脑上配置 maven环境，并修改 settings.xml文件，配置连接私服的用户和密码 。此用户名和密码用于私服校验，因为私服需要知道上传的账号和密码是否和私服中的账号和密码一致。 12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; releases 连接发布版本项目仓库snapshots 连接测试版本项目仓库 第二步： 配置项目 pom.xml配置私服仓库的地址，本公司的自己的 jar 包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为 release 则上传到私服的 release 仓库，如果版本为snapshot 则上传到私服的 snapshot仓库 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt;&lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt;&lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 注意：pom.xml 这里&lt;id&gt; 和 settings.xml 配置 &lt;id&gt; 对应！ 4.4.3 测试将项目 dao 工程打成 jar 包发布到私服：1、首先启动 nexus2、对 ssm_dao工程执行 deploy 命令 根据本项目pom.xml中version定义决定发布到哪个仓库，如果version定义为snapshot，执行deploy后查看nexus的snapshot仓库，如果version定义为release则项目将发布到nexus的 release仓库，本项目将发布到 snapshot仓库： 也可以通过 http方式查看： 4.5 从私服下载 jar 包4.5.1 需求没有配置 nexus 之前，如果本地仓库没有，去中央仓库下载，通常在企业中会在局域网内部署一台私服服务器，有了私服本地项目首先去本地仓库找 jar，如果没有找到则连接私服从私服下载 jar 包，如果私服没有 jar 包私服同时作为代理服务器从中央仓库下载 jar 包，这样做的好处是一方面由私服对公司项目的依赖 jar 包统一管理，一方面提高下载速度，项目连接私服下载 jar 包的速度要比项目连接中央仓库的速度快的多。 本例子测试从私服下载 ssm_dao 工程 jar 包。 4.5.2 管理仓库组nexus中包括很多仓库，hosted中存放的是企业自己发布的jar包及第三方公司的jar包，proxy 中存放的是中央仓库的 jar，为了方便从私服下载 jar 包可以将多个仓库组成一个仓库组，每个工程需要连接私服的仓库组下载 jar 包。 打开 nexus 配置仓库组，如下图： 上图中仓库组包括了本地仓库、代理仓库等。 4.5.3 在 setting.xml 中配置仓库在客户端的 setting.xml 中配置私服的仓库，由于 setting.xml 中没有 repositories 的配置标签需要使用 profile 定义仓库。 1234567891011121314151617181920212223242526272829&lt;profile&gt; &lt;!--profile 的 id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库 id，repositories 可以配置多个仓库，保证 id 不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即 nexus 仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载 releases 构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载 snapshots 构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven 的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的 id 不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/profile&gt; 使用 profile 定义仓库需要激活才可生效。 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 配置成功后通过 eclipse 查看有效 pom，有效 pom 是 maven 软件最终使用的 pom 内容，程序员不直接编辑有效 pom，打开有效 pom 有效 pom 内容如下：下边的 pom 内容中有两个仓库地址，maven 会先从前边的仓库的找，如果找不到 jar 包再从下边的找，从而就实现了从私服下载 jar 包。 123456789101112131415161718192021222324252627282930313233343536373839&lt;repositories&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 4.5.4 测试从私服下载jar包测试 1：局域网环境或本地网络即可在 ssm_service 工程中添加以上配置后，添加 ssm_dao 工程的依赖，删除本地仓库中 ssm_dao工程，同时在 eclipse 中关闭 ssm_dao工程。观察控制台： 项目先从本地仓库找 ssm_dao，找不到从私服找，由于之前执行 deploy 将 ssm_dao 部署到私服中，所以成功从私服下载 ssm_dao 并在本地仓库保存一份。如果此时删除私服中的 ssm_dao，执行 update project 之后是否正常？如果将本地仓库的 ssm_dao 和私服的 ssm_dao 全部删除是否正常？测试 2：需要互联网环境在项目的 pom.xml 添加一个依赖，此依赖在本地仓库和私服都不存在，maven 会先从本地仓库找，本地仓库没有再从私服找，私服没有再去中央仓库下载，jar 包下载成功在私服、本地仓库分别存储一份。 5. 把第三方jar包放入本地仓库或私服5.1 导入本地库随便找一个 jar 包测试，可以先 CMD进入到 jar包所在位置，运行mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dfile= fastjson-1.1.37.jar -Dpackaging=jar 5.2 导入私服需要在 maven 软件的核心配置文件 settings.xml 中配置第三方仓库的 server 信息 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 才能执行一下命令mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dpackaging=jar -Dfile=fastjson-1.1.37.jar-Durl=http://localhost:8081/nexus/content/repositories/thirdparty/-DrepositoryId=thirdparty 5.3 参数说明DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标，项目就是依靠这两个属性定位。自己起名字也行。Dfile 表示需要上传的 jar 包的绝对路径。Durl 私服上仓库的位置，打开 nexus——&gt;repositories菜单，可以看到该路径。DrepositoryId 服务器的表示 id，在 nexus 的configuration 可以看到。Dversion 表示版本信息，关于 jar 包准确的版本：包的名字上一般会带版本号，如果没有那可以解压该包，会发现一个叫 MANIFEST.MF 的文件， 这个文件就有描述该包的版本信息。比如 Specification-Version: 2.2 可以知道该包的版本了。上传成功后，在 nexus 界面点击3rd party 仓库可以看到这包。]]></content>
      <categories>
        <category>协作开发工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>协作开发工具</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven基础]]></title>
    <url>%2F2019%2F06%2F10%2F2019-06-10-Maven%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[目录 Maven介绍 Maven的使用 Maven常用命令 Maven工程运行调试 总结 1. Maven介绍1.1 什么是Maven1.1.1 什么是MavenMaven 的正确发音是[ˈmevən]，而不是“马瘟”以及其他什么瘟。Maven 在美国是一个口语化的词语，代表专家、内行的意思。一个对 Maven 比较正式的定义是这么说的：Maven 是一个项目管理工具，它包含了一个 项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 1.1.2 Maven能解决什么问题可以用更通俗的方式来说明。我们知道，项目开发不仅仅是写写代码而已，期间会伴随着各种必不可少的事情要做，下面列举几个感受一下： 1、我们需要引用各种 jar 包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用到一种 jar 包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的 jar 包冲突，版本冲突。 2、我们辛辛苦苦写好了 Java 文件，可是只懂 0 和 1 的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用 javac 命令一个个地去编译，逗电脑玩。 3、世界上没有不存在 bug的代码，计算机喜欢 bug就和人们总是喜欢美女帅哥一样。为了追求美为了减少 bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是 web项目，还需要将之发布到服务器，供人蹂躏。 试想，如果现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理 jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站点，你会心动吗？Maven 就可以解决上面所提到的这些问题。 1.1.3 Maven的优势举例前面我们通过 Web 阶段项目，要能够将项目运行起来，就必须将该项目所依赖的一些 jar 包添加到工程中，否则项目就不能运行。试想如果具有相同架构的项目有十个，那么我们就需要将这一份 jar包复制到十个不同的工程中。我们一起来看一个CRM项目的工程大小。 使用传统 Web 项目构建的 CRM 项目如下： 原因主要是因为上面的 WEB 程序要运行，我们必须将项目运行所需的 Jar 包复制到工程目录中，从而导致了工程很大。 同样的项目，如果我们使用 Maven 工程来构建，会发现总体上工程的大小会少很多。如下图: 小结：可以初步推断它里面一定没有 jar 包，继续思考，没有 jar 包的项目怎么可能运行呢？ 1.2 Maven的两个经典作用1.2.1 Maven的依赖管理Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 传统的 WEB 项目中，我们必须将工程所依赖的 jar 包复制到工程中，导致了工程的变得很大。那么maven 工程是如何使得工程变得很少呢？ 分析如下： 通过分析发现：maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从而找到这些 jar 包，再把这些 jar 包拿去运行。 那么问题来了 第一：”存放 jar 包的仓库”长什么样？第二：通过读取 pom.xml 文件中的坐标，再到仓库中找到 jar 包，会不会很慢？从而导致这种方式不可行！ 第一个问题：存放 jar 包的仓库长什么样，这一点我们后期会分析仓库的分类，也会带大家去看我们的本地的仓库长什么样。第二个问题：通过 pom.xml 文件配置要引入的 jar 包的坐标，再读取坐标并到仓库中加载 jar 包，这样我们就可以直接使用 jar 包了，为了解决这个过程中速度慢的问题，maven 中也有索引的概念，通过建立索引，可以大大提高加载 jar 包的速度，使得我们认为 jar 包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在 maven 仓库中有了索引我们就可以认为可以快速找到 jar 包。 1.2.2 项目的一键构建我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 什么是构建？ 指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个过程称为构建。 一键构建，指的是整个构建过程，使用 maven 一个命令可以轻松完成整个工作。 Maven 规范化构建流程如下： 我们一起来看 Hello-Maven 工程的一键运行的过程。通过 tomcat:run 的这个命令，我们发现现在的工程编译，测试，运行都变得非常简单。 2. Maven的使用2.1 Maven的安装2.1.1 Maven软件的下载为了使用 Maven 管理工具，我们首先要到官网去下载它的安装软件。通过百度搜索“Maven“如下： 点击 Download 链接，就可以直接进入到 Maven 软件的下载页面： 目前最新版是 apache-maven-3.5.3 版本，我们当时使用的是apache-maven-3.5.2 版本，大家也可以下载最新版本。 Apache-maven-3.5.2 下载地址：http://archive.apache.org/dist/maven/maven-3/下载后的版本如下: 2.1.2 Maven软件的安装Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如 D:\software\maven 下面。解压后目录结构如下： 1234bin:存放了 maven 的命令，比如我们前面用到的mvn tomcat:runboot:存放了一些 maven 本身的引导程序，如类加载器等conf:存放了 maven 的一些配置文件，如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包 至此我们的 maven 软件就可以使用了，前提是你的电脑上之前已经安装并配置好了 JDK。 2.1.3 JDK的准备及统一我们所使用工具软件的统一，JDK 使用 JDK8版本 JDK 环境: 2.1.4 Maven及JDK配置电脑上需安装 java 环境，安装 JDK1.7 + 版本 （将JAVA_HOME/bin 配置环境变量 path ），我们使用的是JDK8 相关版本 配置 MAVEN_HOME ，变量值就是你的 maven 安装 的路径（bin目录之前一级目录） 上面配置了我们的 Maven 软件，注意这个目录就是之前你解压 maven 的压缩文件包在的的目录，最好不要有中文和空格。 再次检查 JDK 的安装目录，如下图： 2.1.5 Maven软件版本测试通过 mvn -v命令检查 maven 是否安装成功，看到 maven 的版本为 3.5.2 及 java 版本为 1.8 即为安装成功。找开 cmd 命令，输入 mvn –v命令，如下图： 我们发现 maven 的版本，及 jdk 的版本符合要求，这样我们的 maven 软件安装就成功了。 2.2 Maven仓库2.1.1 Maven仓库的分类maven 的工作需要从仓库下载一些 jar 包，如下图所示，本地的项目 A、项目 B 等都会通过 maven软件从远程仓库（可以理解为互联网上的仓库）下载 jar 包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此 jar 包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 下图描述了 maven 中仓库的类型： 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows 用户目录。 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 2.2.2 Maven本地仓库的配置在无网的状态下学习，需要配置提前提供的本地仓库，将 “repository.rar”解压至自己的电脑上，我们解压在 D:\repository 目录下（可以放在没有中文及空格的目录下）。 在 MAVE_HOME/conf/settings.xml 文件中配置本地仓库位置（maven 的安装目录下）： 打开 settings.xml文件，配置如下： 2.2.3 全局setting与用户settingmaven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 projec项目，它作为 maven 的全局配置。如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：${user.dir}/.m2/settings.xml 目录中,${user.dir} 指windows 中的用户目录。maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 2.3 Maven工程的认识2.3.1 Maven工程的目录结构 作为一个 maven 工程，它的 src目录和 pom.xml 是必备的。进入 src目录后，我们发现它里面的目录结构如下： 123456src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的class 文件会输出到此目录pom.xml——maven 项目核心配置文件 注意：如果是普通的 java 项目，那么就没有webapp 目录。 2.3.2 Maven工程的运行进入 maven 工程目录（当前目录有 pom.xml 文件），运行 tomcat:run 命令。 根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/ 2.3.3 问题处理如果本地仓库配置错误会报下边的错误 分析：maven 工程运行先从本地仓库找 jar 包，本地仓库没有再从中央仓库找，上边提示 downloading…表示 从中央仓库下载 jar，由于本地没有联网，报错。 解决：在 maven 安装目录的conf/setting.xml 文件中配置本地仓库，参考： “maven 仓库/配置本地仓库章节”。 3. Maven常用命令我们可以在cmd 中通过一系列的 maven 命令来对我们的 maven-helloworld 工程进行编译、测试、运行、打包、安装、部署。 3.1 常用命令3.1.1 compilecompile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。 cmd 进入命令状态，执行mvn compile，如下图提示成功： 查看 target 目录，class 文件已生成，编译完成。 3.1.2 testtest 是 maven 工程的测试命令 mvn test，会执行src/test/java下的单元测试类。 cmd 执行 mvn test 执行 src/test/java 下单元测试类，下图为测试结果，运行 1 个测试用例，全部成功。 3.1.3 cleanclean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容。 3.1.4 packagepackage 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于web 工程打成war包。 3.1.5 installinstall 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。从运行结果中，可以看出：当后面的命令执行时，前面的操作过程也都会自动执行. 3.1.6 Maven指令的生命周期maven 对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： 123Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle 生成项目报告，站点，发布站点。 3.1.7 Maven的概念模型Maven 包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model) 一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统(Dependency Management System) 通过 maven 的依赖管理对项目所依赖的 jar 包进行统一管理。 比如：项目依赖 junit4.9，通过在 pom.xml 中定义 junit4.9 的依赖即使用 junit4.9，如下所示是 junit4.9的依赖定义： 1234567891011121314&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt; &lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围：单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 一个项目生命周期(Project Lifecycle) 使用 maven 完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven 将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： maven 通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行 mvn compile 执行编译、执行 mvn clean 执行清理。 一组标准集合 maven将整个项目管理过程定义一组标准，比如：通过 maven 构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal) maven 管理项目生命周期过程都是基于插件完成的。 3.2 idea开发maven项目在实战的环境中，我们都会使用流行的工具来开发项目。 3.2.1 idea的maven配置 打开–&gt;File–&gt;Settings 配置 maven 依据图片指示，选择本地 maven 安装目录，指定 maven 安装目录下conf文件夹中 settings 配置文件。 3.2.2 idea中创建一个maven的web工程打开 idea，选择创建一个新工程 选择 idea提供好的 maven 的web 工程模板 点击 Next填写项目信息 点击 Next，此处不做改动。 点击 Next选择项目所在目录 点击 Finish后开始创建工程，耐心等待，直到出现如下界面。 手动添加 src/main/java 目录，如下图右键 main 文件夹–&gt;New–&gt;Directory 创建一个新的文件夹命名为 java 点击 OK 后，在新的文件夹 java 上右键–&gt;Make Directory as–&gt;Sources Root 创建一个 Servlet src/java/main 创建了一个 Servlet，但报错 要解决问题，就是要将 servlet-api-xxx.jar 包放进来，作为 maven 工程应当添加 servlet的坐标，从而导入它的 jar 在 pom.xml 文件添加坐标 直接打开 hello_maven 工程的 pom.xml 文件，再添加坐标 添加 jar 包的坐标时，还可以指定这个 jar 包将来的作用范围。 每个 maven 工程都需要定义本工程的坐标，坐标是 maven 对 jar 包的身份定义，比如：入门程序的坐标定义如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;hello_maven&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging &gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 坐标的来源方式 添加依赖需要指定依赖 jar 包的坐标，但是很多情况我们是不知道 jar 包的的坐标，可以通过如下方式查询： 从互联网搜索http://search.maven.org/http://mvnrepository.com/ 网站搜索示例： 3.2.3 依赖范围A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括： 12345678910compile：编译范围，指 A在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。 在 maven-web 工程中测试各各 scop。 123456测试总结：默认引入 的 jar 包 ------- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）servlet-api 、jsp-api ------- provided （编译、测试 有效， 运行时无效 防止和 tomcat 下 jar 冲突）jdbc 驱动 jar 包 ---- runtime （测试、运行 有效 ）junit ----- test （测试有效）依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test 3.2.4 项目中添加的坐标 3.2.5 设置jdk编译版本我们使用 jdk1.8，需要设置编译版本为 1.8，这里需要使用 maven 的插件来设置：在 pom.xml 中加入： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.2.6 编写servlet在 src/main/java中创建 ServletTest 内容如下: 3.2.7 编写jsp 3.2.8 在web.xml中配置servlet访问路径 3.2.9 添加tomcat7插件在 pom 文件中添加如下内容 此时点击 idea最右侧 Maven Projects，就可以看到我们新添加的tomcat7 插件双击 tomcat7插件下tomcat7:run 命令直接运行项目 也可以直接点击如图按钮，手动输入 tomc7:run 命令运行项目 点击后弹出如下图窗口 3.2.10 运行结果 4. Maven工程运行调试4.1 端口占用处理重新执行 tomcat:run 命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误： 4.2 断点调试点击如图所示选项 在弹出框中点击如图加号按钮找到 maven 选项 在弹出窗口中填写如下信息 完成后先 Apply 再 OK 结束配置后，可以在主界面找到我们刚才配置的操作名称。 如上图红框选中的两个按钮，左侧是正常启动，右侧是 debug启动。 5. 总结5.1 maven仓库1231、maven 仓库的类型有哪些？2、maven 工程查找仓库的流程是什么？3、本地仓库如何配置？ 5.2 常用的maven命令12345compile：编译clean：清理test：测试package：打包install：安装 5.3 坐标定义在 pom.xml 中定义坐标，内容包括：groupId、artifactId、version，详细内容如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;maven-first&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging &gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 5.4 pom基本配置pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下： 12345678910&lt;project &gt; ：文件的根节点 .&lt;modelversion &gt; ： pom.xml 使用的对象模型版本&lt;groupId &gt; ：项目名称，一般写项目的域名&lt;artifactId &gt; ：模块名称，子项目名或模块名称&lt;version &gt; ：产品的版本号 .&lt;packaging &gt; ：打包类型，一般有 jar、war、pom 等&lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description &gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。 ##]]></content>
      <categories>
        <category>协作开发工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>协作开发工具</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应数据和结果视图]]></title>
    <url>%2F2019%2F06%2F10%2F2019-06-10-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[目录 返回值分类 转发和重定向 RequestBody响应json数据 1. 返回值分类1.1 字符串controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 123456//指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp@RequestMapping("/testReturnString")public String testReturnString() &#123; System.out.println("AccountController 的 testReturnString 方法执行了。。。。"); return "success";&#125; 运作结果： 1.2 void我们知道 Servlet 原始 API 可以作为控制器中方法的参数： 1234@RequestMapping("/testReturnVoid")public void testReturnVoid(HttpServletRequest request,HttpServletResponse response)throws Exception &#123;&#125; 在controller 方法形参上可以定义 request和 response，使用 request 或 response 指定响应结果： 1 、使用 request 转向页面，如下： 1request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); 2 、也可以通过 response 页面重定向： 1response.sendRedirect("testRetrunString") 3 、也可以通过 response 指定响应结果，例如响应 json 数据： 123response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("n json 串" "); 1.3 ModelAndViewModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。该对象中有两个方法： 示例代码： 1234567891011/*** 返回 ModeAndView* @return*/@RequestMapping("/testReturnModelAndView")public ModelAndView testReturnModelAndView() &#123; ModelAndView mv = new ModelAndView(); mv.addObject("username", "张三"); mv.setViewName("success"); return mv;&#125; 响应的 jsp 代码： 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;执行成功&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 执行成功！ $&#123;requestScope.username&#125; &lt;/body&gt;&lt;/html&gt; 输出结果： 注意：我们在页面上上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏览器跳转只能是请求转发。 2. 转发和重定向2.1 forward转发controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成： 123456789/*** 转发* @return*/@RequestMapping("/testForward")public String testForward() &#123; System.out.println("AccountController 的 testForward 方法执行了。。。。"); return "forward:/WEB-INF/pages/success.jsp";&#125; 需要注意的是，如果用了 formward ：则路径必须写成实际视图 url，不能写逻辑视图。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。 2.2 redirect重定向contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用:redirect: 123456789*** 重定向* @return*/@RequestMapping("/testRedirect")public String testRedirect() &#123; System.out.println("AccountController 的 testRedirect 方法执行了。。。。"); return "redirect:testReturnModelAndView";&#125; 它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。 3. RequestBody响应json数据3.1 使用说明123作用： 该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端 3.2 使用示例12345需 求： 使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端。前置知识点： Springmvc 默认用 MappingJacksonHttpMessageConverter 对 json 数据进行转换，需要加入jackson 的包。(注意：2.7.0 以下的版本用不了) jsp 中的代码： 1234567891011121314151617181920&lt;script type="text/javascript"src="$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("#testJson").click(function()&#123; $.ajax(&#123; type:"post", url:"$&#123;pageContext.request.contextPath&#125;/testResponseJson", contentType:"application/json;charset=utf-8", data:'&#123;"id":1,"name":"test","money":999.0&#125;', dataType:"json", success:function(data)&#123; alert(data); &#125; &#125;); &#125;); &#125;)&lt;/script&gt;&lt;!-- 测试异步请求 --&gt;&lt;input type="button" value=" 测试 ajax 请求 json 和响应 json" id="testJson"/&gt; 控制器中的代码： 1234567891011121314151617/*** 响应 json 数据的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("jsonController")public class JsonController &#123; /** * 测试响应 json 数据 */ @RequestMapping("/testResponseJson") public @ResponseBody Account testResponseJson(@RequestBody Account account) &#123; System.out.println("异步请求："+account); return account; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求参数的绑定与常用注解]]></title>
    <url>%2F2019%2F06%2F09%2F2019-06-09-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目录 绑定说明 特殊情况 RequestParam RequestBody PathVaribale RequestHeader CookieValue ModelAttribute SessionAttribute 1. 绑定说明1.1 绑定的机制我们都知道，表单中请求参数都是基于 key=value 的。SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。例如： 1&lt;a href="account/findAccount?accountId=10"&gt;查询账户&lt;/a&gt; 请求参数是：accountId=10 123456789/*** 查询账户* @return*/@RequestMapping("/findAccount")public String findAccount(Integer accountId) &#123; System.out.println("查询了账户。。。。"+accountId); return "success";&#125; 1.2 支持的数据类型1234567基本类型参数 ： 包括基本类型和 String 类型POJO 类型参数 ： 包括实体类，以及关联的实体类数组和集合类型参数 ： 包括 List 结构和 Map 结构的集合（包括数组）SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。 1.3 使用要求123456789101112131415161718192021222324252627282930313233如果是基本类型或者 String 类型： 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)是 如果是 POJO 类型 ，或者 它的关联对象 ： 要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。如果是集合类型, 有两种方式 ： 第一种： 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。 第二种： 接收的请求参数是 json 格式数据。需要借助一个注解实现。 注意: 它还可以实现一些数据类型自动转换。内置转换器全都在： org.springframework.core.convert.support 包下。有： java.lang.Boolean -&gt; java.lang.String : ObjectToStringConverter java.lang.Character -&gt; java.lang.Number : CharacterToNumberFactory java.lang.Character -&gt; java.lang.String : ObjectToStringConverter java.lang.Enum -&gt; java.lang.String : EnumToStringConverter java.lang.Number -&gt; java.lang.Character : NumberToCharacterConverter java.lang.Number -&gt; java.lang.Number : NumberToNumberConverterFactory java.lang.Number -&gt; java.lang.String : ObjectToStringConverter java.lang.String -&gt; java.lang.Boolean : StringToBooleanConverter java.lang.String -&gt; java.lang.Character : StringToCharacterConverter java.lang.String -&gt; java.lang.Enum : StringToEnumConverterFactory java.lang.String -&gt; java.lang.Number : StringToNumberConverterFactory java.lang.String -&gt; java.util.Locale : StringToLocaleConverter java.lang.String -&gt; java.util.Properties : StringToPropertiesConverter java.lang.String -&gt; java.util.UUID : StringToUUIDConverter java.util.Locale -&gt; java.lang.String : ObjectToStringConverter java.util.Properties -&gt; java.lang.String : PropertiesToStringConverter java.util.UUID -&gt; java.lang.String : ObjectToStringConverter ...... 如遇特殊类型转换要求，需要我们自己编写自定义类型转换器。 1.4 使用示例1.4.1 基本类型和String类型作为参数jsp 代码： 12&lt;!-- 基本类型示例 --&gt;&lt;a href="account/findAccount?accountId=10&amp;accountName=zhangsan"&gt;查询账户&lt;/a&gt; 控制器代码： 123456789/*** 查询账户* @return*/@RequestMapping("/findAccount")public String findAccount(Integer accountId,String accountName) &#123; System.out.println("查询了账户。。。。"+accountId+","+accountName); return "success";&#125; 运行结果： 1.4.2 POJO类型作为参数实体类代码： 1234567891011121314/*** 账户信息* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; private Address address; //getters and setters&#125; 123456789101112*** 地址的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Address implements Serializable &#123; private String provinceName; private String cityName; //getters and setters&#125; jsp 代码： 12345678&lt;!-- pojo 类型演示 --&gt;&lt;form action="account/saveAccount" method="post"&gt; 账户名称：&lt;input type="text" name="name" &gt;&lt;br/&gt; 账户金额：&lt;input type="text" name="money" &gt;&lt;br/&gt; 账户省份：&lt;input type="text" name="address.provinceName" &gt;&lt;br/&gt; 账户城市：&lt;input type="text" name="address.cityName" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制器代码： 12345678910/*** 保存账户* @param account* @return*/@RequestMapping("/saveAccount")public String saveAccount(Account account) &#123; System.out.println("保存了账户。。。。"+account); return "success";&#125; 运行结果： 1.4.3 POJO类中包含集合类型参数实体类代码： 12345678910111213141516171819202122/*** 用户实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class User implements Serializable &#123; private String username; private String password; private Integer age; private List&lt;Account&gt; accounts; private Map&lt;String,Account&gt; accountMap; //getters and setters @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + ", age=" + age + ",\n accounts=" + accounts + ",\n accountMap=" + accountMap + "]"; &#125;&#125; jsp代码： 123456789101112131415&lt;!-- POJO 类包含集合类型演示 --&gt;&lt;form action="account/updateAccount" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; 账户 1 名称：&lt;input type="text" name="accounts[0].name" &gt;&lt;br/&gt; 账户 1 金额：&lt;input type="text" name="accounts[0].money" &gt;&lt;br/&gt; 账户 2 名称：&lt;input type="text" name="accounts[1].name" &gt;&lt;br/&gt; 账户 2 金额：&lt;input type="text" name="accounts[1].money" &gt;&lt;br/&gt; 账户 3 名称：&lt;input type="text" name="accountMap['one'].name" &gt;&lt;br/&gt; 账户 3 金额：&lt;input type="text" name="accountMap['one'].money" &gt;&lt;br/&gt; 账户 4 名称：&lt;input type="text" name="accountMap['two'].name" &gt;&lt;br/&gt; 账户 4 金额：&lt;input type="text" name="accountMap['two'].money" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制器： 123456789/*** 更新账户* @return*/@RequestMapping("/updateAccount")public String updateAccount(User user) &#123; System.out.println("更新了账户。。。。"+user); return "success";&#125; 运行结果： 1.4.4 请求参数乱码问题post 请求方式：在 web.xml 中配置一个过滤器 12345678910111213141516171819202122&lt;!-- 配置 springMVC 编码过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 过滤所有请求 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在 springmvc 的配置文件中可以配置，静态资源不过滤： 1234&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt;&lt;mvc:resources location="/scripts/" mapping="/javascript/**"/&gt; get 请求方式：tomacat 对 GET和 POST 请求处理方式是不同的，GET请求的编码问题，要改 tomcat 的 server.xml配置文件，如下： 12&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; 改为: 123&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" useBodyEncodingForURI="true"/&gt; 如果遇到 ajax 请求仍然乱码，请把： 1useBodyEncodingForURI=&quot;true&quot;改为 URIEncoding=&quot;UTF-8&quot; 2. 特殊情况2.1 自定义类型转换器2.1.1 使用场景：jsp代码： 12&lt;!-- 特殊情况之：类型转换问题 --&gt;&lt;a href="account/deleteAccount?date=2018-01-01"&gt;根据日期删除账户&lt;/a&gt; 控制器代码: 123456789/*** 删除账户* @return*/@RequestMapping("/deleteAccount")public String deleteAccount(String date) &#123; System.out.println("删除了账户。。。。"+date); return "success";&#125; 运行结果： 当我们把控制器中方法参数的类型改为 Date 时： 123456789/*** 删除账户* @return*/@RequestMapping("/deleteAccount")public String deleteAccount(Date date) &#123; System.out.println("删除了账户。。。。"+date); return "success";&#125; 运行结果： 异常提示： 1234Failed to bind request element:org.springframework.web.method.annotation.MethodArgumentTypeMismatchException:Failed to convert value of type &apos;java.lang.String&apos; to required type &apos;java.util.Date&apos;; nested exception is org.springframework.core.convert.ConversionFailedException:Failed to convert from type [java.lang.String] to type [java.util.Date] for value &apos;2018-01-01&apos;; nested exception is java.lang.IllegalArgumentException 2.1.2 使用步骤第一步：定义一个类，实现 Converter 接口，该接口有两个泛型。 1234567public interface Converter&lt;S, T&gt; &#123;//S:表示接受的类型，T：表示目标类型 /** * 实现类型转换的方法 */ @Nullable T convert(S source);&#125; 12345678910111213141516171819202122232425/*** 自定义类型转换器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; /** * 用于把 String 类型转成日期类型 */ @Override public Date convert(String source) &#123; DateFormat format = null; try &#123; if(StringUtils.isEmpty(source)) &#123; throw new NullPointerException("请输入要转换的日期"); &#125; format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(source); return date; &#125; catch (Exception e) &#123; throw new RuntimeException("输入日期有误"); &#125; &#125;&#125; 第二步：在 spring 配置文件中配置类型转换器。 spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。 1234567891011&lt;!-- 配置类型转换器工厂 --&gt;&lt;bean id="converterService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;!-- 给工厂注入一个新的类型转换器 --&gt; &lt;property name="converters"&gt; &lt;array&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean class="com.itheima.web.converter.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 第三步：在 annotation-driven 12&lt;!-- 引用自定义类型转换器 --&gt;&lt;mvc:annotation-driven conversion-service="converterService"&gt;&lt;/mvc:annotation-driven&gt; 运行结果： 2.2 使用ServletAPI对象作为方法参数1234567891011SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 ServletAPI 对象有：HttpServletRequestHttpServletResponseHttpSessionjava.security.PrincipalLocaleInputStreamOutputStreamReaderWriter我们可以把上述对象，直接写在控制的方法参数中使用。 部分示例代码：jsp 代码： 12&lt;!-- 原始 ServletAPI 作为控制器参数 --&gt;&lt;a href=&quot;account/testServletAPI&quot;&gt;测试访问 ServletAPI&lt;/a&gt; 控制器中的代码： 12345678910111213/*** 测试访问 testServletAPI* @return*/@RequestMapping("/testServletAPI")public String testServletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session) &#123; System.out.println(request); System.out.println(response); System.out.println(session); return "success";&#125; 执行结果： 3. RequestParam3.1 使用说明12345作用： 把请求中指定名称的参数给控制器中的形参赋值。属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 3.2 使用示例jsp 中的代码： 12&lt;!-- requestParams 注解的使用 --&gt;&lt;a href="springmvc/useRequestParam?name=test"&gt;requestParam 注解&lt;/a&gt; 控制器中的代码： 1234567891011/*** requestParams 注解的使用* @param username* @return*/@RequestMapping("/useRequestParam")public String useRequestParam(@RequestParam("name")String username, @RequestParam(value="age",required=false)Integer age)&#123; System.out.println(username+","+age); return "success";&#125; 运行结果： 4. RequestBody4.1 使用说明12345作用： 用于获取请求体内容。直接使用得到是 key=value&amp;key=value...结构的数据。 get 请求方式不适用。属性： required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。 4.2 使用示例post 请求 jsp代码： 1234567&lt;!-- request body 注解 --&gt;&lt;form action="springmvc/useRequestBody" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; get 请求 jsp 代码： 1&lt;a href="springmvc/useRequestBody?body=test"&gt;requestBody 注解 get 请求&lt;/a&gt; 控制器代码： 12345678910/*** RequestBody 注解* @param user* @return*/@RequestMapping("/useRequestBody")public String useRequestBody(@RequestBody(required=false) String body)&#123; System.out.println(body); return "success";&#125; post 请求运行结果： get 请求运行结果： 5. PathVaribale5.1 使用说明123456作用： 用于绑定 url 中的占位符。例如：请求 url 中 /delete/&#123;id&#125;，这个&#123;id&#125;就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。属性： value：用于指定 url 中占位符名称。 required：是否必须提供占位符。 5.2 使用示例jsp代码： 12&lt;!-- PathVariable 注解 --&gt;&lt;a href="springmvc/usePathVariable/100"&gt;pathVariable 注解&lt;/a&gt; 控制器代码： 12345678910/*** PathVariable 注解* @param user* @return*/@RequestMapping("/usePathVariable/&#123;id&#125;")public String usePathVariable(@PathVariable("id") Integer id)&#123; System.out.println(id); return "success";&#125; 运行结果： 5.3 REST风格URL1234567891011121314151617181920什么是 rest ： REST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之一。在目前主流的三种 Web 服务交互方案中，REST 相比于 SOAP（Simple Object Access protocol，简单对象访问协议）以及 XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码，REST 都倾向于用更加简单轻量的方法设计和实现。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。 它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口。 restful 的优点 它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 restful 的特性： 资源（ Resources）：网络上的一个实体，或者说是网络上的一个具体信息。 它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。 表现层（ Representation）：把资源具体呈现出来的形式，叫做它的表现层 （ Representation）。 比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 状态转化（ State Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。 HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生 “状态转化 ”（ State Tran sfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化 ”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词： GET、 POST、 PUT、DELETE。它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。 restful 的示例： /account/1 HTTP GET ： 得到 id = 1 的 account /account/1 HTTP DELETE： 删除 id = 1 的 account /account/1 HTTP PUT： 更新 id = 1 的 account /account HTTP POST： 新增 account 5.4 基于 HiddentHttpMethodFilter 的示例123456作用： 由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT与 DELETE 请求。使用方法： 第一步：在 web.xml 中配置该过滤器。 第二步：请求方式必须使用 post 请求。 第三步：按照要求提供_method 请求参数，该参数的取值就是我们需要的请求方式。 源码分析： jsp 中示例代码： 12345678910111213141516171819202122232425&lt;!-- 保存 --&gt;&lt;form action="springmvc/testRestPOST" method="post"&gt; 用户名称：&lt;input type="text" name="username"&gt;&lt;br/&gt; &lt;!-- &lt;input type="hidden" name="_method" value="POST"&gt; --&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt;&lt;hr/&gt;&lt;!-- 更新 --&gt;&lt;form action="springmvc/testRestPUT/1" method="post"&gt; 用户名称：&lt;input type="text" name="username"&gt;&lt;br/&gt; &lt;input type="hidden" name="_method" value="PUT"&gt; &lt;input type="submit" value=" 更新 "&gt;&lt;/form&gt;&lt;hr/&gt;&lt;!-- 删除 --&gt;&lt;form action="springmvc/testRestDELETE/1" method="post"&gt; &lt;input type="hidden" name="_method" value="DELETE"&gt; &lt;input type="submit" value=" 删除 "&gt;&lt;/form&gt;&lt;hr/&gt;&lt;!-- 查询一个 --&gt;&lt;form action="springmvc/testRestGET/1" method="post"&gt; &lt;input type="hidden" name="_method" value="GET"&gt; &lt;input type="submit" value=" 查询 "&gt;&lt;/form&gt; 控制器中示例代码： 12345678910/*** post 请求：保存* @param username* @return*/@RequestMapping(value="/testRestPOST",method=RequestMethod.POST)public String testRestfulURLPOST(User user)&#123; System.out.println("rest post"+user); return "success";&#125; 12345678910/*** put 请求：更新* @param username* @return*/@RequestMapping(value="/testRestPUT/&#123;id&#125;",method=RequestMethod.PUT)public String testRestfulURLPUT(@PathVariable("id")Integer id,User user)&#123; System.out.println("rest put "+id+","+user); return "success";&#125; 12345678910/*** post 请求：删除* @param username* @return*/@RequestMapping(value="/testRestDELETE/&#123;id&#125;",method=RequestMethod.DELETE)public String testRestfulURLDELETE(@PathVariable("id")Integer id)&#123; System.out.println("rest delete "+id); return "success";&#125; 12345678910/*** post 请求：查询* @param username* @return*/@RequestMapping(value="/testRestGET/&#123;id&#125;",method=RequestMethod.GET)public String testRestfulURLGET(@PathVariable("id")Integer id)&#123; System.out.println("rest get "+id); return "success";&#125; 运行结果： 6. RequestHeader6.1 使用说明1234567作用： 用于获取请求消息头。属性： value：提供消息头名称 required：是否必须有此消息头注： 在实际开发中一般不怎么用。 6.2 使用示例jsp 中代码： 12&lt;!-- RequestHeader 注解 --&gt;&lt;a href="springmvc/useRequestHeader"&gt;获取请求消息头&lt;/a&gt; 控制器中代码： 1234567891011/*** RequestHeader 注解* @param user* @return*/@RequestMapping("/useRequestHeader")public String useRequestHeader(@RequestHeader(value="Accept-Language", required=false)String requestHeader)&#123; System.out.println(requestHeader); return "success";&#125; 运行结果： 7. CookieValue7.1 使用说明12345作用： 用于把指定 cookie 名称的值传入控制器方法参数。属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 7.2 使用示例jsp 中的代码： 12&lt;!-- CookieValue 注解 --&gt;&lt;a href="springmvc/useCookieValue"&gt;绑定 cookie 的值&lt;/a&gt; 控制器中的代码： 1234567891011/*** Cookie 注解注解* @param user* @return*/@RequestMapping("/useCookieValue")public String useCookieValue(@CookieValue(value="JSESSIONID",required=false) String cookieValue)&#123; System.out.println(cookieValue); return "success";&#125; 运行结果： 8. ModelAttribute8.1 使用说明12345678910作用： 该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。属性： value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。应用场景： 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。 8.2 使用示例8.2.1 基于POJO属性的基本使用jsp代码： 12&lt;!-- ModelAttribute 注解的基本使用 --&gt;&lt;a href="springmvc/testModelAttribute?username=test"&gt;测试 modelattribute&lt;/a&gt; 控制器代码： 12345678/*** 被 ModelAttribute 修饰的方法* @param user*/@ModelAttributepublic void showModel(User user) &#123; System.out.println("执行了 showModel 方法"+user.getUsername());&#125; 12345678910/*** 接收请求的方法* @param user* @return*/@RequestMapping("/testModelAttribute")public String testModelAttribute(User user) &#123; System.out.println("执行了控制器的方法"+user.getUsername()); return "success";&#125; 运行结果： 8.2.2 基于 Map 的应用场景示例 1 ：ModelAttribute 修饰方法带返回值需求：修改用户信息，要求用户的密码不能修改 jsp的代码： 123456&lt;!-- 修改用户信息 --&gt;&lt;form action="springmvc/updateUser" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制的代码： 1234567891011/*** 查询数据库中用户信息* @param user*/@ModelAttributepublic User showModel(String username) &#123; //模拟去数据库查询 User abc = findUserByName(username); System.out.println("执行了 showModel 方法"+abc); return abc;&#125; 12345678910/*** 模拟修改用户方法* @param user* @return*/@RequestMapping("/updateUser")public String testModelAttribute(User user) &#123; System.out.println("控制器中处理请求的方法：修改用户："+user); return "success";&#125; 123456789101112/*** 模拟去数据库查询* @param username* @return*/private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword("123456"); return user;&#125; 运行结果： 8.2.3 基于 Map 的应用场景示例 1 ：ModelAttribute 修饰方法 不带返回值需求：修改用户信息，要求用户的密码不能修改 jsp中的代码： 123456&lt;!-- 修改用户信息 --&gt;&lt;form action="springmvc/updateUser" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制器中的代码： 1234567891011/*** 查询数据库中用户信息* @param user*/@ModelAttributepublic void showModel(String username,Map&lt;String,User&gt; map) &#123; //模拟去数据库查询 User user = findUserByName(username); System.out.println("执行了 showModel 方法"+user); map.put("abc",user);&#125; 12345678910/*** 模拟修改用户方法* @param user* @return*/@RequestMapping("/updateUser")public String testModelAttribute(@ModelAttribute("abc")User user) &#123; System.out.println("控制器中处理请求的方法：修改用户："+user); return "success";&#125; 123456789101112/*** 模拟去数据库查询* @param username* @return*/private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword("123456"); return user;&#125; 运行结果： 9. SessionAttribute9.1 使用说明12345作用： 用于多次执行控制器方法间的参数共享。属性： value：用于指定存入的属性名称 type：用于指定存入的数据类型。 9.2 使用示例jsp中的代码： 123456&lt;!-- SessionAttribute 注解的使用 --&gt;&lt;a href="springmvc/testPut"&gt;存入 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href="springmvc/testGet"&gt;取出 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href="springmvc/testClean"&gt;清除 SessionAttribute&lt;/a&gt; 控制器中的代码： 123456789101112131415161718192021222324252627282930313233343536373839/*** SessionAttribute 注解的使用* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("sessionAttributeController")@RequestMapping("/springmvc")@SessionAttributes(value =&#123;"username","password"&#125;,types=&#123;Integer.class&#125;)public class SessionAttributeController &#123; /** * 把数据存入 SessionAttribute * @param model * @return * Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap * 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类 */ @RequestMapping("/testPut") public String testPut(Model model)&#123; model.addAttribute("username", "泰斯特"); model.addAttribute("password","123456"); model.addAttribute("age", 31); //跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有 这几个参数 return "success"; &#125; @RequestMapping("/testGet") public String testGet(ModelMap model)&#123;System.out.println(model.get("username")+";"+model.get("password")+";"+model.get("age")); return "success"; &#125; @RequestMapping("/testClean") public String complete(SessionStatus sessionStatus)&#123; sessionStatus.setComplete(); return "success"; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的基本概念与入门]]></title>
    <url>%2F2019%2F06%2F08%2F2019-06-08-SpringMVC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 关于三层架构和MVC SpringMVC概念 SpringMVC的入门案例 入门案例的执行过程及原理分析 入门案例中涉及的组件 RequestMapping注解 1. 关于三层架构和MVC1.1 三层架构我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 构，也就是浏览器服务器。在 JavaEE 开发中，几乎全都是基于 B/S架构的开发。那么在 B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web 层，web 需要接收 http 请求，完成 http 响应。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层： 也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 1.2 MVC模型MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职： Model （模型）： 通常指的就是我们的数据模型。作用一般情况下用于封装数据。 View （视图） ： 通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。 Controller （控制器） ： 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。它相对于前两个不是很好理解，这里举个例子：例如：我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充到模型之中。此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做的。当校验失败后，由控制器负责把错误页面展示给使用者。如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。 2. SpringMVC概念2.1 SpringMVC是什么SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。 2.2 SpringMVC在三层架构的位置 2.3 SpringMVC的优势12345678910111213141516171819201、清晰的角色划分： 前端控制器（DispatcherServlet） 请求到处理器映射（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 处理器或页面控制器（Controller） 验证器（ Validator） 命令对象（Command 请求参数绑定到的对象就叫命令对象） 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。7、功能强大的数据验证、格式化、绑定机制。8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。10、强大的 JSP 标签库，使 JSP 编写更容易。………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。 2.4 SpringMVC和Struts2的优劣分析12345678910共同点： 它们都是表现层框架，都是基于 MVC 模型编写的。 它们的底层都离不开原始 ServletAPI。 它们处理请求的机制都是一个核心控制器。区别： Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。 Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便 (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。) Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。 3. SpringMVC的入门案例3.1 前期准备下载开发包： https://spring.io/projects其实 spring mvc 的 jar 包就在之前我们的 spring 框架开发包中。创建一个 javaweb 工程 创建一个 jsp 用于发送请求 jsp 中的内容： 123&lt;a href="$&#123;pageContext.request.contextPath&#125;/hello"&gt;SpringMVC 入门案例&lt;/a&gt;&lt;br/&gt;&lt;a href="hello"&gt;SpringMVC 入门案例&lt;/a&gt; 3.2 拷贝jar包 除了上面两个 jar 包之外，还需要拷贝 spring 的注解 ioc 所需 jar 包（包括一个 aop 的 jar 包）。 3.3 配置核心控制器——一个Servlet1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;!-- 配置 spring mvc 的核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVCDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取 SpringMVC 的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。 取值只能是非 0 正整数，表示启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVCDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.4 创建SpringMVC的配置文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置创建 spring 容器要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.5 编写控制器并使用注解配置123456789101112131415/*** spring mvc 的入门案例* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("helloController")public class HelloController &#123; @RequestMapping("/hello") public String sayHello() &#123; System.out.println("HelloController 的 sayHello 方法执行了。。。。"); return "success"; &#125;&#125; 3.6 测试 4. 入门案例的执行过程及原理分析4.1 案例的执行过程 1、服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象。 从入门案例中可以看到的是：HelloController 和 InternalResourceViewResolver，但是远不止这些。 2、浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发的路径是根据请求 URL，匹配@RequestMapping 中的内容。3、匹配到了后，执行对应方法。该方法有一个返回值。4、根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。5、渲染结果视图，响应浏览器。 4.2 SpringMVC的请求响应流程 5. 入门案例中涉及的组件5.1 DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 5.2 HandlerMapping：处理器映射器HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 5.3 Handler：处理器它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 5.4 HandlerAdapter：处理器适配器通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 5.5 View Resolver：视图解析器View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 5.6 View：视图SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 5.7 &lt;mvc:annotation-driver&gt;说明在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。使 用 &lt;mvc:annotation-driven&gt; 自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。它就相当于在 xml 中配置了： 123456789101112131415161718192021222324252627&lt;!-- 上面的标签相当于 如下配置--&gt;&lt;!-- Begin --&gt;&lt;!-- HandlerMapping --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;&lt;!-- HandlerAdapter --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- HadnlerExceptionResolvers --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"&gt;&lt;/bean&gt;&lt;!-- End --&gt; 1234注意： 一般开发中，我们都需要写上此标签（虽然从入门案例中看，我们不写也行，随着课程的深入，该标签还有具体的使用场景）。明确： 我们只需要编写处理具体业务的控制器以及视图。 6. RequestMapping注解6.1 使用说明源码： 123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123;&#125; 作用：用于建立请求 URL 和处理请求方法之间的对应关系。 12345678910111213141516171819202122232425262728出现 位置： 类上： 请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的 URL 可以按照模块化管理: 例如： 账户模块： /account/add /account/update /account/delete ... 订单模块： /order/add /order/update /order/delete 把 RequsetMappding 写在类上，使我们的 URL 更加精细。 方法上： 请求 URL 的第二级访问目录。属性： value：用于指定请求的 URL。它和 path 属性的作用是一样的。 method：用于指定请求的方式。 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。 例如： params = &#123;&quot;accountName&quot;&#125;，表示请求参数必须有 accountName params = &#123;&quot;moeny!100&quot;&#125;，表示请求参数中 money 不能是 100。 headers：用于指定限制请求消息头的条件。 注意： 以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。 6.2 使用示例6.2.1 出现位置的示例控制器代码: 12345678910111213141516/*** RequestMapping 注解出现的位置* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("accountController")@RequestMapping("/account")public class AccountController &#123; @RequestMapping("/findAccount") public String findAccount() &#123; System.out.println("查询了账户。。。。"); return "success"; &#125;&#125; jsp 中的代码： 12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;requestmapping 的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 第一种访问方式 --&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/account/findAccount"&gt; 查询账户 &lt;/a&gt; &lt;br/&gt; &lt;!-- 第二种访问方式 --&gt; &lt;a href="account/findAccount"&gt;查询账户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 注意：当我们使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加/ 6.2.2 method属性的示例：控制器代码： 123456789/*** 保存账户* @return*/@RequestMapping(value="/saveAccount",method=RequestMethod.POST)public String saveAccount() &#123; System.out.println("保存了账户"); return "success";&#125; jsp代码： 123456&lt;!-- 请求方式的示例 --&gt;&lt;a href="account/saveAccount"&gt;保存账户，get 请求&lt;/a&gt;&lt;br/&gt;&lt;form action="account/saveAccount" method="post"&gt; &lt;input type="submit" value=" 保存账户， post 请求 "&gt;&lt;/form&gt; 注意：当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求 6.2.3 params属性的示例：控制器的代码： 123456789/*** 删除账户* @return*/@RequestMapping(value="/removeAccount",params= &#123;"accountName","money&gt;100"&#125;)public String removeAccount() &#123; System.out.println("删除了账户"); return "success";&#125; jsp中的代码： 1234&lt;!-- 请求参数的示例 --&gt;&lt;a href="account/removeAccount?accountName=aaa&amp;money&gt;100"&gt;删除账户，金额 100&lt;/a&gt;&lt;br/&gt;&lt;a href="account/removeAccount?accountName=aaa&amp;money&gt;150"&gt;删除账户，金额 150&lt;/a&gt; 注意：当我们点击第一个超链接时,可以访问成功。当我们点击第二个超链接时，无法访问。如下图：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的事务控制与新特性]]></title>
    <url>%2F2019%2F06%2F06%2F2019-06-06-Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[目录 Spring事务控制中我们要明确的 Spring事务控制中的API介绍 基于XML的声明式事务控制 基于注解的配置方式 与JDK相关的升级 核心容器的更新 JetBrains Kotlin语言支持 响应式编程风格 Junit5的支持 依赖类库的更新 1. Spring事务控制中我们要明确的123第一：JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计 业务层的事务处理解决方案。第二：spring 框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在spring-tx-5.0.2.RELEASE.jar 中。第三：spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。 2. Spring事务控制中的API介绍2.1 PlatformTransactionManager此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法，如下图： 我们在开发中都是使用它的实现类 真正管理事务的对象 12org.springframework.jdbc.datasource.DataSourceTransactionManager 用 使用 Spring JDBC 或 或 iBatis 进行持久化数据时使用org.springframework.orm.hibernate5.HibernateTransactionManager 使用 Hibernate 2.2 TransactionDefinition它是事务的定义信息对象，里面有如下方法： 2.2.1 事务的隔离级别 2.2.2 事务的传播行为1234567REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起NEVER:以非事务方式运行，如果当前存在事务，抛出异常NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。 2.2.3 超时时间默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 2.2.4 是否是只读事务建议查询时设置为只读。 2.3 TransactionStatus此接口提供的是事务具体的运行状态，方法介绍如下图： 3. 基于XML的声明式事务控制3.1 环境搭建3.1.1 第一步：拷贝必要的jar包到工程的lib目录 3.1.2 第二步：创建Spring的配置文件并导入约束此处需要导入 aop 和 tx 两个名称空间 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 3.1.3 第三步：准备数据库表和实体类创建数据库： 12create database spring_day04;use spring_day04; 创建表： 12345create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 1234567891011121314151617181920212223242526272829303132/*** 账户的实体*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", name=" + name + ", money=" + money + "]"; &#125;&#125; 3.1.4 第四步：编写业务层接口和实现类123456789101112131415161718/*** 账户的业务层接口*/public interface IAccountService &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id);//查 /** * 转账 * @param sourceName 转出账户名称 * @param targeName 转入账户名称 * @param money 转账金额 */ void transfer(String sourceName,String targeName,Float money);//增删改&#125; 12345678910111213141516171819202122232425262728/*** 账户的业务层实现类*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 3.1.5 第五步：编写Dao接口和实现类123456789101112131415161718192021/*** 账户的 持久层 接口*/public interface IAccountDao &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 1234567891011121314151617181920212223242526272829/*** 账户的持久层实现类* 此版本 dao，只需要给它的父类注入一个数据源*/public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = getJdbcTemplate().query("select * from account where id = ? ",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = getJdbcTemplate().query("select * from account where name = ? ",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException("结果集不唯一，不是只有一个账户对象"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; getJdbcTemplate().update("update account set money = ? where id = ?",account.getMoney(),account.getId()); &#125;&#125; 1234567891011121314/*** 账户的封装类 RowMapper */public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt("id")); account.setName(rs.getString("name")); account.setMoney(rs.getFloat("money")); return account; &#125;&#125; 3.1.6 第六步：在配置文件中配置业务层和持久层对1234567891011121314151617&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;!-- 注入 dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day04"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.2 配置步骤3.2.1 第一步：配置事务管理器123456&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;!-- 注入 DataSource --&gt;&lt; property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 3.2.2 第二步：配置事务的通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;/tx:advice&gt; 3.2.3 第三步：配置事务的属性12345678910111213&lt;!--在 在 tx:advice 标签内部 配置事务的属性 --&gt;&lt;tx:attributes&gt;&lt;!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认 false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。--&gt; &lt;tx:method name="*" read-only="false" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" read-only="true" propagation="SUPPORTS"/&gt;&lt;/tx:attributes&gt; 3.2.4 第四步：配置AOP切入点表达式12345&lt;!-- 配置 aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))" id="pt1"/&gt;&lt;/aop:config&gt; 3.2.5 第五步：配置切入点表达式和事务通知的对应关系12&lt;!-- 在 在 aop:config 标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt; 4. 基于注解的配置方式4.1 搭建环境4.1.1 第一步：拷贝必备的jar包到工程的lib目录 4.1.2 第二步：创建Spring的配置文件导入约束并配置扫描的包1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置 JdbcTemplate--&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 spring 提供的内置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.1.3 第三步：创建数据库表和实体类和基于 xml 的配置相同。略 4.1.4 第四步：创建业务层接口和实现类并使用注解让Spring管理123456789/*** 账户的业务层实现类*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; //其余代码和基于 XML 的配置相同&#125; 4.1.5 第五步：创建Dao接口和实现类并使用注解让Spring管理12345678910/*** 账户的持久层实现类*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; //其余代码和基于 XML 的配置相同&#125; 4.2 配置步骤4.2.1 第一步：配置事务管理器并注入数据源12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 4.2.2 第二步：在业务层使用@Transactional注解123456789101112131415161718192021222324252627@Service("accountService")@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override @Transactional(readOnly=false,propagation=Propagation.REQUIRED) public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); //int i=1/0; accountDao.updateAccount(target); &#125;&#125; 12345该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。出现接口上，表示该接口的所有实现类都有事务支持。出现在类上，表示类中所有方法有事务支持出现在方法上，表示方法有事务支持。以上三个位置的优先级：方法&gt;类&gt;接口 4.2.3 第三步：在配置文件中开启Spring对注解事务的支持12&lt;!-- 开启 spring 对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 4.3 不使用xml的配置方式12345Configuration@EnableTransactionManagementpublic class SpringTxConfiguration &#123; //里面配置数据源，配置 JdbcTemplate,配置事务管理器。在之前的步骤已经写过了。&#125; 5. 与JDK相关的升级5.1 JDK版本要求：123456spring5.0 在 2017 年 9 月发布了它的 GA（通用）版本。该版本是基于 jdk8 编写的，所以 jdk8 以下版本将无法使用。同时，可以兼容 jdk9 版本。tomcat 版本要求 8.5 及以上。注： 我们使用 jdk8 构建工程，可以降版编译。但是不能使用 jdk8 以下版本构建工程。 由于 jdk 和 tomcat 版本的更新，我们的 IDE 也需要同时更新。(目前使用的 eclipse 4.7.2) 5.2 利用JDK8版本更新的内容第一：基于 JDK8 的反射增强 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566请看下面的代码：/**** @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Test &#123; //循环次数定义：10 亿次 private static final int loopCnt = 1000 * 1000 * 1000; public static void main(String[] args) throws Exception &#123; //输出 jdk 的版本 System.out.println("java.version=" + System.getProperty("java.version")); t1(); t2(); t3(); &#125; // 每次重新生成对象 public static void t1() &#123; long s = System.currentTimeMillis(); for (int i = 0; i &lt; loopCnt; i++) &#123; Person p = new Person(); p.setAge(31); &#125; long e = System.currentTimeMillis(); System.out.println("循环 10 亿次创建对象的时间：" + (e - s)); &#125; // 同一个对象 public static void t2() &#123; long s = System.currentTimeMillis(); Person p = new Person(); for (int i = 0; i &lt; loopCnt; i++) &#123; p.setAge(32); &#125; long e = System.currentTimeMillis(); System.out.println("循环 10 亿次给同一对象赋值的时间： " + (e - s)); &#125; //使用反射创建对象 public static void t3() throws Exception &#123; long s = System.currentTimeMillis(); Class&lt;Person&gt; c = Person.class; Person p = c.newInstance(); Method m = c.getMethod("setAge", Integer.class); for (int i = 0; i &lt; loopCnt; i++) &#123; m.invoke(p, 33); &#125; long e = System.currentTimeMillis(); System.out.println("循环 10 亿次反射创建对象的时间：" + (e - s)); &#125; static class Person &#123; private int age = 20; public int getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; &#125;&#125; jdk1.8 版本（就是 JDK8）运行时间如下： 当切换到 jdk1.7 版本之后，运行时间如下： 有此我们可以看出，在反射创建对象上，jdk8 确实做了加强。 第二：@NonNull 注解和@Nullable 注解的使用 1用 @Nullable 和 @NotNull 注解来显示表明可为空的参数和以及返回值。这样就够在编译的时候处理空值而不是在运行时抛出 NullPointerExceptions。 第三：日志记录方面 1Spring Framework 5.0 带来了 Commons Logging 桥接模块的封装, 它被叫做 spring-jcl 而不是标准的 Commons Logging。当然，无需任何额外的桥接，新版本也会对 Log4j 2.x, SLF4J, JUL( java.util.logging) 进行自动检测。 6. 核心容器的更新123456Spring Framework 5.0 现在支持候选组件索引作为类路径扫描的替代方案。该功能已经在类路径扫描器中添加，以简化添加候选组件标识的步骤。应用程序构建任务可以定义当前项目自己的 META-INF/spring.components 文件。在编译时，源模型是自包含的，JPA 实体和 Spring 组件是已被标记的。从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目是没有明显差异。但对大型项目影响较大。加载组件索引开销更低。因此，随着类数的增加，索引读取的启动时间将保持不变。加载组件索引的耗费是廉价的。因此当类的数量不断增长，加上构建索引的启动时间仍然可以维持一个常数,不过对于组件扫描而言，启动时间则会有明显的增长。这个对于我们处于大型 Spring 项目的开发者所意味着的，是应用程序的启动时间将被大大缩减。虽然 20或者 30 秒钟看似没什么，但如果每天要这样登上好几百次，加起来就够你受的了。使用了组件索引的话，就能帮助你每天过的更加高效。你可以在 Spring 的 Jira 上了解更多关于组件索引的相关信息。 7. JetBrains Kotlin语言支持Kolin概述：是一种支持函数式编程编程风格的面向对象语言。Kotlin 运行在 JVM 之上，但运行环境并不限于 JVM。 Kolin 的示例代码： 12345678910&#123; ("/movie" and accept(TEXT_HTML)).nest &#123; GET("/", movieHandler::findAllView) GET("/&#123;card&#125;", movieHandler::findOneView) &#125; ("/api/movie" and accept(APPLICATION_JSON)).nest &#123; GET("/", movieApiHandler::findAll) GET("/&#123;id&#125;", movieApiHandler::findOne) &#125;&#125; Kolin 注册 bean 对象到 spring 容器： 1234val context = GenericApplicationContext &#123; registerBean() registerBean &#123; Cinema(it.getBean()) &#125;&#125; 8. 响应式编程风格123456789此次 Spring 发行版本的一个激动人心的特性就是新的响应式堆栈 WEB 框架。这个堆栈完全的响应式且非阻塞，适合于事件循环风格的处理，可以进行少量线程的扩展。Reactive Streams 是来自于 Netflix, Pivotal, Typesafe, Red Hat, Oracle, Twitter 以及Spray.io 的工程师特地开发的一个 API。它为响应式编程实现的实现提供一个公共的 API，好实现Hibernate 的 JPA。这里 JPA 就是这个 API, 而 Hibernate 就是实现。Reactive Streams API 是 Java 9 的官方版本的一部分。在 Java 8 中, 你会需要专门引入依赖来使用 Reactive Streams API。Spring Framework 5.0 对于流式处理的支持依赖于 Project Reactor 来构建, 其专门实现了Reactive Streams API。Spring Framework 5.0 拥有一个新的 spring-webflux 模块，支持响应式 HTTP 和 WebSocket 客户端。Spring Framework 5.0 还提供了对于运行于服务器之上，包含了 REST, HTML, 以及 WebSocket 风格交互的响应式网页应用程序的支持。在 spring-webflux 中包含了两种独立的服务端编程模型： 基于注解：使用到了@Controller 以及 Spring MVC 的其它一些注解； 使用 Java 8 lambda 表达式的函数式风格的路由和处理。有 了 Spring Webflux, 你 现 在 可 以创建出 WebClient, 它是响应式且非阻塞的，可以 作为RestTemplate 的一个替代方案。 这里有一个使用 Spring 5.0 的 REST 端点的 WebClient 实现： 123456WebClient webClient = WebClient.create();Mono person = webClient.get() .uri(&quot;http://localhost:8080/movie/42&quot;) .accept(MediaType.APPLICATION_JSON) .exchange() .then(response -&gt; response.bodyToMono(Movie.class)); 9. Junit5的支持12345完全支持 JUnit 5 Jupiter，所以可以使用 JUnit 5 来编写测试以及扩展。此外还提供了一个编程以及扩展模型，Jupiter 子项目提供了一个测试引擎来在 Spring 上运行基于 Jupiter 的测试。另外，Spring Framework 5 还提供了在 Spring TestContext Framework 中进行并行测试的扩展。针对响应式编程模型， spring-test 现在还引入了支持 Spring WebFlux 的 WebTestClient 集成测试的支持，类似于 MockMvc，并不需要一个运行着的服务端。使用一个模拟的请求或者响应， WebTestClient就可以直接绑定到 WebFlux 服务端设施。你可以在这里找到这个激动人心的 TestContext 框架所带来的增强功能的完整列表。当然， Spring Framework 5.0 仍然支持我们的老朋友 JUnit! 在我写这篇文章的时候， JUnit 5 还只是发展到了 GA 版本。对于 JUnit4， Spring Framework 在未来还是要支持一段时间的。 10. 依赖类库的更新123456789101112131415终止支持的类库 Portlet. Velocity. JasperReports. XMLBeans. JDO. Guava.支持的类库 Jackson 2.6+ EhCache 2.10+ / 3.0 GA Hibernate 5.0+ JDBC 4.0+ XmlUnit 2.x+ OkHttp 3.x+ Netty 4.1+]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的JdbcTemplate]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04-Spring%E4%B8%AD%E7%9A%84JdbcTemplate%2F</url>
    <content type="text"><![CDATA[目录 JdbcTemplate概述 JdbcTemplate对象的创建 Spring中配置数据源 JdbcTemplate的增删改查操作 在dao中使用JdbcTemplate 1. JdbcTemplate概述它是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。spring 框架为我们提供了很多的操作模板类。 1234567操作关系型数据的： JdbcTemplate HibernateTemplate操作 nosql 数据库的： RedisTemplate操作消息队列的： JmsTemplate 我们今天的主角在 spring-jdbc-5.0.2.RELEASE.jar 中，我们在导包的时候，除了要导入这个 jar 包外，还需要导入一个 spring-tx-5.0.2.RELEASE.jar（它是和事务相关的）。 2. JdbcTemplate对象的创建我们可以参考它的源码，来一探究竟： 12345678910111213public JdbcTemplate() &#123;&#125;public JdbcTemplate(DataSource dataSource) &#123; setDataSource(dataSource); afterPropertiesSet();&#125;public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123; setDataSource(dataSource); setLazyInit(lazyInit); afterPropertiesSet();&#125; 除了默认构造函数之外，都需要提供一个数据源。既然有set方法，依据我们之前学过的依赖注入，我们可以在配置文件中配置这些对象。 3. Spring中配置数据源3.1 环境搭建 3.2 编写Spring的配置文件1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 3.3 配置数据源我们之前已经接触过了两个数据源，C3P0 和 DBCP。要想使用这两数据源都需要导入对应的 jar 包。 3.3.1 配置C3P0数据源导入到工程的 lib 目录。在 spring 的配置文件中配置： 123456&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.3.2 配置DBCP数据源导入到工程的 lib 目录。在 spring 的配置文件中配置： 1234567&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:// /spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.3.3 配置Spring内置数据源spring 框 架 也 提 供 了 一 个 内 置 数 据 源 ， 我 们 也 可 以 使 用 spring 的 内 置 数 据 源 ， 它 就 在spring-jdbc-5.0.2.REEASE.jar 包中： 1234567&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.4 将数据库连接的信息配置到属性文件中：【定义属性文件】 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///spring_day02jdbc.username=rootjdbc.password=123 【引入外部的属性文件】 一种方式: 12345&lt;!-- 引入外部属性文件： --&gt;&lt;beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"/&gt;&lt;/bean&gt; 另一种方式: 1&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; 4. JdbcTemplate的增删改查操作4.1 前期准备123456789创建数据库：create database spring_day02;use spring_day02;创建表：create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 4.2 在Spring配置文件中配置JdbcTemplate1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.3 最基本使用12345678910public class JdbcTemplateDemo2 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 jt.execute("insert into account(name,money)values('eee',500)"); &#125;&#125; 4.4 保存操作1234567891011public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //保存 jt.update("insert into account(name,money)values(?,?)","fff",5000); &#125;&#125; 4.5 更新操作1234567891011public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //修改 jt.update("update account set money = money-? where id = ?",300,6); &#125;&#125; 4.6 删除操作1234567891011public class JdbcTemplateDemo3 &#123;public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //删除 jt.update("delete from account where id = ?",6); &#125;&#125; 4.7 查询所有操作123456789101112131415161718192021222324252627public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query("select * from account where money &gt; ? ", new AccountRowMapper(), 500); for(Account o : accounts)&#123; System.out.println(o); &#125; &#125;&#125;public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt("id")); account.setName(rs.getString("name")); account.setMoney(rs.getFloat("money")); return account; &#125;&#125; 4.8 查询一个操作使用 RowMapper 12345678910111213public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询一个 List&lt;Account&gt; as = jt.query("select * from account where id = ? ", new AccountRowMapper(), 55); System.out.println(as.isEmpty()?"没有结果":as.get(0)); &#125;&#125; 使用 ResultSetExtractor 的方式: 12345678910111213public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询一个 Account account = jt.query("select * from account where id = ?", new AccountResultSetExtractor(),3); System.out.println(account); &#125;&#125; 4.9 查询返回一行一列操作12345678910111213public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询返回一行一列：使用聚合函数，在不使用 group by 字句时，都是返回一行一列。最长用的就是分页中获取总记录条数 Integer total = jt.queryForObject("select count(*) from account where money &gt; ? ",Integer.class,500); System.out.println(total); &#125;&#125; 5. 在dao中使用JdbcTemplate5.1 准备实体类1234567891011121314151617181920212223242526272829303132/*** 账户的实体*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", name=" + name + ", money=" + money + "]"; &#125;&#125; 5.2 第一种方式：在dao中定义JdbcTemplate123456789101112131415161718192021222324/*** 账户的接口*/public interface IAccountDao &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 123456789101112131415161718192021222324252627282930313233343536/*** 账户的持久层实现类* 此版本的 dao ，需要给 dao 注入 JdbcTemplate*/public class AccountDaoImpl implements IAccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account where id = ? ",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account where name = ? ",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException("结果集不唯一，不是只有一个账户对象"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update("update account set money = ? where id = ? ",account.getMoney(),account.getId()); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置一个 dao --&gt; &lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;!-- 注入 jdbcTemplate --&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day04"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 思考：此种方式有什么问题吗?答案：有个小问题。就是我们的 dao 有很多时，每个 dao 都有一些重复性的代码。下面就是重复代码： 1234private JdbcTemplate jdbcTemplate;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate;&#125; 能不能把它抽取出来呢？请看下一小节。 5.3 第二种方式：让dao继承JdbcDaoSupportJdbcDaoSupport 是spring 框架为我们提供的一个类，该类中定义了一个 JdbcTemplate 对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源：具体源码如下： 12345678910111213141516171819202122232425public abstract class JdbcDaoSupport extends DaoSupport &#123; //定义对象 private JdbcTemplate jdbcTemplate; //set 方法注入数据源，判断是否注入了，注入了就创建 JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; //如果提供了数据源就创建 JdbcTemplate this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; //使用数据源创建 JdcbTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; //当然，我们也可以通过注入 JdbcTemplate 对象 public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; //使用 getJdbcTmeplate 方法获取操作模板对象 public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 123456789101112131415161718192021/*** 账户的接口*/public interface IAccountDao &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 12345678910111213141516171819202122232425262728293031323334/*** 账户的持久层实现类* 此版本 dao，只需要给它的父类注入一个数据源*/public class AccountDaoImpl2 extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query("select * from account whereid = ? ",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query("select * from account wherename = ? ",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException("结果集不唯一，不是只有一个账户对象"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 getJdbcTemplate().update("update account set money = ? where id = ?",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 dao2 --&gt; &lt;bean id="accountDao2" class="com.itheima.dao.impl.AccountDaoImpl2"&gt; &lt;!-- 注入 dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day04"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 12345思考： 两版 Dao 有什么区别呢？答案： 在 第一种在 Dao 类中定义 JdbcTemplate 的方式，适用于所有配置方式（xml 和注解都可以）。 让 第二种让 Dao 继承 JdbcDaoSupport 的方式，只能用于基于 XML 的方式，注解用不了。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis快速入门]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-Redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 Redis介绍 Redis安装配置 Redis五种数据类型 Keys命令 Redis客户端 Redis的事务 Redis的持久化方案 Redis的主从复制 Redis的集群 1. Redis介绍1.1 问题的引入 ​ 1.2 NoSQL数据库概述为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。 NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。 它不遵循SQL标准、不支持ACID、远超SQL的性能。 1.3 NoSQL用在哪些地方 1.4 Nosql数据库分类1.4.1 缓存数据库 1.4.2 文档数据库 1.4.3 列式数据库 1.4.4 图关系数据库 1.5 数据库排名 1.6 什么是Redis1.6.1 Redis介绍Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 12345字符串类型散列类型列表类型集合类型有序集合类型。 1.6.2 Redis应用场景 2. Redis安装配置2.1 Redis下载官网地址：http://redis.io/ 下载地址：http://download.redis.io/releases/redis-3.0.0.tar.gz 在Linux中使用wget下载到linux或者下载到window在上传到linux 1wget http://download.redis.io/releases/redis-3.0.0.tar.gz 2.2 Redis安装Redis是C语言开发，建议在linux上运行，我们使用Centos6.5作为安装环境。 第一步：在VMware中安装CentOS 第二步：在Linux下安装gcc环境 12# yum install gcc-c++可以通过rpm -qa | grep gcc 来查询是否已经安装了gcc 第三步：将下载的Redis源码包上传到Linux服务器中【如果是linux直接下载的，就省略这个步骤】 第四步：解压缩Redis源码包 1# tar -zxf redis-3.0.0.tar.gz 【直接解压到当前文件夹】 第五步：编译redis源码 12# cd redis-3.0.0# make 第六步：安装redis 1# make install PREFIX=/usr/local/redis 2.3 Redis启动2.3.1 前端启动启动方式： 直接运行bin/redis-server将以前端模式启动。【bin目录是在/usr/local/redis/bin】 1# ./redis-server 启动缺点： ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法 启动图例： 前端启动的关闭： 1ctrl+c 2.3.2 后端启动第一步：将redis源码包中的redis.conf配置文件复制到/usr/local/redis/bin/下 12# cd /root/redis-3.0.0# cp redis.conf /usr/local/redis/bin/ 第二步：修改redis.conf，将daemonize由no改为yes 1# vi redis.conf 第三步：执行命令 1# ./redis-server redis.conf 后端启动的关闭方式 非正常关闭（不推荐使用）： 1# kill 5528 正常关闭： 1# ./redis-cli shutdown 3. Redis五种数据类型Mysql中声明字段有哪些：int,varchar,char,datetime….. Redis中存储数据是通过key-value存储的，对于value的类型有以下几种： 12345String字符串Hash类型ListSetSortedSet（zset） PS：在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的。 3.1 String类型3.1.1 命令1. 赋值语法：SET key value 12127.0.0.1:6379&gt; set test 123OK 2. 取值语法：GET key 12127.0.0.1:6379&gt; get test&quot;123“ 3. 设置/获取多个键值语法： MSET key value [key value …] MGET key [key …] 1234567127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; mget k1 k31) &quot;v1&quot;2) &quot;v3&quot; 4. 取值并赋值语法：GETSET key value 1234127.0.0.1:6379&gt; getset s2 222&quot;111&quot;127.0.0.1:6379&gt; get s2&quot;222&quot; 5. 删除语法：DEL key 12127.0.0.1:6379&gt; del test(integer) 1 6. 数值增减递增数字 当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 Auto_increment 语法：INCR key 123456127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; incr num(integer) 3 增加指定的整数 语法：INCRBY key increment 123456127.0.0.1:6379&gt; incrby num 2(integer) 5127.0.0.1:6379&gt; incrby num 2(integer) 7127.0.0.1:6379&gt; incrby num 2(integer) 9 递减数值 语法：DECR key 1234127.0.0.1:6379&gt; decr num(integer) 9127.0.0.1:6379&gt; decr num(integer) 8 减少指定的整数 语法：DECRBY key decrement 12345678127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5127.0.0.1:6379&gt; decrby num 3(integer) 2127.0.0.1:6379&gt; decrby num 3(integer) -1 7. 其他命令（自学）向尾部追加值 APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 语法：APPEND key value 123456127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; append str &quot; world!&quot;(integer) 12127.0.0.1:6379&gt; get str &quot;hello world!&quot; 获取字符串长度 STRLEN命令返回键值的长度，如果键不存在则返回0。 语法：STRLEN key 123456127.0.0.1:6379&gt; strlen str (integer) 0127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; strlen str (integer) 5 3.1.2 应用自增主键商品编号、订单号采用string的递增数字特性生成。 定义商品编号key：items:id 1234192.168.101.3:7003&gt; INCR items:id(integer) 2192.168.101.3:7003&gt; INCR items:id(integer) 3 3.2 Hash类型3.2.1 使用String的问题假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 保存、更新： 1User对象 --&gt; json(string) --&gt; redis 如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。 1User “&#123;“username”:”gyf”,”age”:”80”&#125;” 3.2.2 Redis hash介绍hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下： 3.2.3 命令1. 赋值HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。 一次只能设置一个字段值 语法：HSET key field value 12127.0.0.1:6379&gt; hset user username zhangsan (integer) 1 一次可以设置多个字段值 语法：HMSET key field value [field value ...] 12127.0.0.1:6379&gt; hmset user age 20 username lisi OK 当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作 语法：HSETNX key field value 12127.0.0.1:6379&gt; hsetnx user age 30 如果user中没有age字段则设置age值为30，否则不做任何操作(integer) 0 2. 取值一次只能获取一个字段值 语法：HGET key field 12127.0.0.1:6379&gt; hget user username&quot;zhangsan“ 一次可以获取多个字段值 语法：HMGET key field [field ...] 123127.0.0.1:6379&gt; hmget user age username1) &quot;20&quot;2) &quot;lisi&quot; 获取所有字段值 语法：HGETALL key 12345127.0.0.1:6379&gt; hgetall user1) &quot;age&quot;2) &quot;20&quot;3) &quot;username&quot;4) &quot;lisi&quot; 3. 删除字段可以删除一个或多个字段，返回值是被删除的字段个数 语法：HDEL key field [field...] 123456127.0.0.1:6379&gt; hdel user age(integer) 1127.0.0.1:6379&gt; hdel user age name(integer) 0127.0.0.1:6379&gt; hdel user age username(integer) 1 4. 增加数字语法：HINCRBY key field increment 1234127.0.0.1:6379&gt; hincrby user age 2 将用户的年龄加2(integer) 22127.0.0.1:6379&gt; hget user age 获取用户的年龄&quot;22“ 5. 其他命令（自学）判断字段是否存在 语法：HEXISTS key field 1234127.0.0.1:6379&gt; hexists user age 查看user中是否有age字段(integer) 1127.0.0.1:6379&gt; hexists user name 查看user中是否有name字段(integer) 0 只获取字段名或字段值 语法： HKEYS key HVALS key 12345678127.0.0.1:6379&gt; hmset user age 20 name lisi OK127.0.0.1:6379&gt; hkeys user1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; hvals user1) &quot;20&quot;2) &quot;lisi&quot; 获取字段数量 语法：HLEN key 12127.0.0.1:6379&gt; hlen user(integer) 2 3.2.4 应用存储商品信息商品字段 1【商品id、商品名称、商品描述、商品库存、商品好评】 定义商品信息的key 1商品1001的信息在 Redis中的key为：[items:1001] 存储商品信息 12192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9OK 获取商品信息 123456789192.168.101.3:7003&gt; HGET items:1001 id&quot;3&quot;192.168.101.3:7003&gt; HGETALL items:10011) &quot;id&quot;2) &quot;3&quot;3) &quot;name&quot;4) &quot;apple&quot;5) &quot;price&quot;6) &quot;999.9&quot; 3.3 List类型3.3.1 ArrayList与LinkedList的区别ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。 LinkedList使用双向链表方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快。然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。 3.3.2 Redis list介绍列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。 列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。通过索引下标的操作中间的节点性能会较差。 3.3.3 命令1.向列表两端添加元素向列表左边增加元素 语法：LPUSH key value [value ...] 12127.0.0.1:6379&gt; lpush list:1 1 2 3(integer) 3 向列表右边增加元素 语法：RPUSH key value [value ...] 12127.0.0.1:6379&gt; rpush list:1 4 5 6(integer) 3 2. 查看列表LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 语法：LRANGE key start stop 1234127.0.0.1:6379&gt; lrange list:1 0 21) &quot;2&quot;2) &quot;1&quot;3) &quot;4&quot; 3. 从列表两端弹出元素LPOP命令从列表左边弹出一个元素，会分两步完成： 第一步是将列表左边的元素从列表中移除 第二步是返回被移除的元素值。 语法： LPOP key RPOP key 1234127.0.0.1:6379&gt; lpop list:1&quot;3“127.0.0.1:6379&gt; rpop list:1&quot;6“ 4. 获取列表中元素的个数语法：LLEN key 12127.0.0.1:6379&gt; llen list:1(integer) 2 5. 其它命令(自学)删除列表中指定的值 LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 123当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 语法：LREM key count value 获得/设置指定索引的元素值 语法：LINDEX key index 12127.0.0.1:6379&gt; lindex l:list 2&quot;1&quot; 设置指定索引的元素值 语法：LSET key index value 1234567127.0.0.1:6379&gt; lset l:list 2 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;2&quot;4) &quot;2&quot; 只保留列表指定片段 指定范围和LRANGE一致 语法：LTRIM key start stop 1234567891011127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;4) &quot;2&quot;127.0.0.1:6379&gt; ltrim l:list 0 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot; 向列表中插入元素 该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 语法：LINSERT key BEFORE|AFTER pivot value 1234567891011127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot; 将元素从一个列表转移到另一个列表中 语法：RPOPLPUSH source destination 12345678127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot; 3.3.4 应用商品评论列表1234思路：在Redis中创建商品评论列表用户发布商品评论，将评论信息转成json存储到list中。用户在页面查询评论列表，从redis中取出json数据展示到页面。 定义商品评论列表key： 商品编号为1001的商品评论key【items: comment:1001】 1192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289&#125;&apos; 3.4 Set类型3.4.1 Redis set介绍集合中的数据是不重复且没有顺序。 集合类型和列表类型的对比： 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 Redis还提供了多个集合之间的交集、并集、差集的运算。 3.4.2 命令1. 增加/删除元素语法：SADD key member [member ...] 1234127.0.0.1:6379&gt; sadd set a b c(integer) 3127.0.0.1:6379&gt; sadd set a(integer) 0 语法：SREM key member [member ...] 12127.0.0.1:6379&gt; srem set c d(integer) 1 2. 获取集合中的所有元素语法：SMEMBERS key 123127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a” 3. 判断元素是否在集合中语法：SISMEMBER key member 1234127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; sismember set h(integer) 0 3.4.3 运算命令1. 集合的差集运算 A-B属于A并且不属于B的元素构成的集合。 语法：SDIFF key [key ...] 12345678127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot;127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot; 2. 集合的交集运算 A ∩ B属于A且属于B的元素构成的集合。 语法：SINTER key [key ...] 123127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot;2) &quot;3&quot; 3. 集合的并集运算 A∪ B属于A或者属于B的元素构成的集合 语法：SUNION key [key ...] 12345127.0.0.1:6379&gt; sunion setA setB1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot; 3.4.4 其他命令(自学)获得集合中元素的个数 语法：SCARD key 123456127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; scard setA (integer) 3 从集合中弹出一个元素 注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 语法：SPOP key 12127.0.0.1:6379&gt; spop setA &quot;1“ 3.5 SortedSet类型zset3.5.1 redis sorted set介绍在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 在某些方面有序集合和列表类型有些相似。 121、二者都是有序的。 2、二者都可以获得某一范围的元素。 但是，二者有着很大区别： 12341、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 4、有序集合要比列表类型更耗内存。 3.5.2 命令1. 增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 语法：ZADD key score member [score member ...] 1234127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0 2. 获取元素的分数语法：ZSCORE key member 12127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot; 3. 删除元素移除有序集key中的一个或多个成员，不存在的成员将被忽略。 当key存在但不是有序集类型时，返回一个错误。 语法：ZREM key member [member ...] 12127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1 4. 获得排名在某个范围的元素列表获得排名在某个范围的元素列表 按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：ZRANGE key start stop [WITHSCORES] 1234127.0.0.1:6379&gt; zrange scoreboard 0 21) &quot;zhangsan&quot;2) &quot;wangwu&quot;3) &quot;lisi“ 按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：ZREVRANGE key start stop [WITHSCORES] 1234127.0.0.1:6379&gt; zrevrange scoreboard 0 21) &quot; lisi &quot;2) &quot;wangwu&quot;3) &quot; zhangsan “ 如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 12345127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES1) &quot;zhangsan&quot;2) &quot;80&quot;3) &quot;wangwu&quot;4) &quot;94&quot; 5. 其他命令(自学)获得指定分数范围的元素 语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 12345678127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;3) &quot;lisi&quot;4) &quot;97&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot;2) &quot;lisi&quot; 增加某个元素的分数 返回值是更改后的分数 语法：ZINCRBY key increment member 12127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“ 获得集合中元素的数量 语法：ZCARD key 12127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3 获得指定分数范围内的元素个数 语法：ZCOUNT key min max 12127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1 按照排名范围删除元素 语法：ZREMRANGEBYRANK key start stop 1234127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot; 按照分数范围删除元素 语法：ZREMRANGEBYSCORE key min max 1234127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1 获取元素的排名从小到大 语法：ZRANK key member 12127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0 从大到小 语法：ZREVRANK key member 12127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1 3.5.3 应用商品销售排行榜12需求：根据商品销售量对商品进行排行显示思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。 写入商品销售量： 商品编号1001的销量是9，商品编号1002的销量是10 1192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002 商品编号1001的销量加1 1192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001 商品销量前10名： 1192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores 4. Keys命令4.1 设置key的生存时间Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 1234EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除TTL key 查看key生于的生存时间PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 例子： 123456789101112192.168.101.3:7002&gt; set test 1 设置test的值为1OK192.168.101.3:7002&gt; get test 获取test的值&quot;1&quot;192.168.101.3:7002&gt; EXPIRE test 5 设置test的生存时间为5秒(integer) 1192.168.101.3:7002&gt; TTL test 查看test的生于生成时间还有1秒删除(integer) 1192.168.101.3:7002&gt; TTL test(integer) -2192.168.101.3:7002&gt; get test 获取test的值，已经删除(nil) 4.2 其他命令(自学)keys 返回满足给定pattern 的所有key 123456redis 127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot; exists 确认一个key 是否存在 示例：从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的 12345redis 127.0.0.1:6379&gt; exists HongWan(integer) 0redis 127.0.0.1:6379&gt; exists age(integer) 1redis 127.0.0.1:6379&gt; del 删除一个key 1234redis 127.0.0.1:6379&gt; del age(integer) 1redis 127.0.0.1:6379&gt; exists age(integer) 0 rename 重命名key 示例：age 成功的被我们改名为age_new 了 1234567redis 127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;redis 127.0.0.1:6379[1]&gt; rename age age_newOKredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age_new&quot;redis 127.0.0.1:6379[1]&gt; type 返回值的类型 示例：这个方法可以非常简单的判断出值的类型 1234567redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlistredis 127.0.0.1:6379&gt; 5. Redis客户端5.1 Redis自带的客户端 指定主机和端口 12# ./redis-cli -h 127.0.0.1 -p 6379127.0.0.1:6379&gt; exit 【退出】 12-h：redis服务器的ip地址-p：redis实例的端口号 如果不指定主机和端口也可以 1# ./redis-cli 12默认主机地址是127.0.0.1 默认端口是6379 5.2 图形界面客户端(了解)前提：需要安装图形界面管理器【redis-desktop-manager-0.8.0.3841.exe】 5.2.1 连接超时解决远程连接redis服务，需要关闭或者修改防火墙配置。 123将修改后的端口添加到防火墙中./sbin/iptables -I INPUT -p tcp --dport 8081 -j ACCEPT/etc/rc.d/init.d/iptables save 第一步：编辑iptables 1#vim /etc/sysconfig/iptables 在命令模式下，选定要复制的那一行的末尾，然后点击键盘yyp，就完成复制，然后修改。 第二步：重启防火墙 1# service iptables restart 注意：默认一共是16个数据库，每个数据库之间是相互隔离。数据库的数量是在redis.conf中配置的。 切换数据库使用命令：select 数据库编号 例如：select 1【相当于mysql 的use databasename】 5.3 Java客户端Jedis5.3.1 Jedis介绍Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。 Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 5.3.2 添加jar包12Commons-pool-1.6.jarJedis-2.1.0.jar 5.3.3 单实例连接1234567891011121314@Testpublic void testJedis() &#123; //创建一个Jedis的连接 Jedis jedis = new Jedis("127.0.0.1", 6379); jedis.select(1);//设置数据库 //执行redis命令 jedis.set("mytest", "hello world, this is jedis client!"); //从redis中取值 String result = jedis.get("mytest"); //打印结果 System.out.println(result); //关闭连接 jedis.close(); &#125; 5.3.4 连接池连接1234567891011121314@Testpublic void testJedisPool() &#123; //创建一连接池对象 JedisPool jedisPool = new JedisPool("127.0.0.1", 6379); //从连接池中获得连接 Jedis jedis = jedisPool.getResource(); String result = jedis.get("mytest"); System.out.println(result); //关闭连接 jedis.close(); //关闭连接池 jedisPool.close();&#125; 5.3.5 Spring整合jedisPool（自学）添加spring的jar包 配置spring配置文件applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="close"&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig" /&gt; &lt;constructor-arg name="host" value="192.168.242.130" /&gt; &lt;constructor-arg name="port" value="6379" /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码 12345678910111213141516171819@Test public void testJedisPool() &#123; JedisPool pool = (JedisPool) applicationContext.getBean("jedisPool"); Jedis jedis = null; try &#123; jedis = pool.getResource(); jedis.set("name", "lisi"); String name = jedis.get("name"); System.out.println(name); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; // 关闭连接 jedis.close(); &#125; &#125; &#125; Jedis测试： 完成一个手机验证码功能 1234要求： 1、输入手机号，点击发送后随机生成6位数字码，2分钟有效 2、输入验证码，点击验证，返回成功或失败 3、每个手机号每天只能输入3次 6. Redis的事务6.1 什么是事务Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队 6.2 命令 6.3 事务的错误管理 6.4 为什么要有事务12想想一个场景： 有很多人有你的账户,同时去参加双十一抢购 用乐观锁和悲观锁来解决事务冲突问题 123悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。 WATCH key [key …] 在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 unwatch 取消 WATCH 命令对所有 key 的监视。 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。 Redis事务秒杀案例 7. Redis的持久化方案Redis 提供了2个不同形式的持久化方式。 12RDB （Redis DataBase）AOF （Append Of File） 7.1 RDB持久化RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。 RDB是Redis默认采用的持久化方式。 1234rdb的保存策略 save 900 1 save 300 10 save 60 10000 7.1.1 持久化条件配置save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。 “save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照。 “save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。 7.1.2 配置快照文件目录配置dir指定rdb快照文件的位置，默认为Redis启动时命令行所在的目录下。 12# Note that you must specify a directory here, not a file name.dir ./ 7.1.3 配置快照文件的名称设置dbfilename指定rdb快照文件的名称 12# The filename where to dump the DBdbfilename dump.rdb Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 7.1.4 问题总结通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。 如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 7.2 AOF持久化默认情况下Redis没有开启AOF（append only file）方式的持久化，【操作一次就写一次数据】 可以通过修改redis.conf配置文件中的appendonly参数开启 1appendonly yes 开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。 AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。 1dir ./ 默认的文件名是appendonly.aof，可以通过appendfilename参数修改： 1appendfilename appendonly.aof 重启服务，再添加数据，然后会有一个aof文件,然后分析appendonly.aof文件内容 12345[root@A01 bin]# ./redis-cli shutdown[root@A01 bin]# ./redis-server redis.conf[root@A01 bin]# ./redis-cli127.0.0.1:6379&gt; set ip 192.168.1.1OK AOF和RDB同时开启，redis听谁的？ AOF和RDB同时开启，系统默认取AOF的数据 8. Redis的主从复制8.1 什么是是主从复制持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明： 主redis中的数据有三个副本（replication）即从redis1、从redis2和从redis3，即使一台redis服务器宕机其它三台redis服务也可以继续提供服务。 主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。 只有一个主redis，可以有多个从redis。 主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求 一个redis可以即是主又是从，如下图： 8.2 主从配置8.2.1 主redis配置无需特殊配置。 8.2.2 从机redis配置第一步：复制出一个从机 1cp bin/ bin2 –r 第二步：修改从机的redis.conf,配置slaveof 为主机的ip地址和端口号 第三步：修改从机的port地址为6380 在redis.conf中修改 第四步：清除从机中的持久化文件 1rm -rf appendonly.aof dump.rdb 第五步：启动从机【一定要使用配置文件启动,否则还是使用默认的端口】,如图，有两个redis服务启动 1./redis-server redis.conf 第六步：启动6380的客户端【不指定端口，默认访问的还是6379的服务】 1# ./redis-cli -p 6380 注意： ​ 主机一旦发生增删改操作，那么主机会将数据同步到从机中 ​ 从机不能执行写操作 12127.0.0.1:6380&gt; set s2 222(error) READONLY You can&apos;t write against a read only slave. 9. Redis的集群9.1 redis-cluster【集群】架构图 123456架构细节:(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可(4)redis-cluster把所有的物理节点映射到[0-16383]slot槽上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;valueRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点 示例如下： 9.2 redis-cluster投票:容错 1234(1)集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超时(cluster-node-timeout),认为该master节点挂掉.(2):什么时候整个集群不可用(cluster_state:fail)? 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。 9.3 搭建Ruby环境redis集群管理工具redis-trib.rb依赖ruby环境，首先需要安装ruby环境。 安装ruby 12# yum install ruby# yum install rubygems 使用工具上传redis-3.0.0.gem至/usr/local下 安装ruby和redis的接口程序 1# gem install /usr/local/redis-3.0.0.gem 将Redis集群搭建脚本文件复制到/usr/local/redis/redis-cluster目录下 12# cd /root/redis-3.0.0/src/# ll *.rb【查看rb文件】 1# cp redis-trib.rb /usr/local/redis/rediscluster/ -r 9.4 集群的搭建过程搭建集群最少也得需要3台主机，如果每台主机再配置一台从机的话，则最少需要6台机器。端口设计如下：7001-7006 第一步：复制出一个7001机器 1[root@A001 redis]# cp bin ./redis-cluster/7001 –r 第二步：如果存在持久化文件，则删除 1[root@A001 7001]# rm -rf appendonly.aof dump.rdb 第三步：设置集群参数 第四步：修改端口 第五步：复制出7002-7006机器 12345[root@A001 redis-cluster]# cp 7001/ 7002 -r[root@A001 redis-cluster]# cp 7001/ 7003 -r[root@A001 redis-cluster]# cp 7001/ 7004 -r[root@A001 redis-cluster]# cp 7001/ 7005 -r[root@A001 redis-cluster]# cp 7001/ 7006 –r 第六步：修改7002-7006机器的端口 第七步：启动7001-7006这六台机器 1[root@A001redis-cluster]#vi startall.sh 【然后输入上面的内容，保存并退出】 第八步：修改startall.sh文件的权限 12[root@A001 redis-cluster]# chmod u+x startall.sh[root@A001 redis-cluster]# ./startall.sh 第九步：创建集群 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@A001 redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.242.137:7001 192.168.242.137:7002 192.168.242.137:7003 192.168.242.137:7004 192.168.242.137:7005 192.168.242.137:7006&gt;&gt;&gt; Creating clusterConnecting to node 192.168.242.137:7001: OKConnecting to node 192.168.242.137:7002: OKConnecting to node 192.168.242.137:7003: OKConnecting to node 192.168.242.137:7004: OKConnecting to node 192.168.242.137:7005: OKConnecting to node 192.168.242.137:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.242.137:7001192.168.242.137:7002192.168.242.137:7003Adding replica 192.168.242.137:7004 to 192.168.242.137:7001Adding replica 192.168.242.137:7005 to 192.168.242.137:7002Adding replica 192.168.242.137:7006 to 192.168.242.137:7003M: 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24 192.168.242.137:7001 slots:0-5460 (5461 slots) masterM: 4f52a974f64343fd9f1ee0388490b3c0647a4db7 192.168.242.137:7002 slots:5461-10922 (5462 slots) masterM: cb7c5def8f61df2016b38972396a8d1f349208c2 192.168.242.137:7003 slots:10923-16383 (5461 slots) masterS: 66adf006fed43b3b5e499ce2ff1949a756504a16 192.168.242.137:7004 replicates 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24S: cbb0c9bc4b27dd85511a7ef2d01bec90e692793b 192.168.242.137:7005 replicates 4f52a974f64343fd9f1ee0388490b3c0647a4db7S: a908736eadd1cd06e86fdff8b2749a6f46b38c00 192.168.242.137:7006 replicates cb7c5def8f61df2016b38972396a8d1f349208c2Can I set the above configuration? (type &apos;yes&apos; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join..&gt;&gt;&gt; Performing Cluster Check (using node 192.168.242.137:7001)M: 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24 192.168.242.137:7001 slots:0-5460 (5461 slots) masterM: 4f52a974f64343fd9f1ee0388490b3c0647a4db7 192.168.242.137:7002 slots:5461-10922 (5462 slots) masterM: cb7c5def8f61df2016b38972396a8d1f349208c2 192.168.242.137:7003 slots:10923-16383 (5461 slots) masterM: 66adf006fed43b3b5e499ce2ff1949a756504a16 192.168.242.137:7004 slots: (0 slots) master replicates 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24M: cbb0c9bc4b27dd85511a7ef2d01bec90e692793b 192.168.242.137:7005 slots: (0 slots) master replicates 4f52a974f64343fd9f1ee0388490b3c0647a4db7M: a908736eadd1cd06e86fdff8b2749a6f46b38c00 192.168.242.137:7006 slots: (0 slots) master replicates cb7c5def8f61df2016b38972396a8d1f349208c2[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@A001 redis-cluster]# 9.5 连接集群命令： 1./redis-cli –h 127.0.0.1 –p 7001 -c【c表示集群方式连接】 9.6 查看集群状态123456789101112127.0.0.1:7003&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:3cluster_stats_messages_sent:926cluster_stats_messages_received:926 查看集群中的节点：【可以杀死一个节点，来看节点的数据】 12345678127.0.0.1:7003&gt; cluster nodes7a12bc730ddc939c84a156f276c446c28acf798c 127.0.0.1:7002 master - 0 1443601739754 2 connected 5461-1092293f73d2424a796657948c660928b71edd3db881f 127.0.0.1:7003 myself,master - 0 0 3 connected 10923-16383d8f6a0e3192c905f0aad411946f3ef9305350420 127.0.0.1:7001 master - 0 1443601741267 1 connected 0-54604170a68ba6b7757e914056e2857bb84c5e10950e 127.0.0.1:7006 slave 93f73d2424a796657948c660928b71edd3db881f 0 1443601739250 6 connectedf79802d3da6b58ef6f9f30c903db7b2f79664e61 127.0.0.1:7004 slave d8f6a0e3192c905f0aad411946f3ef9305350420 0 1443601742277 4 connected0bc78702413eb88eb6d7982833a6e040c6af05be 127.0.0.1:7005 slave 7a12bc730ddc939c84a156f276c446c28acf798c 0 1443601740259 5 connected127.0.0.1:7003&gt; 9.7 维护节点（自学）9.7.1 添加主节点集群创建成功后可以向集群中添加节点，下面是添加一个master主节点添加7007结点作为新节点 1执行命令：./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001 查看集群结点发现7007已添加到集群中 9.7.2 hash槽重新分配添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据。 查看集群中槽占用情况 redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。 给刚添加的7007结点分配槽 第一步：连接上集群（连接集群中任意一个可用结点都行） 1root@A001 redis]# ./redis-trib.rb reshard 192.168.101.3:7001 第二步：输入要分配的槽数量 1输入：500，表示要分配500个槽 第三步：输入接收槽的结点id 123输入：15b809eadae88955e36bcdbb8144f61bbbaf38fbPS：这里准备给7007分配槽，通过cluster nodes查看7007结点id为：15b809eadae88955e36bcdbb8144f61bbbaf38fb 第四步：输入源结点id 1输入：all 第五步：输入yes开始移动槽到目标结点id 1输入：yes 9.7.3 添加从节点集群创建成功后可以向集群中添加节点，下面是添加一个slave从节点。 添加7008从结点，将7008作为7007的从结点 1命令：./redis-trib.rb add-node --slave --master-id 主节点id 新节点的ip和端口 旧节点ip和端口 执行如下命令： 1./redis-trib.rb add-node --slave --master-id cad9f7413ec6842c971dbcc2c48b4ca959eb5db4 192.168.101.3:7008 192.168.101.3:7001 1cad9f7413ec6842c971dbcc2c48b4ca959eb5db4 是7007结点的id，可通过cluster nodes查看。 注意：如果原来该结点在集群中的配置信息已经生成到cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错： 1[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0 1解决方法是删除生成的配置文件nodes.conf，删除后再执行./redis-trib.rb add-node指令 查看集群中的结点，刚添加的7008为7007的从节点： 9.7.4 删除结点1命令：./redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017 删除已经占有hash槽的结点会失败，报错如下： 1[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again. 需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）。 10. Jedis连接集群10.1 防火墙配置12345678910111213141516171819202122[root@localhost-0723 bin]# service iptables stop-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 6380 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7001 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7002 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7003 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7004 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7005 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7006 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT~ &quot;/etc/sysconfig/iptables&quot; 22L, 1079C 已写入 [root@localhost-0723 bin]# service iptables restartiptables：应用防火墙规则： [确定][root@localhost-0723 bin]# 10.2 代码实现创建JedisCluster类连接redis集群。 123456789101112131415161718@Testpublic void testJedisCluster() throws Exception &#123; //创建一连接，JedisCluster对象,在系统中是单例存在 Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;(); nodes.add(new HostAndPort("127.0.0.1", 7001)); nodes.add(new HostAndPort("127.0.0.1", 7002)); nodes.add(new HostAndPort("127.0.0.1", 7003)); nodes.add(new HostAndPort("127.0.0.1", 7004)); nodes.add(new HostAndPort("127.0.0.1", 7005)); nodes.add(new HostAndPort("127.0.0.1", 7006)); JedisCluster cluster = new JedisCluster(nodes); //执行JedisCluster对象中的方法，方法和redis一一对应。 cluster.set("cluster-test", "my jedis cluster test"); String result = cluster.get("cluster-test"); System.out.println(result); //程序结束时需要关闭JedisCluster对象 cluster.close();&#125; 10.3 使用Spring配置applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 连接池配置 --&gt;&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="true" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt;&lt;/bean&gt;&lt;!-- redis集群 --&gt;&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg index="0"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7001"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7002"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7003"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7004"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7005"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7006"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 测试代码 12345678910111213141516private ApplicationContext applicationContext; @Before public void init() &#123; applicationContext = new ClassPathXmlApplicationContext( "classpath:applicationContext.xml"); &#125; // redis集群 @Test public void testJedisCluster() &#123; JedisCluster jedisCluster = (JedisCluster) applicationContext .getBean("jedisCluster"); jedisCluster.set("name", "zhangsan"); String value = jedisCluster.get("name"); System.out.println(value); &#125;]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的AOP]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-Spring%E4%B8%AD%E7%9A%84AOP%2F</url>
    <content type="text"><![CDATA[目录 Spring中的AOP的细节 基于XML的AOP配置 基于注解的AOP配置 1. Spring中的AOP的细节1.1 说明我们学习 spring 的 aop，就是通过配置的方式，实现上一章节的功能。 1.2 AOP相关术语123456789101112131415161718Joinpoint( 连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。Pointcut( 切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。Advice( 通知/ 增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction( 引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。Target( 目标对象):代理的目标对象。Weaving( 织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。Proxy （代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。Aspect( 切面):是切入点和通知（引介）的结合。 1.3 学习Spring中的AOP要明确的事123456a 、开发阶段（我们做的）编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP 编程人员来做。在配置文件中，声明切入点与通知间的关系，即切面。：AOP 编程人员来做。b 、运行阶段（Spring 框架完成的）Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 1.4 关于代理的选择在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 2. 基于XML的AOP配置123示例： 我们在学习 spring 的 aop 时，采用账户转账作为示例。 并且把 spring 的 ioc 也一起应用进来。 2.1 环境搭建2.1.1 第一步：准备必要的代码此处包含了实体类，业务层和持久层代码。我们沿用上一章节中的代码即可。 2.1.2 第二步：拷贝必备的jar包到工程的lib目录此处要拷贝 spring 的 ioc 和 aop 两组 jar 包 2.1.3 第三步：创建Spring的配置文件并导入约束此处要导入 aop 的约束 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 2.1.4 第四步：配置Spring的IOC123456789101112131415161718192021222324&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据库操作对象 --&gt;&lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 指定 connection 和线程绑定 --&gt; &lt;property name="useCurrentConnection" value="true"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 2.1.5 第五步：抽取公共代码制作成通知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class TransactionManager &#123; //定义一个 DBAssit private DBAssit dbAssit ; public void setDbAssit(DBAssit dbAssit) &#123; this.dbAssit = dbAssit; &#125; //开启事务 public void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //提交事务 public void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //回滚事务 public void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //释放资源 public void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.2 配置步骤2.2.1 第一步：把通知类bean标签配置起来1234&lt;!-- 配置通知 --&gt;&lt;bean id="txManager" class="com.itheima.utils.TransactionManager"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2 第二步：使用aop:config声明aop配置aop:config:作用：用于声明开始 aop 的配置 123&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt;&lt;/aop:config&gt; 2.2.3 第三步：使用aop:aspect配置切面aop:aspect:作用：用于配置切面。属性：id：给切面提供一个唯一标识。ref：引用配置好的通知类 bean 的 id。 123&lt;aop:aspect id="txAdvice" ref="txManager"&gt; &lt;!--配置通知的类型要写在此处--&gt;&lt;/aop:aspect&gt; 2.2.4 第四步：使用aop:pointcut配置切入点表达式aop:pointcut ：作用：用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。属性：expression：用于定义切入点表达式。id：用于给切入点表达式提供一个唯一标识 1234&lt;aop:pointcut expression="execution( public void com.itheima.service.impl.AccountServiceImpl.transfer( java.lang.String, java.lang.String, java.lang.Float))" id="pt1"/&gt; 2.2.5 第五步：使用aop:xxx配置对应的通知类型aop:before作用：用于配置前置通知。指定增强的方法在切入点方法之前执行属性：method:用于指定通知类中的增强方法名称ponitcut-ref：用于指定切入点的表达式的引用poinitcut：用于指定切入点表达式执行时间点：切入点方法执行之前执行 1&lt;aop:before method="beginTransaction" pointcut-ref="pt1"/&gt; aop:after-returning 作用：用于配置后置通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 1&lt;aop:after-returning method="commit" pointcut-ref="pt1"/&gt; aop:after-throwing作用：用于配置异常通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个 1&lt;aop:after-throwing method="rollback" pointcut-ref="pt1"/&gt; aop:after作用：用于配置最终通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 1&lt;aop:after method="release" pointcut-ref="pt1"/&gt; 2.3 切入点表达式说明123456789101112131415161718192021222324252627execution:匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式：public void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 访问修饰符可以省略void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 返回值可以使用*号，表示任意返回值* com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 包名可以使用*号，表示任意包，但是有几级包，需要写几个** *.*.*.*.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 使用..来表示当前包，及其子包* com..AccountServiceImpl.saveAccount(com.itheima.domain.Account) 类名可以使用*号，表示任意类* com..*.saveAccount(com.itheima.domain.Account) 方法名可以使用*号，表示任意方法* com..*.*( com.itheima.domain.Account) 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数* com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型* com..*.*(..) 全通配方式：* *..*.*(..)注： 通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。 execution(* com.itheima.service.impl.*.*(..)) 2.4 环绕通知配置方式: 12345678&lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))"id="pt1"/&gt; &lt;aop:aspect id="txAdvice" ref="txManager"&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method="transactionAround" pointcut-ref="pt1"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567891011aop:around ： 作用： 用于配置环绕通知 属性： method：指定通知中方法的名称。 pointcut：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 说明： 它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意： 通常情况下，环绕通知都是独立使用的 1234567891011121314151617181920212223242526272829/*** 环绕通知* @param pjp* spring 框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。* 在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。* @return*/public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3. 基于注解的AOP配置3.1 环境搭建3.1.1 第一步：准备必要的代码和jar包拷贝上一小节的工程即可。 3.1.2 第二步：再配置文件中导入context的名称空间123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置数据库操作对象 --&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 指定 connection 和线程绑定 --&gt; &lt;property name="useCurrentConnection" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.1.3 第三步：把资源使用注解配置123456789101112/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao;&#125; 123456789101112/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private DBAssit dbAssit ;&#125; 3.1.4 第四步：在配置文件指定Spring要扫描的包12&lt;!-- 告知 spring，在创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; 3.2 配置步骤3.2.1 第一步：把通知类也使用注解配置123456789101112/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("txManager")public class TransactionManager &#123; //定义一个 DBAssit @Autowired private DBAssit dbAssit ;&#125; 3.2.2 第二步：在通知类使用@Aspect注解声明为切面作用：把当前类声明为切面类。 1234567891011121314/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("txManager")@Aspect//表明当前类是一个切面类public class TransactionManager &#123; //定义一个 DBAssit @Autowired private DBAssit dbAssit ;&#125; 3.2.3 第三步：在增强的方法上使用注解配置通知12345@Before 作用： 把当前方法看成是前置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 123456789//开启事务@Before("execution(* com.itheima.service.impl.*.*(..))")public void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@AfterReturning 作用： 把当前方法看成是后置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//提交事务@AfterReturning("execution(* com.itheima.service.impl.*.*(..))")public void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@AfterThrowing 作用： 把当前方法看成是异常通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//回滚事务@AfterThrowing("execution(* com.itheima.service.impl.*.*(..))")public void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@After 作用： 把当前方法看成是最终通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//释放资源@After("execution(* com.itheima.service.impl.*.*(..))")public void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.2.4 第四步：在Spring配置文件中开启Spring对注解AOP的支持12&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;&lt;aop:aspectj-autoproxy/&gt; 3.3 环绕通知注解配置12345@Around 作用： 把当前方法看成是环绕通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 12345678910111213141516171819202122232425262728/*** 环绕通知* @param pjp* @return*/@Around("execution(* com.itheima.service.impl.*.*(..))")public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3.4 切入点表达式注解12345@Pointcut 作用： 指定切入点表达式 属性： value：指定表达式的内容 12@Pointcut("execution(* com.itheima.service.impl.*.*(..))")private void pt1() &#123;&#125; 引用方式： 12345678910111213141516171819202122232425262728/*** 环绕通知* @param pjp* @return*/@Around("pt1()")// 注意：千万别忘了写括号public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3.5 不使用XML的配置方式12345@Configuration@ComponentScan(basePackages="com.itheima")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP的相关概念]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-02-AOP%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[目录 AOP概述 AOP的具体应用 1. AOP概述1.1 什么是AOPAOP：全称是 Aspect Oriented Programming 即：面向切面编程。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 1.2 AOP的作用及优势作用：在程序运行期间，不修改源码对已有方法进行增强。优势：减少重复代码提高开发效率维护方便 1.3 AOP的实现方式使用动态代理技术 2. AOP的具体应用2.1 案例中问题这是我们昨天做的增删改查例子。下面是客户的业务层实现类。我们能看出什么问题吗? 客户的业务层实现类 123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void saveAccount(Account account) throws SQLException &#123; accountDao.save(account); &#125; @Override public void updateAccount(Account account) throws SQLException&#123; accountDao.update(account); &#125; @Override public void deleteAccount(Integer accountId) throws SQLException&#123; accountDao.delete(accountId); &#125; @Override public Account findAccountById(Integer accountId) throws SQLException &#123; return accountDao.findById(accountId); &#125; @Override public List&lt;Account&gt; findAllAccount() throws SQLException&#123; return accountDao.findAll(); &#125;&#125; 问题就是：事务被自动控制了。换言之，我们使用了 connection 对象的 setAutoCommit(true)此方式控制事务，如果我们每次都执行一条 sql 语句，没有问题，但是如果业务方法一次要执行多条 sql语句，这种方式就无法实现功能了。 请看下面的示例：我们在业务层中多加入一个方法。 业务层接口 1234567/*** 转账* @param sourceName* @param targetName* @param money*/void transfer(String sourceName,String targetName,Float money); 业务层实现类： 12345678910111213@Overridepublic void transfer(String sourceName, String targetName, Float money) &#123; //根据名称查询两个账户信息 Account source = accountDao.findByName(sourceName); Account target = accountDao.findByName(targetName); //转出账户减钱，转入账户加钱 source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); //更新两个账户 accountDao.update(source); int i=1/0; //模拟转账异常 accountDao.update(target);&#125; 当我们执行时，由于执行有异常，转账失败。但是因为我们是每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性） 2.2 问题的解决解决办法：让业务层来控制事务的提交和回滚。 改造后的业务层实现类： 注：此处没有使用 spring 的 的 IoC. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl(); @Override public void saveAccount(Account account) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.save(account); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; &#125; @Override public void updateAccount(Account account) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.update(account); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125;&#125; @Override public void deleteAccount(Integer accountId) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.delete(accountId); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125;&#125; @Override public Account findAccountById(Integer accountId) &#123; Account account = null; try &#123; TransactionManager.beginTransaction(); account = accountDao.findById(accountId); TransactionManager.commit(); return account; &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; return null; &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; List&lt;Account&gt; accounts = null; try &#123; TransactionManager.beginTransaction(); accounts = accountDao.findAll(); TransactionManager.commit(); return accounts; &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; return null; &#125; @Override public void transfer(String sourceName, String targetName, Float money) &#123; try &#123; TransactionManager.beginTransaction(); Account source = accountDao.findByName(sourceName); Account target = accountDao.findByName(targetName); source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); accountDao.update(source); int i=1/0; accountDao.update(target); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; &#125;&#125; TransactionManager 类的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class TransactionManager &#123; //定义一个 DBAssit private static DBAssit dbAssit = new DBAssit(C3P0Utils.getDataSource(),true); //开启事务 public static void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //提交事务 public static void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //回滚事务 public static void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //释放资源 public static void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.3 新的问题上一小节的代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了一个新的问题：业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了。试想一下，如果我们此时提交，回滚，释放资源中任何一个方法名变更，都需要修改业务层的代码，况且这还只是一个业务层实现类，而实际的项目中这种业务层实现类可能有十几个甚至几十个。思考：这个问题能不能解决呢？答案是肯定的，使用下一小节中提到的技术。 2.4 动态代理回顾2.4.1 动态代理的特点字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 2.4.2 动态代理常用的两种方式1234567基于接口的动态代理提供者：JDK 官方的 Proxy 类。要求：被代理类最少实现一个接口。基于子类的动态代理提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。要求：被代理类不能用 final 修饰的类（最终类）。 2.4.3 使用JDK官方的Proxy类创建代理对象此处我们使用的是一个演员的例子：在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。 12345678910111213141516/*** 一个经纪公司的要求:* 能做基本的表演和危险的表演*/public interface IActor &#123; /** * 基本演出 * @param money */ public void basicAct(float money); /** * 危险演出 * @param money */ public void dangerAct(float money);&#125; 12345678910111213/*** 一个演员*///实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求public class Actor implements IActor&#123; public void basicAct(float money)&#123; System.out.println("拿到钱，开始基本的表演："+money); &#125; public void dangerAct(float money)&#123; System.out.println("拿到钱，开始危险的表演："+money); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Client &#123; public static void main(String[] args) &#123; //一个剧组找演员： final Actor actor = new Actor();//直接 /** * 代理： * 间接。 * 获取代理对象： * 要求： * 被代理类最少实现一个接口 * 创建的方式 * Proxy.newProxyInstance(三个参数) * 参数含义： * ClassLoader：和被代理对象使用相同的类加载器。 * Interfaces：和被代理对象具有相同的行为。实现相同的接口。 * InvocationHandler：如何代理。 * 策略模式：使用场景是： * 数据有了，目的明确。 * 如何达成目标，就是策略。 * */ IActor proxyActor = (IActor) Proxy.newProxyInstance( actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。 * 此方法有拦截的功能。 * * 参数： * proxy：代理对象的引用。不一定每次都用得到 * method：当前执行的方法对象 * args：执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String name = method.getName(); Float money = (Float) args[0]; Object rtValue = null; //每个经纪公司对不同演出收费不一样，此处开始判断 if("basicAct".equals(name))&#123; //基本演出，没有 2000 不演 if(money &gt; 2000)&#123; //看上去剧组是给了 8000，实际到演员手里只有 4000 //这就是我们没有修改原来 basicAct 方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; if("dangerAct".equals(name))&#123; //危险演出,没有 5000 不演 if(money &gt; 5000)&#123; //看上去剧组是给了 50000，实际到演员手里只有 25000 //这就是我们没有修改原来 dangerAct 方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); //没有经纪公司的时候，直接找演员。 // actor.basicAct(1000f); // actor.dangerAct(5000f); //剧组无法直接联系演员，而是由经纪公司找的演员 proxyActor.basicAct(8000f); proxyActor.dangerAct(50000f); &#125;&#125; 2.4.4 使用CGLib的Enhancer类创建代理对象还是那个演员的例子，只不过不让他实现接口。 123456789101112/*** 一个演员*/public class Actor&#123;//没有实现任何接口 public void basicAct(float money)&#123; System.out.println("拿到钱，开始基本的表演："+money); &#125; public void dangerAct(float money)&#123; System.out.println("拿到钱，开始危险的表演："+money); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Client &#123; /** * 基于子类的动态代理 * 要求： * 被代理对象不能是最终类 * 用到的类： * Enhancer * 用到的方法： * create(Class, Callback) * 方法的参数： * Class：被代理对象的字节码 * Callback：如何代理 * @param args */ public static void main(String[] args) &#123; final Actor actor = new Actor(); Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何 方法进行增强。 * * 参数： * 前三个和基于接口的动态代理是一样的。 * MethodProxy：当前执行方法的代理对象。 * 返回值： * 当前执行方法的返回值 */ @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; String name = method.getName(); Float money = (Float) args[0]; Object rtValue = null; if("basicAct".equals(name))&#123; //基本演出 if(money &gt; 2000)&#123; rtValue = method.invoke(actor, money/2); &#125; &#125; if("dangerAct".equals(name))&#123; //危险演出 if(money &gt; 5000)&#123; rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); cglibActor.basicAct(10000); cglibActor.dangerAct(100000); &#125;&#125; 思考：这个故事（示例）讲完之后，我们从中受到什么启发呢？它到底能应用在哪呢？ 2.5 解决案例中的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过我们此处不做那么繁琐）* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class BeanFactory &#123; /** * 创建账户业务层实现类的代理对象 * @return */ public static IAccountService getAccountService() &#123; //1.定义被代理对象 final IAccountService accountService = new AccountServiceImpl(); //2.创建代理对象 IAccountService proxyAccountService = (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(),new InvocationHandler() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。 * 此处添加事务控制 */ @Override public Object invoke(Object proxy, Method method,Object[] args) throws Throwable &#123; Object rtValue = null; try &#123; //开启事务 TransactionManager.beginTransaction(); //执行业务层方法 rtValue = method.invoke(accountService, args); //提交事务 TransactionManager.commit(); &#125;catch(Exception e) &#123; //回滚事务 TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; //释放资源 TransactionManager.release(); &#125; return rtValue; &#125; &#125;); return proxyAccountService; &#125;&#125; 当我们改造完成之后，业务层用于控制事务的重复代码就都可以删掉了。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在虚拟机上部署Web项目]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2Web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[目录 获取虚拟机的IP地址 使用putty连接Linux 在Linux上安装JDK 在Linuxs上安装Mysql 在Linux上安装tomcat 部署项目war包到tomcat 1. 获取虚拟机的IP地址如果我们想用工具来连接linux来进行操作，首先要获取虚拟机的IP地址，使用ifconfig命令，如果没有IP地址，则是没有设置开机时启动网上,设置操作如下： 1vim /etc/sysconfig/network-scripts/ifcfg-eth0 123TYPE=Ethernet #以太网BOOTPROTO=DHCP #dhcp方式分配网址 ONBOOT=yes #启动网卡 改完保存wq reboot [重启]之后才会生效 在本地ping一下：ping 192.168.228.129 2. 使用putty连接Linux 点击save可以保存一个设置，下次打开就可以直接用了。 选中gyf_centos01点击load按钮 然后输入账号密码就可以连接上虚拟机了 3. 在Linux上安装JDK3.1 卸载OpenJDKRPM 是RPM Package Manager（RPM软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。 1234执行命令查看:rpm -qa 是查看所有安装的软件 --nodeps 不验证软件包的依赖关系 -e 删除软件 1rpm –qa | grep java 查看和java相关的包 1rpm -e --nodeps java-1.60-openjdk-1.6.0.0-1.66.1 卸载OpenJDK 卸载完毕 3.2 创建JDK的安装路径12在/usr/local/ 创建文件夹javamkdir java 3.3 上传安装文件到Linux使用FileZilla-3.7.3上传 3.3.1 先连接到Linux 3.3.2 把下面的几个文件，拖到root目录下 12cd ~ll 3.4 解压tar.gz123首先需要安装依赖： yum install glibc.i686 【前提得能上网】 tar –xvf xxx.tar.gz –C /usr/local/java 3.5 配置环境变量1234567vim /etc/profile #set java environment JAVA_HOME=/usr/local/java/jdk1.7.0_72 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 12重新加载配置文件：source /etc/profile 4. 在Linuxs上安装Mysql4.1 卸载自带MySQL1234先查看有没有安装mysqlrpm -qa | grep mysql删除rpm -e --nodeps mysql-libs-5.1.71-1.el6.i686 4.2 创建MySQL的安装路径 4.3 解压MySQL1tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql 4.4 安装依赖（可选）12yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6yum update libstdc++-4.4.7-4.el6.x86_64 4.5 安装MySQL的服务端1rpm -ivh MySQL-server-5.5.49-1.linux2.6.i386.rpm 4.6 安装MySQL的客户端1rpm -ivh MySQL-client-5.5.49-1.linux2.6.i386.rpm 4.7 启动MySQL的服务12service mysql statusservice mysql start 4.8 登录MySQL1mysql –u root -p 12修改密码：set password = password(&apos;123456&apos;); 4.9 设置开机自动启动MySQL1234加入到系统服务：chkconfig --add mysql自动启动：chkconfig mysql on 4.10 开启远程服务123登录mysql授权可以远程访问:grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;123456&apos;;flush privileges; 4.11 设置Linux的防火墙1233306端口放行 且将该设置添加到防火墙的规则中/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save 配置完成以后，我们就在本地测试一下 5. 在Linux上安装tomcat5.1 创建tomcat的安装路径1在/usr/local 下mkdir tomcat 5.2 解压tomcat1tar –xvf xxx.tar.gz –C /usr/local/tomcat 5.3 设置防护墙12/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save 5.4 启动tomcat12进入到tomcat/bin执行 ./startup.sh 在本地访问一下tomcat 12关闭tomcat执行 ./shutdown.sh 6. 部署项目war包到tomcat先在linux的mysql创建表，初始化数据 把SSM web项目打包成war 1234567上传到linux的tomcat的webapps中导入windows的mysql数据和数据window导出mysqldump -uroot -p123456 bos &gt; C:/Users/guoyongfeng/Desktop/bos.sqllinux导入mysql&gt; source /root/bos.sql 访问项目 1234查看tomcat的进程idps -ef | grep java杀死tomcatkill 3355]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚拟机</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于注解的IoC配置和整合Junit]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IoC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%95%B4%E5%90%88Junit%2F</url>
    <content type="text"><![CDATA[目录 明确：写在前面 环境搭建 常用注解 Spring管理对象细节 Spring的纯注解配置 测试类中的问题和解决思路 配置步骤 为什么不把测试类配置到xml中 1. 明确：写在前面学习基于注解的 IoC 配置，大家脑海里首先得有一个认知，即注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握。 2. 环境搭建2.1 第一步：拷贝必备jar包到工程的lib目录注意：在基于注解的配置中，我们还要多拷贝一个 aop 的 jar 包。如下图： 2.2 第二步：使用@Component注解配置管理的资源123456789101112131415161718192021222324252627/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("accountService")public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125;&#125;/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("accountDao")public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit;&#125; 注意：当我们使用注解注入时，set 方法不用写 2.3 第三步：创建Spring的xml配置文件并开启对注解的支持 注意：基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。由于我们使用了注解配置，此时不能在继承 JdbcDaoSupport，需要自己配置一个 JdbcTemplate 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 告知 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置 dbAssit --&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 常用注解3.1 用于创建对象的 相当于：&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 3.1.1 @Componet作用：把资源让 spring 来管理。相当于在 xml 中配置一个 bean。属性：value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。 3.1.2 @Controller @Service @Repository他们三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。他们只不过是提供了更加明确的语义化。 123@Controller ：一般用于表现层的注解。@Service ：一般用于业务层的注解。@Repository ：一般用于持久层的注解。 细节：如果注解中有且只有一个属性 要赋值时是 ，且名称是 value ，value 3.2 用于注入数据的相当于：&lt;property name=&quot;&quot; ref=&quot;&quot;&gt;、&lt;property name=&quot;&quot; value=&quot;&quot;&gt; 3.2.1 @Autowired作用：自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他 bean 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 3.2.2 @Qualifier作用：在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用。属性：value：指定 bean 的 id。 3.2.3 @Resource作用：直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。属性：name：指定 bean 的 id。 3.2.4 @Value作用：注入基本数据类型和 String 类型数据的属性：value：用于指定值 3.3 用于改变作用范围的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt; 3.3.1 @Scope作用：指定 bean 的作用范围。属性：value：指定范围的值。取值：singleton prototype request session globalsession 3.4 和生命期相关的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot; /&gt; 3.4.1 @PostConstruct作用：用于指定初始化方法。 3.4.2 @PreDestroy作用：用于指定销毁方法。 3.5 关于Spring注解和XML的选择问题注解的优势：配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。XML 的优势：修改时，不用改源码。不涉及重新编译和部署。Spring 管理 Bean 方式的比较： 4. Spring管理对象细节基于注解的 spring IoC 配置中，bean 对象的特点和基于 XML 配置是一模一样的。 5. Spring的纯注解配置写到此处，基于注解的 IoC 配置已经完成，但是大家都发现了一个问题：我们依然离不开 spring 的 xml 配置文件，那么能不能不写这个 bean.xml，所有配置都用注解来实现呢？ 当然，同学们也需要注意一下，我们选择哪种配置的原则是简化开发和配置方便，而非追求某种技术。 5.1 待改造的问题我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置： 12&lt;!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中 --&gt;&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; 如果他要也能用注解配置，那么我们就离脱离 xml 文件又进了一步。 另外，数据源和 JdbcTemplate 的配置也需要靠注解来实现。 123456789101112&lt;!-- 配置 dbAssit --&gt;&lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 5.2 新注解说明5.2.1 @Configuration作用：用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration 注解的类.class)。属性：value:用于指定配置类的字节码 示例代码： 123456789/*** spring 的配置类，相当于 bean.xml 文件* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Configuration public class SpringConfiguration &#123;&#125; 注意：我们已经把配置文件用类来代替了，但是如何配置创建容器时要扫描的包呢？请看下一个注解。 5.2.2 @ComponentScan作用：用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;是一样的。属性：basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。示例代码： 12345678910/*** spring 的配置类，相当于 bean.xml 文件* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Configuration@ComponentScan("com.itheima") public class SpringConfiguration &#123;&#125; 注意：我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？请看下一个注解。 5.2.3 @Bean作用：该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。属性：name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。 示例代码： 123456789101112131415161718192021222324252627282930313233343536/*** 连接数据库的配置类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class JdbcConfig &#123; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setUser("root"); ds.setPassword("1234"); ds.setDriverClass("com.mysql.jdbc.Driver"); ds.setJdbcUrl("jdbc:mysql:///spring_day02"); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 创建一个 DBAssit，并且也存入 spring 容器中 * @param dataSource * @return */ @Bean(name="dbAssit") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSource); &#125;&#125; 注意:我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？请看下一个注解。 5.2.4 @PropertySource作用：用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。属性：value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath: 示例代码： 12345678910111213141516171819202122232425262728293031323334/*** 连接数据库的配置类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; jdbc.properties 文件： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/day44_ee247_springjdbc.username=rootjdbc.password=1234 注意：此时我们已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？请看下一个注解。 5.2.5 @Import作用：用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。属性：value[]：用于指定其他配置类的字节码。示例代码： 12345678910@Configuration@ComponentScan(basePackages = "com.itheima.spring")@Import(&#123; JdbcConfig.class&#125;)public class SpringConfiguration &#123;&#125;@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig&#123;&#125; 注意：我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？请看下一小节。 5.2.6 通过注解获取容器12ApplicationContext ac =new AnnotationConfigApplicationContext(SpringConfiguration.class); 5.3 工程结构图 6. 测试类中的问题和解决思路6.1 问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");IAccountService as = ac.getBean("accountService",IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 6.2 解决思路分析针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建spring 容器，我们就无须手动创建了，问题也就解决了。我们都知道，junit 单元测试的原理（在 web 阶段课程中讲过），但显然，junit 是无法实现的，因为它自己都无法知晓我们是否使用了 spring 框架，更不用说帮我们创建 spring 容器了。不过好在，junit 给我们暴露了一个注解，可以让我们替换掉它的运行器。这时，我们需要依靠 spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。 7. 配置步骤7.1 第一步：拷贝整合junit的必备jar包到lib目录此处需要注意的是，导入 jar 包时，需要导入一个 spring 中 aop 的 jar 包。 7.2 第二步：使用@RunWith注解替换原有运行器123456789/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)public class AccountServiceTest &#123;&#125; 7.3 第三步：使用@ContextConfiguration指定Spring配置文件的位置12345678910/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;)public class AccountServiceTest &#123;&#125; @ContextConfiguration 注解：locations 属性：用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明classes 属性：用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。 7.4 第四步：使用@Autowired给测试类中的变量注入数据12345678910111213/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;)public class AccountServiceTest &#123; @Autowired private IAccountService as ;&#125; 8. 为什么不把测试类配置到xml中在解释这个问题之前，先解除大家的疑虑，配到 XML 中能不能用呢？答案是肯定的，没问题，可以使用。那么为什么不采用配置到 xml 中的方式呢？这个原因是这样的：第一：当我们在 xml 中配置了一个 bean，spring 加载配置文件创建容器时，就会创建对象。第二：测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。所以，基于以上两点，我们不应该把测试配置到 xml 文件中。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyUI快速入门]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31-EasyUI%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 什么是EasyUI 第一个HelloWorld程序 创建和配置的方式 linkbutton的初始化原理 核心 常用的组件 综合案例 1. 什么是EasyUIjQuery EasyUI是一组基于jQuery的UI插件集合，而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript，也不需要对css样式有深入的了解，开发者只有需要了解一些简单的html标签。 jQuery EasyUI为我们提供了大多数UI控件的使用，如：accordion，combobox，menu，dialog，tabs，tree，validatebox，window等等。 特点: 上手很简单 功能丰富 美观的UI界面. 2. 第一个HelloWorld程序1234567891011121314步骤:1.导入相关的资源2.在页面中引入相关的配置信息&lt;link rel="stylesheet" type="text/css" href="../jquery-easyui/themes/default/easyui.css"&gt;&lt;!-- 样式文件 --&gt; &lt;link rel="stylesheet" type="text/css" href="../jquery-easyui/themes/icon.css"&gt; &lt;!-- 图标样式 --&gt; &lt;script type="text/javascript" src="../jquery-easyui/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- jQuery核心库 --&gt; &lt;script type="text/javascript" src="../jquery-easyui/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;!-- EasyUI核心库 --&gt;3.在页面添加对应的标签.每个组件都有对应的标签例如按钮就必须是&lt;a&gt;标签4.在标签上添加class=”easyui-插件名”,插件名必须全小写的.5.可以使用data-options来配置组件 3. 创建和配置的方式创建方式： 1.在页面标签中直接使用class=”easyui-插件名”来初始化组件. 1&lt;input class="easyui-datebox" name="time"&gt; 2.使用JS的初始化方式(推荐使用) 页面中： 1&lt;div id="myPanel" title="新新的标题头" data-options="width:800"&gt;EasyUI的面板&lt;/div&gt; JS中: 123456$(function()&#123; $("#myPanel").panel(&#123; height:800, title:'js中的标题' &#125;);&#125;); 配置方式： 1.在标签体重使用data-options配置信息. 1&lt;div class="easyui-panel" data-options="title:'EasyUI面板'" style="width:200px;height: 200px;"&gt;EasyUI的面板&lt;/div&gt; 2.直接在标签上配置属性,&lt;div title=&quot;标题&quot; class=&quot;easyui-panel&quot;&gt;&lt;div&gt; 3.在JS中最配置(推荐使用) 页面中： 1&lt;div id=&quot;myPanel&quot; title=&quot;标题&quot;&gt;&lt;/div&gt; JS中： 123456$(function()&#123; $("#myPanel").panel(&#123; height:800, title:'js中的标题' &#125;);&#125;); 注意:三种方式都是可以混合使用的.JS中的配置会覆盖页面中的配置. 4. linkbutton的初始化原理1.所有的标签都以class=”easyui-插件名“,通过筛选器可以找到这些标签. 2.在EasyUI代码中,准备好了一大堆的模板和样式类. 3.根据到底是什么标签,给对应的标签加上模板和样式类. 12345678910111213//放在页面加载完毕后执行$(function()&#123; //1.先获取到需要初始化的组件 var myBtn = $(".myButton"); //2.拿到一开始定义文本信息 var text = myBtn.html(); //3.定义模板 var temp = '&lt;span class="l-btn-left"&gt;&lt;span class="l-btn-text"&gt;'+text+'&lt;/span&gt;&lt;/span&gt;'; //4.在标签中插入模板 myBtn.html(temp); //5.给组件添加样式 myBtn.addClass("easyui-linkbutton l-btn");&#125;); 5. 核心5.1 属性所有的属性都定义在jQuery.fn.{plugin}.defaults里面。例如，对话框属性定义在jQuery.fn.dialog.defaults里面。 Panel（面板） 使用$.fn.panel.defaults重写默认值对象。 面板作为承载其它内容的容器。这是构建其他组件的基础（比如：layout,tabs,accordion等）。它还提供了折叠、关闭、最大化、最小化和自定义行为。面板可以很容易地嵌入到web页面的任何位置。 常用属性: 1234567891011121314151617title:设置标题iconCls :设置一个16x16图标的CSS类ID显示在面板左上角。 headerCls：添加一个CSS类ID到面板头部。 null bodyCls ： 添加一个CSS类ID到面板正文部分。 fit:当设置为true的时候面板大小将自适应父容器border boolean 定义是否显示面板边框。 collapsible boolean 定义是否显示可折叠按钮。 false minimizable boolean 定义是否显示最小化按钮。 false maximizable boolean 定义是否显示最大化按钮。 false closable boolean 定义是否显示关闭按钮。 collapsed boolean 定义是否在初始化的时候折叠面板。 false minimized boolean 定义是否在初始化的时候最小化面板。 false maximized boolean 定义是否在初始化的时候最大化面板。 false closed boolean 定义是否在初始化的时候关闭面板。 href:从远程加载文本内容cache：如果为true，在超链接载入时缓存面板内容。loadingMessage string 在加载远程数据的时候在面板内显示一条消息 使用$.fn.panel.defaults给组件添加默认值. 给组件添加默认标题. $.fn.panel.defaults.title=”默认标题”; 5.2 事件所有的事件（回调函数）也都定义在jQuery.fn.{plugin}.defaults里面。 fn大多都是以on开头的,大部分复杂组件,都可以在初始化时,使用onxxx属性配置,值为事件响应 onCollapse 折叠是触发 onExpand 展开时触发 小部分简单组件,还是使用JQuery事件监听方式,使用on方法添加事件.例如linkbutton linkButton没有事件，需要通过jquery的方式去处理.$(“#button”).on(“click”,functtion(){}); 5.3 方法调用方法的语法：$(‘selector’).plugin(‘method’, parameter); 和我们以前的调用方法的方式有些不同. 调用panel的打开方法 $(“#myPanel”).panel(“open”); $(“组件”).插件名(“方法名”,方法参数) 6. 常用的组件6.1 LinkButton(按钮)使用$.fn.linkbutton.defaults重写默认值对象。 按钮组件使用超链接按钮创建。它使用一个普通的&lt;a&gt;标签进行展示。它可以同时显示一个图标和文本,或只有图标或文字。按钮的宽度可以动态和折叠/展开以适应它的文本标签。 常用属性： iconCls：配置图标信息 plain:简洁风格 常用方法: enable：变亮按钮 disable：变灰按钮 6.2 Window(窗口)扩展自$.fn.panel.defaults。使用$.fn.window.defaults重写默认值对象。 窗口控件是一个浮动和可拖拽的面板可以用作应用程序窗口。默认情况下,窗口可以移动,调整大小和关闭。它的内容也可以被定义为静态html或要么通过ajax动态加载 常用属性: draggable boolean 定义是否能够拖拽窗口。 true resizable boolean 定义是否能够改变窗口大小。 true modal:定义是否将窗体显示为模式化窗口。 （起到遮蔽的效果） 6.3 Dialog(对话窗口)扩展自$.fn.window.defaults。使用$.fn.dialog.defaults重写默认值对象。 该对话框是一种特殊类型的窗口，它在顶部有一个工具栏，在底部有一个按钮栏。对话框窗口右上角只有一个关闭按钮用户可以配置对话框的行为显示其他工具,如collapsible,minimizable,maximizable工具等。 6.4 Dialog上的按钮创建按钮的方式: 1.array:通过数组的方式配置按钮 12345678910111213141516171819$(function()&#123; $("#myDialog").dialog(&#123; width:200, height:200, tools:[ &#123; iconCls:'icon-add', handler:function()&#123; alert("add"); &#125;, &#123; iconCls:'icon-edit', handler:function()&#123; alert("edit"); &#125; &#125; ] &#125;);&#125;); 2.selector:通过选择器的方式 1.工具栏按钮(tools)： 页面： 1234&lt;div id="tt"&gt; &lt;a class="icon-add" onclick="javascript:alert('iconadd')"&gt;&lt;/a&gt; &lt;a class="icon-remove" onclick="javascript:alert('iconremove')"&gt;&lt;/a&gt;&lt;/div&gt; JS中： 12345$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt'&#125;); 2.顶部按钮（toolbar）： 12345&lt;!--配置顶部按钮--&gt;&lt;div id="tb"&gt; &lt;a class="easyui-linkbutton" iconCls="icon-add" plain="true"&gt;新增&lt;/a&gt; &lt;a class="easyui-linkbutton" iconCls="icon-edit" plain="true"&gt;编辑&lt;/a&gt;&lt;/div&gt; 123456$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt', toolbar:'#tb'&#125;); 3.底部按钮 1234&lt;div id="bb"&gt; &lt;a href="#" class="easyui-linkbutton" iconCls="icon-save"&gt;保存&lt;/a&gt; &lt;a href="#" class="easyui-linkbutton" iconCls="icon-cancel"&gt;关闭&lt;/a&gt;&lt;/div&gt; 1234567$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt', toolbar:'#tb', buttons:'#bt'&#125;); 6.5 Tabs(选项卡)使用$.fn.tabs.defaults重写默认值对象。 选项卡显示一批面板。但在同一个时间只会显示一个面板。每个选项卡面板都有头标题和一些小的按钮工具菜单，包括关闭按钮和其他自定义按钮。 1234567891011121314151617181920212223//放在页面加载完毕后执行$(function() &#123; // 获取组件 var myTabs = $("#myTabs"); myTabs.tabs(&#123; width:500, height:'auto' &#125;); // 获取所有panel集合 var panelArr = myTabs.tabs("tabs"); // 循环 for ( var i = 0; i &lt; panelArr.length; i++) &#123; var panelUI = panelArr[i]; var title = panelUI.panel("options").tab; console.debug(panelUI.panel("options")); // 找到头部信息,添加鼠标移入事件 title.off().on("mouseenter", &#123;index : i&#125;, function(e) &#123; // 选中面板 myTabs.tabs("select", e.data.index); &#125;) &#125;&#125;); 动态添加选项卡和删除选项卡. 12345678910111213141516171819202122232425262728//放在页面加载完毕后执行$(function() &#123; // 获取组件 var myTabs = $("#myTabs"); myTabs.tabs(&#123; width:500, height:400, tools:'#tab-tools' &#125;);&#125;);var index = 0;function addPanel() &#123; // 往tabs动图添加选项卡 var myTabs = $("#myTabs"); myTabs.tabs("add", &#123; title : '面板'+(++index), closable : true, content : '面板' &#125;);&#125;function removePanel() &#123; // 目前哪个选中,就删除哪个. var myTabs = $("#myTabs"); var tabs = myTabs.tabs("getSelected"); var index = myTabs.tabs('getTabIndex', tabs); console.debug(index); myTabs.tabs("close", index);&#125; 6.6 DataGrid(数据表格)扩展自$.fn.panel.defaults。使用$.fn.datagrid.defaults重写默认值对象。 数据表格以表格形式展示数据，并提供了丰富的选择、排序、分组和编辑数据的功能支持。数据表格的设计用于缩短开发时间，并且使开发人员不需要具备特定的知识。它是轻量级的且功能丰富。单元格合并、多列标题、冻结列和页脚只是其中的一小部分功能。 常用属性: 1234567title:'数据表格',url:'data.json',//从远程地址获取对应的数据，对数据格式有要求,必须是要求格式.striped:true,//斑马线效果singleSelect:true,//单选操作toolbar:'#tb',//顶部按钮pagination:true,//配置分页栏信息fitColumns:true//表头自适应网格,需要和表头中width配合使用,此时width表示比例 列常用属性: 12345field:'listprice',//映射后台那个数据formatter:priceFormatter,//格式化函数width:1//如果没有和fitColumns配合使用表示普通的px值,如果和fitColumns配合使用,表示比例.rowspan:2//行合并colspan:5:列合并. 12345&lt;thead data-options="frozen:true"&gt; &lt;tr&gt; &lt;th data-options="field:'productid',rowspan:2,halign:'center'"&gt;产品ID&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; JS中配置表头 123456789101112131415161718frozenColumns:[ [ &#123;field:'productid',title:'产品ID',rowspan:2&#125; ] ], columns:[ [ &#123;field:'productname',title:'产品名称',width:1,rowspan:2&#125;, &#123;title:'汇总信息',width:1,colspan:5&#125; ], [ &#123;field:'unitcost',title:'成本单价',width:1&#125;, &#123;field:'status',title:'状态',width:1&#125;, &#123;field:'listprice',title:'售价',width:1&#125;, &#123;field:'attr1',title:'属性',width:1&#125;, &#123;field:'itemid',title:'分类ID',width:1&#125; ] ] 效果图： 6.7 Tree(树)使用$.fn.tree.defaults重写默认值对象。 树控件在web页面中一个将分层数据以树形结构进行显示。它提供用户展开、折叠、拖拽、编辑和异步加载等功能。 常用属性: 1234567url:远程地址,数据是要求的.标准JSON格式formatter：格式化函数lines:true,//节点之间通过线条连接animate:true,//展开收缩有动画效果. 常用事件: 123onClick：点击触发onDblClick：双击触发onSelect：选中触发. 12345678910111213141516171819202122232425262728293031323334353637$(function()&#123; //完成功能,双击自动展开或者收缩节点 //1,监听鼠标双击的事件. //2.判断节点的状态 // 如果是展开展开,让节点收缩 // 如果节点为收缩,让节点展开. $("#myTree").tree(&#123; url:'tree.json', animate:true, checkbox:true, lines:true, dnd:true, onDblClick:function(node)&#123; console.log(node); if(node.state=='open')&#123; //调用tree组件的收缩方法 $("#myTree").tree("collapse",node.target); &#125;else&#123; //调用tree组件的展开方法 $("#myTree").tree("expand",node.target); &#125; &#125;, formatter:function(node)&#123; //需要判断一下节点是否有子元素 if(node.children)&#123; //如果有 //返回的内容修改 return node.text+"("+node.children.length+")"; &#125;else&#123; //如果没有 //返回原样内容 return node.text; &#125; &#125; &#125;);&#125;); 7. 综合案例1234567891011121314151.对页面进行布局.&lt;div class=”easyui-layou”&gt; &lt;div data-options=”region:&apos;north&apos;”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;east&apos;”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;center”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;sourth&apos;”&gt;&lt;/div&gt;&lt;/div&gt;2.设置logo和版权信息.3.在左侧添加手风琴效果+树组件。4.在中间部分添加tabs组件,显示对应的数据.5.菜单添加对应的点击事件. 7.1 员工新增1.定义datagrid展示员工的数据 2.添加分页栏+顶部按钮. 3.添加员工新增的对话框(默认隐藏) 4.给新增按钮添加对应的时间,触发对话的显示. 5.监听保存按钮的事件，通过异步的方式提交数据到后台 7.2 员工编辑1.编辑的时候需要打开对话框. 2.对内容进行回显(基于同名匹配规则) 7.3 员工删除1.判断用户是否有选中数据. 2.让用户确定是否需要删除该数据. 3.调用ajax请求,把id传递到后台,进行删除. 4.提示操作反馈信息，刷新数据表格. 7.4 集成到首页中注意:href只加载body部分的内容.会发生页面不对的情况.建议使用content]]></content>
      <categories>
        <category>前端</category>
        <category>EasyUI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>EasyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring的IoC实现账户的CRUD]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31-%E4%BD%BF%E7%94%A8Spring%E7%9A%84IoC%E5%AE%9E%E7%8E%B0%E8%B4%A6%E6%88%B7%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[目录 需求和技术要求 环境搭建 配置步骤 测试案例 1. 需求和技术要求1.1 需求实现账户的CRUD操作 1.2 技术要求 使用 spring 的 IoC 实现对象的管理使用 DBAssit 作为持久层解决方案使用 c3p0 数据源 2. 环境搭建2.1 拷贝jar包 2.2 创建数据库和编写实体类123456789create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci;insert into account(name,money) values(&apos;aaa&apos;,1000);insert into account(name,money) values(&apos;bbb&apos;,1000);insert into account(name,money) values(&apos;ccc&apos;,1000); 12345678910111213141516171819202122232425262728293031/*** 账户的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 2.3 编写持久层代码123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存 * @param account */ void save(Account account); /** * 更新 * @param account */ void update(Account account); /** * 删除 * @param accountId */ void delete(Integer accountId); /** * 根据 id 查询 * @param accountId * @return */ Account findById(Integer accountId); /** * 查询所有 * @return */ List&lt;Account&gt; findAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit; public void setDbAssit(DBAssit dbAssit) &#123; this.dbAssit = dbAssit; &#125; @Override public void save(Account account) &#123; dbAssit.update("insert into account(name,money)values(?,?)",account.getName(),account.getMoney()); &#125; @Override public void update(Account account) &#123; dbAssit.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId()); &#125; @Override public void delete(Integer accountId) &#123; dbAssit.update("delete from account where id=?",accountId); &#125; @Override public Account findById(Integer accountId) &#123; return dbAssit.query("select * from account where id=?",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; @Override public List&lt;Account&gt; findAll() &#123; return dbAssit.query("select * from account where id=?",new BeanListHandler&lt;Account&gt;(Account.class)); &#125;&#125; 2.4 编写业务层代码123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户 * @param account */ void saveAccount(Account account); /** * 更新账户 * @param account */ void updateAccount(Account account); /** * 删除账户 * @param account */ void deleteAccount(Integer accountId); /** * 根据 id 查询账户 * @param accountId * @return */ Account findAccountById(Integer accountId); /** * 查询所有账户 * @return */ List&lt;Account&gt; findAllAccount();&#125; 123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void saveAccount(Account account) &#123; accountDao.save(account); &#125; @Override public void updateAccount(Account account) &#123; accountDao.update(account); &#125; @Override public void deleteAccount(Integer accountId) &#123; accountDao.delete(accountId); &#125; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findById(accountId); &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAll(); &#125;&#125; 2.5 创建并编写配置文件 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 3. 配置步骤3.1 配置对象123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 service --&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 dao --&gt; &lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 dbAssit 此处我们只注入了数据源，表明每条语句独立事务--&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4. 测试案例4.1 测试类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceTest &#123; /** * 测试保存 */ @Test public void testSaveAccount() &#123; Account account = new Account(); account.setName("黑马程序员"); account.setMoney(100000f); ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.saveAccount(account); &#125; /** * 测试查询一个 */ @Test public void testFindAccountById() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); Account account = as.findAccountById(1); System.out.println(account); &#125; /** * 测试更新 */ @Test public void testUpdateAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); Account account = as.findAccountById(1); account.setMoney(20301050f); as.updateAccount(account); &#125; /** * 测试删除 */ @Test public void testDeleteAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.deleteAccount(1); &#125; /** * 测试查询所有 */ @Test public void testFindAllAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); List&lt;Account&gt; list = as.findAllAccount(); for(Account account : list) &#123; System.out.println(account); &#125; &#125;&#125; 4.2 分析测试中的问题通过上面的测试类，我们可以看出，每个测试方法都重新获取了一次 spring 的核心容器，造成了不必要的重复代码，增加了我们开发的工作量。这种情况，在开发中应该避免发生。有些同学可能想到了，我们把容器的获取定义到类中去。例如： 12345678910/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceTest &#123; private ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); private IAccountService as = ac.getBean("accountService",IAccountService.class);&#125; 这种方式虽然能解决问题，但是扔需要我们自己写代码来获取容器。能不能测试时直接就编写测试方法，而不需要手动编码来获取容器呢？]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架概述]]></title>
    <url>%2F2019%2F05%2F30%2F2019-05-30-Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 Spring框架概述 Ioc的概念和作用 案例的前期准备 基于XML的配置 Spring基于XML的IoC细节 Spring配置文件中提示的配置 1. Spring框架概述1.1 Spring是什么Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 1.2 Spring的发展历程1997 年 IBM提出了EJB 的思想1998 年，SUN制定开发标准规范 EJB1.01999 年，EJB1.1 发布2001 年，EJB2.0 发布2003 年，EJB2.1 发布2006 年，EJB3.0 发布Rod Johnson （ spring 之父）Expert One-to-One J2EE Design and Development(2002)阐述了 J2EE 使用EJB 开发设计的优点及解决方案Expert One-to-One J2EE Development without EJB(2004)阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）2017 年 9 9 月份发布了 g spring 的最新版本 0 spring 5.0 通用版 (GA) 1.3 Spring的优势方便解耦，简化开发通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。AOP 编程的支持通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。方便集成各种优秀框架Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。低降低 JavaEE API 的使用难度Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。Java 源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 1.4 Spring的体系结构 2. 程序的耦合和解耦2.1 什么是程序的耦合耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚低耦合。 它有如下分类： （1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 我们在开发 中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码： 123456789/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();&#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决。 再比如：早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采用 Class.forName 的方式？ 123456789101112131415161718public class JdbcDemo1 &#123; /** * @author 黑马程序员 * @Company http://www.ithiema.com * @Version 1.0 * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName("com.mysql.jdbc.Driver"); //2.获取连接 //3.获取预处理 sql 语句对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 原因就是：我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要修改源码来重新数据库驱动。这显然不是我们想要的。 2.2 解决程序耦合的思路当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： 1Class.forName("com.mysql.jdbc.Driver");//此处只是一个字符串 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。 2.3 工厂模式解耦在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来 并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 2.4 控制反转-Inversion Of Control上一小节解耦的思路有 2 个问题：1 、存哪去？分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。所以我们的答案就是在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 map 称之为 容器。2、还是没解释什么是工厂？工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。原来：我们在获取对象时，都是采用 new 的方式。是主动的。 现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。 明确 ioc 的作用：削减计算机程序的耦合(解除我们代码中的依赖关系)。 3. 案例的前期准备本章我们使用的案例是，账户的业务层和持久层的依赖关系解决。在开始 spring 的配置之前，我们要先准备一下环境。由于我们是使用 spring 解决依赖关系，并不是真正的要做增删改查操作，所以此时我们没必要写实体类。并且我们在此处使用的是 java 工程，不是 java web 工程。 3.1 尊卑Spring的开发包官网：http://spring.io/下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring 目录结构:) docs :API 和开发规范. libs :jar 包和源码. schema :约束. 我们使用的版本是 是 spring5.0.2 。特别说明：spring5 版本是用 jdk8 编写的，所以要求我们的 jdk 版本是 8 及以上。时 同时 tomcat 的版本要求 8.5 3.2 创建业务接口和实现类123456789101112/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户（此处只是模拟，并不是真的要保存） */ void saveAccount();&#125; 123456789101112131415/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();// 此处的依赖关系有待解决 @Override public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 3.3 创建持久层接口和实现类123456789101112/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存账户 */ void saveAccount();&#125; 123456789101112/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountDaoImpl implements IAccountDao &#123; @Override public void saveAccount() &#123; System.out.println("保存了账户"); &#125;&#125; 4. 基于XML的配置4.1 第一步：拷贝必备的jar包到工程的lib目录中 4.2 第二步：在类的根路径下创建一个任意名称的xml文件（不能是中文） 给配置文件导入约束： /spring-framework-5.0.2.RELEASE/docs/spring-framework-reference/html5/core.html 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 4.3 第三步：让Spring管理资源，在配置文件中配置service和dao12345678&lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中 id 属性：对象的唯一标识。 class 属性：指定要创建对象的全限定类名--&gt;&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt; 4.4 测试配置是否成功123456789101112131415161718192021/*** 模拟一个表现层* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Client &#123; /** * 使用 main 方法获取容器测试执行 */ public static void main(String[] args) &#123; //1.使用 ApplicationContext 接口，就是在获取 spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 bean 的 id 获取对象 IAccountService aService = (IAccountService) ac.getBean("accountService"); System.out.println(aService); IAccountDao aDao = (IAccountDao) ac.getBean("accountDao"); System.out.println(aDao); &#125;&#125; 运行结果： 5. Spring基于XML的IoC细节5.1 Spring中工厂的类结构图 5.1.1 BeanFactory和ApplicationContext的区别BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。BeanFactory 和 ApplicationContext 的区别：创建对象的时间点不一样。ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。BeanFactory：什么时候使用什么时候创建对象。 5.1.2 ApplicationContext接口的实现类123456ClassPathXmlApplicationContext ：它是从类的根路径下加载配置文件 推荐使用这种FileSystemXmlApplicationContext ：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 5.2 IoC中bean标签和管理对象细节5.2.1 bean标签作用：用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性：id：给对象在容器中提供一个唯一标识。用于获取对象。class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。scope：指定对象的作用范围。 singleton :默认值，单例的. prototype :多例的. request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session. init-method：指定类中的初始化方法名称。destroy-method：指定类中销毁方法名称。 5.2.2 bean的作用范围和生命周期单例对象：scope=&quot;singleton&quot;一个应用只有一个对象的实例。它的作用范围就是整个引用。生命周期：对象出生：当应用加载，创建容器时，对象就被创建了。对象活着：只要容器在，对象一直活着。对象死亡：当应用卸载，销毁容器时，对象就被销毁了。多例对象：scope=&quot;prototype&quot;每次访问对象时，都会重新创建对象实例。生命周期：对象出生：当使用对象时，创建新的对象实例。对象活着：只要对象在使用中，就一直活着。对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 5.2.3 实例化Bean的三种方式第一种方式：使用默认无参构造函数 1234&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"/&gt; 第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象 1234567891011121314151617/*** 模拟一个静态工厂，创建业务层实现类*/public class StaticFactory &#123; public static IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器 id 属性：指定 bean 的 id，用于从容器中获取 class 属性：指定静态工厂的全限定类名 factory-method 属性：指定生产对象的静态方法--&gt;&lt;bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象 12345678910111213141516171819/*** 模拟一个实例工厂，创建业务层实现类* 此工厂创建对象，必须现有工厂实例对象，再调用方法*/public class InstanceFactory &#123; public IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是： 先把工厂的创建交给 spring 来管理。 然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。 factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id="instancFactory" class="com.itheima.factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instancFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 5.3 Spring的依赖注入5.3.1 依赖注入的概念依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 5.3.2 构造函数注入顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。具体代码如下： 12345678910111213141516171819/***/public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 12345678910111213141516171819202122&lt;!-- 使用构造函数的方式，给 service 中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 用这个找给谁赋值=======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和 String 类型 ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg name="name" value=" 张三 "&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 5.3.3 set方法注入顾名思义，就是在类中提供需要注入成员的 set 方法。具体代码如下： 123456789101112131415161718192021public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 12345678910111213141516&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式 涉及的标签： property 属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发中，此种方式用的较多。--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 5.3.4 使用p名称空间注入数据（本质还是调用set方法）此种方式是通过在 xml中导入 p名称空间，使用 p:propertyName 来注入数据，它的本质仍然是调用类中的set 方法实现注入功能。Java 类代码： 123456789101112131415161718192021222324/*** 使用 p 名称空间注入，本质还是调用类中的 set 方法*/public class AccountServiceImpl4 implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 配置文件代码： 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl4" p:name="test" p:age="21" p:birthday-ref="now"/&gt;&lt;/beans&gt; 5.3.5 注入集合属性顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 12345678910111213141516171819202122232425262728293031323334/***/public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- 注入集合数据 List 结构的： array,list,set Map 结构的 map,entry,props,prop--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name="myStrs"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入 list 集合数据 --&gt; &lt;property name="myList"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 注入 set 集合数据 --&gt; &lt;property name="mySet"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入 Map 数据 --&gt; &lt;property name="myMap"&gt; &lt;props&gt; &lt;prop key="testA"&gt;aaa&lt;/prop&gt; &lt;prop key="testB"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入 properties 数据 --&gt; &lt;property name="myProps"&gt; &lt;map&gt; &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt; &lt;entry key="testB"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 6. Spring配置文件中提示的配置]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解开发]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-Mybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[目录 mybatis的常用注解说明 使用Mybatis注解实现基本CRUD 使用注解实现复杂关系映射开发 mybatis基于注解的二级缓存 这几年来注解开发越来越流行，Mybatis 也可以使用注解开发方式，这样我们就可以减少编写 Mapper 映射文件了。本次我们先围绕一些基本的 CRUD 来学习，再学习复杂映射关系及延迟加载。 1. mybatis的常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用 2. 使用Mybatis注解实现基本CRUD单表的 CRUD 操作是最基本的操作，前面我们的学习都是基于 Mybaits 的映射文件来实现的。 2.1 编写实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 注意：此处我们故意和数据库表的列名不一致。 2.2 使用注解方式开发持久层接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据 id 查询一个用户 * @param userId * @return */ @Select("select * from user where id = #&#123;uid&#125; ") @ResultMap("userMap") User findById(Integer userId); /** * 保存操作 * @param user * @return */ @Insert("insert into user(username,sex,birthday,address)values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125; )") @SelectKey(keyColumn="id",keyProperty="id",resultType=Integer.class,before = false, statement = &#123; "select last_insert_id()" &#125;) int saveUser(User user); /** * 更新操作 * @param user * @return */ @Update("update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id =#&#123;id&#125; ") int updateUser(User user); /** * 删除用户 * @param userId * @return */ @Delete("delete from user where id = #&#123;uid&#125; ") int deleteUser(Integer userId); /** * 查询使用聚合函数 * @return */ @Select("select count(*) from user ") int findTotal(); /** * 模糊查询 * @param name * @return */ @Select("select * from user where username like #&#123;username&#125; ") List&lt;User&gt; findByName(String name);&#125; 通过注解方式，我们就不需要再去编写 UserDao.xml 映射文件了。 2.3 编写SqlMapConfig配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 properties 文件的位置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置别名的注册 --&gt; &lt;typeAliases&gt; &lt;package name="com.itheima.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型是 JDBC --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射信息 --&gt; &lt;mappers&gt; &lt;!-- 配置 dao 接口的位置，它有两种方式 第一种：使用 mapper 标签配置 class 属性 第二种：使用 package 标签，直接指定 dao 接口所在的包 --&gt; &lt;package name="com.itheima.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4 编写测试方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/**** &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt;* &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisAnnotationCRUDTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试查询一个 */ @Test public void testFindById() &#123; User user = userDao.findById(41); System.out.println(user); &#125; /** * 测试保存 */ @Test public void testSave() &#123; User user = new User(); user.setUserName("mybatis annotation"); user.setUserSex("男"); user.setUserAddress("北京市顺义区"); user.setUserBirthday(new Date()); int res = userDao.saveUser(user); System.out.println("影响数据库记录的行数："+res); System.out.println("插入的主键值："+user.getUserId()); &#125; /** * 测试更新 */ @Test public void testUpdate() &#123; User user = userDao.findById(63); user.setUserBirthday(new Date()); user.setUserSex("女"); int res = userDao.updateUser(user); System.out.println(res); &#125; /** * 测试删除 */ @Test public void testDelete() &#123; int res = userDao.deleteUser(63); System.out.println(res); &#125; /** * 测试查询使用聚合函数 */ @Test public void testFindTotal() &#123; int res = userDao.findTotal(); System.out.println(res); &#125; /** * 测试模糊查询 */ @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findByName("%m%"); for(User user : users) &#123; System.out.println(user); &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit 的注解 public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in); //3.创建 session session = factory.openSession(); //4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123; //提交事务 session.commit(); //释放资源 session.close(); //关闭流 in.close(); &#125; &#125; 3. 使用注解实现复杂关系映射开发实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，在使用注解开发时我们需要借助@Results 注解，@Result 注解，@One 注解，@Many 注解。 3.1 复杂关系映射的注解说明12345678910111213141516171819202122232425262728@Results 注解代替的是标签&lt;resultMap&gt;该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（&#123;@Result（），@Result（）&#125;）或@Results（@Result（））@Resutl 注解代替了 &lt;id&gt; 标签和&lt;result&gt; 标签@Result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解（@Result（one=@One）（））） many 需要使用的@Many 注解（@Result（many=@many）（）））@One 注解（一对一） 代替了&lt;assocation&gt; 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One 注解属性介绍： select 指定用的 来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。使用格式： @Result(column=" ",property="",one=@One(select=""))@Many 注解（多对一） 代替了&lt;Collection&gt; 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType（一般为 ArrayList）但是注解中可以不定义；使用格式： @Result(property="",column="",many=@Many(select="")) 3.2 使用注解实现一对一复杂关系映射及延迟加载需求：加载账户信息时并且加载该账户的用户信息，根据情况可实现延迟加载。（注解方式实现） 3.2.1 添加User实体类及Account实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一关系映射：从表方应该包含一个主表方的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 3.2.2 添加账户的持久层接口并使用注解配置1234567891011121314151617181920212223242526/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，采用延迟加载的方式查询账户的所属用户 * @return */ @Select("select * from account") @Results(id="accountMap", value= &#123; @Result(id=true,column="id",property="id"), @Result(column="uid",property="uid"), @Result(column="money",property="money"), @Result(column="uid", property="user", one=@One(select="com.itheima.dao.IUserDao.findById", fetchType=FetchType.LAZY) ) &#125;) List&lt;Account&gt; findAll();&#125; 3.2.3 添加用户的持久层接口并使用注解配置1234567891011121314151617181920212223242526272829303132/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据 id 查询一个用户 * @param userId * @return */ @Select("select * from user where id = #&#123;uid&#125; ") @ResultMap("userMap") User findById(Integer userId);&#125; 3.2.4 测试一对一关联及延迟加载12345678910111213141516/**** &lt;p&gt;Title: AccountTest&lt;/p&gt;* &lt;p&gt;Description: 账户的测试类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll(); // for(Account account : accounts) &#123; // System.out.println(account); // System.out.println(account.getUser()); // &#125;&#125; 3.3 使用注解实现一对多复杂关系映射需求：查询用户信息时，也要查询他的账户列表。使用注解方式实现。分析：一个用户具有多个账户信息，所以形成了用户(User)与账户(Account)之间的一对多关系。 3.3.1 User实体类加入List&lt;Account&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; //一对多关系映射：主表方法应该包含一个从表方的集合引用 private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 3.3.2 编写用户的持久层接口并使用注解配置1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday"), @Result(column="id",property="accounts", many=@Many( select="com.itheima.dao.IAccountDao.findByUid", fetchType=FetchType.LAZY ) ) &#125;) List&lt;User&gt; findAll();&#125; @Many:相当于&lt;collection&gt;的配置select 属性：代表将要执行的 sql 语句fetchType 属性：代表加载方式，一般如果要延迟加载都设置为 LAZY 的值 3.3.3 编写账户的持久层接口并使用注解配置123456789101112131415/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 根据用户 id 查询用户下的所有账户 * @param userId * @return */ @Select("select * from account where uid = #&#123;uid&#125; ") List&lt;Account&gt; findByUid(Integer userId);&#125; 3.3.4 添加测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**** &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt;* &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); // for(User user : users) &#123; // System.out.println("-----每个用户的内容-----"); // System.out.println(user); // System.out.println(user.getAccounts()); // &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit 的注解 public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in); //3.创建 session session = factory.openSession(); //4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123; //提交事务 session.commit(); //释放资源 session.close(); //关闭流 in.close(); &#125;&#125; 4. mybatis基于注解的二级缓存4.1 在SqlMapConfig中开启二级缓存支持12345&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 4.2 在持久层接口中使用注解配置二级缓存12345678/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis延迟加载策略与缓存]]></title>
    <url>%2F2019%2F05%2F28%2F2019-05-28-Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[目录 何为延迟加载 实现需求 使用assocation实现延迟加载 使用Collection实现延迟加载 Mybatis一级缓存 Mybatis二级缓存 通过前面的学习，我们已经掌握了 Mybatis 中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。 1. 何为延迟加载延迟加载：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处 ：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 2. 实现需求需求：查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。 昨天实现多表操作时，我们使用了resultMap来实现一对一，一对多，多对多关系的操作。主要是通过 association、collection 实现一对一及一对多映射。association、collection 具备延迟加载功能。 3. 使用assocation实现延迟加载需求：查询账户信息同时查询用户信息。 3.1 账户的持久层DAO接口12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，同时获取账户的所属用户名称以及它的地址信息 * @return */ List&lt;Account&gt; findAll();&#125; 3.2 账户的持久层映射文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 建立对应关系 --&gt; &lt;resultMap type="account" id="accountMap"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt; &lt;association property="user" javaType="user" select="com.itheima.dao.IUserDao.findById" column="uid"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="accountMap"&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; select ： 填写我们要调用的 select 映射的 idcolumn ： 填写我们要传递给 select 映射的参数 3.3 用户的持久层接口和映射文件1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 id 查询 * @param userId * @return */ User findById(Integer userId);&#125; 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 根据 id 查询 --&gt; &lt;select id="findById" resultType="user" parameterType="int" &gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 3.4 开启Mybatis的延迟加载策略进入 Mybaits 的官方文档，找到 settings 的说明信息： 我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 12345&lt;!-- 开启延迟加载的支持 --&gt;&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 3.5 编写测试只查询账户信息而不查用户信息12345678910111213141516171819202122232425262728293031323334353637383940/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IAccountDao accountDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;Account&gt; accounts = accountDao.findAll(); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 accountDao = session.getMapper(IAccountDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们发现，因为本次只是将Account对象查询出来放入List集合中，并没有涉及到User对象，所以就没有发出 SQL 语句查询账户所关联的 User 对象的查询。 4. 使用Collection实现延迟加载同样我们也可以在一对多关系配置的&lt;collection&gt;结点中配置延迟加载策略。&lt;collection&gt;结点中也有 select 属性，column 属性。 需求：完成加载用户对象时，查询该用户所拥有的账户信息。 4.1 在User实体类中加入List&lt;Account&gt;属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 4.2 编写用户和账户持久层接口的方法12345/*** 查询所有用户，同时获取出每个用户下的所有账户信息* @return*/List&lt;User&gt; findAll(); 123456/*** 根据用户 id 查询账户信息* @param uid* @return*/List&lt;Account&gt; findByUid(Integer uid); 4.3 编写用户持久层映射配置123456789101112131415161718192021&lt;resultMap type="user" id="userMap"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称） column 是用于指定使用哪个字段的值作为条件查询 --&gt; &lt;collection property="accounts" ofType="account" select="com.itheima.dao.IAccountDao.findByUid" column="id"&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user&lt;/select&gt; &lt;collection&gt; 标签 ：主要用于加载关联的集合对象select 属性 ：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性 ：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 4.4 编写账户持久层映射配置1234&lt;!-- 根据用户 id 查询账户信息 --&gt;&lt;select id="findByUid" resultType="account" parameterType="int"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; 4.5 测试只加载用户信息1234567891011121314151617181920212223242526272829303132333435363738394041/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;User&gt; users = userDao.findAll(); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们发现并没有加载 Account 账户信息。 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。Mybatis 中缓存分为一级缓存，二级缓存。 5. Mybatis一级缓存5.1 证明一级缓存的存在一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 5.1.1 编写用户持久层Dao接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 id 查询 * @param userId * @return */ User findById(Integer userId);&#125; 5.1.2 编写用户持久层映射文件12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 根据 id 查询 --&gt; &lt;select id="findById" resultType="User" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 5.1.3 编写测试方法1234567891011121314151617181920212223242526272829303132333435363738394041424344/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindById() &#123; //6.执行操作 User user = userDao.findById(41); System.out.println("第一次查询的用户："+user); User user2 = userDao.findById(41); System.out.println("第二次查询用户："+user2); System.out.println(user == user2); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 5.2 一级缓存的分析一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 5.3 测试一级缓存的清空123456789101112131415161718192021222324252627282930313233343536/*** 测试一级缓存*/@Testpublic void testFirstLevelCache()&#123; User user1 = userDao.findById(41); System.out.println(user1); // sqlSession.close(); //再次获取 SqlSession 对象 // sqlSession = factory.openSession(); sqlSession.clearCache();//此方法也可以清空缓存 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125;/*** 测试缓存的同步*/@Testpublic void testClearlCache()&#123; //1.根据 id 查询用户 User user1 = userDao.findById(41); System.out.println(user1); //2.更新用户信息 user1.setUsername("update user clear cache"); user1.setAddress("北京市海淀区"); userDao.updateUser(user1); //3.再次查询 id 为 41 的用户 User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 当执行sqlSession.close()后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。 6. Mybatis二级缓存二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 6.1 二级缓存结构图 首先开启 mybatis 的二级缓存。 sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。 sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 6.2 二级缓存的开启与关闭6.2.1 第一步：在SqlMapConfig.xml文件开启二级缓存1234&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 6.2.2 第二步：配置相关的Mapper映射文件&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; 6.2.3 第三步：配置statement上面的useCache属性1234&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="user" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 6.3 二级缓存测试123456789101112131415161718192021222324252627282930313233343536373839404142/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class SecondLevelCacheTest &#123; private InputStream in; private SqlSessionFactory factory; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; in.close(); &#125; /** * 测试一级缓存 */ @Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125;&#125; 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。 6.4 二级缓存注意事项当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这样就可以使用序列化方式来保存对象。 12345678910111213/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多表查询之一对多与多对多]]></title>
    <url>%2F2019%2F05%2F27%2F2019-05-27-Mybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[目录 一对一查询（多对一） 一对多查询 实现Role到User的多对多 实现User到Role的多对多 本次案例主要以最为简单的用户和账户的模型来分析Mybatis多表关系。用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。具体关系如下： 1. 一对一查询（多对一）需求： 查询所有账户信息，关联查询下单用户信息。注意： 因为一个账户信息只能供某个用户使用，所以从查询账户信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。 1.1 方式一1.1.1 定义账户信息的实体类1234567891011121314151617181920212223242526272829303132333435/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 1.1.2 编写Sql语句实现查询账户信息时，也要查询账户所对应的用户信息。 12345678SELECT account.*, user.username, user.addressFROM account, userWHERE account.uid = user.id 在 MySQL 中测试的查询结果如下： 1.1.3 定义 AccountUser类为了能够封装上面 SQL 语句的查询结果，定义 AccountCustomer 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 AccountUser 类时可以继承 User 类。 123456789101112131415161718192021222324252627/**** &lt;p&gt;Title: AccountUser&lt;/p&gt;* &lt;p&gt;Description: 它是 account 的子类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountUser extends Account implements Serializable &#123; private String username; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return super.toString() + " AccountUser [username=" + username + ", address=" + address + "]"; &#125;&#125; 1.1.4 定义账户的持久层Dao接口12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123;/*** 查询所有账户，同时获取账户的所属用户名称以及它的地址信息* @return*/List&lt;AccountUser&gt; findAll();&#125; 1.1.5 定义AccountDao.xml文件中的查询配置信息12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 配置查询所有操作--&gt; &lt;select id="findAll" resultType="accountuser"&gt; select a.*,u.username,u.address from account a,user u where a.uid =u.id; &lt;/select&gt;&lt;/mapper&gt; 注意：因为上面查询的结果中包含了账户信息同时还包含了用户信息，所以我们的返回值类型 returnType的值设置为 AccountUser 类型，这样就可以接收账户信息和用户信息了。 1.1.6 创建AccountTest测试类12345678910111213141516171819202122232425262728293031323334353637383940414243/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IAccountDao accountDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;AccountUser&gt; accountusers = accountDao.findAll(); for(AccountUser au : accountusers) &#123; System.out.println(au); &#125; &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 accountDao = session.getMapper(IAccountDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 1.1.7 小结定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。 1.2 方式二使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。 通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。 1.2.1 修改Account类在 Account 类中加入 User 类的对象作为 Account 类的一个属性。 123456789101112131415161718192021222324252627282930313233343536373839404142/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 1.2.2 修改AccountDao接口中的方法12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，同时获取账户的所属用户名称以及它的地址信息 * @return */ List&lt;Account&gt; findAll();&#125; 注意：第二种方式，将返回值改 为了 Account 类型。因为 Account 类中包含了一个 User 类的对象，它可以封装账户所对应的用户信息。 1.2.3 重新定义AccountDao.xml文件1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 建立对应关系 --&gt; &lt;resultMap type="account" id="accountMap"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt; &lt;association property="user" javaType="user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="accountMap"&gt; select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id; &lt;/select&gt;&lt;/mapper&gt; 1.2.4 在AccountTest类中加入测试方法12345678@Testpublic void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll(); for(Account au : accounts) &#123; System.out.println(au); System.out.println(au.getUser()); &#125; &#125; 2. 一对多查询需求：查询所有用户信息及用户关联的账户信息。 分析：用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，我们想到了左外连接查询比较合适。 2.1 编写SQL语句1234567SELECT u.*, acc.id id, acc.uid, acc.moneyFROM user uLEFT JOIN account acc ON u.id = acc.uid 测试该 SQL 语句在 MySQL 客户端工具的查询结果如下： 2.2 User类加入List&lt;Account&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 2.3 在持久层Dao接口中加入查询方法12345/*** 查询所有用户，同时获取出每个用户下的所有账户信息* @return*/List&lt;User&gt; findAll(); 2.4 在持久层Dao映射文件配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;resultMap type="user" id="userMap"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 --&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultMap="userMap"&gt; select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid &lt;/select&gt;&lt;/mapper&gt; collection 部分定义了用户关联的账户信息。表示关联查询结果集property=&quot;accList&quot; ： 关联查询的结果集存储在 User 对象的上哪个属性。ofType=&quot;account&quot; ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 2.5 测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println("-------每个用户的内容---------"); System.out.println(user); System.out.println(user.getAccounts()); &#125; &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 3. 实现Role到User的多对多通过前面的学习，我们使用 Mybatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系。 3.1 用户与角色的关系模型用户与角色的多对多关系模型如下： 在 MySQL 数据库中添加角色表，用户角色的中间表。 角色表 用户角色中间表 3.2 业务要求及实现SQL需求：实现查询所有对象并且加载它所分配的用户信息。分析：查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中间表(USER_ROLE 表)才能关联到用户信息。 下面是实现的 SQL 语句： 1234567891011121314SELECT r.*,u.id uid, u.username username, u.birthday birthday, u.sex sex, u.address addressFROM ROLE rINNER JOIN USER_ROLE urON ( r.id = ur.rid)INNER JOIN USER uON (ur.uid = u.id); 3.3 编写角色实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; public Integer getRoleId() &#123; return roleId; &#125; public void setRoleId(Integer roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleDesc() &#123; return roleDesc; &#125; public void setRoleDesc(String roleDesc) &#123; this.roleDesc = roleDesc; &#125; @Override public String toString() &#123; return "Role&#123;" + "roleId=" + roleId + ", roleName='" + roleName + '\'' + ", roleDesc='" + roleDesc + '\'' + '&#125;'; &#125;&#125; 3.4 编写Role持久层接口1234567891011/*** @author 黑马程序员* @Company http://www.ithiema.com*/public interface IRoleDao &#123; /** * 查询所有角色 * @return */ List&lt;Role&gt; findAll();&#125; 3.5 编写映射文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IRoleDao"&gt; &lt;!--定义 role 表的 ResultMap--&gt; &lt;resultMap id="roleMap" type="role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--查询所有--&gt; &lt;select id="findAll" resultMap="roleMap"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt;&lt;/mapper&gt; 3.6 编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class RoleTest &#123; private InputStream in; private SqlSession sqlSession; private IRoleDao roleDao; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取 SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取 SqlSession 对象 sqlSession = factory.openSession(true); //4.获取 dao 的代理对象 roleDao = sqlSession.getMapper(IRoleDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; //提交事务 // sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;Role&gt; roles = roleDao.findAll(); for(Role role : roles)&#123; System.out.println("---每个角色的信息----"); System.out.println(role); System.out.println(role.getUsers()); &#125; &#125;&#125; 4. 实现User到Role的多对多4.1 User到Role的多对多从 User 出发，我们也可以发现一个用户可以具有多个角色，这样用户到角色的关系也还是一对多关系。这样我们就可以认为 User 与 Role 的多对多关系，可以被拆解成两个一对多关系来实现。 4.2 实现User到Role的一对多查询需求：实现查询所有用户信息并关联查询出每个用户的角色列表。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的动态SQL片段]]></title>
    <url>%2F2019%2F05%2F26%2F2019-05-26-Mybatis%E7%9A%84%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[目录 动态SQL之&lt;if&gt;标签 动态SQL之&lt;where&gt;标签 动态标签之&lt;foreach&gt;标签 Mybatis中简化编写的SQL片段 Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 1. 动态SQL之&lt;if&gt;标签我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1.1 持久层Dao接口123456/*** 根据用户信息，查询用户列表* @param user* @return*/List&lt;User&gt; findByUser(User user); 1.2 持久层Dao映射配置123456789&lt;select id="findByUser" resultType="user" parameterType="user"&gt; select * from user where 1=1 &lt;if test="username!=null and username != '' "&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test="address != null"&gt; and address like #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 注意：标签的 test 属性中写的是对象的属性名，如果是包装类的对象要使用 OGNL 表达式的写法。另外要注意 where 1=1 的作用~！ 1.3 测试1234567891011@Testpublic void testFindByUser() &#123; User u = new User(); u.setUsername("%王%"); u.setAddress("%顺义%"); //6.执行操作 List&lt;User&gt; users = userDao.findByUser(u); for(User user : users) &#123; System.out.println(user); &#125; &#125; 2. 动态SQL之&lt;where&gt;标签为了简化上面where 1=1的条件拼装，我们可以采用&lt;where&gt;标签来简化开发。 2.1 持久层Dao映射配置123456789101112&lt;!-- 根据用户信息查询 --&gt;&lt;select id="findByUser" resultType="user" parameterType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="username!=null and username != '' "&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test="address != null"&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3. 动态标签之&lt;foreach&gt;标签3.1 需求传入多个 id 查询用户信息，用下边两个 sql 实现： SELECT FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16)SELECT FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。这样我们将如何进行参数的传递？ 3.2 在QueryVo中加入一个List集合用于封装参数1234567891011121314151617/**** &lt;p&gt;Title: QueryVo&lt;/p&gt;* &lt;p&gt;Description: 查询的条件&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125;&#125; 3.3 持久层Dao接口123456/*** 根据 id 集合查询用户* @param vo* @return*/List&lt;User&gt; findInIds(QueryVo vo); 3.4 持久层Dao映射配置123456789101112&lt;!-- 查询所有用户在 id 的集合之中 --&gt;&lt;select id="findInIds" resultType="user" parameterType="queryvo"&gt;&lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="ids != null and ids.size() &gt; 0"&gt; &lt;foreach collection="ids" open="id in ( " close=")" item="uid" separator=","&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; SQL 语句：select 字段 from user where id in (?) &lt;foreach&gt;标签用于遍历集合，它的属性：collection:代表要遍历的集合元素，注意编写时不要写#{}open:代表语句的开始部分close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名sperator:代表分隔符 3.5 编写测试方法12345678910111213141516@Testpublic void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(41); ids.add(42); ids.add(43); ids.add(46); ids.add(57); vo.setIds(ids); //6.执行操作 List&lt;User&gt; users = userDao.findInIds(vo); for(User user : users) &#123; System.out.println(user); &#125; &#125; 4. Mybatis中简化编写的SQL片段Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。 4.1 定义代码片段1234&lt;!-- 抽取重复的语句代码片段 --&gt;&lt;sql id="defaultSql"&gt; select * from user&lt;/sql&gt; 4.2 引用代码块12345678910&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt;&lt;/select&gt;&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="User" parameterType="int"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; where id = #&#123;uid&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis连接池与事务深入]]></title>
    <url>%2F2019%2F05%2F25%2F2019-05-25-Mybatis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[目录 Mybatis的连接池技术 Mybatis的事务控制 1. Mybatis的连接池技术Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现 Mybatis 中连接池的配置。 1.1 Mybatis连接池的分类在 Mybatis 中我们将它的数据源 dataSource 分为以下几类： 可以看出 Mybatis 将它自己的数据源分为三类：UNPOOLED 不使用连接池的数据源POOLED 使用连接池的数据源JNDI 使用 JNDI 实现的数据源具体结构如下： 相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 在这三种数据源中，我们一般采用的是 POOLED 数据源（很多时候我们所说的数据源就是为了更好的管理数据库连接，也就是我们所说的连接池技术）。 1.2 Mybatis 中数据源的配置我们的数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下： 1234567&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; MyBatis 在初始化时，根据的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 1.3 Mybatis中DataSource的存取MyBatis 是通过工厂模式来创建数据源 DataSource 对象的， MyBatis 定义了抽象的工厂接口:org.apache.ibatis.datasource.DataSourceFactory,通过其 getDataSource()方法返回数据源DataSource。 下面是 DataSourceFactory 源码，具体如下： 12345678910111213package org.apache.ibatis.datasource;import java.util.Properties;import javax.sql.DataSource;/*** @author Clinton Begin*/public interface DataSourceFactory &#123; void setProperties(Properties props); DataSource getDataSource();&#125; MyBatis 创建了 DataSource 实例后，会将其放到 Configuration 对象内的 Environment 对象中， 供以后使用。 具体分析过程如下： 1.先进入 XMLConfigBuilder 类中，可以找到如下代码： 2.分析 configuration 对象的 environment 属性，结果如下： 1.4 Mybatis中连接的获取过程分析当我们需要创建 SqlSession 对象并需要执行 SQL 语句时，这时候 MyBatis 才会去调用 dataSource 对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。 12345678@Testpublic void testSql() throws Exception &#123; InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = factory.openSession(); List&lt;User&gt; list = sqlSession.selectList("findUserById",41); System.out.println(list.size());&#125; 只有当第 4 句sqlSession.selectList(“findUserById”)，才会触发 MyBatis 在底层执行下面这个方法来创建 java.sql.Connection 对象。 如何证明它的加载过程呢？ 我们可以通过断点调试，在 PooledDataSource 中找到如下 popConnection()方法，如下所示： 分析源代码，得出 PooledDataSource 工作原理如下： 下面是连接获取的源代码： 最后我们可以发现，真正连接打开的时间点，只是在我们执行SQL语句时，才会进行。其实这样做我们也可以进一步发现，数据库连接是我们最为宝贵的资源，只有在要用到的时候，才去获取并打开连接，当我们用完了就再立即将数据库连接归还到连接池中。 2. Mybatis的事务控制2.1 JDBC中事务的回顾在 JDBC 中我们可以通过手动方式将事务的提交改为手动方式，通过 setAutoCommit()方法就可以调整。通过 JDK 文档，我们找到该方法如下： 那么我们的 Mybatis 框架因为是对 JDBC 的封装，所以 Mybatis 框架的事务控制方式，本身也是用 JDBC的setAutoCommit()方法来设置事务提交方式的。 2.2 Mybatis中事务提交方式Mybatis 中事务的提交方式，本质上就是调用 JDBC 的 setAutoCommit()来实现事务控制。我们运行之前所写的代码： 1234567891011121314151617181920212223242526272829303132@Testpublic void testSaveUser() throws Exception &#123; User user = new User(); user.setUsername("mybatis user09"); //6.执行操作 int res = userDao.saveUser(user); System.out.println(res); System.out.println(user.getId());&#125;@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.提交事务 session.commit(); //8.释放资源 session.close(); in.close();&#125; 观察在它在控制台输出的结果： 这是我们的 Connection 的整个变化过程，通过分析我们能够发现之前的 CUD 操作过程中，我们都要手动进行事务的提交，原因是 setAutoCommit()方法，在执行时它的值被设置为 false 了，所以我们在 CUD 操作中，必须通过 sqlSession.commit()方法来执行提交操作。 2.3 Mybatis自动提交事务的设置通过上面的研究和分析，现在我们一起思考，为什么 CUD 过程中必须使用 sqlSession.commit()提交事务？主要原因就是在连接池中取出的连接，都会将调用 connection.setAutoCommit(false)方法，这样我们就必须使用 sqlSession.commit()方法，相当于使用了 JDBC 中的 connection.commit()方法实现事务提交。 明白这一点后，我们现在一起尝试不进行手动提交，一样实现 CUD 操作。 1234567891011121314151617181920@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(true); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close();&#125; 所对应的 DefaultSqlSessionFactory 类的源代码： 运行的结果如下： 我们发现，此时事务就设置为自动提交了，同样可以实现CUD操作时记录的保存。虽然这也是一种方式，但就编程而言，设置为自动提交方式为 false再根据情况决定是否进行提交，这种方式更常用。因为我们可以根据业务情况来决定提交是否进行提交。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件系统功能设计概述]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 什么是软件功能设计 功能设计在整个软件设计中的层次 功能设计在整个软件设计中的地位 功能设计与设计模式的关系 功能设计与详细设计的关系 功能设计要考虑的东西/评价标准 功能设计的实战方法——经验总结 关于软件设计的一些思考 1. 什么是软件功能设计所谓软件的功能设计，指的是：针对软件中某一个具体的功能，所进行的设计。包括这个功能的实现方式、实现的基本结构、类的组成、职责的划分等。是软件设计中最重要的基本功。 我们看一下一个仿QQ软件所需要设计的功能： 2. 功能设计在整个软件设计中的层次软件设计的层次很多，不同的软件设计过程有不同的划分方式，大致可分为：架构设计、api/spi设计、数据库设计、功能设计、类设计、方法设计。 从难度上说：公共类库&gt;公共框架&gt;基础平台/框架&gt;应用（产品&gt;项目） 3. 功能设计在整个软件设计中的地位功能设计从属详细设计，是整个系统功能实现的基石。 4. 功能设计与设计模式的关系功能设计通常会综合应用多种设计模式，是各种设计思想的具体体现的载体。由于功能千变万化，因而要有较高的设计技巧和功力，才能设计出正确的、易用的、灵活的、扩展性高的、高性能实现。 设计模式是业界公认的，优秀的设计经验和设计理念，理解、掌握、融会贯通、并能熟练变形应用设计模式，对于功能设计是有极大的帮助的。 5. 功能设计与详细设计的关系功能设计只是详细设计中的一个部分，详细设计还包括很多其他的设计，比如：流程设计、对API/SPI的完善和细化、对数据库设计的完善和细化、对多个功能交互的控制、事务的规划、权限/安全的规划、例外的控制……很多很多 6. 功能设计要考虑的东西/评价标准这个业界并没有统一的标准，而且不同类型、不同业务的系统考虑的东西并不一样，但还是有一些通常要考虑的东西： 正确性、易用性、可扩展性、复杂性（易理解、开发难度等）、易维护、安全、性能、可复用、可测试…… 当然还有很多其他需要考虑的，比如：多线程、分布式、可靠性、稳定性、对资源的利用和消耗、可伸缩、可配置、可移植、可定制…… 7. 功能设计的实战方法——经验总结 基本的功能实现方式，并进行细化 分析每个步骤，每个细节中，哪些是可变的，哪些是不可变的。通常分析3个部分：数据输入、具体实现、数据产出。 分析这个细节步骤的功能和其他步骤的关系，比如：顺序、平行、依赖等，以确定这些职责的粒度和分离方式，从而考虑他们之间的组合方式，也需要分离这些组合方式的变与不变。 根据前面分析的结果，进行相应的类、方法的设计、进行职责的划分，并通过合适的方式把他们组织起来。通常这个时候，就会融合进一个或多个设计模式的应用。当然也可能是没有现成的设计模式，需要自己来灵活组织和实现。 按照前面讲述的评价标准，进行系统的思考和调度，以形成最终的设计。 8. 关于软件设计的一些思考 设计的基本技巧：发现和封装变化，进行抽象和封装，实现高内聚和低耦合。 设计就是危险的平衡艺术，尽可能的找到最佳平衡点。 没有完美的设计，设计总是在不断演变中。 设计是没有标准答案的，只要能更好的实现功能，更好的满足那些评价标准，就是好东西。 不要过度设计不等于不设计，而是更要精巧设计。 关于重构的思考 关于敏捷的思考 设计是否增加了复杂度 设计是否增加了软件成本 关于训练功能设计的意义]]></content>
      <categories>
        <category>软件工程</category>
        <category>系统功能设计</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>系统功能设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis输入参数和输出结果封装]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24-Mybatis%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目录 parameterType配置参数 传递pojo包装对象 resultType配置结果类型 resultMap结果类型 SqlMapConfig.xml配置内容 properties（属性） typeAliases(类型别名) mappers(映射器) 1. parameterType配置参数1.1 使用说明我们在上一章节中已经介绍了 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类，本章节将介绍如何使用实体类的包装类作为参数传递。 1.2 注意事项基 本类 型和 String 我 们可 以直接 写类型 名称 ，也 可以 使用包 名 . 类名的 方式 ，例如 ：java.lang.String。 实体类类型，目前我们只能使用全限定类名。 究其原因，是 mybaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。在今天课程的最后一个章节中将讲解如何注册实体类的别名。 在 mybatis 的官方文档的说明(第 19 页) 这些都是支持的默认别名。我们也可以从源码角度来看它们分别都是如何定义出来的。可以参考 TypeAliasRegistery.class 的源码。 2. 传递pojo包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。 Pojo 类中包含 pojo。 需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。 2.1 编写QueryVo1234567891011121314151617/**** &lt;p&gt;Title: QueryVo&lt;/p&gt;* &lt;p&gt;Description: 查询条件对象&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class QueryVo implements Serializable &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 2.2 编写持久层接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 QueryVo 中的条件查询用户 * @param vo * @return */ List&lt;User&gt; findByVo(QueryVo vo);&#125; 2.3 持久层接口的映射文件1234&lt;!-- 根据用户名称模糊查询，参数变成一个 QueryVo 对象了 --&gt;&lt;select id="findByVo" resultType="com.itheima.domain.User" parameterType="com.itheima.domain.QueryVo"&gt; select * from user where username like #&#123;user.username&#125;;&lt;/select&gt; 2.4 测试包装类作为参数1234567891011@Testpublic void testFindByQueryVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName("%王%"); vo.setUser(user); List&lt;User&gt; users = userDao.findByVo(vo); for(User u : users) &#123; System.out.println(u); &#125;&#125; 3. resultType配置结果类型resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。 我们在前面的 CRUD 案例中已经对此属性进行过应用了。 需要注意的是，它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如：我们的实体类此时必须是全限定类名（今天最后一个章节会讲解如何配置实体类的别名） 同时，当是实体类名称时，还有一个要求，实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。 3.1 基本类型示例3.1.1 Dao接口12345/*** 查询总记录条数* @return*/int findTotal(); 3.1.2 映射配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; select count(*) from user;&lt;/select&gt; 3.2 实体类类型示例3.2.1 Dao接口12345/*** 查询所有用户* @return*/List&lt;User&gt; findAll(); 3.2.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user&lt;/select&gt; 3.3 特殊情况示例3.3.1 修改实体类实体类代码如下：（此时的实体类属性和数据库表的列名已经不一致了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 3.3.2 Dao接口12345/*** 查询所有用户* @return*/List&lt;User&gt; findAll(); 3.3.3 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user&lt;/select&gt; 3.3.4 测试查询结果1234567@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125;&#125; 运行结果： 为什么名称会有值呢？ 因为：mysql 在 在 windows 系统中不区分大小写！ 3.3.5 修改映射配置使用别名查询 12345&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select id as userId,username as userName,birthday as userBirthday, sex as userSex,address as userAddress from user&lt;/select&gt; 运行结果： 思考：如果我们的查询很多，都使用别名的话写起来岂不是很麻烦，有没有别的解决办法呢？ 请看下一小节。 4. resultMap结果类型resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 4.1 定义resultMap1234567891011&lt;!-- 建立 User 实体和数据库表的对应关系type 属性：指定实体类的全限定类名id 属性：给定一个唯一标识，是给查询 select 标签引用用的。--&gt;&lt;resultMap type="com.itheima.domain.User" id="userMap"&gt; &lt;id column="id" property="userId"/&gt; &lt;result column="username" property="userName"/&gt; &lt;result column="sex" property="userSex"/&gt; &lt;result column="address" property="userAddress"/&gt; &lt;result column="birthday" property="userBirthday"/&gt;&lt;/resultMap&gt; id 标签：用于指定主键字段result 标签：用于指定非主键字段column 属性：用于指定数据库列名property 属性：用于指定实体类属性名称 4.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user&lt;/select&gt; 4.3 测试结果1234567@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125;&#125; 运行结果： 5. SqlMapConfig.xml配置内容5.1 SqlMapConfig.xml中配置的内容和顺序1234567891011121314151617-properties （属性） --property-settings（全局配置参数） --setting-typeAliases （类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers （映射器） --mapper --package 6. properties（属性）在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。 6.1 第一种123456&lt;properties&gt; &lt;property name="jdbc.driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbc.url" value="jdbc:mysql://localhost:3306/eesy"/&gt; &lt;property name="jdbc.username" value="root"/&gt; &lt;property name="jdbc.password" value="1234"/&gt;&lt;/properties&gt; 6.2 第二种6.2.1 在classpath下定义da.properties文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=1234 6.2.2 properties标签配置1234567891011121314&lt;!-- 配置连接数据库的信息resource 属性：用于指定 properties 配置文件的位置，要求配置文件必须在类路径下resource="jdbcConfig.properties"url 属性：URL： Uniform Resource Locator 统一资源定位符http://localhost:8080/mystroe/CategoryServlet URL协议 主机 端口 URIURI：Uniform Resource Identifier 统一资源标识符/mystroe/CategoryServlet它是可以在 web 应用中唯一定位一个资源的路径--&gt;&lt;properties url= file:///D:/IdeaProjects/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.properties"&gt;&lt;/properties&gt; 6.2.3 此时我们的dataSource标签就变成了引用上面的配置123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; 7. typeAliases(类型别名)在前面我们讲的 Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发。 7.1 自定义别名在SqlMapConfig.xml中配置： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="user" type="com.itheima.domain.User"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name="com.itheima.domain"/&gt; &lt;package name=" 其它包 "/&gt;&lt;/typeAliases&gt; 8. mappers(映射器)8.1 &lt;mapper resource=” “使用相对于类路径的资源 如： 1&lt;mapper resource="com/itheima/dao/IUserDao.xml" /&gt; 8.2 &lt;mapper class=” “使用 mapper 接口类路径 如： 1&lt;mapper class="com.itheima.dao.UserDao"/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 8.3 &lt;package name=””注册指定包下的所有 mapper 接口 如： 1&lt;package name="cn.itcast.mybatis.mapper"/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于代理Dao实现CRUD操作]]></title>
    <url>%2F2019%2F05%2F23%2F2019-05-23-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86Dao%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[目录 自定义流程再分析 Mybatis环境搭建步骤 根据ID查询 保存操作 用户更新 用户删除 用户模糊查询 查询使用聚合函数 Mybatis与JDBC编程的比较 1. 自定义流程再分析 2. Mybatis环境搭建步骤第一步：创建maven工程 第二步：导入坐标 第三步：编写必要代码（实体类和持久层接口） 第四步：编写SqlMapConfig.xml 第五步：编写映射配置文件 第六步：编写测试类 使用要求： 1、持久层接口和持久层接口的映射配置必须在相同的包下 2、持久层映射配置中mapper标签的namespace属性必须是持久层接口的全限定类名 3、SQL语句的配置标签 ,,, 的id属性必须和持久层接口的方法名相同。 3. 根据ID查询3.1 在持久层接口中添加findById方法123456/*** 根据 id 查询* @param userId* @return*/User findById(Integer userId); 3.2 在用户的映射配置文件中配置1234&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="com.itheima.domain.User" parameterType="int"&gt;select * from user where id = #&#123;uid&#125;&lt;/select&gt; 细节： resultType属性：用于指定结果集的类型。 parameterType属性：用于指定传入参数的类型。 sql语句中使用#{ }字符：它代表占位符，相当于原来jdbc中所学的？，都是用于执行语句时替换实际的数据。具体的数据是由#{ }里面的内容决定的。 #{ }中内容的写法：由于数据类型是基本类型，所以此处可以随意写。 3.3 在测试类中添加测试123456789101112131415161718192021222324252627282930313233343536373839404142/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的 crud 操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybastisCRUDTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindOne() &#123; //6.执行操作 User user = userDao.findById(41); System.out.println(user); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 4. 保存操作4.1 在持久层接口中添加saveUser方法123456/*** 保存用户* @param user* @return 影响数据库记录的行数*/int saveUser(User user); 4.2 在用户的映射配置文件中配置12345&lt;!-- 保存用户--&gt;&lt;insert id="saveUser" parameterType="com.itheima.domain.User"&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 细节： parameterType属性：代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。 sql语句中使用#{ }字符：它代表占位符，相当于原来jdbc中所学的？，都是用于执行语句时替换实际的数据。具体的数据是由#{ }里面的内容决定的。 #{ }中内容的写法：由于我们保存方法的参数是一个User对象，此处要写User对象中的属性名称。它用的是ognl表达式。ognl表达式：它是apache提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言 它是按照一定的语法格式来获取数据的。语法格式就是使用#{对象.对象}的方式#{user.username}它会先去找user对象，然后在user对象中找到username属性，并调用getUsername()方法把值取出来。但是我们在parameterType属性上指定了实体类名称，所以可以省略user.而直接写username。 4.3 添加测试类中的测试方法123456789101112@Testpublic void testSave()&#123; User user = new User(); user.setUsername("modify User property"); user.setAddress("北京市顺义区"); user.setSex("男"); user.setBirthday(new Date()); System.out.println("保存操作之前："+user); //5.执行保存方法 userDao.saveUser(user); System.out.println("保存操作之后："+user);&#125; 打开 Mysql 数据库发现并没有添加任何记录，原因是什么？ 这一点和 jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在 mybatis 中如何控制事务提交呢？ 可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下： 1234567@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close();&#125; 4.4 问题扩展：新增用户id的返回值新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。 12345678&lt;insert id="saveUser" parameterType="USER"&gt; &lt;!-- 配置保存时获取插入的 id --&gt; &lt;selectKey keyColumn="id" keyProperty="id" resultType="int"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 5. 用户更新5.1 在持久层接口中添加updateUser方法123456/*** 更新用户* @param user* @return 影响数据库记录的行数*/int updateUser(User user); 5.2 在用户的映射配置文件中配置1234&lt;!-- 更新用户 --&gt;&lt;update id="updateUser" parameterType="com.itheima.domain.User"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 5.3 加入更新的测试方法123456789@Testpublic void testUpdateUser()throws Exception&#123; //1.根据 id 查询 User user = userDao.findById(52); //2.更新操作 user.setAddress("北京市顺义区"); int res = userDao.updateUser(user); System.out.println(res);&#125; 6. 用户删除6.1 在持久层接口中添加deleteUser方法123456/*** 根据 id 删除用户* @param userId* @return*/int deleteUser(Integer userId); 6.2 在用户的映射配置文件中配置1234&lt;!-- 删除用户 --&gt;&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; delete from user where id = #&#123;uid&#125;&lt;/delete&gt; 6.3 加入删除的测试方法123456@Testpublic void testDeleteUser() throws Exception &#123; //6.执行操作 int res = userDao.deleteUser(52); System.out.println(res);&#125; 7. 用户模糊查询7.1 在持久层接口中添加findByName方法123456/*** 根据名称模糊查询* @param username* @return*/List&lt;User&gt; findByName(String username); 7.2 在用户的映射配置文件中配置1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" resultType="com.itheima.domain.User" parameterType="String"&gt; select * from user where username like #&#123;username&#125;&lt;/select&gt; 7.3 加入模糊查询的测试方法12345678@Testpublic void testFindByName()&#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName("%王%"); for(User user : users)&#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 我们在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以 SQL 语句显示为“？”。 7.4 模糊查询的另一种配置方式第一步：修改 SQL 语句的配置，配置如下： 1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" parameterType="string" resultType="com.itheima.domain.User"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。 第二步：测试，如下： 1234567891011/*** 测试模糊查询操作*/@Testpublic void testFindByName()&#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName("王"); for(User user : users)&#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行的语句是不一样的。 7.5 #{}与${}的区别#{}表示一个占位符 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 ${} 表示拼接 sql 串 通过${}可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 7.6 模糊查询的${value}源码分析我们一起来看 TextSqlNode 类的源码： 这就说明了源码中指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字了。 8. 查询使用聚合函数8.1 在持久层接口中添加findTotal()方法12345/*** 查询总记录条数* @return*/int findTotal(); 8.2 在用户的映射配置文件中配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; select count(*) from user;&lt;/select&gt; 8.3 加入聚合查询的测试方法123456@Testpublic void testFindTotal() throws Exception &#123; //6.执行操作 int res = userDao.findTotal(); System.out.println(res);&#125; 9. Mybatis与JDBC编程的比较1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 3.向sql语句传参数麻烦，因为sql语句的where 条件不一定，可能多也可能少，占位符需要和参数对应。 解决：Mybatis自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。 4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。 解决：Mybatis自动将 sql执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写Mybatis框架]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-22-%E6%89%8B%E5%86%99Mybatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目录 自定义Mybatis框架的分析 前期准备 基于XML的自定义Mybatis框架 基于注解方式定义Mybatis框架 自定义Mybatis的设计模式说明 1. 自定义Mybatis框架的分析1.1 涉及知识点介绍本章我们将使用前面所学的基础知识来构建一个属于自己的持久层框架，将会涉及到的一些知识点：工厂模式（Factory 工厂模式）、构造者模式（Builder 模式）、代理模式，反射，自定义注解，注解的反射，xml 解析，数据库元数据，元数据的反射等。 1.2 分析流程 2. 前期准备2.1 创建maven工程创建 mybatis02 的工程，工程信息如下： Groupid:com.itheimaArtifactId:mybatis02Packing:jar 2.2 引入相关坐标12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 日志坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解析 xml 的 dom4j --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dom4j 的依赖包 jaxen --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 引入工具类到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/*** @author 黑马程序员* @Company http://www.ithiema.com* 用于解析配置文件*/public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到 DefaultSqlSession 所需要的地方 * 使用的技术： * dom4j+xpath * @param session */ public static void loadConfiguration(DefaultSqlSession session,InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis 的配置对象） Configuration cfg = new Configuration(); //1.获取 SAXReader 对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取 Document 对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用 xpath 中选择指定节点的方式，获取所有 property 节点 List&lt;Element&gt; propertyElements = root.selectNodes("//property"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出 name 属性的值 String name = propertyElement.attributeValue("name"); if("driver".equals(name))&#123; //表示驱动 //获取 property 标签 value 属性的值 String driver = propertyElement.attributeValue("value"); cfg.setDriver(driver); &#125; if("url".equals(name))&#123; //表示连接字符串 //获取 property 标签 value 属性的值 String url = propertyElement.attributeValue("value"); cfg.setUrl(url); &#125; if("username".equals(name))&#123; //表示用户名 //获取 property 标签 value 属性的值 String username = propertyElement.attributeValue("value"); cfg.setUsername(username); &#125; if("password".equals(name))&#123; //表示密码 //获取 property 标签 value 属性的值 String password = propertyElement.attributeValue("value"); cfg.setPassword(password); &#125; &#125; //取出 mappers 中的所有 mapper 标签，判断他们使用了 resource 还是 class 属性 List&lt;Element&gt; mapperElements = root.selectNodes("//mappers/mapper"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断 mapperElement 使用的是哪个属性 Attribute attribute = mapperElement.attribute("resource"); if(attribute != null)&#123; System.out.println("使用的是 XML"); //表示有 resource 属性，用的是 XML //取出属性的值 String mapperPath = attribute.getValue();// 获 取 属 性 的 值"com/itheima/dao/IUserDao.xml" //把映射配置文件的内容获取出来，封装成一个 map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println("使用的是注解"); //表示没有 resource 属性，用的是注解 //获取 class 属性的值 String daoClassPath = mapperElement.attributeValue("class"); //根据 daoClassPath 获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); &#125; &#125; //把配置对象传递给 DefaultSqlSession session.setCfg(cfg); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析 XML，并且封装到 Map 中 * @param mapperPath 映射配置文件的位置 * @return map 中包含了获取的唯一标识（key 是由 dao 的全限定类名和方法名组成） * 以及执行所需的必要信息（value 是一个 Mapper 对象，里面存放的是执行的 SQL 语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取 Document 对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的 namespace 属性取值 String namespace = root.attributeValue("namespace");//是组成 map 中 key 的部分 //5.获取所有的 select 节点 List&lt;Element&gt; selectElements = root.selectNodes("//select"); //6.遍历 select 节点集合 for(Element selectElement : selectElements)&#123; //取出 id 属性的值 组成 map 中 key 的部分 String id = selectElement.attributeValue("id"); //取出 resultType 属性的值 组成 map 中 value 的部分 String resultType = selectElement.attributeValue("resultType"); //取出文本内容 组成 map 中 value 的部分 String queryString = selectElement.getText(); //创建 Key String key = namespace+"."+id; //创建 Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把 key 和 value 存入 mappers 中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到 dao 中所有被 select 注解标注的方法。 * 根据方法名称和类名，以及方法上注解 value 属性的值，组成 Mapper 的必要信息 * @param daoClassPath * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到 dao 接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到 dao 接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历 Method 数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有 select 注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建 Mapper 对象 Mapper mapper = new Mapper(); //取出注解的 value 属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断 type 是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取 domainClass 的类名 String resultType = domainClass.getName(); //给 Mapper 赋值 mapper.setResultType(resultType); &#125; //组装 key 的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+"."+methodName; //给 map 赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** @author 黑马程序员* @Company http://www.ithiema.com* 负责执行 SQL 语句，并且封装结果集*/public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出 mapper 中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType);//User.class //2.获取 PreparedStatement 对象 pstm = conn.prepareStatement(queryString); //3.执行 SQL 语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance();//User 对象 //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从 1 开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给 obj 赋值：使用 Java 内省机制（借助 PropertyDescriptor 实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod();//setUsername(String username); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125;&#125; private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223/**** &lt;p&gt;Title: DataSourceUtil&lt;/p&gt;* &lt;p&gt;Description: 数据源的工具类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DataSourceUtil &#123; /** * 获取连接 * @param cfg * @return */ public static Connection getConnection(Configuration cfg) &#123; try &#123; Class.forName(cfg.getDriver()); Connection conn = DriverManager.getConnection(cfg.getUrl(),cfg.getUsername() , cfg.getPassword()); return conn; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.4 编写 SqlMapConfig.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///eesy" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 注意：此处我们直接使用的是 mybatis 的配置文件，但是由于我们没有使用 mybatis 的 jar 包，所以要把配置文件的约束删掉否则会报错（如果电脑能接入互联网，不删也行） 2.5 编写读取配置文件类12345678910111213141516171819/**** &lt;p&gt;Title: Resources&lt;/p&gt;* &lt;p&gt;Description: 用于读取配置文件的类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Resources &#123; /** * 用于加载 xml 文件，并且得到一个流对象 * @param xmlPath * @return * 在实际开发中读取配置文件: * 第一：使用类加载器。但是有要求：a 文件不能过大。 b 文件必须在类路径下(classpath) * 第二：使用 ServletContext 的 getRealPath() */ public static InputStream getResourceAsStream(String xmlPath) &#123; return Resources.class.getClassLoader().getResourceAsStream(xmlPath); &#125;&#125; 2.6 编写 Mapper 类123456789101112131415161718192021222324252627/**** &lt;p&gt;Title: Mapper&lt;/p&gt;* &lt;p&gt;Description: 用于封装查询时的必要信息：要执行的 SQL 语句和实体类的全限定类名&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Mapper &#123; private String queryString;//sql private String resultType;//结果类型的全限定类名 public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; 2.7 编写 Configuration 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 核心配置类* 1.数据库信息* 2.sql 的 map 集合*/public class Configuration &#123; private String username; //用户名 private String password;//密码 private String url;//地址 private String driver;//驱动 //map 集合 Map&lt;唯一标识，Mapper&gt; 用于保存映射文件中的 sql 标识及 sql 语句 private Map&lt;String,Mapper&gt; mappers; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123; this.mappers = mappers; &#125;&#125; 2.8 编写User实体类1234567891011121314public class User implements Serializable &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 //省略 getter 与 setter @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", sex=" + sex + ", birthday=" + birthday + ", address=" + address + "]"; &#125;&#125; 3. 基于XML的自定义Mybatis框架3.1 编写持久层接口和 IUserDao.xml12345678910111213/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注意：此处我们使用的也是 mybatis 的配置文件，所以也要把约束删除了 3.2 编写构建者类12345678910111213141516171819/**** &lt;p&gt;Title: SqlSessionFactoryBuilder&lt;/p&gt;* &lt;p&gt;Description: 用于构建 SqlSessionFactory 的&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class SqlSessionFactoryBuilder &#123; /** * 根据传入的流，实现对 SqlSessionFactory 的创建 * @param in 它就是 SqlMapConfig.xml 的配置以及里面包含的 IUserDao.xml 的配置 * @return */ public SqlSessionFactory build(InputStream in) &#123; DefaultSqlSessionFactory factory = new DefaultSqlSessionFactory(); //给 factory 中 config 赋值 factory.setConfig(in); return factory; &#125;&#125; 3.3 编写 SqlSessionFactory 接口和实现类12345678910111213/**** &lt;p&gt;Title: SqlSessionFactory&lt;/p&gt;* &lt;p&gt;Description: SqlSessionFactory 的接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface SqlSessionFactory &#123; /** * 创建一个新的 SqlSession 对象 * @return */ SqlSession openSession();&#125; 12345678910111213141516171819/**** &lt;p&gt;Title: DefaultSqlSessionFactory&lt;/p&gt;* &lt;p&gt;Description:SqlSessionFactory 的默认实现 &lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private InputStream config = null; public void setConfig(InputStream config) &#123; this.config = config; &#125; @Override public SqlSession openSession() &#123; DefaultSqlSession session = new DefaultSqlSession(); //调用工具类解析 xml 文件 XMLConfigBuilder.loadConfiguration(session, config); return session; &#125;&#125; 3.4 编写 SqlSession 接口和实现类123456789101112131415161718/**** &lt;p&gt;Title: SqlSession&lt;/p&gt;* &lt;p&gt;Description: 操作数据库的核心对象&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface SqlSession &#123; /** * 创建 Dao 接口的代理对象 * @param daoClass * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoClass); /** * 释放资源 */ void close();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/**** &lt;p&gt;Title: DefaultSqlSession&lt;/p&gt;* &lt;p&gt;Description: SqlSession 的具体实现&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DefaultSqlSession implements SqlSession &#123; //核心配置对象 private Configuration cfg; public void setCfg(Configuration cfg) &#123; this.cfg = cfg; &#125; //连接对象 private Connection conn; //调用 DataSourceUtils 工具类获取连接 public Connection getConn() &#123; try &#123; conn = DataSourceUtil.getDataSource(cfg).getConnection(); return conn; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 动态代理： * 涉及的类：Proxy * 使用的方法：newProxyInstance * 方法的参数： * ClassLoader：和被代理对象使用相同的类加载器,通常都是固定的 * Class[]：代理对象和被代理对象要求有相同的行为。（具有相同的方法） * InvocationHandler：如何代理。需要我们自己提供的增强部分的代码 */ @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; daoClass) &#123; conn = getConn(); System.out.println(conn); T daoProxy = (T) Proxy.newProxyInstance(daoClass.getClassLoader(),new Class[] &#123;daoClass&#125;, new MapperProxyFactory(cfg.getMappers(),conn)); return daoProxy; &#125; //释放资源 @Override public void close() &#123; try &#123; System.out.println(conn); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //查询所有方法 public &lt;E&gt; List&lt;E&gt; selectList(String statement)&#123; Mapper mapper = cfg.getMappers().get(statement); return new Executor().selectList(mapper,conn); &#125;&#125; 3.5 编写用于创建 Dao 接口代理对象的类12345678910111213141516171819202122232425262728293031323334353637383940414243/**** &lt;p&gt;Title: MapperProxyFactory&lt;/p&gt;* &lt;p&gt;Description: 用于创建代理对象是增强方法&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MapperProxyFactory implements InvocationHandler &#123; private Map&lt;String,Mapper&gt; mappers; private Connection conn; public MapperProxyFactory(Map&lt;String, Mapper&gt; mappers,Connection conn) &#123; this.mappers = mappers; this.conn = conn; &#125; /** * 对当前正在执行的方法进行增强 * 取出当前执行的方法名称 * 取出当前执行的方法所在类 * 拼接成 key * 去 Map 中获取 Value（Mapper) * 使用工具类 Executor 的 selectList 方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; //1.取出方法名 String methodName = method.getName(); //2.取出方法所在类名 String className = method.getDeclaringClass().getName(); //3.拼接成 Key String key = className+"."+methodName; //4.使用 key 取出 mapper Mapper mapper = mappers.get(key); if(mapper == null) &#123; throw new IllegalArgumentException("传入的参数有误，无法获取执行的必要条件"); &#125; //5.创建 Executor 对象 Executor executor = new Executor(); return executor.selectList(mapper, conn); &#125;&#125; 3.6 运行测试类1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: MybatisTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的环境&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; //7.释放资源 session.close(); in.close(); &#125;&#125; 4. 基于注解方式定义Mybatis框架4.1 自定义@Select注解1234567891011/**** &lt;p&gt;Title: Select&lt;/p&gt;* &lt;p&gt;Description: 自定义查询注解&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; String value();&#125; 4.2 修改持久层接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 4.3 修改 SqlMapConfig.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee50"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper class="com.itheima.dao.IUserDao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5. 自定义Mybatis的设计模式说明5.1 工厂模式（SqlSessionFactory） 5.2 代理模式（MapperProxyFactory） 代理模式分为静态和动态代理。静态代理，我们通常都很熟悉。有一个写好的代理类，实现与要代理的类的一个共同的接口，目的是为了约束也为了安全。具体不再多说。 这里主要想说的是关于动态代理。我们知道静态代理若想代理多个类，实现扩展功能，那么它必须具有多个代理类分别取代理不同的实现类。这样做的后果是造成太多的代码冗余。那么我们会思考如果做，才能既满足需求，又没有太多的冗余代码呢？——————动态代理。通过前面的课程我们已经学过了基于 JDK 的动态代理实现方式，今天我们就会使用 JDK 动态代理方式来编写 MapperProxyFactory 类。 动态代理模型图： 5.3 构建者模式（SqlSessionFactoryBuilder） 具体设计模式的模型图如下： 从图中我们可以看出，创建者模式由四部分组成。 抽象创建者角色：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体创建者角色。具体创建者必须实现这个接口的两种方法：一是建造方法，比如图中的 buildPart1 和 buildPart2 方法；另一种是结果返回方法，即图中的 getProduct 方法。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少零件，就有多少相应的建造方法。 具体创建者角色：他们在应用程序中负责创建产品的实例。这个角色要完成的任务包括：1、实现抽象创建者所声明的抽象方法，给出一步一步的完成产品创建实例的操作。2、在创建完成后，提供产品的实例。 导演者角色：这个类调用具体创建者角色以创建产品对象。但是导演者并没有产品类的具体知识，真正拥有产品类的具体知识的是具体创建者角色。 产品角色：产品便是建造中的复杂对象。一般说来，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以使不相关联的。 5.4 小结通过自定义 Mybatis 框架的学习，我们将前面的基础知识很好的结合在一起，并且强化了我们的设计模式及使用。希望大家能够抽时间多练习，这也是系统架构师的必由之路。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件项目需求分析到详细设计]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%88%B0%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[目录 软件生命周期 需求分析 详细设计 1. 软件生命周期1.1 什么是软件生命周期软件生命周期又称为软件生存周期或系统开发生命周期，是指从软件的产生直到报废的整个过程。 软件生命周期过程包括： 问题定义： 用户需要计算机解决的问题是什么？ 电商系统：要计算机实现一个平台，商家通过平台销售自己的商品，一般用户通过平台购买商品。 可行性分析 用户需要计算机解决的问题是否可行？需要进行可行性分析。 市场可行性分析，是否有市场价值。 技术可行性分析，使用什么技术解决用户提出的问题。 需求分析（重点） 将用户提出的问题进行细化。 先确定大模块：比如电商系统包括：前台（用户购买商品），后台（商家维护商品）。 对每一个大模块进行细化。。。。。 直到细化到不能细化为止（可以对需求分析的结果进行设计 ）。 设计（次重点） 确定细化问题的实现方法（比如：要设计什么接口，设计功能什么技术实现。。。）。 编码 去解决问题，依据需求和设计 文档进行开发。 测试 验证是否已经解决用户提出的问题。 单元测试（通过在开发阶段由开发人员进行测试）。 集成测试（测试业务整体流程）。 功能用例测试（对每个细化 的功能点进行测试）。 性能测试(使用专业工具进行压力和稳定性测试)。 维护（占整个软件生命周期很大的比重） 修改性维护：前期没有测试出的问题，正式上线运行后bug（缺陷）显示出来了，对这些bug进行修改。 完善性维护：在现有功能的基础上增加或完善功能。 预防性维护：后期根据正式运行的情况对系统进行优化，避免一些问题的发生。 1.2 常用的开发模型企业开发中对上边开发阶段常使用一些模型： 1.2.1 瀑布模型 强调：开发的每个阶段是顺序执行，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈（为了解决问题需要重复执行），如何在某个阶段出现问题，需要从上一个阶段甚至更早的阶段去解决排查问题。 适用场合：需求明确，解决方案明确，常在一些中小型项目中使用。 1.2.2 原型模型 强调：逐步求精（每一次修改对上次原型的完善）对原型 进行修改优化，开发阶段围绕着原型（当成样品）进行实施。 适用场合：前期需求不确定，采用原型方法方便搜集需求。 1.2.3 增量模型 增量模型：瀑布模型加上原型模型，增量模型融合了瀑布模型的基本成分（重复应用）和原型实现的迭代特征。 每一次增量经过了开发的每一个阶段（瀑布模型经过的所有阶段） 每一次增量对功能进行完善（原型模型的逐步求精） 适用场合：大型项目，需求不明确。 2. 需求分析（重点）2.1 什么是需求分析需求分析是在问题定义及可行性分析完成后细化用户对软件的功能和性能的要求，即用户希望软件能做什么事情，完成什么样的功能，达到什么性能。 包括：需求调研、需求描述（重要）、需求评审。 重要性：需求分析是软件工发的开端，我们设计的软件产品存在不完整性、不正确性大部分原因是需求分析错误所导致的，因此，需求分析是软件生命周期中最重要的过程。 2.2 需求调研目标：挖掘用户需求 过程：首先确定目标用户，开发人员和目标用户确定一个问题领域，并定义一个描述该问题的系统，用户在这个问题领域和系统下提出需求，需求类型包括：功能需求、质量需求、用户体验需求等。 需求调研方法： 根据不同的项目、不同的用户群体采用不同的方法： 与客户交谈，向用户提问题 参观用户工作流程，观察用户操作 向用户发调查问卷（通常是以选择题和是非题为主） 与同行、专家交谈，听取他们的意见 分析已经存在的软件产品，提取需求 从行业标准、规划中提取需求 上网搜索相关资料 成果物：需求调研报告.doc 2.3 需求描述(重要)通过需求调研对收集到的资料进行分析、鉴别、综合和建模，清除用户需求的模糊性、歧义性和不一致性，分析系统的数据要求，为原始问题及目标软件建立逻辑模型。 分析人员需要编写“软件需求说明书”并与用户进行交流确认。 成果物：“软件需求说明书”或“软件需求规格说明书” 重要性： 需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书 软件开发人员需要根据“软件需求规格说明书”进行设计和编码。 软件需求规格说明书的内容也是根据公司的项目管理水平而定。 内容基本包括：系统概述、运行环境、功能模块图、功能用例、性能需求、接口需求、其它需求等。 功能模块图/功能架构图：通常使用visio画。 使用powerDesigner画用例图： 描述 了每类用户所操作的功能点。 功能用例： 描述功能点的具体内容。 接口需求： 系统对外接口： 接口描述内容：商品支付接口 接口功能描述： 电商网站需要调用网银支付接口进行支付 接口方向： 电商网站–&gt;网银 接口协议：https 接口数据描述(重点)： 开发人员依据接口数据描述开发程序。 电商网站要向网银发送什么数据格式（常用格式有xml或json） （包括请求和响应两部分数据） 建议：企业开发必须经过正规的需求分析过程。 2.4 需求评审由架构师、技术经理、需求分析人员、设计人员、开发人员对“需求规格说明书”进行审核。 审核内容： 1、看需求规格说明书是否符合文档规范。 2、需求描述 是否详细（设计人员可以依据需求说明书进行设计） 3 设计根据软件需求说明书进行设计，设计系统整体架构、系统外部和内部接口、实现算法和核心代码编写等，总之包括两个阶段：总体设计（概要设计 ）、详细设计。 3.1 概要设计概要设计内容： 总体结构和模块间的关系； 系统架构包括：技术架构和功能架构。 技术架构： 系统使用什么技术完成哪些模块的功能。 javaEE常用技术架构： ssh：struts2+spring+hibernate 主要开发中小型的传统企业应用系统。 ssm：springmvc+mybatis 主要开发分布式联系网项目。 功能架构 就是需求描述的功能框图 业务流程图： 使用visio画核心业务流程图： 系统网络部署结构 定义系统的外部接口、及模块间的接口； 接口描述内容：商品支付接口 接口功能描述： 电商网站需要调用网银支付接口进行支付 接口方向： 电商网站–&gt;网银 接口协议：https 接口数据描述(重点)： 开发人员依据接口数据描述开发程序。 电商网站要向网银发送什么数据格式（常用格式有xml或json） （包括请求和响应两部分数据） 3.2 详细设计详细设计内容： ​ 详细设计的主要任务是设计每个模块的类接口、所需的局部数据结构、物理数据模型、页面原型等。 注意：一般情况下公司根据人力现状不写详细设计文档的，可以在需求分析阶段和概要设计 阶段对详细设计的内容进行描述。 每个模块的类接口： 通过伪代码实现，描述接口参数、接口功能。 局部数据结构：需要自定义什么数据类型。。 物理数据模型（重点）： 使用powerDesigner设计物理数据模型(根据公司要求可能在需求分析阶段或概要设计 阶段实现) 通过powerDesigner创建数据库表、存储过程等元素。]]></content>
      <categories>
        <category>软件工程</category>
        <category>需求分析与详细设计</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>需求分析</tag>
        <tag>详细设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架快速入门]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21-Mybatis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 Mybatis框架开发的准备 搭建Mybatis开发环境 小结 基于注解的Mybatis使用 1. Mybatis框架开发的准备1.1 官网下载 Mybatis 框架从百度中“mybatis download”可以下载最新的 Mybatis 开发包。 进入选择语言的界面，进入中文版本的开发文档。 我们可以看到熟悉的中文开发文档了。 下载相关的 jar 包或 maven 开发的坐标。 下载的 zip 文件如下 我们所使用的 Mybatis 版本是 3.4.5 版本。 2. 搭建 Mybatis 开发环境2.1 创建maven工程创建 mybatis01 的工程，工程信息如下： Groupid:com.itheimaArtifactId:mybatis01Packing:jar 2.2 添加 Mybatis3.4.5 的坐标在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 编写User实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 2.4 编写持久层接口IUserDaoIUserDao 接口就是我们的持久层接口（也可以写成 UserDao 或者 UserMapper）,具体代码如下： 12345678910111213/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; 2.5 编写持久层接口的映射文件IUserDao.xml要求： 创建位置：必须和持久层接口在相同的包中。 名称：必须以持久层接口名称命名文件名，扩展名是.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.6 编写 SqlMapConfig.xml 配置文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee50"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper resource="com/itheima/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.7 编写测试类1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: MybatisTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的环境&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; //7.释放资源 session.close(); in.close(); &#125;&#125; 3. 小结通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。） 但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。 这些问题我们在自定义 mybatis 框架的章节，通过层层剥离的方式，给大家讲解。 请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有一个认识。 4. 基于注解的 Mybatis 使用4.1 在持久层接口中添加注解1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") List&lt;User&gt; findAll();&#125; 4.2 修改 SqlMapConfig.xml1234&lt;!-- 告知 mybatis 映射配置的位置 --&gt;&lt;mappers&gt; &lt;mapper class="com.itheima.dao.IUserDao"/&gt;&lt;/mappers&gt; 4.3 注意事项在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架概述]]></title>
    <url>%2F2019%2F05%2F20%2F2019-05-20-Mybatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 什么是框架 JDBC编程的分析 1. 什么是框架1.1 什么是框架框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 1.2 框架要解决的问题框架要解决的最重要的一个问题是技术整合的问题，在 J2EE 的 框架中，有着各种各样的技术，不同的软件企业需要从 J2EE 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。 框架一般处在低层应用平台（如 J2EE）和高层业务逻辑之间的中间层 。 1.3 软件开发的分层重要性框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。 我们常见的MVC 软件设计思想就是很好的分层思想。 1.4 分层开发下的常见框架 1.5 MyBatis 框架概述mybatis是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis通过 xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。 2. JDBC 编程的分析2.1 jdbc 程序的回顾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); //通过驱动管理类获取数据库链接 connection = DriverManager .getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8","root", "root"); //定义 sql 语句 ?表示占位符 String sql = "select * from user where username = ?"; //获取预处理 statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的参数值 preparedStatement.setString(1, "王五"); //向数据库发出 sql 执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString("id")+" "+resultSet.getString("username")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 上边使用 jdbc 的原始方法（未经封装）实现了查询数据库表记录的操作。 2.2 jdbc 问题分析1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java代码。3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo 对象解析比较方便。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（下）]]></title>
    <url>%2F2019%2F03%2F21%2F2019-03-21-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（中）的学习，小艾对MySQL的多表查询有了更深刻的了解，掌握前面的内容，其实对于我们一般的开发也就足够了，今天就学习MySQL原理性一点的内容。 目录 存储引擎 事务 索引 视图 DBA命令 数据库设计三大范式 1. 存储引擎 存储引擎是MySQL特有的，其它数据库没有 1.1 存储引擎的本质 通过采用不同的技术将数据存储在文件或内存中； 每一种技术都有不同的存储机制，不同的存储机制提供不同的功能和能力； 通过选择不同的技术，可以获得额外的速度或功能，改善我们的应用； 1.2 MySQL支持很多种存储引擎常见命令： 1.2.1.show engines\G (1)在创建表时，可使用Engine选项为CREATE TABLE语句显示指定存储引擎 例如： 123CREATE TABLE table_name( NO INT)ENGINE = MyISAM; (2)如果创建表时没有指定存储引擎，则使用当前默认的存储引擎； (3)默认的存储引擎可在 my.ini 配置文件中使用 default-storage-engin 选项指定； (4)修改表的存储引擎使用：ALTER TABLE 表名 ENGINE = 存储引擎名称; (5)查看表使用的存储引擎，命令如下： SHOW CREATE TABLE emp\G; SHOW TABLE STATUS LIKE ‘emp’\G; 1.3 常用的存储引擎1.3.1 MyISAM存储引擎MyISAM引擎是MySQL数据库最常用的； 它管理的表具有以下特性： 使用三个文件表示每个表： 格式文件 — 存储表的结构（mytable.frm）数据文件 — 存储表的数据（mytable.MYD）索引文件 — 存储表的索引（mytable.MYI） 可转换为压缩、只读表来节省空间 1.3.2 InnoDB存储引擎InnoDB存储引擎是MySQL数据库的缺省引擎； 它管理的表具体有以下特征： a) 每个InnoDB表在数据库目录中以.frm格式文件表示b) InnoDB表空间tablespace被用亍存储表的内容c) 提供一组用来记录事务性活劢的日志文件d) 用COMMIT（提交）、SAVEPOINT及ROLLBACK（回滚）支持事务处理e) 提供全部ACID兼容f) 在MySQL服务器崩溃后提供自劢恢复g) 多版本（MVCC）和行级锁定h) 支持外键及引用的完整性，包括级联更新和删除 1.3.3 MEMORY存储引擎使用MEMORY存储引擎的表，因为数据存储在内存中，且行的长度固定，所以使得MEMORY存储引擎非常快； MEMORY存储引擎管理的表具有下列特征： a) 在数据库目录内，每个表均以.frm格式文件表示；b) 表数据及索引被存储在内存中；c) 表级锁机制；d) 字段属性不能包含TEXT戒BLOB字段； MEMORY存储引擎以前被称为HEAP引擎； 1.4 选择合适的存储引擎MyISAM表最适合于大量的数据读而少量数据更新的混合操作。MyISAM表的另一种适用情形是使用压缩的只读表。 如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为数据读取和更新的混合提供了良好的并发机制。 使用MEMORY存储引擎存储非永丽需要的数据，戒者是能够从基于磁盘的表中重新生成的数据。 2. 事务2.1 事务是什么（5点） 一个最小的不可再分的工作单元； 通常一个事务对应一个完整的业务；（如：银行转账业务） 而一个完整的业务需要批量的DML（insert、update、delete）语句共同完成 事务只和DML语句有关系，戒者说叧有DML语句才有事务； 以上所描述的批量DML语句共有多少DML诧句，这个和业务逻辑有关系，业务逻辑不同DML语句个数不同 ； 2.1.1 关与银行转账业务银行转账业务：是一个完整的业务，最小的单元，不可再分，也就是说银行转账业务是一个完整的事务。 示例：账户转账 t_act账户表：actno，balance actno balance act-001 50000.0 act-002 10000.0 act-001转10000.0给act-002，操作如下： update t_act set balance = 40000.0 where actno = ‘act-001’; update t_act set balance = 20000.0 where actno = ‘act-002’; 分析： （1）以上两条DML语句必须同时成功或者同时失败，因为它为最小业务单元，不可拆分； （2）当第一条DML语句执行成功之后，并不能将底层数据库中的第一个账户的数据修改，而是将操作记录了一下，这个记录是在内存中完成的。 （3）当第二条DML与句执行成功之后，和底层数据库文件中的数据完成同步。 （4）若第二条DML语句执行失败，将清空所有的历史操作记录。 结论：要完成以上功能，必须借助事务 transaction。 2.2 概述事务可以保证多个操作原子性，要举全成功，要举全失败。对亍数据库来说，事务保证批量的DML要举全成功，要么全失败。 2.2.1 事务具有四个特征ACID：（1）原子性（Atomicity）事务是最小单元，不可再分； （2）一致性（Consistency）事务要求所有的DML语句操作的时候，必须保证同时成功或同时失败； （3）隔离性（Isolation）一个事务不会影响其它事务的运行； （4）持久性（Durability）在事务完成之后，该事务对数据库所作的更改将持久地保存在数据库中，并不会被回滚； 2.2.2 事务中的一些概念（1）开启事务：start transaction （2）结束事务：end transaction （3）提交事务：commit transaction （4）回滚事务：rollback transaction 2.3.3 和事务有关的两条SQL语句【TCL】COMMIT； 提交 ROLLBACK； 回滚 2.3.4 事务开启和结束的标志是什么 ？开始的标志 任何一条DML语句执行，标志事务的开启； 结束的标志 提交（commit）或者回滚（rollback） 提交：成功的结束，将所有的DML与句操作记录和底层硬盘文件中数据进行一次同步； 回滚：失败的结束，将所有DML语句操作记录全部清空； 2.3.5 重点（1）在事务进行过程中，未结束之前，DML语句是不会修改底层数据库文件中的数据。 （2）叧是将历史操作记录一下，在内存中完成记录。 （3）叧有在事务结束的，而且是成功结束的时候才会修改底层硬盘文件中的数据。 2.3.6 MySQL事务的提交和回滚的演示MySQL默认事务：自劢提交 show variables like ‘%commit%’; 在MySQL数据库管理系统中，默认情况下，事务是自动提交的；也就是说，叧要执行一条DML语句，就开启了事务，并且提交了事务； 第一种：关闭MySQL事务自动提交 事务成功用法：start transaction；commit; 第一步：start transaction; 手动开启事务第二步：DML语句…. 执行批量DML语句 .第三步：commit; 手动提交事务【事务成功结束】 演示例子：在t_user表中插入数据：事务成功提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询原表数据 第二步：窗口1，手动开启事务 start transaction，插入数据，查询数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，手动提交事务commit 第五步：窗口2，查询 t_user 表 回滚提交用法：start transaction; rollback;第一步：start transaction; 手动开启事务第二步：DML语句….. 批量DML语句 演示例子：在 t_user表中插入数据，事务失败提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询 t_user 表数据 第二步：窗口1，开启事务start transaction，并向t_user表插入数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，rollback 回滚事务，并查询t_user表数据 第五步：窗口2，查询t_user表数据 第二种：关闭MySQL事务自动提交：只对当前会话有效 两种关闭自动提交事务a） set autocommit = offb） set session autocommit = off 两种打开自动提交事务a） set autocommit = onb） set session autocommit = on注：以上打开或关闭事务只对当前窗口有效； 查询事务状态： show variables like &#39;%commit%&#39;; 2.3.7 事务的隔离级别事务四个特性ACID之一：隔离性（isolation） 隔离性有四个隔离级别： 1） read uncommitted 读未提交2） read committed 读已提交3） repeatable read 可重复读4） serializable 串行化 read committed 读未提交（级别最低） 1） 事务A和和事务B，事务A未提交的数据，事务B可以读取2） 这里读取到的数据可以叫做“脏数据”或“脏读 Dirty Read”3） 读未提交隔离级别最低，这种级别一般只在理论上存在，数据库默认隔离级别一般都高于该隔离级别； read committed 读已提交 1） 事务A和事务B，事务A提交的数据，事务B才可读取到；2） 该隔离级别高于“读未提交”级别3） 换句话说：对方事务提交之后的数据，当前事务才可读取到。4） 该隔离级别可以避免脏数据；5） 该隔离级别能够导致“不可重复读取”6） Oracle数据库管理系统默认隔离级别为“可重复读” repeatable read 可重复读 1） 事务A和事务B，事务A提交之后的数据，事务B读取不到2） 事务B是可重复读到数据的3） 这种隔离级别高于“读已提交”4） 换句话说，对方提交之后的数据，还是读取不到5） 这种隔离级别可以避免“脏读和不可重复读”，达到“重复读取”；6） MySQL数据库管理系统默认隔离级别为：可重复读7） 虽然可以达到“可重复读”效果，但是会导致“幻象读” serializable 串行化 1） 事务A和事务B，事务A在操作数据库表中数据的时候，事务B叧能排队等待；2） 这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好；3） 这种隔离级别可以避免“幻象读”，每一次读取都是数据库表中真实的记录；4） 事务A和事务B不再并发； 查看隔离级别 1） 查看当前会话级隔离级别select @@tx_isolation;select @@session.tx_isolation; 2） 查看当前全局隔离级别： @@global.tx_isolation;select @@global.tx_isolation; 设置服务器缺省隔离级别 第一种：修改my.ini配置文件在 my.ini 文件中的[mysqld]下面添加：————————-my.ini——————————-[mysqld]transaction-isolation = READ-COMMITTED————————–my.ini——————————-a） 隔离级别可选项为：– READ-UNCOMMITTED– READ-COMMITTED– REPEATABLE-READ– SERIALIZABLE 第二种：通过命令方式设置事务隔离级别a） SET TRANSACTION ISOLATION LEVEL isolation-level;b） isolation-level 可选值：– READ UNCOMMITTED– READ COMMITTED– REPEATABLE READ– SERIALIZABLE 设置隔离级别作用的范围 1） 事务隔离级别的作用范围分为两种：会话级、全局级a） 会话级（session）：叧对当前会话有效b） 全局级（global）：对所有会话有效2） 使用方法如下 a） 会话级：SET TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;SET SESSION TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;b） 全局级SET GLOBAL TRANSACTION ISOLATION LEVEL; 隔离级别不一致性问题的关系 隔离级别 脏读 不可重复读 幻象读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 隔离级别不一致性问题的关系 1） 读未提交 READ UNCOMMITTED 会话一 会话二 set global transaction isolation level read uncommitted; 退出DOS窗口 use bjpowernode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpowernode; start transaction; start transaction; insert into t_user(name) values(‘king’); select * from t_user; 2） 读已提交 READ COMMITTED 会话一 会话二 set global transaction isolation level read committed; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; insert into t_user(name) values(‘allen’); select * from t_user; commit; select * from t_user; 3） 可重复读 REPEATABLE READ 会话一 会话二 set global transaction isolation level repeatable read; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; 4） 串行化 SERIALIZABLE 会话一 会话二 use bjpowernode; Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32));insert into t_user(name) values(‘zhangsan’);insert into t_user(name) values(‘lisi’); set global transaction isolation level serializable; 退出DOS窗口 use bjpownode; use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; commit; 3.索引3.1 索引原理3.1.1 什么索引索引对应的英语单词：index 索引作用： 相当于一本字典目录，提高程序的检索 / 查询效率；表中每一个字段都可添加索引 主键自动添加索引： 能够通过主键查询的尽量通过主键查询，效率较高； 索引和表相同，存储在硬盘文件中 索引和表相同，都是一个对象，表是存储在硬盘文件中的，那举索引也是表的一部分，索引也存储在硬盘文件中； MySQL数据库中表的检索方式有2种： 第一种：全表扫描（效率较低） 举例：查询ename=’KING’假设有一张表：emp 员工表，select from emp where ename = ‘KING’;若ename没有添加索引，那举通过ename过滤数据的时候，ename字段会全表扫描；假设有一张表：dept 部门表，select from dept where dname = ‘ACCOUNTING’；若dname没有添加索引，那举通过dname过滤数据的时候，dname字段会全表扫描； 第二种：通过索引检索（提高查询效率） 3.1.2 什么情况下适合给表中字段添加索引1） 该字段数据量庞大2） 该字段很少的DML操作（由亍索引也需要维护，DML操作多的话，也影响检索效率）3） 该字段经常出现在where条件中注：实际开发中会根据项目需求或客户需求等综合因素来做调整 3.1.3 索引的应用创建索引 1） 语法结构：a） create index 索引名 on 表名（列名）b） create unique index 索引名 on 表名（列名）注：添加unique表示在该表中的该列添加一个唯一性约束示例：create index dept_dname_index on dept(dname); 查看索引 1） 语法结构：a） show index from 表名示例：show index from dept; 删除索引 1） 语法结构：a） drop index 索引名 on 表名;示例：drop index dept_dname_index on dept; 4.视图4.1 什么是视图1） 视图对应英文单词：view2） 视图在数据库管理系统中也是一个对象，也是以文件形式存在的3） 视图也对应了一个查询结果，叧是从不同的角度查看数据 4.2 创建视图语法结构：create view 视图名称 as 查询语句； 例子：从emp表查询empno,ename,sal，结果当作视图展示 4.3 删除视图语法结构：drop view if exists 视图名称; 示例：删除myview视图：drop view if exists myview; 4.4 修改视图语法结构：alter view 视图名称 as 查询语句 示例：将myview视图修改为deptno,ename,job,sal 4.5 视图作用4.5.1 面向视图查询，可以提高查询效率例如 1） 单独执行：select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;2） 将上面执行结果当作视图对象创建create view myview as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;3） 面向视图查询：没有迚行表连接，提高检索效率select * from myview;【非常重要】隐藏表的实现细节 1、 create view myview as select empno a,ename b,sal c from emp;2、面向视图查询，叧知道myview视图中有a,b,c三个字段，不知道该视图背后真实表的结构是什么 5.DBA命令5.1 新建用户CREATE USER username IDENTIFIED BY ‘password’; username：你将创建的用户名,password：该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.示例：create user p361 identified by ‘123’;–可以登录但是只可以看见一个库 information_schema 5.2 授权命令详解 示例：grant all privileges on dbname.tbname to ‘username‘@’login ip’ identified by ‘password’ with grant option; 1) dbname=表示所有数据库2) tbname=表示所有表3) login ip=%表示任何ip4) password为空，表示不需要密码即可登录5) with grant option; 表示该用户还可以授权给其他用户细粒度授权1、首先以root用户进入mysql2、然后键入命令：grant select,insert,update,delete on . to p361 @localhost Identified by “123”;3、如果希望该用户能够在任何机器上登陆mysql，则将localhost改为 “%” 。 粗粒度授权我们测试用户一般使用该命令授权：GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123”;注意：用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123” WITH GRANT OPTION;用户权限privileges包括：1） alter：修改数据库的表2） create：创建新的数据库戒表3） delete：删除表数据4） drop：删除数据库/表5） index：创建/删除索引6） insert：添加表数据7） select：查询表数据8） update：更新表数据9） all：允许任何操作10） usage：叧允许登录 5.3 回收授权命令详解 revoke privileges on dbname[.tbname] from username;revoke all privileges on . from p361; use mysqlselect * from user进入 mysql库中修改密码; update user set password = password(‘qwe’) where user = ‘p646’;刷新权限;flush privileges 5.4 导入导出导出：mysqldump 导出整个数据库C: \Administrator&gt; mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123导出指定库下的指定表C: \Administrator&gt;mysqldump bjpowernode emp&gt; D:\ bjpowernode.sql -uroot -p123 导入：source 登录MySQL数据库管理系统之后执行：mysql&gt;source D:\ bjpowernode.sql 6.数据库设计三范式定义：设计数据库的时候所依据的规范，共有三个规范； 6.1 第一范式：主键、字段不能再分定义：要求有主键，数据库中不能出现重复记录，每一个字段是原子性不能再分； 示例：不符合第一范式 学生编号 学生姓名 联系方式 1001 张三 zs@gmail.com,1359999999 1002 李四 ls@gmail.com,13699999999 1001 王五 ww@163.net,13488888888 分析以上设计存在的问题：1） 数据存在重复记录，数据不唯一，没有主键2） 联系方式可以再分，不是原子性修改以上设计方案： 学生编号(pk) 学生姓名 email 联系电话 1001 张三 zs@gmail.com 1359999999 1002 李四 ls@gmail.com 13699999999 1003 王五 ww@163.net 13488888888 结论：关于第一范式 1、 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，2、 主键主要通常采用数值型或定长字符串表示3、 关亍列丌可再分，应根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段了； 6.2 第二范式：非主键字段完成依赖主键定义：第二范式是建立在第一范式基础之上，要求数据库中所有非主键字段完全依赖主键，不能产生部分依赖；（严格意义上说：尽量不要使用联合主键） 示例一：数据仍然可能重复 学生编号 学生姓名 教师编号 教师姓名 1001 张三 001 王老师 1002 李四 002 赵老师 1003 王五 001 王老师 1001 张三 002 超老师 示例二：确定主键，学生编号、教师编号，出现冗余 学生编号（PK） 教师编号(PK) 学生姓名 教师姓名 1001 001 张三 王老师 1002 002 李四 赵老师 1003 001 王五 王老师 1001 002 张三 赵老师 综合分析：1、 以上虽然确定了主键，但此表会出现大量冗余，主要涉及到的冗余字段为“学生姓名”和“教师姓名”；2、 出现冗余的原因在于：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。 解决方案如下： 学生信息表： 学生编号（PK） 学生姓名 1001 张三 1002 李四 1003 王五 教师信息表： 教师编号（PK） 教师姓名 001 王老师 002 赵老师 教师和学生的关系表： 学生编号(PK) fk-&gt;学生表的学生编号 教师编号(PK) fk-&gt;教师表的教师编号 1001 001 1002 002 1003 001 1001 002 结论：一种典型的“多对多”的设计 6.3 第三范式定义：建立在第二范式基础之上，要求非主键字段不能产生传递依赖于主键字段； 示例一：学生信息表 学生编号（PK） 学生姓名 班级编号 班级名称 1001 张三 01 一年一班 1002 李四 02 一年二班 1003 王五 03 一年三班 1004 六 03 一年三班 综合分析：1、从表中看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键2、班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖， 解决方案：1、 将冗余字段单独拿出来建立表2、 如下表所示：学生信息表中班级编号设为外键FK学生信息表： 学生编号（PK） 学生姓名 班级编号（FK） 1001 张三 01 1002 李四 02 1003 王五 03 1004 赵六 03 班级信息表： 班级编号（PK） 班级名称 01 一年一班 02 一年二班 03 一年三班 结论： 典型的一对多以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键 6.4 三范式总结6.4.1 一对一第一种方案：分两张表存储，共享主键 1） 示例：t_husband 和 t_wife两张表丈夫表 ：t_husband hno（PK） hname 1 Zhangsan 2 Wangwu 3 zhaoliu 妻子表：t_wife wno（PK）【同时也是外键FK，引用t_husband的主键】 wname 3 a 2 b 1 c 第二种方案：分两张表存储，外键唯一 示例：t_husband 和 t_wife两张表 丈夫表 ：t_husband hno（PK） hname Wifeno（FK - unique） 1 Zhangsan 100 2 Wangwu 200 3 zhaoliu 300 妻子表：t_wife wno（PK） wname 100 a 200 b 300 c 6.4.2 一对多分两张表存储，在多的一方添加外键，这个外键字段引用一的一方中的主键字段例如：学生信息表和班级信息表，请参考：20.3.2 示例一 6.4.3 多对多例如：分三张表存储，在学生表中存储学生信息，在课程表中存储课程信息，在选课表中存储学生选课信息，请参考：20.2 6.5 实际开发中是怎么的？1） 数据库设计尽量遵循三范式2） 根据实际需求迚行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。 好，终于学完MySQL了，那么MySQL的学习就暂告一段落了。这么多东西，小艾要去休息休息消化消化一下才行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（中）]]></title>
    <url>%2F2019%2F03%2F19%2F2019-03-19-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%AD)%20%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（上）的学习，小艾已经有初步对MySQL的了解，前面学习的内容还是比较简单的，今天，就再深入的学习MySQL的查询吧。 目录 连接查询 子查询 union合并集合 limit使用 表 1. 连接查询在实际开发中，数据往往不是存放储一张表中，而是同时存储在多张表中，这些表与表存在着关系，我们在检索数据的时候往往需要多张表联合起来检索，这种多表联合检索被称为连表查询或跨表查询。 1.1 笛卡尔积现象含义：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录的乘积，该现在称为笛卡尔积现象。 1.1.1 显示每个员工信息，并显示所属部门名称 1.2连接查询根据：年代分类1.2.1 SQL92语法语法结构：select xxxx from A表名,B表名 where 表连接条件 and 数据查询条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e,dept d where e.deptno = d.deptno; 缺点：表连接条件与查询条件放在一起，没有分离； 1.2.2 SQL99语法【只掌握SQL99】语法结构：select xxxx from A表名 join B表名 on 表的连接条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e join dept d on e.deptno = d.deptno; 优点：表连接独立，结构清晰，如果结果数据不满足要求，可再追加where条件进行过滤； 1.3连接查询根据：连接方式分类1.3.1 内连接定义：只连接匹配的行，即A表与B表相连接，能够匹配的记录查询出来。 （1）等值连接 示例：查询员工的名称和员工所对应的部门名称 select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;注：inner可忽略 （2）非等值连接 示例：查询员工的工资等级 select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可忽略 （3）自连接 示例：查询员工的名称和员工对应的领导名称 select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno;注：inner可忽略 1.3.2 外连接定义：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录时，会自动模拟出null值与之匹配；注意：外连接的查询结果条数 &gt;= 内连接的查询结果条数 （1）左外连接（左连接） 定义：包含左边表的全部行（不管右边的表中是否存在不它们匹配的行），以及右边表中全部匹配的行； （2）右外连接（右连接） 定义：包含右边表的全部行（不管左边的表中是否存在不它们匹配的行），以及左边表中全部匹配的行； （3）全连接（了解） 定义：包含左、右两个表的全部行，不管另外一边的表中是否存在不它们匹配的行。 1.4七大案例详解1.4.1 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（笛卡尔积）注意：多张表查询时，通常会对表起别名，若两张表中有相同名称的字段时，该相同名称字段不知道属亍哪张表中，这时需要通过对表起别名来限制该字段属于哪张表，并且提高SQL语句的效率，可读性也高。 思路分析：（1） Step 1：先查询出员工姓名和部门编号；emp员工表 （2）Step 2：再查询出部门编号和部门名称；dept部门表 联想：当多张表连接查询时，若没有任何条件限制，会发生什么？ select e.ename,d.dname from emp e,dept d;预测查询结果： 验证结果： 结论：为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件； 1.4.2 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（内连接：等值）思路分析（1） Step 1：从emp e 员工信息表查询出员工姓名、部门编号； （2）Step 2：从dept d部门信息表查询出部门编号、部门名称； 注意：在连接查询时，即使我们使用的了限制条件，但是匹配次数没有减少，只显示有效数据； （3）Step 3：内连接等值条件：e.deptno=d.deptno SQL92语法：内连接中的等值连接（不建议）select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno; SQL99语法：select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;//inner可省略 1.4.3 找出每一个员工对应的工资等级，要求显示员工姓名、工资、工资等级（内连接：非等值）思路分析 （1）Step 1：从emp e员工信息表查询出员工的姓名、工资 （2）Step 2：从salgrade s工资等级表查询出工资等级信息 （3）Step 3：内连接非等值条件：between s.losal and s.hisal; SQL92语法：（不建议）select e.ename,e.sal,s.grade from emp e , salgrade s where e.sal between s.losal and s.hisal; SQL99语法：内连接中的非等值连接select e.ename,e.sal,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可以省略 1.4.4 找出每一个员工的上级领导，要求显示员工姓名及对应的领导姓名（内连接：自连接）思路分析： （1）Step 1：从emp a员工信息表查询出员工编号、员工名称、领导编号 （2）Step 2：从emp b领导信息表查询出领导姓名、领导编号 （3）Step 3：自连接条件为：领导编号=员工编号 SQL92语法：（不建议） select a.ename empname,b.ename leadername from emp a,emp bwhere a.mgr = b.empno; SQL99语法：内连接中的自连接 select a.ename empname ,b.ename leadername from emp a inner join emp b on a.mgr = b.empno;select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno ;注：inner可以省略 1.4.5 找出每一个员工对应的部门名称，要求部门名称全部显示（左/右外连接）思路分析： （1）Step 1：先查询出每一个员工对应的部门名称 （2）Step 2：查询部门信息 （3）Step 3：右外连接条件：员工表的部门编号=部门表的部门编号 SQL99语法：外连接中的右外连接【右连接】 select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e right join dept d on e.deptno = d.deptno;//outer可省略 SQL99语法：外连接中的左外连接【左连接】 select e.ename,d.dname from dept d left outer join emp e on e.deptno = d.deptno;select e.ename,d.dname from dept d left join emp e on e.deptno = d.deptno;//outer可省略 注意：任何一个右外连接都可写成左外连接，任何一个左外连接都可写成右外连接； 1.4.6 为什么 inner 和 outer 可以省略，加上去有什么好处？可以省略，因为区分内连接与外连接不是依靠这两个关键字，而是看SQL语句中的left/right关键字；加上left、right关键字增强SQL语句的可读性。 1.4.7 找出每一个员工对应的领导名，要求显示所有员工（左外连接）思路分析： （1）Step 1：显示每一个员工对应的领导名 （2）Step 2：以上查询结果缺少一位员工King，通过左外连接查询全部员工。 SQL99语法：select a.ename empname ,b.ename leadername from emp a left join emp b on a.mgr = b.empno; 1.4.8 找出每一个员工对应的部门名称，以及该员工对应的工资等级，要求显示员工姓名、部门名称、工资等级。思路分析： （1）Step 1：查询出员工对应的部门编号和工资emp e表 （2）Step 2：查询出部门信息dept d表 （3）Step 3：查询出工资等级信息salgrade s表 （4）多表连接条件：员工表与部门表连接（e.deptno = d.deptno），再与工资等级表连接（e.sal between s.losal and s.hisal） 重点：多张表进行表连接的语法格式： 123456789101112select xxxxfrom A表join B表on 连接条件1join C表on 连接条件2； 原理：A表和B表通过连接条件1连接之后，A表再和C表通过连接条件2进行连接； 12345678910111213emp e表、dept d表、salgrade s表select e.ename,d.dname,e.sal,s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 2.子查询定义：select 语句嵌套 select 语句被称为子查询；注意：select子句可出现在select、from、where关键字后面，如下：select … (select)…【很少很少使用了解即可】from …(select)…where …(select)… 2.1 案例2.1.1 （where后）找出薪水比公司平均薪水高的员工，要求显示员工名和薪水注意：select ename,sal from emp where sal &gt; avg(sal);执行错误：因为分组函数不能直接使用在where关键字后面 思路分析： （1）第一步：找出公司的平均薪水，平均薪水：2073.214286 （2）第二步：找出薪水比公司平均薪水：2073.214286高的员工 （3）第三步：将平均薪水2073.214286值替换为它的查询语句即可； 2.1.2 （from后）找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级思路分析： （1）第一步：根据部门分组找出每个部门的平均薪水 （2）第二步：查询出薪水等级信息 （3）第三步：将第一步查询结果当作一张临时表 t，然后将t表与薪水等级表做进行表连接，条件t.avgsal between s.losal and s.hisal; 小窍门：可将查询结果当做临时表 2.1.3 （select后使用了解）select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; 3.union合并集合定义：将查询的结果集合幵注意事项：合并结果集的时候，查询字段个数必须相同； 3.1 示例3.1.1 查询出job为MANAGER和SALESMAN的员工123select empno,ename,job from emp where job = ‘MANAGER’unionselect ename,job from emp where job = ‘SALESMAN’; 以上写法错误： 正确写法： 123select empno,ename,job from emp where job = ‘MANAGER’unionselect empno,ename,job from emp where job = ‘SALESMAN’; 注意：查询字段类型在MySQL中不必完全相同，但是Oracle中一定要类型也相同； 写法错误： 123select e.empno,e.ename from emp eunionselect d.dname,d.loc from dept d; 正确写法： 123select e.empno,e.ename from emp eunionselect d.deptno,d.loc from dept d; 3.1.2 查询包含 MANAGER 和 SALESMAN 的员工信息（1）第一种方式：in (‘MANAGER’,‘SALESMAN’) select * from emp where job in(‘MANAGER’,‘SALESMAN’);select * from emp where job = ‘MANAGER’or job = ‘SALESMAN’; （2）第二种试：使用 union关键字查询 123select * from emp where job = &apos;MANAGER&apos;unionselect * from emp where job = &apos;SALESMAN&apos;; 4.limit使用作用：（只在MySQL中起作用）获取一表前几条或中间某几行数据； 4.1 用法：limit 起始下标m,长度nm：记录开始的index，默认从 0 开始，表示第一条记录；n ：指从第 m+1 条开始，取 n 条； 4.2 取前5个员工信息思路分析 （1）第一步：查询出全部员工的信息 （2）第二步：使用limit取出前5个员工的信息 以上SQL语句中的“limit 5”中的“5”表示：从表中记录下标0开始，取5条记录，等同于 select * from emp limit 0,5; 4.3 找出工资排名在前5的员工思路分析： （1）第一步：按照工资降序排列 order by desc （2）第二步：在以上基础上，取前5个员工limit出现在SQL语句的最后位置 4.4 找出工资掋名在[ 3-9 ]的员工思路分析： （1）第一步：按照工资降序排列 order by desc （2）第二步：使用limit取出排名在3到9的员工 4.5 MySQL中通用的分页SQL语句提示：每页显示3条记录（长度为3） 第1页：0，3 包含页：1，2，3 limit 0,3第2页：3，3 包含页：4，5，6 limit 3,3第3页：6，3 包含页：7，8，9 limit 6,3… …每页显示pageSize条记录第pageNo页：(pageNo – 1) * pageSize，pageSize 12345678select enamefrom emporder by sal desclimit (pageNo – 1) * pageSize , pageSize; 通用分页SQL【只适用于MySQL数据库管理系统】 12345678select t.*from torder by t.xx desc/asclimit (pageNo – 1) * pageSize , pageSize; 5.表5.1 定义：表（table）：是数据库最基本的组成单元，数据库是用来存储数据的，数据库中有很多表，每一个表都是一个独立的单元，表也是一个结构化的文件，由行和列组成，行称为数据或记录，列称为字段，字段又包含：字段名称、字段类型、长度、约束。 5.2 创建表5.2.1 语法格式:create table 表名称(字段名 类型(长度) 约束)； 5.2.2 MySQL常用数据类型 （1）VARCHAR：可变长度字符串 VARCHAR(3)表示存储的数据长度不能超过3个字符长度 （2）CHAR：定长字符串 CHAR(3) 表示存储的数据长度不能超过3个字符长度 （3）INT：整数型 INT(3)表示最大可以存储999 （4）BIGINT：长整型 对应java程序中的long类型 （5）FLOAT：浮点型单精度 FLOAT(7,2)表示7个有效数字，2个有效小数位 （6）DOUBLE：浮点型双精度 DOUBLE(7,2)表示7个有效数字，2个有效小数位 （7）DATE：日期类型 实际开发中，常用字符串代替日期类型 （8）BLOB：二迚制大对象 Binary Large Object 与门存储图片、视频、声音等数据 数据库存储图片是很常见，但存储大视频是很少的，一般都是存储视频地址 （9）CLOB：字符型大对象 Character Large Object 可存储超大文本，可存储4G+字符串 （10）注意：VARCHAR与CHAR对比： 都是字符串 VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间；但在分配的时候需要相关判断，效率低。 CHAR不需要劢态分配空间，所以执行效率高，但是可能会导致空间浪费 若字段中的数据不具备伸缩性，建议采用CHAR类型存储 若字段中的数据具备很强的伸缩性，建议采用VARCHAR类型存储 5.2.3 创建表格&lt;t_student 学生信息表&gt;学生信息表字段包括： 学号：no INT(10)姓名：name varchar(32)性别：sex char(1)出生日期：birth date邮箱：email varchar(128) 建表语句，如下图： 注意： 表格名称最好以 t_ 或 tbl_ 开始，增强可读性VARCHAR长度最好是2的倍数，方便存储中文 5.2.4 删除表格： drop table t_student;（如果数据库中没有该表格，则会报错）； drop table if exists t_student;最好采用这种方式删除表格，但这是MySQL特色其它数据库无法使用 5.2.5 向t_student表格中插入数据DML语句包括：insert、update、delete；（增删改表中的数据不表结构无关） 插入数据 insert 语法 Insert into 表名(字段名1，字段名2，…) values(值1, 值1,…); 注意：字段和数值必须一 一对应，字段不数据个数必须相同，数据类型必须一致；第一种方式：向 t_student 表格中所有字段插入数据 INSERT INTO t_student(no,name,sex,birth,email) VALUES(1,&#39;zhangsan&#39;,&#39;m&#39;,&#39;1970-01-01&#39;,&#39;zhangsan@powernode.com&#39;);INSERT INTO t_student(no,name,sex,birth,email) VALUES(2,&#39;lisi&#39;,&#39;f&#39;,&#39;1978-10-10&#39;,&#39;lisi@powernode.com&#39;); 第二种方式：向 t_student 表格中部分字段插入数据insert into t_student(name,email) values(&#39;wangwu&#39;,&#39;wangwu@163.com&#39;); 注意：默认情况下，当表创建之后，没有指定约束也没指定默认值，系统默认值就是NULL ，默认值NULL表示：若插入的时候没有指定任何数据，默认插入 NULL 值。目前wangwu的 no、sex、birth 值为 null ，我们可以往里插入值吗？ 以上执行insert 语句叧能导致底层数据表中新增一条记录；若希望NULL值变为其它值，我们必须使用UPDATE更新语句；第三种方式：向 t_student 表格中所有字段插入数据INSERT INTO t_student VALUES(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1990-01-18&#39;,&#39;zhaoliu@126.com&#39;); 结论：不建议将前面的字段省略，若省略就表示要将表中所有字段必须赋值，并且程序不健壮，若修改表结构，将可能导致INSERT语句执行失败； 插入中文试试？ insert into t_student(no,name) values(5,’李丽’); 查看建表语句：show create table t_student; 错误原因：DOS窗口字符编码为GBK，数据库字符编码为UTF-8，可以使用MySQL-Front工具插入数据，该MySQL客户端开发软件在实际工作中使用较多； 查看变量：show variables like &#39;%char%&#39;; 设置结果编码集（叧对当前窗口有效） set character_set_results = &#39;GBK&#39;; 5.2.6 创建表格时给字段设置默认值:default 默认值 联想知识点： 该文件是一个普通的文本文件，以.sql后缀结尾的文件我们称为SQL脚本； 在SQL脚本中包含了大量的SQL语句，我们可以通过直接使用source执行这个大批量脚本； 在项目中期入职，数据库环境都已完善，PM可能会给程序员SQL脚本完成数据库的初始化； 如果脚本过大，我们可以使用Sublime Text这个软件； 额外小知识点：获取数据库系统当前时间 使用 now() 函数 创建机构表： 获取系统时间另外方式，通过java的Date对象也可获取； 5.2.7 表的复制定义：将查询结果当作一张表创建 语法结构：CREATE TABLE 表名 as select查询语句； （1）完全复制emp表到emp1： create table emp1 as select * from emp; （2）选择性复制emp表到emp2: create table emp2 as select ename,sal from emp; 5.2.8 将查询结果插入到某张表中语法结构: INSERT INTO 表名 select查询语句； （1）从emp2表中查询出员工工资为3000的，同时将查询结果插入到emp2表中 （2）复制emp表为emp_bak，再将emp表中数据插入到emp_bak中 create table emp_bak as select * from emp;insert into emp_bak select * from emp2 where sal = 3000; 5.3 增 / 删 / 改 表结构5.3.1 语法结构：新增：ALTER TABLE 表名 ADD 字段名 字段类型（长度）；修改：ALTER TABLE 表名 MODIFY 字段名 字段类型（长度）；删除：ALTER TABLE 表名 DROP 字段名; 5.3.2 创建t_student表：no int(10)、name varchar(32)编号：no int(10)姓名：name varchar(32) 5.3.3 【增加】给 t_student 表添加一个电话字段alter table t_student add tel varchar(10); 5.3.4 【修改】将字段 tel 长度扩展到20个长度alter table t_student modify tel varchar(20); 5.3.5 【删除】将 t_student 表中的 tel 字段删除alter table t_student drop tel; 5.4 添加 / 修改 / 删除 表数据5.4.1 DML数据操作诧句：insert 、update 、delete；5.4.2 insert 添加数据语法格式：insert into 表名(字段名1，字段名2,…) values(值1,值2,…); 创建表 s_student 省略字段插入 insert into t_student values(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1990-01-18&#39;,&#39;zhaoliu@126.com&#39;); 注意：不建议使用此种方式，因为当数据库表中的字段位置发生改变的时候会影响到insert语句 5.4.3 update 修改数据语法格式：UPDATE 表名 SET 字段名 = 字段值，字段名 = 字段值 WHERE 条件；注意：update如果没有条件限制，将把整张表的数据全部更新； 示例一：向 t_student 表中插入数据 准备工作：1、 向t_student表添加 email varchar(128)2、 向t_student表插入测试数据 （1）将编号no为3的记录name改为zhangsan,email改为zhangsan@126.com； update t_student set name = &#39;zhangsan&#39;,email = &#39;zhangsan@126.com&#39; where no = 3; （2）将所有名字 name 改为 lisi update t_student set name = &#39;lisi&#39;; （3）将 emp_bak 表中的 name 包含“o”字母的改为 wangwu ;update emp_bak set name=&#39;wangwu&#39; where email like &#39;%O%&#39;; （4）将 emp_bak 表中工作岗位为 MANAGER 和 SALESMAN 员工的工资上调10%；update emp_bak set sal=sal*1.1 where job in (&#39;MANAGER&#39;,&#39;SALESMAN&#39;); 5.4.4 delete 删除数据语法格式： DELETE FROM 表名 WHERE 条件限制；注意：若没有条件限制，会将表中所有记录全部删除； 示例一：将 t_student 表中 no 为 3的学生删除delete from t_student where no = 3; 示例二：将 t_student 表中的数据全部删除delete from t_student; 将 emp_bak 表中部门编号为20的 MANAGER 删除掉；delete from emp_bak where deptno = 20 and job = ‘MANAGER’; 5.5 创建表加入约束英文单词：constraint什么是约束？实际上是对表中数据的限制条件；设计表时加入约束的目的？保证表中数据的完整和有效； 5.5.1 非空约束（not null）作用：not null约束的字段不能为 NULL 值，必须赋具体数据；示例：需求如下所示：创建t_user表，name字段不能为空表名：t_user 字段名 字段类型 约束 id int(10) name varchar(32) not null不为空 email varchar(128) 向 t_user 表中插入数据 5.5.2 唯一性约束（unique）作用：unique约束的字段具有唯一性，不可重复 示例：创建t_user表，name丌能为空，email保证唯一方法一：【列级约束】保证邮箱email地址唯一email varchar(128) unique 向 t_user 表中插入数据 注意：”unique约束”约束的字段不能重复，但是可以为NULL，NULL不是一个值，也不能用等号比较； 方法二：【表级约束】保证邮箱email地址唯一unique(email) 以上写法与例1效果相同 使用表级约束给多个字段联合添加约束： 【以下程序表示：name和email两个字段联合唯一】 向 t_user 表中插入数据 以上语句执行失败，原因：表级联合约束限制； 表级约束还可以给约束起名字，原因：以后可通过名字操作这个约束 查询唯一性约束的名字 查看 information_schema 库的表 table_constraint 该表格专门存储约束信息 查询出表 t_user 中的唯一约束名称 组合使用 not null 和 unique 作用：被 not null 和 unique 约束的字段，该字段即不能为null 也不能重复；示例： 需求，创建t_user表，用户编号为id，用户名称name即不能为空也不能重复 向 t_user 表中插入数据 正确写法：insert into t_user(id,name) values(3,’jack’); 错误写法：insert into t_user(id) values(3); 错误原因：name 字段约束条件：即不为空也不能重复 5.5.3 主键约束PK（primary key）主键约束 primary key 简称 PK 实例讲解主键：中国公民身份信息 id Name Sex Age 身份证号 张三 男 27 身份证号 张三 男 27 主键涉及到的3个术语: 主键约束、主键字段、主键值 主键约束、主键字段、主键值三者之间关系？ 表中某个字段添加主键约束之后，该字段被称为主键字段，主键字段中出现的每一个数据都被称为主键值； 主键作用 添加主键primary key的字段即不能重复也不能为空，效果不“not null nuique”相同，但本质是不同的，添加主键约束之后，主键不仅会有“not null unique”作用，而且主键字段还会自劢添加“索引 — index”； 一张表应该有主键，若没有，表示这张表是无效的【联想：数据库设计第一范式】，“主键值”是当前行数据的唯一标识，“主键值”是当前行数据的身仹证号；（即使表中两行数据完全相同，但是由亍主键不同，我们也认为这是两行完全不同的数据） 主键根据个数分类：单一主键、复合主键 【单一主键】是给一个字段添加主键约束； 创建单一主键约束【列/表级】 【列级】单一主键约束：id int(10) primary key 创建t_user表：包含：id int(10) 主键、name varchar(32) 【表级】单一主键约束: 表级单一主键命名：constraint t_uer_id_pk primary key(id) 以上方式实际工作中最常用； 【复合主键】是给多个字段联合添加一个主键约束； 需求：创建t_user表包含id,name,email，id和name是复合主键primary key(id,name) 复合主键命名： constraint t_user_id_name_pk primary key(id,name) 插入数据测试结果 创建 t_uer 表，测试联合主键功能 表中主键个数（只能有一个） 无论是单一主键还是复合主键，一张表中主键约束只能有一个； 主键根据性质分类：自然主键、业务主键 自然主键：主键值若是一个自然数，并且这个自然数与业务没有任何关系，这种主键称为自然主键； 业务主键：主键值若和当前表中的业务紧密相关，那么这种主键值被业务主键；如果业务发生改变时，业务主键往往会受到影响，所以业务主键使用较少，大多情况使用自然主键。 【如：身份证号位数扩展】 MySQL中自动生成主键值（MySQL特有） 定义：MySQL数据库管理系统中提供了一个自增数字auto_increment，与门用来自动生成主键值，主键值丌需要用户去维护，也丌需要用户生成，MySQL会自劢生成。自增数字默认从1开始，以1递增：1、2、3、4、… 示例： 递增关键字：auto_increment 创建 t_user表：id,name，id为自增主键 5.5.4 外键约束FK（foreign key）外键约束 foreign key 简称：FK 外键涉及到的术语：外键约束、外键字段、外键值 外键约束、外键字段、外键值三者之间的关系？ 给某个字段添加外键约束之后，该字段称为外键字段，外键字段中的数据称为外键值； 外键根据个数分为：单一外键、复合外键 【单一外键】：给一个字段添加外键约束【复合外键】：给多个字段联合添加一个外键 外键在同一张表中可以有多个外键存在 示例一： 需求：设计数据库表用来存储学生和班级信息（给出两种解决方案） 需求分析： 学生表 t_student包含：sno,sname,classno,cname 学生信息和班级信息之间的关系：一个班级对应多个学生，典型的一对多关系； 第一种解决方案：将学生信息和班级信息存储到同一张表中 学生信息表：t_student sno(PK) sname classno cname 1 Jack 100 北京市101中学高三1班 2 Lucy 100 北京市101中学高三1班 3 Lily 100 北京市101中学高三1班 4 Ford 200 北京市101中学高三2班 5 allen 200 北京市101中学高三2班 6 Jason 300 北京市101中学高三3班 7 Teddy 300 北京市101中学高三3班 以上设计的缺点：数据冗余 第二种解决方案：将学生信息和班级信息分开两张表存储：学生表 + 班级表思路分析：第一步：创建t_student表和t_class表 学生表 t_student Sno sname 1 Jack 2 Lucy 3 Lily 4 Ford 5 Allen 6 Jason 7 Teddy 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 第二步：t_student表要与t_class表有关系，需要在t_student表中添加一个classno字段做为外键 学生表 t_student Sno sname classno(FK) 1 Jack 100 2 Lucy 100 3 Lily 100 4 Ford 200 5 Allen 200 6 Jason 300 7 Teddy 300 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 结论（classno值必须来自cno）：为了保证 t_student 表中的 classno 字段中的数据必须来自 t_class表中的 cno 字段中数据，有必要给 t_student 表中classno 字段添加外键约束；classno 称为外键字段，classno 中的100、200、300称为外键值，classno在这里是单一外键； 请注意以下三点： 外键字段可以为NULL，外键为空的数据也叨孤儿数据； 被引用字段必须具有unique约束； 有了外键引用乊后，表分为父表和子表，以上父表：班级表 t_class； 子表是：学生表 t_student；创建表时先创建父表，再删除子表；插入数据时，先插入父表数据,再插入子表数据； 示例一的完整实现 测试：在t_student表中插入一个班级编号为400的 执行失败原因：引用外键值在外键表 t_class 中 cno数据中不存在； 示例二：找出每个学生的班级名称 找出每个学生的班级名称 重点：典型的一对多设计是，在多的一方加外键。 在MySQL中没有提供修改外键约束的语法功能 5.5.5 级联更新与级联删除用法：在添加级联更新不级联删除的时候，需要在外键约束后面添关键字； 注意：级联更新不级联删除操作谨慎使用，因为级联操作会将数据改变或者删除【数据无价】 （1）级联删除：on delete cascade 定义：在删除父表数据的时候，级联删除子表中数据； 删除外键约束 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 添加外键约束及级联删除功能 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段)REFERENCES 引用表名(引用表中字段名称) ON DELETE CASCADE; 级联删除—完整示例 第一步：删除t_student中的外键 alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联删除 on delete cascade; 第三步：删除t_class表中班级编号为200的信息，包括所在班级的学生信息 （2）级联更新：on update cascade 定义：在更新父表中数据的时候，级联更新子表中数据； 删除外键约束（没有修改外键约束语法） 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 更新外键约束和添加级联更新功能 语法：**ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 引用表名称(引用表字段) ON UPDATE CASCADE;** 级联更新—完整示例 第一步：删除 t_student中的外键alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联更新 on update cascade; 第三步：更新t_class表中班级编号200改为100，包括所在班级的学生信息 好，今天就学这么多先~好好休息一下，慢慢吸收。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（上）]]></title>
    <url>%2F2019%2F03%2F17%2F2019-03-17-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[因为有了数据库管理系统，我们操作数据更加的方便直观，不再需要通过IO流的操作进行数据管理。而我们今天就来学习一款比较流行的关系型数据库管理系统——MySQL。 目录 学前准备 常用命令 演示数据结构 简单的查询 条件查询 数据排序 处理函数 总结 1. 学前准备1.1 安装MySQL（省）1.2 启动MySQL的服务1.2.1 可以通过服务管理器管理MySQL的服务停止MySQL服务 启动MySQL服务 1.2.2 在DOS窗口直接通过命令行的形式进行控制启动MySQL服务：net start mysql 停止MySQL服务：net stop mysql 1.3 MySQL登录配置用户环境变量path:C:\Program Files\MySQL\MySQL Server 5.7\bin，否则如下图显示 提示：mysql不是内部或外部命令，也不是可运行的程序戒批处理文件。 配置完成之后，再次运行，提示：ERROR 1045 (28000): Access denied for user ‘ODBC‘@’localhost’ (using password: NO) 打开dos窗口，输入mysql –uusername –ppassword，点击回车登录，看到以“mysql&gt;”说明已经登录成功 1.4 表的定义表是一种结构化的文件，可以用来存储特定类型的数据，如：学生信息、课程信息等，都可以放到表中，另外表都有特定的名称，而且不能重复。表中有以下几个概念：列、行、主键。 （1）列（字段） 列， 通常叫做字段，每一个字段都包含：字段名称、字段数据类型、字段约束、字段长度； （2）行记录 行，通常叫做表中的记录。表中的数据是按行（记录）存储的，表里可以有0条或多条记录； 1.5 SQL的分类（1）数据库查询语言（DQL） 简称：DQL，Data Query Language 代表关键字：select （2）数据库操作语言（DML） 简称：MQL，Data Manipulation Language 代表关键字：update、delete、insert 增、删、改表中的数据 （3）数据库定义语言（DDL） 简称：DDL，Data Denifition Language 代表关键字：create、drop、alter 创建、删除、修改表的结构 （4）事务控制语言（TCL） 简称：TCL，Transaction ControlLanguage 代表关键字：commit、rollback （5）数据控制语言（DCL） 简称：DCL，Data Controller Language 代表关键字：grant、revoke （6）DML与DDL的区别是什么？ DML是修改数据库表中的数据，而DDL是修改数据中表的结构 1.6 导入演示数据 使用MySQL命令行客户端来装载数据库 (1) 连接MySQL：mysql -uroot -p123 (2) 创建数据库：create database bjpowernode; (3) 选择数据库：use bjpowernode; (4)导入数据库：source D:\bjpowernode.sql (5)删除数据库：drop database bjpowernode; 查看数据库相关命令 (1) 查看数据库管理系统中所有的数据库：show databases; (2) 查看bjpowernode数据库中的所有表格：show tables; (3) 查看描述表的结构：desc 表名; 演示数据表结构描述 (1) 表名称：dept 描述：部门信息表 (2) 表名称：emp 描述：员工信息表 注：DEPTNO是外键，DEPTNO的值来源于dept表的主键，起到了约束的作用 表名称：salgrade 描述：薪水等级信息表 2. 常用命令2.1 查看MySQL版本（进入Mysql前）2.1.1. mysql –versionC:\Users\Administrator&gt;mysql --version 2.1.2. mysql -V（注：大写字母V）C:\Users\Administrator&gt;mysql –V 2.2 查询当前使用数据库及MySQL版本(进入MySQL后)2.2.1. 查看当前使用数据库select database (); 2.2.2. 查看MySQL数据库版本select version(); 2.3 创建数据库2.3.1. create database 数据库名称；mysql&gt;create database bjpowernode; 2.3.2. use 数据库名称；use bjpowernode;注：在数据库中创建表，因此创建表的时候必须要先选择数据库。 2.4 终止一条语句2.4.1. 如果想要终止一条SQL询句，可输入\c；2.5 退出MySQL2.5.1. 可使用exit、\q或exit；最方便快捷的是crtl+c3. 演示数据结构3.1. 如何取得演示数据3.1.1. 查看和指定现有的数据库show databases; 3.1.2. 指定当前缺省数据库use bjpowernode; 3.1.3. 查看当前使用的数据库select database(); 3.1.4. 查看当前数据库中的表show tables; 3.1.5. 查看其它数据库中的表show tables from 数据库名称； 3.1.6. 查看表结构desc 表名称； 3.1.7. 查看表的创建语句show create table 表名称; 4. 简单的查询4.1 查询一个字段4.1.1 查询员工姓名注：在SQL语句中不区分大小写；SQL语句以；分号结束select ename from emp; 注：select语句后面跟的是字段名称，select是关键字，select和字段名称之间采用空格隔开，from表示将要查询的表，它和字段之间采用空格隔开。 4.2 查询多个字段4.2.1 查询员工编号和员工姓名注：多个字段查询时，字段与字段之间用,隔开select empno,ename from emp; 注：查询多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段不能使用逗号了. 4.3 查询全部字段我们可以将所有字段放到 select 语句之后，这种方案不方便，但是比较清楚，我们可以采用下面的方式查询全部字段。select * from emp; 注：采用 select from emp，虽然简单，但是 号不是很明确，并且select 语句会先去编译，将``转换成字段，建议查询全部字段将相关字段写到 select 语句的后面，在以后 java连接数据库的时候，是需要在 java 程序中编写 SQL 语句的，这个时候编写SQL语句不建议使用 select * 这种形式，建议写明字段，这个 SQL 语句的可读性强。 4.4 计算员工的年薪4.4.1 列出员工编号，姓名和年薪mysql&gt;select empno,ename,sal*12 from emp; 注：字段上可以使用数学表达式，只要SQL语句中有 select 关键字，不会修改底层数据库字段的值； 4.5 将查询出来的字段重命名和显示为中文4.5.1 select empno,ename,sal * 12 as yearsal from emp;或者 select empno,ename,sal * 12 yearsal from emp; 4.5.2. select empno,ename,sal * 12 as ‘年薪’ from emp;或者 select empno,ename,sal * 12 ‘年薪’ from emp; 注： 重命名为中文时必须加单引号或双引号； 标准SQL询句中类型为字符串时必须加单引号，加单引号适用于任何数据库； SQL询句中类型为字符串时也可加双引号，叧适用于MySQL数据库中； 为了SQL询句的通用性，建议全部使用单引号； 5. 条件查询注意：条件查询需要用到 where 语句，where 必须放到 from 语句表的后面；执行顺序：先from再where过滤后再检索出来。 5.1 支持如下运算符 运算符 说明 = 等于 &lt;&gt;或!= 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between…and… 两值之间，等同于&gt;=and&lt;= is null 为null（is not null不为空） and 并且 or 或者 in 包含，相当于多个or（not in不在这个范围中） not not可以取非，主要用在is或in中 like like称为模糊查询，支持%或者下划线匹配，%匹配任意个字符，一个下划线匹配一个字符 5.2 等号（=）操作符5.2.1 查询薪水为5000的员工select empno,ename,sal from emp where sal = 5000; 5.2.2 查询 job 为 MANAGER 的员工错诣：select empno,ename,job from emp where job = MANAGER; 以上查询结构出现错误，因为 job 字段为字符串，所以出现了以上错误信息；正确：select empno,ename,job from emp where job =“manager”; 也可使用单引号 select empno,ename,job from emp where job = &#39;manager&#39;; select empno,ename,job from emp where job = &#39;MANAGER&#39;; 以上输入结果输入结果正确，MySQL默认情况下大小写不敏感； 5.3 不等号（&lt;&gt;、!=）操作符5.3.1. 查询薪水不等于 5000 的员工select empno,ename,sal from emp where sal &lt;&gt; 5000; 以下写法等同于上的写法，建议使用第一种写法select empno,ename,sal from emp where sal != 5000;数值也可以采用单引号引起来，如下语句也是正确，但不建议，原因MySQL数据库做数据类型自动转换select empno,ename,sal from emp where sal &lt;&gt; ‘5000’; 5.3.2. 查询工作岗位不等于MANAGER的员工 5.4 between … and …操作符5.4.1. 查询薪水为1600到3000的员工（第一种方式：采用&gt;=、&lt;=）select empno,ename,sal from emp where sal &gt;= 1600 and sal &lt;= 3000; 5.4.2. 查询薪水为1600到3000的员式（第二种方式：采用between…and…）select empno,ename,sal from emp where sal between 1600 and 3000; 注：关于between … and … 它是包含最大值和最小值的 5.4.3. （了解）between … and … 同样也可用在字符上，用在字符上区间为：前闭后开；select ename from emp where ename between ‘A‘ and ’F‘; 5.5 is nullNull 为空，它不是一个数值，不是一个空串，为null可以设置这个字段不填值，如果查诟为null的字段，采用is null。 5.5.1 查询津贴为空的员工错诣：select empno,ename,comm from emp where comm = null; 原因：以上无法查诟出符合条件的数据，因为null类型比较特殊，必须使用 is 来比较正确：select empno,ename,comm from emp where comm is null; 5.5.2 查询津贴不为空的员工select empno,ename,comm from emp where comm is not null; 5.6 and含义：表示并且，表示所有查诟条件必须满足 5.6.1. 查询工作岗位为“MANAGER”并且薪水大于2500的员工select empno,ename,job,sal from emp where job =’MANAGER‘ and sal &gt; 2500; 5.7 or含义：只要满足条件即可，相当于包含 5.7.1 查询出 job 为 SALESMAN 或 job为MANAGER的员工select ename,job from emp where job = ’SALESMAN‘or job = ’MANAGER‘; 5.8 and与or表达式的优先级and的优先级高于or 5.8.1. 查询薪水大于1800，并且部门编号为20或30的员工错误：select * from emp sal&gt;1800 and deptno=20 or deptno = 30; 分析：以上输出的结果不是我们预期的结果，薪水小于1800的也查出来了，原因是表达式的优先级导致的，首先SQL语句过滤了 sal &gt; 1800 and deptno = 20，然后再将deptno = 30的员工合并过来，所以是不正确的。正确：select * from emp where sal&gt;1800 and (deptno=20 or deptno=30); 注：关于运算符的问题不用死记硬背，没有把握的尽量采用括号； 5.9 in含义：表示包含的意思，完全可以采用or来表示，采用in会更简洁一些。 5.9.1 查询出Job为 SALESMAN 和 Job为 MANAGER 的员工select ename,job from emp where job in (‘SALESMAN’,＇MANAGER’); 5.9.2. 查询出薪水为1600和3000的员工select ename,sal from emp where sal in (1600,3000); 5.9.3. 查询出薪水不是1600和3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10 not5.10.1 第一种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal &lt;&gt; 1600 and sal &lt;&gt; 3000; 5.10.2 第二种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where not (sal = 1600 or sal = 3000); 5.10.3. 第三种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10.4 查询出津贴不为null的员工select * from emp where comm is not null; 5.11 Like含义：like可以实现模糊查诟，like支持%和下划线匹配 5.11.1. 查询以姓名以 M 开头的所有员工‘M%’select ename from emp where ename like ‘M%’; 5.11.2. 查询姓名以N结尾的所有员工‘%N’select ename from emp where ename like &#39;%N&#39;; 5.11.3. 查询姓名中包含O的所有员工‘%O%’select ename from emp where ename like &#39;%O%&#39;; 5.11.4. 查询姓名中第二个字符为A的所有员工‘_A%’select ename from emp where ename like &#39;_A%&#39;; 5.11.5. 查询姓名中倒数第二个字符为E的所有员工‘%E_’select ename from emp where ename like &#39;%E_&#39;; 5.11.6. 查询姓名中第三个字符为R的所有员工姓名‘__R%’select ename from emp where ename like ‘__R%’; 6. 数据排序6.1. 单一字段排序 order by 字段名称6.1.1. 作用：通过哪个或哪些字段进行排序含义：排序采用 order by 子句，order by 后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序（asc），如果存在 where 子句，那么 order by 必须放到where 语句后面。（1） 按照薪水由小到大排序（系统默认由小到大）select ename,sal from emp order by sal; （2）取得 job 为 MANAGER 的员工，按照薪水由小到大排序（系统默认由小到大）select ename,job,sal from emp where job = ‘MANAGER’ order by sal; 注：如果包含 where 语句 order by 必须放到 where 后面，如果没有 where 语句 order by 放到表的后面； （3） 以下语法是错误的：a） select * from emp order by sal where job = ‘MANAGER’; 6.2. 手动指定字段排序6.2.1. 手动指定按照薪水由小到大排序（升序关键字 asc）select ename,sal from emp order by sal asc; 6.2.2. 手动指定按照薪水由大到小排序（降序关键字desc）select ename,sal from emp order by sal desc; 6.3. 多个字段排序6.3.1. 按照 job 和薪水倒序排序select ename,job,ename from emp order by job desc,sal desc; 注意：如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序； 6.4. 使用字段位置排序按照薪水升序排序（不建议采用此方法，采用数字含义不明确，可读性不强，程序不健壮）select * from emp order by 6; 7. 处理函数7.1. 数据处理函数（单行处理函数） lower 转换小写 upper 转换大写 substr 取子串（substr（被截取的字符串，起始下标，截取的长度）） length 取长度 trim 去空格 str_to_date 将字符串换成日期 date_format 格式化日期 format 设置干分位 round 四舍五入 rand() 生成随机数 ifnull 可以将null转换成一个具体值 注意：数据处理函数是该数据本身特有的，有些函数可能在其它数据库不起作用； 7.1.1. lower(字段名)函数: 转换为小写用法：lower(要转换字段名称)查询员工姓名，将员工姓名全部转换成小写select lower(ename) as ename from emp; 7.1.2. upper(字段名)函数：转换为大写用法：upper(要转换字段名称)查询员工姓名，将员工姓名全部转换为大写select upper(ename) as ename from emp; 7.1.3. substr(字段名,起始下标,截取长度)函数：取子串用法：substr(被截取字段名称,起始下标,截取长度)注意：起始下标：从1开始查询并显示所有员工姓名的第二个字母select substr(ename,2,1) from emp; 查询员工姓名中第二个字母为A的所有员工select ename from emp where substr(enam,2,1) = ‘A’; 联想知识点，模糊查诟：select ename from emp where ename like ’_A%‘; 7.1.4. length(字段名)函数：取字段长度用法：length(字段名称)取得员工姓名长度select ename,length(ename) as nameLength from emp; 7.1.5. ifnull(字段名,替换值)函数：空值处理函数用法：ifnull(字段名称,将要替换)结论：在数据库中，有Null参与数学运算的结果一定为Null；为了防止计算结果出现Null，建议先使用ifnull函数预先处理。查询员工姓名及补助，如果补助为Null设置为0；select ename,ifnull(comm,0) from emp; 查询员工薪水与补助的和 错误写法：select sal+comm from emp; 正确写法：select sal + ifnull(comm,0) from emp; 没有补助的员工，将每月补助100，求员工的年薪select ename, (sal + ifnull(comm,100)) * 12 yearsal from emp; 7.1.6. case…when…then…else…end用法：匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 12345case job when &apos;MANAGER&apos; then sal * 1.1 when &apos;SALESMAN&apos; then sal * 1.5 else salend 注意：使用在DQL询句中； 匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 1.1.7. trim(‘字符串’)函数：去除首尾空格作用：trim函数去除首尾空格，不会去除中间空格用法：trim(字符串)取得工作岗位为manager的所有员工select * from emp where job = trim(&#39; manager &#39;);注意：MySQL默认去除字段后面的空格，原因：MySQL语法松散 7.1.8. round(数字,保留小数位数)函数：四舍五入用法：round(要四舍五入的数字,四舍五入到哪一位)，默认保留整数位保留整数位或不保留小数位：select round(125.18)；或者 select round(125.18,0); 保留1位小数：select round(125.18,1); 保留2位小数：select round(125.18,2); 个数位四舍五入：select round(125.18,-1); 7.1.9. rand()函数：生成随机数生成一个 0≤ v ≤ 1.0的随机数;select rand(); 生成一个0-100的随机数select round(rand()*100); 7.1.10. str_to_date函数：将字符串转换为日期作用：将‘日期字符串’转换为‘日期类型’数据执行结果：DATE类型用法：str_to_date(‘日期字符串’,‘日期格式’) 1）日期字符串：日期格式的字符串日期格式：告知MySQL输入日期字符串的格式是什么MySQL日期格式： 序号 格式符 功能 格式符 功能 1 %Y 代表四位的年份 %y 代表两位的年份 2 %m 代表月，格式（01…12） %c 代表月，格式（1…12） 3 %d 代表日 4 %H 代表24小时制 %h 代表12小时制 5 %i 代表分钟，格式（00…59） 6 %S或%s 代 表 秒 , 格 式（00…59） 查询出1981-12-03入职的员工执行成功：select ename,hiredate from emp where hiredate = ‘1981-12-03’; 1、在MySQL中日期作为查询条件时，可以使用字符串为其赋值，常用格式有三种:1949-10-101949/10/10194910102、输入的日期字符串格式不MySQL默认日期格式相同，MySQL默认日期格式：%y-%m-%d查询出02-20-1981入职的员工错误执行：select ename,hiredate from emp where hiredate = &#39;02-20-1981&#39;; 错误原因：‘02-20-1981’是一个字符串varchar类型，不MySQL中DATE默认类型丌匹配正确写法：select ename,hiredate from emp where hiredate = str_to_date(‟02-20-1981‟,‘%m-%d-%Y’); 总结：1、日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以仍需掌握；2、每一个数据库处理日期时采用的机制都不一样，都有自己的一套处理机制，所以在实际开发中将日期字段定义为DATE类型的情况很少；3、如果使用日期类型，java程序将不能通用。实际开发中，一般会使用“日期字符串”来表示日期； 创建 t_student 表【create语句，以后再细讲】，插入含有日期的数据 插入数据：1980-01-18【insert 语句，以后详细讲】 执行成功：‘1980-01-18’虽然是一个varchar类型，但是由于格式和MySQL数据库默认的日期格式相同，所以存在自动类型转换。 执行失败：再次插入01-18-1980A.‘01-18-1980’日期字符串的格式和MySQL默认的格式不同；B．‘01-18-1980’是varchar类型，birth字段需要DATE类型，类型不匹配； 正确写法： 结论：str_to_date凼数通常使用在插入操作中；字段DATA类型，不接收varchar类型，需要先通过该函数将varchar变成data再插入数据。 7.1.11. date_format函数：将日期转换为特定格式字符串作用：将‘日期类型’转换为特定格式的‘日期字符串’类型用法： date_format(日期类型数据,’日期格式’)查询员工的入职日期，以‘10-12-1980’的格式显示到窗口中； 查询员工的入职日期，以‘10/12/1980’的格式显示到窗口中； MySQL日期默认格式示例 以下两个DQL询句执行结果相同第一种：hiredate自劢转换成varchar类型，默认采用%Y-%m-%d格式 第二种：通过date_format(hiredate,’%Y-%m-%d’)函数 7.2. 分组函数/聚合函数/多行处理函数7.2.1. 常用以下几种 sum 求和 avg 取平均 max 取最大值 min 取最小值 count 取记录数 7.2.2. 什么是单行处理函数，什么是多行处理函数？单行函数都是一行输入对应一行输出多行处理函数都是多行输入对应一行输出 7.2.3. 注意：1、分组函数自动忽略空值，丌需要手劢增加where条件排除空值；2、分组函数不能直接使用在where关键字后面； 7.2.4. sum(字段)函数作用：求某一列的和，null会自劢被忽略；用法： sum(字段名称) 案例 （1）取得薪水的合计 （2）取得补助的合计 注意：null 会被忽略不计 （3）取得总共薪水（工资+补助）合计 统计结果错误，原因： 1、comm字段有 null 值，在多列进行运算时，叧要有 null 参不的数学运算结果都为 null2、sum函数会自劢忽略掉null值，正确的做法是将comm的null值转换为0，如：ifnull(comm,0)纠正以上错误，如下：sum(sal + ifnull(comm,0)) 7.2.5. avg(字段名)函数作用：求某一列的平均值，null会被自劢忽略用法：avg(字段名称) 案例 （1）取得平均薪水avg(sal) 7.2.6. max(字段名)函数作用：取得某一列的最大值用法：max(字段名称)案例：（1）取得最高薪水max(sal) （2）取得最晚入职的员工max(hireddate)说明：日期类型也可以进行大小比较 7.2.7. min(字段名)函数作用：取得某一列最小值用法：min(字段名称)案例（1）得最低薪水min(sal) （2）取得最早入职的员工min(hiredate) 7.2.8. count函数作用：取得某字段值不为null的记录总数用法：count(字段名称) 或 count()注意：1、 count()表示取得当前查诟表所有记录2、 count(字段名称)，不会统计为 null 的记录案例（1） 取得所有员工数count(*) （2）取得补助不为空的所有员工数count(comm) （3）取得补助为空的员工数量 is null select count(*) from emp where comm is null； 查询出补助comm为null的数量 7.2.9. 组合聚合函数sum、avg、max、min、count可以将这些聚合函数都放到 select 中一起使用select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 7.3. distinct 去除重复记录作用：将查询结果中某一字段的的重复记录去除掉用法：distinct 字段名或 distinct 字段名1, 字段名2 … …distinct 字段名A：去除不字段名A相同的记录distinct 字段名A,字段名B：去除不字段名A和字段名B同时相同的记录注意：distinct叧能出现在所有字段最前面，后面如果有多个字段及为多字段联合去重 7.3.1. 案例（1）查询全公司有哪些工作岗位 （2）查询全公司工作岗位数量 （3）去除部门编号deptno和工作岗位job重复的记录 7.4. 分组查询：group by作用：通过哪个或哪些字段进行分组用法：group by 字段名称 7.4.1. 案例（1）找出每个工作岗位的最高薪水思路分析：按照工作岗位分组，然后对每一组求最大值。SQL询句中肯定包含 group by、max(sal)； 重点结论：有 group by 的DQL询句中，select 语句后面只能跟 分组函数 + 参与分组的字段； （2）计算每个工作岗位的最高薪水，并且按照由低到高进行排序思路分析：先按照工作岗位 job 进行分组，然后对每一组薪水求最大值max，最后再根据每一组薪水的最大值进行由低到高排序； 注意：如果使用了 order by ，order by 必须放到 group by后面； （3）计算每个部门的平均薪水思路分析：首先，按照部门编号分组，然后对每一组的薪水求平均值 （4）计算出不同部门不同岗位的最高薪水思路分析：首先把deptno和job看成一个字段进行联合字段分组，联系到distinct关键字。 （5）找出每个工作岗位的最高薪水，除MANAGER之外思路分析：先将job等于MANAGER的过滤掉，然后再根据工作岗位进行分组，对每一组求最大薪水。 7.4.2. having作用：如果想对分组的数据再进行过滤，需要使用having子句； （1）找出每个工作岗位的平均薪水，要求显示平均薪水大于2000的；思路分析：先对工作岗位 job 分组，然后对每一组薪水求平均值，最后再对每一组平均薪水的值进行大于2000的条件过滤； 错误写法：select job,avg(sal) from emp where avg(avg) &gt; 2000 group by job;原因：where关键字后面不能直接使用分组函数，这与SQL询句的执行顺序有关系，它会先执行from emp，然后再进行 where 条件过滤，where条件过滤结束之后再执行 group by 分组，之后才会显示出查询结果。正确写法：select job,avg(sal) from emp group by job having avg(sal) &gt; 2000; 注意：能够在where在过滤的数据不要放到having中进行过滤，否则影响SQL询句的执行效率 7.4.3. where 与 having 区别： where 和 having 都是为了完成数据的过滤，它们后面都是添加条件； where 是在 group by之前完成过滤； having 是在 group by 之后完成过滤； 8. 总结一个完整的SQL语句如下： 123456789101112select xxxxfrom xxxxwhere xxxxgroup by xxxxhaving xxxxorder by xxxx 以上关键字的顺序不能变，严格遵守以上语句的执行顺序： from 将硬盘上的表文件加载到内存 where:将符合条件的数据行摘取出来。生成一张新的临时表 group by :根据列中的数据种类，将当前临时表划分成若干个新的临时表 having : 可以过滤掉group by生成的不符合条件的临时表 select : 对当前临时表进行整列读取 order by : 对select生成的临时表，进行重新排序，生成新的临时表 limit : 对最终生成的临时表的数据行，进行截取。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM快速入门]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-JVM-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM快速入门 听说Java虚拟机是我们成为一名优秀程序员必须掌握的一个知识，这也是我们和一般只会敲代码的程序员特别能体现差距的地方。所以小艾今天就赶紧的去学习了一下JVM。 目录 JVM体系结构概述 堆体系结构概述 堆参数调优入门 GC垃圾回收 总结 一、JVM体系结构概述首先我们要知道JVM是运行在操作系统之上的，与硬件并没有直接的交互。 它的体系结构概览如下图所示： 其中的灰色区域Java栈、本地方法栈、程序计数器三块绝对不会有垃圾回收，而所谓的JVM调优就是调方法区和堆，主要是堆。记住这两点后，我们来详细的了解一下各个模块，先从红色的类装载子系统和执行引擎说起。 1.1 类装载器Class Loader它类似于快递员，负责把硬盘上的class文件送去执行，也就是说只负责class文件的加载，至于它是否运行由Execution Engine决定。 注意硬盘上的Car.class是小写的class，是指存在于硬盘上的一个文件。 1.1.1 类加载器的分类Java是由C++演变过来的，分为“虚拟机自带的加载器”和“用户自定义加载器”。 虚拟机自带的加载器 启动类加载器（Bootstrap）C++编写 扩展类加载器（Extension）Java编写 应用程序类加载器（AppClassLoader）Java编写，也叫系统类加载器，加载当前应用的classpath的所有类。 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式。 它的特点包括“双亲委派机制”和“沙箱安全机制” 双亲委派机制 双亲委派模型的运作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己加载。 沙箱机制 沙箱机制是基于双亲委派机制上的采取一种JVM的自我保护机制，假设你要写一个java.lang.String的类，由于双亲委派机制的原理，此请求会先交给Bootstrap试图进行加载，但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类，有则优先加载rt.jar包中的类，因此就保证了java的运行机制不会被破坏。 Sun.misc.Launcher它是Java虚拟机的入口应用，最后Execution Engine执行引擎负责解析命令，提交到操作系统执行。 1.2 本地方法栈本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies. 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等待。 1.3 PC寄存器PC寄存器也叫Program Counter Register程序计数器，每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储下一条指令的地址，就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。直白点说就是程序执行顺序的调度依靠它来完成。 1.4 方法区方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间。 静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中，But实例变量存在堆内存中，与方法区无关。 1.5 栈偏理论：程序=算法+数据结构 偏应用：程序=框架+业务逻辑 其中有种数据结构叫做栈，后进先出，先进后出，类似于子弹夹。对于Java来说，栈里存放的就是方法，main方法是最先进的所以在底层，main方法中引用的方法先完成后，main方法才能执行出栈。 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建的，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 1.5.1 栈存储什么栈帧中主要保存3类数据： 本地变量（Local Variable）：输入参数和输出参数以及方法内的变量。 栈操作（Operand Stack）：记录出栈、入栈的操作。 栈帧数据（Frame Data）：包括类文件、方法等待。 1.5.2 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中。 A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈， ……. ……. 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧… … 遵循“先进后出”/“后进先出”原则。 栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。 每次执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。 栈的大小也是有极限的。 栈异常：Exception in thread “main” java.lang.StackOverflowError 1.5.3 栈+堆+方法区的交互关系 HotSpot是SUN公司的Java虚拟机版本名，是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，即指向方法区中的模板文件，保证每一个实例一致性，reference存储的就直接是对象的地址。 三种JVM Sun公司的HotSpot BEA公司的JRockit IBM公司的J9 VM SUN和EBA都被Oracle公司收购，进行了产品整合，PK后产生了Java8。 二、堆体系结构概述2.1 堆一个JVM实例中只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space 新生区 Young/New Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm 2.1.1 新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。辛存区有两个：0区（Survivor 0 Space）和1区（Survivor 1 Space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError：Java head space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 2.1.2 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError：PermGen Space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 JDK1.6及之前：有永久代，常量池1.6在方法区 JDK1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。 JDK1.8及以后：无永久代，常量池1.8在元空间。 属性三区结构后方可学习JVM垃圾收集 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 三、堆参数调优入门我们先来看看Java7和Java8的堆结构区别 Java7 Java8之后最初的永久代取消了，由元空间取代。 3.1 堆内存调优简介01 123456public static void main(String[] args)&#123;long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。System.out.println("MAX_MEMORY = " + maxMemory + "（字节）、" + (maxMemory / (double)1024 / 1024) + "MB");System.out.println("TOTAL_MEMORY = " + totalMemory + "（字节）、" + (totalMemory / (double)1024 / 1024) + "MB");&#125; 发现默认的情况下分配的内存是总内存的“1/4”、而初始化的内存为“1/64” VM参数： -Xms1024m -Xmx1024m -XX:+PrintGCDetails 12345String str = "www.atguigu.com" ;while(true) &#123; str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;&#125; VM参数：-Xms8m -Xmx8m -XX:+PrintGCDetails 3.2 MAT 官网访问地址：https://projects.eclipse.org/projects/tools.mat/downloads -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件。 -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError 四、GC垃圾回收 4.1 GC是什么（分代算法）GC俗称垃圾回收器 （java Garbage Collection） 次数上频繁收集Young区 次数上较少收集Old区 基本上不动Perm区 4.2 GC4大算法JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 普通GC（minor GC）：只针对新生代区域的GC。 全局GC（major GC or Full GC）：针对年老代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 4.2.1 引用计数法4.2.2 复制算法（Copying）年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying） 原理： Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden区就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过==-XX:MaxTenuringThreshold== 来设定参数)，这些对象就会成为老年代。 -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数 解析： 年轻代中的GC,主要是复制算法（Copying） HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区 （分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 动图 缺点 复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 4.2.3 标记清除老年代一般是由标记清除或者是标记整理的混合实现。 原理 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象，标记为存活的对象。 清除：遍历整个堆，把未标记的对象清除。 用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 动图 缺点： 此算法需要暂停整个应用，会产生内存碎片 4.2.4 标记压缩老年代一般是由标记清除或者是标记整理的混合实现。 原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 缺点 标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 4.2.5 标记清除压缩 动图 4.2.6 这几种算法的比较内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。内存整齐度：复制算法=标记整理算法&gt;标记清除算法。内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 猜猜看 答案是没有，没有最好，只有更好，最适合的算法。 五、总结通过上面的学习，相信你已经对Java虚拟机有了初步的了解，接来下还需要再深入一点学习JVM的知识。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F03%2F03%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo介绍 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
