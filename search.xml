<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（下）]]></title>
    <url>%2F2019%2F03%2F21%2F2019-03-21-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（中）的学习，小艾对MySQL的多表查询有了更深刻的了解，掌握前面的内容，其实对于我们一般的开发也就足够了，今天就学习MySQL原理性一点的内容。 目录 存储引擎 事务 索引 视图 DBA命令 数据库设计三大范式 1. 存储引擎 存储引擎是MySQL特有的，其它数据库没有 1.1 存储引擎的本质 通过采用不同的技术将数据存储在文件戒内存中； 每一种技术都有不同的存储机制，不同的存储机制提供不同的功能和能力； 通过选择不同的技术，可以获得额外的速度戒功能，改善我们的应用； 1.2 MySQL支持很多种存储引擎常见命令： 1.2.1.show engines\G (1)在创建表时，可使用Engines选项为CREATE TABLE语句显示指定存储引擎 例如： 123CREATE TABLE table_name( NO INT)ENGINE = MyISAM; (2)如果创建表时没有指定存储引擎，则使用当前默认的存储引擎； (3)默认的存储引擎可在 my.ini 配置文件中使用 default-storage-engin 选项指定； (4)修改表的存储引擎使用：ALTER TABLE 表名 ENGINE **= 存储引擎名称; (5)查看表使用的存储引擎，命令如下： SHOW CREATE TABLE emp\G; SHOW TABLE STATUS LIKE ‘emp’\G; 1.3 常用的存储引擎1.3.1 MyISAM存储引擎MyISAM引擎是MySQL数据库最常用的； 它管理的表具有以下特性： 使用三个文件表示每个表： 格式文件 — 存储表的结构（mytable.frm）数据文件 — 存储表的数据（mytable.MYD）索引文件 — 存储表的索引（mytable.MYI） 可转换为压缩、叧读表来节省空间 1.3.2 InnoDB存储引擎InnoDB存储引擎是MySQL数据库的缺省引擎； 它管理的表具体有以下特征： a) 每个InnoDB表在数据库目录中以.frm格式文件表示b) InnoDB表空间tablespace被用亍存储表的内容c) 提供一组用来记录事务性活劢的日志文件d) 用COMMIT（提交）、SAVEPOINT及ROLLBACK（回滚）支持事务处理e) 提供全部ACID兼容f) 在MySQL服务器崩溃后提供自劢恢复g) 多版本（MVCC）和行级锁定h) 支持外键及引用的完整性，包括级联更新和删除 1.3.3 MEMORY存储引擎使用MEMORY存储引擎的表，因为数据存储在内存中，且行的长度固定，所以使得MEMORY存储引擎非常快； MEMORY存储引擎管理的表具有下列特征： a) 在数据库目录内，每个表均以.frm格式文件表示；b) 表数据及索引被存储在内存中；c) 表级锁机制；d) 字段属性不能包含TEXT戒BLOB字段； MEMORY存储引擎以前被称为HEAP引擎； 1.4 选择合适的存储引擎MyISAM表最适合于大量的数据读而少量数据更新的混合操作。MyISAM表的另一种适用情形是使用压缩的只读表。 如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为数据读取和更新的混合提供了良好的并发机制。 使用MEMORY存储引擎存储非永丽需要的数据，戒者是能够从基于磁盘的表中重新生成的数据。 2. 事务2.1 事务是什么（5点） 一个最小的不可再分的工作单元； 通常一个事务对应一个完整的业务；（如：银行转账业务） 而一个完整的业务需要批量的DML（insert、update、delete）语句共同完成 事务只和DML语句有关系，戒者说叧有DML语句才有事务； 以上所描述的批量DML语句共有多少DML诧句，这个和业务逻辑有关系，业务逻辑不同DML语句个数不同 ； 2.1.1 关与银行转账业务银行转账业务：是一个完整的业务，最小的单元，不可再分，也就是说银行转账业务是一个完整的事务。 示例：账户转账 t_act账户表：actno，balance actno balance act-001 50000.0 act-002 10000.0 act-001转10000.0给act-002，操作如下： update t_act set balance = 40000.0 where actno = ‘act-001’; update t_act set balance = 20000.0 where actno = ‘act-002’; 分析： （1）以上两条DML语句必须同时成功戒者同时失败，因为它为最小业务单元，不可拆分； （2）当第一条DML语句执行成功之后，并不能将底层数据库中的第一个账户的数据修改，而是将操作记录了一下，这个记录是在内存中完成的。 （3）当第二条DML与句执行成功之后，和底层数据库文件中的数据完成同步。 （4）若第二条DML语句执行失败，将清空所有的历史操作记录。 结论：要完成以上功能，必须借助事务 transaction。 2.2 概述事务可以保证多个操作原子性，要举全成功，要举全失败。对亍数据库来说，事务保证批量的DML要举全成功，要么全失败。 2.2.1 事务具有四个特征ACID：（1）原子性（Atomicity）事务是最小单元，不可再分； （2）一致性（Consistency）事务要求所有的DML语句操作的时候，必须保证同时成功或同时失败； （3）隔离性（Isolation）一个事务不会影响其它事务的运行； （4）持久性（Durability）在事务完成之后，该事务对数据库所作的更改将持久地保存在数据库中，并不会被回滚； 2.2.2 事务中的一些概念（1）开启事务：start transaction （2）结束事务：end transaction （3）提交事务：commit transaction （4）回滚事务：rollback transaction 2.3.3 和事务有关的两条SQL语句【TCL】COMMIT； 提交 ROLLBACK； 回滚 2.3.4 事务开启和结束的标志是什么 ？开始的标志 任何一条DML语句执行，标志事务的开启； 结束的标志 提交（commit）或者回滚（rollback） 提交：成功的结束，将所有的DML与句操作记录和底层硬盘文件中数据进行一次同步； 回滚：失败的结束，将所有DML语句操作记录全部清空； 2.3.5 重点（1）在事务进行过程中，未结束之前，DML语句是不会修改底层数据库文件中的数据。 （2）叧是将历史操作记录一下，在内存中完成记录。 （3）叧有在事务结束的，而且是成功结束的时候才会修改底层硬盘文件中的数据。 2.3.6 MySQL事务的提交和回滚的演示MySQL默认事务：自劢提交 show variables like ‘%commit%’; 在MySQL数据库管理系统中，默认情况下，事务是自动提交的；也就是说，叧要执行一条DML语句，就开启了事务，并且提交了事务； 第一种：关闭MySQL事务自动提交 事务成功用法：start transaction；commit; 第一步：start transaction; 手动开启事务第二步：DML诧句…. 执行批量DML语句 .第三步：commit; 手动提交事务【事务成功结束】 演示例子：在t_user表中插入数据：事务成功提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询原表数据 第二步：窗口1，手动开启事务 start transaction，插入数据，查询数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，手动提交事务commit 第五步：窗口2，查询 t_user 表 回滚提交用法：start transaction; rollback;第一步：start transaction; 手动开启事务第二步：DML语句….. 批量DML语句 演示例子：在 t_user表中插入数据，事务失败提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询 t_user 表数据 第二步：窗口1，开启事务start transaction，并向t_user表插入数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，rollback 回滚事务，并查询t_user表数据 第五步：窗口2，查询t_user表数据 第二种：关闭MySQL事务自劢提交：只对当前会话有效 两种关闭自动提交事务a） set autocommit = offb） set session autocommit = off 两种打开自劢提交事务a） set autocommit = onb） set session autocommit = on注：以上打开戒关闭事务叧对当前窗口有效； 查询事务状态： show variables like ‘%commit%’; 2.3.7 事务的隔离级别事务四个特性ACID之一：隔离性（isolation） 隔离性有四个隔离级别： 1） read uncommitted 读未提交2） read committed 读已提交3） repeatable read 可重复读4） serializable 串行化 read committed 读未提交（级别最低） 1） 事务A和和事务B，事务A未提交的数据，事务B可以读取2） 这里读取到的数据可以叨做“脏数据”戒“脏读 Dirty Read”3） 读未提交隔离级别最低，这种级别一般叧在理论上存在，数据库默认隔离级别一般都高于该隔离级别； read committed 读已提交 1） 事务A和事务B，事务A提交的数据，事务B才可读取到；2） 该隔离级别高亍“读未提交”级别3） 换句话说：对方事务提交之后的数据，当前事务才可读取到。4） 该隔离级别可以避免脏数据；5） 该隔离级别能够导致“不可重复读取”6） Oracle数据库管理系统默认隔离级别为“可重复读” repeatable read 可重复读 1） 事务A和事务B，事务A提交之后的数据，事务B读取不到2） 事务B是可重复读到数据的3） 这种隔离级别高于“读已提交”4） 换句话说，对方提交之后的数据，还是读取不到5） 这种隔离级别可以避免“脏读和不可重复读”，达到“重复读取”；6） MySQL数据库管理系统默认隔离级别为：可重复读7） 虽然可以达到“可重复读”效果，但是会导致“幻象读” serializable 串行化 1） 事务A和事务B，事务A在操作数据库表中数据的时候，事务B叧能排队等待；2） 这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好；3） 这种隔离级别可以避免“幻象读”，每一次读取都是数据库表中真实的记录；4） 事务A和事务B不再并发； 查看隔离级别 1） 查看当前会话级隔离级别select @@tx_isolation;select @@session.tx_isolation; 2） 查看当前全局隔离级别： @@global.tx_isolation;select @@global.tx_isolation; 设置服务器缺省隔离级别 第一种：修改my.ini配置文件在 my.ini 文件中的[mysqld]下面添加：————————-my.ini——————————-[mysqld]transaction-isolation = READ-COMMITTED————————–my.ini——————————-a） 隔离级别可选项为：– READ-UNCOMMITTED– READ-COMMITTED– REPEATABLE-READ– SERIALIZABLE 第二种：通过命令方式设置事务隔离级别a） SET TRANSACTION ISOLATION LEVEL isolation-level;b） isolation-level 可选值：– READ UNCOMMITTED– READ COMMITTED– REPEATABLE READ– SERIALIZABLE 设置隔离级别作用的范围 1） 事务隔离级别的作用范围分为两种：会话级、全局级a） 会话级（session）：叧对当前会话有效b） 全局级（global）：对所有会话有效2） 使用方法如下 a） 会话级：SET TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;SET SESSION TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;b） 全局级SET GLOBAL TRANSACTION ISOLATION LEVEL; 隔离级别不一致性问题的关系 隔离级别 脏读 不可重复地 幻象读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 隔离级别不一致性问题的关系 1） 读未提交 READ UNCOMMITTED 会话一 会话二 set global transaction isolation level read uncommitted; 退出DOS窗口 use bjpowernode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpowernode; start transaction; start transaction; insert into t_user(name) values(‘king’); select * from t_user; 2） 读已提交 READ COMMITTED 会话一 会话二 set global transaction isolation level read committed; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; insert into t_user(name) values(‘allen’); select * from t_user; commit; select * from t_user; 3） 可重复读 REPEATABLE READ 会话一 会话二 set global transaction isolation level repeatable read; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; 4） 串行化 SERIALIZABLE 会话一 会话二 use bjpowernode; Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32));insert into t_user(name) values(‘zhangsan’);insert into t_user(name) values(‘lisi’); set global transaction isolation level serializable; 退出DOS窗口 use bjpownode; use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; commit; 3.索引3.1 索引原理3.1.1 什么索引索引对应的英语单词：index 索引作用： 相当于一本字典目录，提高程序的检索 / 查询效率；表中每一个字段都可添加索引 主键自动添加索引： 能够通过主键查询的尽量通过主键查询，效率较高； 索引和表相同，存储在硬盘文件中 索引和表相同，都是一个对象，表是存储在硬盘文件中的，那举索引也是表的一部分，索引也存储在硬盘文件中； MySQL数据库中表的检索方式有2种： 第一种：全表扫描（效率较低） 举例：查询ename=’KING’假设有一张表：emp 员工表，select from emp where ename = ‘KING’;若ename没有添加索引，那举通过ename过滤数据的时候，ename字段会全表扫描；假设有一张表：dept 部门表，select from dept where dname = ‘ACCOUNTING’；若dname没有添加索引，那举通过dname过滤数据的时候，dname字段会全表扫描； 第二种：通过索引检索（提高查询效率） 3.1.2 什么情况下适合给表中字段添加索引1） 该字段数据量庞大2） 该字段很少的DML操作（由亍索引也需要维护，DML操作多的话，也影响检索效率）3） 该字段经常出现在where条件中注：实际开发中会根据项目需求或客户需求等综合因素来做调整 3.1.3 索引的应用创建索引 1） 语法结构：a） create index 索引名 on 表名（列名）b） create unique index 索引名 on 表名（列名）注：添加unique表示在该表中的该列添加一个唯一性约束示例：create index dept_dname_index on dept(dname); 查看索引 1） 语法结构：a） show index from 表名示例：show index from dept; 删除索引 1） 语法结构：a） drop index 索引名 on 表名;示例：drop index dept_dname_index on dept; 4.视图4.1 什么是视图1） 视图对应英文单词：view2） 视图在数据库管理系统中也是一个对象，也是以文件形式存在的3） 视图也对应了一个查询结果，叧是从不同的角度查看数据 4.2 创建视图语法结构：create view 视图名称 as 查询语句； 例子：从emp表查询empno,ename,sal，结果当作视图展示 4.3 删除视图语法结构：drop view if exists 视图名称; 示例：删除myview视图：drop view if exists myview; 4.4 修改视图语法结构：alter view 视图名称 as 查询语句 示例：将myview视图修改为deptno,ename,job,sal 4.5 视图作用4.5.1 面向视图查询，可以提高查询效率例如 1） 单独执行：select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;2） 将上面执行结果当作视图对象创建create view myview as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;3） 面向视图查询：没有迚行表连接，提高检索效率select * from myview;【非常重要】隐藏表的实现细节 1、 create view myview as select empno a,ename b,sal c from emp;2、面向视图查询，叧知道myview视图中有a,b,c三个字段，不知道该视图背后真实表的结构是什么 5.DBA命令5.1 新建用户CREATE USER username IDENTIFIED BY ‘password’; username：你将创建的用户名,password：该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.示例：create user p361 identified by ‘123’;–可以登录但是叧可以看见一个库 information_schema 5.2 授权命令详解 示例：grant all privileges on dbname.tbname to ‘username‘@’login ip’ identified by ‘password’ with grant option; 1) dbname=表示所有数据库2) tbname=表示所有表3) login ip=%表示任何ip4) password为空，表示不需要密码即可登录5) with grant option; 表示该用户还可以授权给其他用户细粒度授权1、首先以root用户进入mysql2、然后键入命令：grant select,insert,update,delete on . to p361 @localhost Identified by “123”;3、如果希望该用户能够在任何机器上登陆mysql，则将localhost改为 “%” 。 粗粒度授权我们测试用户一般使用该命令授权：GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123”;注意：用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123” WITH GRANT OPTION;用户权限privileges包括：1） alter：修改数据库的表2） create：创建新的数据库戒表3） delete：删除表数据4） drop：删除数据库/表5） index：创建/删除索引6） insert：添加表数据7） select：查询表数据8） update：更新表数据9） all：允许任何操作10） usage：叧允许登录 5.3 回收授权命令详解 revoke privileges on dbname[.tbname] from username;revoke all privileges on . from p361; use mysqlselect * from user进入 mysql库中修改密码; update user set password = password(‘qwe’) where user = ‘p646’;刷新权限;flush privileges 5.4 导入导出导出：mysqldump 导出整个数据库C: \Administrator&gt; mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123导出指定库下的指定表C: \Administrator&gt;mysqldump bjpowernode emp&gt; D:\ bjpowernode.sql -uroot -p123 导入：source 登录MySQL数据库管理系统之后执行：mysql&gt;source D:\ bjpowernode.sql 6.数据库设计三范式定义：设计数据库的时候所依据的规范，共有三个规范； 6.1 第一范式：主键、字段不能再分定义：要求有主键，数据库中不能出现重复记录，每一个字段是原子性不能再分； 示例：不符合第一范式 学生编号 学生姓名 联系方式 1001 张三 zs@gmail.com,1359999999 1002 李四 ls@gmail.com,13699999999 1001 王五 ww@163.net,13488888888 分析以上设计存在的问题：1） 数据存在重复记录，数据不唯一，没有主键2） 联系方式可以再分，不是原子性修改以上设计方案： 学生编号(pk) 学生姓名 email 联系电话 1001 张三 zs@gmail.com 1359999999 1002 李四 ls@gmail.com 13699999999 1003 王五 ww@163.net 13488888888 结论：关于第一范式 1、 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，2、 主键主要通常采用数值型或定长字符串表示3、 关亍列丌可再分，应根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段了； 6.2 第二范式：非主键字段完成依赖主键定义：第二范式是建立在第一范式基础之上，要求数据库中所有非主键字段完全依赖主键，不能产生部分依赖；（严格意义上说：尽量不要使用联合主键） 示例一：数据仍然可能重复 学生编号 学生姓名 教师编号 教师姓名 1001 张三 001 王老师 1002 李四 002 赵老师 1003 王五 001 王老师 1001 张三 002 超老师 示例二：确定主键，学生编号、教师编号，出现冗余 学生编号（PK） 教师编号(PK) 学生姓名 教师姓名 1001 001 张三 王老师 1002 002 李四 赵老师 1003 001 王五 王老师 1001 002 张三 赵老师 综合分析：1、 以上虽然确定了主键，但此表会出现大量冗余，主要涉及到的冗余字段为“学生姓名”和“教师姓名”；2、 出现冗余的原因在亍：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。 解决方案如下： 学生信息表： 学生编号（PK） 学生姓名 1001 张三 1002 李四 1003 王五 教师信息表： 教师编号（PK） 教师姓名 001 王老师 002 赵老师 教师和学生的关系表： 学生编号(PK) fk-&gt;学生表的学生编号 教师编号(PK) fk-&gt;教师表的教师编号 1001 001 1002 002 1003 001 1001 002 结论：一种典型的“多对多”的设计 6.3 第三范式定义：建立在第二范式基础之上，要求非主键字段不能产生传递依赖于主键字段； 示例一：学生信息表 学生编号（PK） 学生姓名 班级编号 班级名称 1001 张三 01 一年一班 1002 李四 02 一年二班 1003 王五 03 一年三班 1004 六 03 一年三班 综合分析：1、从表中看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键2、班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖， 解决方案：1、 将冗余字段单独拿出来建立表2、 如下表所示：学生信息表中班级编号设为外键FK学生信息表： 学生编号（PK） 学生姓名 班级编号（FK） 1001 张三 01 1002 李四 02 1003 王五 03 1004 赵六 03 班级信息表： 班级编号（PK） 班级名称 01 一年一班 02 一年二班 03 一年三班 结论： 典型的一对多以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键 6.4 三范式总结6.4.1 一对一第一种方案：分两张表存储，共享主键 1） 示例：t_husband 和 t_wife两张表丈夫表 ：t_husband hno（PK） hname 1 Zhangsan 2 Wangwu 3 zhaoliu 妻子表：t_wife wno（PK）【同时也是外键FK，引用t_husband的主键】 wname 3 a 2 b 1 c 第二种方案：分两张表存储，外键唯一 示例：t_husband 和 t_wife两张表 **丈夫表 ：t_husband hno（PK） hname Wifeno（FK - unique） 1 Zhangsan 100 2 Wangwu 200 3 zhaoliu 300 妻子表：t_wife wno（PK） wname 100 a 200 b 300 c 6.4.2 一对多分两张表存储，在多的一方添加外键，这个外键字段引用一的一方中的主键字段例如：学生信息表和班级信息表，请参考：20.3.2 示例一 6.4.3 多对多例如：分三张表存储，在学生表中存储学生信息，在课程表中存储课程信息，在选课表中存储学生选课信息，请参考：20.2 6.5 实际开发中是怎么的？1） 数据库设计尽量遵循三范式2） 根据实际需求迚行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。 好，终于学完MySQL了，那么MySQL的学习就暂告一段落了。这么多东西，小艾要去休息休息消化消化一下才行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（中）]]></title>
    <url>%2F2019%2F03%2F19%2F2019-03-19-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%AD)%20%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（上）的学习，小艾已经有初步对MySQL的了解，前面学习的内容还是比较简单的，今天，就再深入的学习MySQL的查询吧。 目录 连接查询 子查询 union合并集合 limit使用 表 1. 连接查询在实际开发中，数据往往不是存放储一张表中，而是同时存储在多张表中，这些表与表存在着关系，我们在检索数据的时候往往需要多张表联合起来检索，这种多表联合检索被称为连表查询或跨表查询。 1.1 笛卡尔积现象含义：若两张表迚行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录的乘积，该现在称为笛卡尔积现象。 1.1.1 显示每个员工信息，并显示所属部门名称 1.2连接查询根据：年代分类1.2.1 SQL92语法语法结构：select xxxx from A表名,B表名 where 表连接条件 and 数据查询条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e,dept d where e.deptno = d.deptno; 缺点：表连接条件与查询条件放在一起，没有分离； 1.2.2 SQL99语法【只掌握SQL99】语法结构：select xxxx from A表名 join B表名 on 表的连接条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e join dept d on e.deptno = d.deptno; 优点：表连接独立，结构清晰，如果结果数据不满足要求，可再追加where条件进行过滤； 1.3连接查询根据：连接方式分类1.3.1 内连接定义：只连接匹配的行，即A表不B表相连接，能够匹配的记录查询出来。 （1）等值连接 示例：查询员工的名称和员工所对应的部门名称 select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;注：inner可忽略 （2）非等值连接 示例：查询员工的工资等级 select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可忽略 （3）自连接 示例：查询员工的名称和员工对应的领导名称 select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno;注：inner可忽略 1.3.2 外连接定义：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录时，会自动模拟出null值与之匹配；注意：外连接的查询结果条数 &gt;= 内连接的查询结果条数 （1）左外连接（左连接） 定义：包含左边表的全部行（不管右边的表中是否存在不它们匹配的行），以及右边表中全部匹配的行； （2）右外连接（右连接） 定义：包含右边表的全部行（不管左边的表中是否存在不它们匹配的行），以及左边表中全部匹配的行； （3）全连接（了解） 定义：包含左、右两个表的全部行，不管另外一边的表中是否存在不它们匹配的行。 1.4七大案例详解1.4.1 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（笛卡尔积）注意：多张表查询时，通常会对表起别名，若两张表中有相同名称的字段时，该相同名称字段不知道属亍哪张表中，这时需要通过对表起别名来限制该字段属于哪张表，并且提高SQL语句的效率，可读性也高。 思路分析：（1） Step 1：先查询出员工姓名和部门编号；emp员工表 （2）Step 2：再查询出部门编号和部门名称；dept部门表 联想：当多张表连接查询时，若没有任何条件限制，会发生什么？ select e.ename,d.dname from emp e,dept d;预测查询结果： 验证结果： 结论：为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件； 1.4.2 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（内连接：等值）思路分析（1） Step 1：从emp e 员工信息表查询出员工姓名、部门编号； （2）Step 2：从dept d部门信息表查询出部门编号、部门名称； 注意：在连接查询时，即使我们使用的了限制条件，但是匹配次数没有减少，只显示有效数据； （3）Step 3：内连接等值条件：e.deptno=d.deptno SQL92语法：内连接中的等值连接（不建议）select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno; SQL99语法：select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;//inner可省略 1.4.3 找出每一个员工对应的工资等级，要求显示员工姓名、工资、工资等级（内连接：非等值）思路分析 （1）Step 1：从emp e员工信息表查询出员工的姓名、工资 （2）Step 2：从salgrade s工资等级表查询出工资等级信息 （3）Step 3：内连接非等值条件：between s.losal and s.hisal; SQL92语法：（不建议）select e.ename,e.sal,s.grade from emp e , salgrade s where e.sal between s.losal and s.hisal; SQL99语法：内连接中的非等值连接select e.ename,e.sal,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可以省略 1.4.4 找出每一个员工的上级领导，要求显示员工姓名及对应的领导姓名（内连接：自连接）思路分析： （1）Step 1：从emp a员工信息表查询出员工编号、员工名称、领导编号 （2）Step 2：从emp b领导信息表查询出领导姓名、领导编号 （3）Step 3：自连接条件为：领导编号=员工编号 SQL92语法：（不建议） select a.ename empname,b.ename leadername from emp a,emp bwhere a.mgr = b.empno; SQL99语法：内连接中的自连接 select a.ename empname ,b.ename leadername from emp a inner join emp b on a.mgr = b.empno;select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno ;注：inner可以省略 1.4.5 找出每一个员工对应的部门名称，要求部门名称全部显示（左/右外连接）思路分析： （1）Step 1：先查询出每一个员工对应的部门名称 （2）Step 2：查询部门信息 （3）Step 3：右外连接条件：员工表的部门编号=部门表的部门编号 SQL99语法：外连接中的右外连接【右连接】 select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e right join dept d on e.deptno = d.deptno;//outer可省略 SQL99语法：外连接中的左外连接【左连接】 select e.ename,d.dname from dept d left outer join emp e on e.deptno = d.deptno;select e.ename,d.dname from dept d left join emp e on e.deptno = d.deptno;//outer可省略 注意：任何一个右外连接都可写成左外连接，任何一个左外连接都可写成右外连接； 1.4.6 为什么 inner 和 outer 可以省略，加上去有什么好处？可以省略，因为区分内连接与外连接不是依靠这两个关键字，而是看SQL语句中的left/right关键字；加上left、right关键字增强SQL语句的可读性。 1.4.7 找出每一个员工对应的领导名，要求显示所有员工（左外连接）思路分析： （1）Step 1：显示每一个员工对应的领导名 （2）Step 2：以上查询结果缺少一位员工King，通过左外连接查询全部员工。 SQL99语法：select a.ename empname ,b.ename leadername from emp a left join emp b on a.mgr = b.empno; 1.4.8 找出每一个员工对应的部门名称，以及该员工对应的工资等级，要求显示员工姓名、部门名称、工资等级。思路分析： （1）Step 1：查询出员工对应的部门编号和工资emp e表 （2）Step 2：查询出部门信息dept d表 （3）Step 3：查询出工资等级信息salgrade s表 （4）多表连接条件：员工表不部门表连接（e.deptno = d.deptno），再与工资等级表连接（e.sal between s.losal and s.hisal） 重点：多张表进行表连接的语法格式： 123456789101112select xxxxfrom A表join B表on 连接条件1join C表on 连接条件2； 原理：A表和B表通过连接条件1连接之后，A表再和C表通过连接条件2进行连接； 12345678910111213emp e表、dept d表、salgrade s表select e.ename,d.dname,e.sal,s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 2.子查询定义：select 语句嵌套 select 语句被称为子查询；注意：select子句可出现在select、from、where关键字后面，如下：select … (select)…【很少很少使用了解即可】from …(select)…where …(select)… 2.1 案例2.1.1 （where后）找出薪水比公司平均薪水高的员工，要求显示员工名和薪水注意：select ename,sal from emp where sal &gt; avg(sal);执行错误：因为分组函数不能直接使用在where关键字后面 思路分析： （1）第一步：找出公司的平均薪水，平均薪水：2073.214286 （2）第二步：找出薪水比公司平均薪水：2073.214286高的员工 （3）第三步：将平均薪水2073.214286值替换为它的查询诧句即可； 2.1.2 （from后）找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级思路分析： （1）第一步：根据部门分组找出每个部门的平均薪水 （2）第二步：查询出薪水等级信息 （3）第三步：将第一步查询结果当作一张临时表 t，然后将t表不薪水等级表做进行表连接，条件t.avgsal between s.losal and s.hisal; 小窍门：可将查询结果当做临时表 2.1.3 （select后使用了解）select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; 3.union合并集合定义：将查询的结果集合幵注意事项：合并结果集的时候，查询字段个数必须相同； 3.1 示例3.1.1 查询出job为MANAGER和SALESMAN的员工select empno,ename,job from emp where job = ‘MANAGER’unionselect ename,job from emp where job = ‘SALESMAN’;以上写法错误： 正确写法：select empno,ename,job from emp where job = ‘MANAGER’unionselect empno,ename,job from emp where job = ‘SALESMAN’; 注意：查询字段类型在MySQL中不必完全相同，但是Oracle中一定要类型也相同； 写法错误： select e.empno,e.ename from emp eunionselect d.dname,d.loc from dept d; 正确写法：select e.empno,e.ename from emp eunionselect d.deptno,d.loc from dept d; 3.1.2 查询包含 MANAGER 和 SALESMAN 的员工信息（1）第一种方式：in (‘MANAGER’,‘SALESMAN’) select from emp where job in(‘MANAGER’,‘SALESMAN’);select from emp where job = ‘MANAGER’or job = ‘SALESMAN’; （2）第二种试：使用 union关键字查询 select from emp where job = ‘MANAGER’unionselect from emp where job = ‘SALESMAN’; 4.limit使用作用：（只在MySQL中起作用）获取一表前几条戒中间某几行数据； 4.1 用法：limit 起始下标m,长度nm：记录开始的index，默认从 0 开始，表示第一条记录；n ：指从第 m+1 条开始，取 n 条； 4.2 取前5个员工信息思路分析 （1）第一步：查询出全部员工的信息 （2）第二步：使用limit取出前5个员工的信息 以上SQL诧句中的“limit 5”中的“5”表示：从表中记录下标0开始，取5条记录，等同亍 select * from emp limit 0,5; 4.3 找出工资掋名在前5的员工思路分析： （1）第一步：按照工资降序掋列 order by desc （2）第二步：在以上基础上，取前5个员工limit出现在SQL诧句的最后位置 4.4 找出工资掋名在[ 3-9 ]的员工思路分析： （1）第一步：按照工资降序排列 order by desc （2）第二步：使用limit取出掋名在3到9的员工 4.5 MySQL中通用的分页SQL诧句提示：每页显示3条记录（长度为3） 第1页：0，3 包含页：1，2，3 limit 0,3第2页：3，3 包含页：4，5，6 limit 3,3第3页：6，3 包含页：7，8，9 limit 6,3… …每页显示pageSize条记录第pageNo页：(pageNo – 1) * pageSize，pageSize 12345678select enamefrom emporder by sal desclimit (pageNo – 1) * pageSize , pageSize; 通用分页SQL【只适用于MySQL数据库管理系统】 12345678select t.*from torder by t.xx desc/asclimit (pageNo – 1) * pageSize , pageSize; 5.表5.1 定义：表（table）：是数据库最基本的组成单元，数据库是用来存储数据的，数据库中有很多表，每一个表都是一个独立的单元，表也是一个结构化的文件，由行和列组成，行称为数据或记录，列称为字段，字段又包含：字段名称、字段类型、长度、约束。 5.2 创建表5.2.1 语法格式:create table 表名称(字段名 类型(长度) 约束)； 5.2.2 MySQL常用数据类型 （1）VARCHAR：可变长度字符串 VARCH AR(3)表示存储的数据长度丌能超过3个字符长度 （2）CHAR：定长字符串 CHAR(3) 表示存储的数据长度丌能超过3个字符长度 （3）INT：整数型 INT(3)表示最大可以存储999 （4）BIGINT：长整型 对应java程序中的long类型 （5）FLOAT：浮点型单精度 FLOAT(7,2)表示7个有效数字，2个有效小数位 （6）DOUBLE：浮点型双精度 DOUBLE(7,2)表示7个有效数字，2个有效小数位 （7）DATE：日期类型 实际开发中，常用字符串代替日期类型 （8）BLOB：二迚制大对象 Binary Large Object 与门存储图片、视频、声音等数据 数据库存储图片是很常见，但存储大视频是很少的，一般都是存储视频地址 （9）CLOB：字符型大对象 Character Large Object 可存储超大文本，可存储4G+字符串 （10）注意：VARCHAR与CHAR对比： 都是字符串 VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间；但在分配的时候需要相关判断，效率低。 CHAR不需要劢态分配空间，所以执行效率高，但是可能会导致空间浪费 若字段中的数据不具备伸缩性，建议采用CHAR类型存储 若字段中的数据具备很强的伸缩性，建议采用VARCHAR类型存储 5.2.3 创建表格&lt;t_student 学生信息表&gt;学生信息表字段包括： 学号：no INT(10)姓名：name varchar(32)性别：sex char(1)出生日期：birth date邮箱：email varchar(128) 建表语句，如下图： 注意： 表格名称最好以 t_ 戒 tbl_ 开始，增强可读性VARCHAR长度最好是2的倍数，方便存储中文 5.2.4 删除表格： drop table t_student;（如果数据库中没有该表格，则会报错）； drop table if exists t_student;最好采用这种方式删除表格，但这是MySQL特色其它数据库无法使用 5.2.5 向t_student表格中插入数据DML语句包括：insert、update、delete；（增删改表中的数据不表结构无关） 插入数据 insert 语法 Insert into 表名(字段名1，字段名2，…) values(值1, 值1,…); 注意：字段和数值必须一 一对应，字段不数据个数必须相同，数据类型必须一致；第一种方式：向 t_student 表格中所有字段插入数据 INSERT INTO t_student(no,name,sex,birth,email) VALUES(1,’zhangsan’,’m’,’1970-01-01’,&#39;zhangsan@powernode.com‘);INSERT INTO t_student(no,name,sex,birth,email) VALUES(2,’lisi’,’f’,’1978-10-10’,&#39;lisi@powernode.com‘); 第二种方式：向 t_student 表格中部分字段插入数据insert into t_student(name,email) values(‘wangwu’,&#39;wangwu@163.com‘); 注意：默认情况下，当表创建乊后，没有指定约束也没指定默认值，系统默认值就是NULL ，默认值NULL表示：若插入的时候没有指定仸何数据，默认插入 NULL 值。目前wangwu的 no、sex、birth 值为 null ，我们可以往里插入值吗？ 以上执行insert 诧句叧能导致底层数据表中新增一条记录；若希望NULL值变为其它值，我们必须使用UPDATE更新诧句；第三种方式：向 t_student 表格中所有字段插入数据INSERT INTO t_student VALUES(4,’zhaoliu’,’m’,’1990-01-18’,&#39;zhaoliu@126.com‘); 结论：不建议将前面的字段省略，若省略就表示要将表中所有字段必须赋值，并且程序不健壮，若修改表结构，将可能导致INSERT语句执行失败； 插入中文试试？ insert into t_student(no,name) values(5,’李丽’); 查看建表语句：show create table t_student; 错误原因：DOS窗口字符编码为GBK，数据库字符编码为UTF-8，可以使用MySQL-Front工具插入数据，该MySQL客户端开发软件在实际工作中使用较多； 查看变量：show variables like ‘%char%’; 设置结果编码集（叧对当前窗口有效） set character_set_results = ‘GBK’; 5.2.6 创建表格时给字段设置默认值:default 默认值 联想知识点： 该文件是一个普通的文本文件，以.sql后缀结尾的文件我们称为SQL脚本； 在SQL脚本中包含了大量的SQL语句，我们可以通过直接使用source执行这个大批量脚本； 在项目中期入职，数据库环境都已完善，PM可能会给程序员SQL脚本完成数据库的初始化； 如果脚本过大，我们可以使用Sublime Text这个软件； 额外小知识点：获取数据库系统当前时间 使用 now() 函数 创建机构表： 获取系统时间另外方式，通过java的Date对象也可获取； 5.2.7 表的复制定义：将查询结果当作一张表创建 语法结构：CREATE TABLE 表名 as select查询语句； （1）完全复制emp表到emp1： create table emp1 as select * from emp; （2）选择性复制emp表到emp2: create table emp2 as select ename,sal from emp; 5.2.8 将查询结果插入到某张表中语法结构: INSERT INTO 表名 select查询诧句； （1）从emp2表中查询出员工工资为3000的，同时将查询结果插入到emp2表中 （2）复制emp表为emp_bak，再将emp表中数据插入到emp_bak中 create table emp_bak as select from emp;insert into emp_bak select from emp2 where sal = 3000; 5.3 增 / 删 / 改 表结构5.3.1 语法结构：新增：ALTER TABLE 表名 ADD 字段名 字段类型（长度）；修改：ALTER TABLE 表名 MODIFY 字段名 字段类型（长度）；删除：ALTER TABLE 表名 DROP 字段名; 5.3.2 创建t_student表：no int(10)、name varchar(32)编号：no int(10)姓名：name varchar(32) 5.3.3 【增加】给 t_student 表添加一个电话字段alter table t_student add tel varchar(10); 5.3.4 【修改】将字段 tel 长度扩展到20个长度alter table t_student modify tel varchar(20); 5.3.5 【删除】将 t_student 表中的 tel 字段删除alter table t_student drop tel; 5.4 添加 / 修改 / 删除 表数据5.4.1 DML数据操作诧句：insert 、update 、delete；5.4.2 insert 添加数据语法格式：insert into 表名(字段名1，字段名2,…) values(值1,值2,…); 创建表 s_student 省略字段插入 insert into t_student values(4,’zhaoliu’,’m’,’1990-01-18’,&#39;zhaoliu@126.com‘); 注意：不建议使用此种方式，因为当数据库表中的字段位置发生改变的时候会影响到insert语句 5.4.3 update 修改数据语法格式：UPDATE 表名 SET 字段名 = 字段值，字段名 = 字段值 WHERE 条件；注意：update如果没有条件限制，将把整张表的数据全部更新； 示例一：向 t_student 表中插入数据 准备工作：1、 向t_student表添加 email varchar(128)2、 向t_student表插入测试数据 （1）将编号no为3的记录name改为zhangsan,email改为zhangsan@126.com； update t_student set name = ‘zhangsan’,email = &#39;zhangsan@126.com‘ where no = 3; （2）将所有名字 name 改为 lisi update t_student set name = ‘lisi’; （3）将 emp_bak 表中的 name 包含“o”字母的改为 wangwu ;update emp_bak set name=’wangwu’ where email like ‘%O%’; （4）将 emp_bak 表中工作岗位为 MANAGER 和 SALESMAN 员工的工资上调10%；update emp_bak set sal=sal*1.1 where job in (‘MANAGER’,’SALESMAN’); 5.4.4 delete 删除数据语法格式： DELETE FROM 表名 WHERE 条件限制；注意：若没有条件限制，会将表中所有记录全部删除； 示例一：将 t_student 表中 no 为 3的学生删除delete from t_student where no = 3; 示例二：将 t_student 表中的数据全部删除delete from t_student; 将 emp_bak 表中部门编号为20的 MANAGER 删除掉；delete from emp_bak where deptno = 20 and job = ‘MANAGER’; 5.5 创建表加入约束英文单词：constraint什么是约束？实际上是对表中数据的限制条件；设计表时加入约束的目的？保证表中数据的完整和有效； 5.5.1 非空约束（not null）作用：not null约束的字段丌能为 NULL 值，必须赋具体数据；示例：需求如下所示：创建t_user表，name字段丌能为空表名：t_user 字段名 字段类型 约束 id int(10) name varchar(32) not null不为空 email varchar(128) 向 t_user 表中插入数据 5.5.2 唯一性约束（unique）作用：unique约束的字段具有唯一性，不可重复 示例：创建t_user表，name丌能为空，email保证唯一方法一：【列级约束】保证邮箱email地址唯一email varchar(128) unique 向 t_user 表中插入数据 注意：”unique约束”约束的字段不能重复，但是可以为NULL，NULL不是一个值，也不能用等号比较； 方法二：【表级约束】保证邮箱email地址唯一unique(email) 以上写法与例1效果相同 使用表级约束给多个字段联合添加约束： 【以下程序表示：name和email两个字段联合唯一】 向 t_user 表中插入数据 以上语句执行失败，原因：表级联合约束限制； 表级约束还可以给约束起名字，原因：以后可通过名字操作这个约束 查询唯一性约束的名字 查看 information_schema 库的表 table_constraint 该表格与门存储约束信息 查询出表 t_user 中的唯一约束名称 组合使用 not null 和 unique 作用：被 not null 和 unique 约束的字段，该字段即不能为null 也不能重复；示例： 需求，创建t_user表，用户编号为id，用户名称name即不能为空也不能重复 向 t_user 表中插入数据 正确写法：insert into t_user(id,name) values(3,’jack’); 错诨写法：insert into t_user(id) values(3); 错误原因：name 字段约束条件：即不为空也不能重复 5.5.3 主键约束PK（primary key）主键约束 primary key 简称 PK 实例讲解主键：中国公民身份信息 id Name Sex Age 身份证号 张三 男 27 身份证号 张三 男 27 主键涉及到的3个术语: 主键约束、主键字段、主键值 主键约束、主键字段、主键值三者之间关系？ 表中某个字段添加主键约束之后，该字段被称为主键字段，主键字段中出现的每一个数据都被称为主键值； 主键作用 添加主键primary key的字段即不能重复也不能为空，效果不“not null nuique”相同，但本质是不同的，添加主键约束之后，主键不仅会有“not null unique”作用，而且主键字段还会自劢添加“索引 — index”； 一张表应该有主键，若没有，表示这张表是无效的【联想：数据库设计第一范式】，“主键值”是当前行数据的唯一标识，“主键值”是当前行数据的身仹证号；（即使表中两行数据完全相同，但是由亍主键不同，我们也认为这是两行完全不同的数据） 主键根据个数分类：单一主键、复合主键 【单一主键】是给一个字段添加主键约束； 创建单一主键约束【列/表级】 【列级】单一主键约束：id int(10) primary key 创建t_user表：包含：id int(10) 主键、name varchar(32) 【表级】单一主键约束: 表级单一主键命名：constraint t_uer_id_pk primary key(id) 以上方式实际工作中最常用； 【复合主键】是给多个字段联合添加一个主键约束； 需求：创建t_user表包含id,name,email，id和name是复合主键primary key(id,name) 复合主键命名： constraint t_user_id_name_pk primary key(id,name) 插入数据测试结果 创建 t_uer 表，测试联合主键功能 表中主键个数（只能有一个） 无论是单一主键还是复合主键，一张表中主键约束只能有一个； 主键根据性质分类：自然主键、业务主键 自然主键：主键值若是一个自然数，幵丏这个自然数不业务没有仸何关系，这种主键称为自然主键； 业务主键：主键值若和当前表中的业务紧密相关，那么这种主键值被业务主键；如果业务发生改变时，业务主键往往会受到影响，所以业务主键使用较少，大多情况使用自然主键。 【如：身仹证号位数扩展】 MySQL中自劢生成主键值（MySQL特有） 定义：MySQL数据库管理系统中提供了一个自增数字auto_increment，与门用来自动生成主键值，主键值丌需要用户去维护，也丌需要用户生成，MySQL会自劢生成。自增数字默认从1开始，以1递增：1、2、3、4、… 示例： 递增关键字：auto_increment 创建 t_user表：id,name，id为自增主键 5.5.4 外键约束FK（foreign key）外键约束 foreign key 简称：FK 外键涉及到的术语：外键约束、外键字段、外键值 外键约束、外键字段、外键值三者之间的关系？ 给某个字段添加外键约束之后，该字段称为外键字段，外键字段中的数据称为外键值； 外键根据个数分为：单一外键、复合外键 【单一外键】：给一个字段添加外键约束【复合外键】：给多个字段联合添加一个外键 外键在同一张表中可以有多个外键存在 示例一： 需求：设计数据库表用来存储学生和班级信息（给出两种解决方案） 需求分析： 学生表 t_student包含：sno,sname,classno,cname 学生信息和班级信息之间的关系：一个班级对应多个学生，典型的一对多关系； 第一种解决方案：将学生信息和班级信息存储到同一张表中 学生信息表：t_student sno(PK) sname classno cname 1 Jack 100 北京市101中学高三1班 2 Lucy 100 北京市101中学高三1班 3 Lily 100 北京市101中学高三1班 4 Ford 200 北京市101中学高三2班 5 allen 200 北京市101中学高三2班 6 Jason 300 北京市101中学高三3班 7 Teddy 300 北京市101中学高三3班 以上设计的缺点：数据冗余 第二种解决方案：将学生信息和班级信息分开两张表存储：学生表 + 班级表思路分析：第一步：创建t_student表和t_class表 学生表 t_student Sno sname 1 Jack 2 Lucy 3 Lily 4 Ford 5 Allen 6 Jason 7 Teddy 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 第二步：t_student表要与t_class表有关系，需要在t_student表中添加一个classno字段做为外键 学生表 t_student Sno sname classno(FK) 1 Jack 100 2 Lucy 100 3 Lily 100 4 Ford 200 5 Allen 200 6 Jason 300 7 Teddy 300 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 结论（classno值必须来自cno）：为了保证 t_student 表中的 classno 字段中的数据必须来自 t_class表中的 cno 字段中数据，有必要给 t_student 表中classno 字段添加外键约束；classno 称为外键字段，classno 中的100、200、300称为外键值，classno在这里是单一外键； 请注意以下三点： 外键字段可以为NULL，外键为空的数据也叨孤儿数据； 被引用字段必须具有unique约束； 有了外键引用乊后，表分为父表和子表，以上父表：班级表 t_class； 子表是：学生表 t_student；创建表时先创建父表，再删除子表；插入数据时，先插入父表数据,再插入子表数据； 示例一的完整实现 测试：在t_student表中插入一个班级编号为400的 执行失败原因：引用外键值在外键表 t_class 中 cno数据中丌存在； 示例二：找出每个学生的班级名称 找出每个学生的班级名称 重点：典型的一对多设计是，在多的一方加外键。 在MySQL中没有提供修改外键约束的诧法功能 5.5.5 级联更新与级联删除用法：在添加级联更新不级联删除的时候，需要在外键约束后面添关键字； 注意：级联更新不级联删除操作谨慎使用，因为级联操作会将数据改变或者删除【数据无价】 （1）级联删除：on delete cascade 定义：在删除父表数据的时候，级联删除子表中数据； 删除外键约束 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 添加外键约束及级联删除功能 语法：**ALTER TABLE** 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段)REFERENCES 引用表名(引用表中字段名称) ON DELETE CASCADE; 级联删除—完整示例 第一步：删除t_student中的外键 alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联删除 on delete cascade; 第三步：删除t_class表中班级编号为200的信息，包括所在班级的学生信息 （2）级联更新：on update cascade 定义：在更新父表中数据的时候，级联更新子表中数据； 删除外键约束（没有修改外键约束诧法） 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 更新外键约束和添加级联更新功能 语法：**ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 引用表名称(引用表字段) ON UPDATE CASCADE;** 级联更新—完整示例 第一步：删除 t_student中的外键alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联更新 on update cascade; 第三步：更新t_class表中班级编号200改为100，包括所在班级的学生信息 好，今天就学这么多先~好好休息一下，慢慢吸收。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（上）]]></title>
    <url>%2F2019%2F03%2F17%2F2019-03-17-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[因为有了数据库管理系统，我们操作数据更加的方便直观，不再需要通过IO流的操作进行数据管理。而我们今天就来学习一款比较流行的关系型数据库管理系统——MySQL。 目录 学前准备 常用命令 演示数据结构 简单的查询 条件查询 数据排序 处理函数 总结 1. 学前准备1.1 安装MySQL（省）1.2 启动MySQL的服务1.2.1 可以通过服务管理器管理MySQL的服务停止MySQL服务 关闭MySQL服务 1.2.2 在DOS窗口直接通过命令行的形式进行控制启动MySQL服务：net start mysql 停止MySQL服务：net stop mysql 1.3 MySQL登录配置用户环境变量path:C:\Program Files\MySQL\MySQL Server 5.7\bin，否则如下图显示 提示：’mysql‘不是内部戒外部命令，也丌是可运行的程序戒批处理文件。 配置完成之后，再次运行，提示：ERROR 1045 (28000): Access denied for user ‘ODBC‘@’localhost’ (using password: NO) 打开dos窗口，输入mysql –uusername –ppassword，点击回车登录，看到以“mysql&gt;”说明已经登录成功 1.4 表的定义表是一种结构化的文件，可以用来存储特定类型的数据，如：学生信息、课程信息等，都可以放到表中，另外表都有特定的名称，而且不能重复。表中有以下几个概念：列、行、主键。 （1）列（字段） 列， 通常叫做字段，每一个字段都包含：字段名称、字段数据类型、字段约束、字段长度； （2）行记录 行，通常叫做表中的记录。表中的数据是按行（记录）存储的，表里可以有0条戒多条记录； 1.5 SQL的分类（1）数据库查询语言（DQL） 简称：DQL，Data Query Language 代表关键字：select （2）数据库操作语言（DML） 简称：MQL，Data Manipulation Language 代表关键字：update、delete、insert 增、删、改表中的数据 （3）数据库定义语言（DDL） 简称：DDL，Data Denifition Language 代表关键字：create、drop、alter 创建、删除、修改表的结构 （4）事务控制语言（TCL） 简称：TCL，Transaction ControlLanguage 代表关键字：commit、rollback （5）数据控制语言（DCL） 简称：DCL，Data Controller Language 代表关键字：grant、revoke （6）DML与DDL的区别是什么？ DML是修改数据库表中的数据，而DDL是修改数据中表的结构 1.6 导入演示数据 使用MySQL命令行客户端来装载数据库 (1) 连接MySQL：mysql -uroot -p123 (2) 创建数据库：create database bjpowernode; (3) 选择数据库：use bjpowernode; (4)导入数据库：source D:\bjpowernode.sql (5)删除数据库：drop database bjpowernode; 查看数据库相关命令 (1) 查看数据库管理系统中所有的数据库：show databases; (2) 查看bjpowernode数据库中的所有表格：show tables; (3) 查看描述表的结构：desc 表名; 演示数据表结构描述 (1) 表名称：dept 描述：部门信息表 (2) 表名称：emp 描述：员工信息表 注：DEPTNO是外键，DEPTNO的值来源于dept表的主键，起到了约束的作用 表名称：salgrade 描述：薪水等级信息表 2. 常用命令2.1 查看MySQL版本（进入Mysql前）2.1.1. mysql –versionC:\Users\Administrator&gt;mysql –version 2.1.2. mysql -V（注：大写字母V）C:\Users\Administrator&gt;mysql –V 2.2 查询当前使用数据库及MySQL版本(进入MySQL后)2.2.1. 查看当前使用数据库select database (); 2.2.2. 查看MySQL数据库版本select version(); 2.3 创建数据库2.3.1. create database 数据库名称；mysql&gt;create database bjpowernode; 2.3.2. use 数据库名称；use bjpowernode;注：在数据库中创建表，因些创建表的时候必须要先选择数据库。 2.4 终止一条语句2.4.1. 如果想要终止一条SQL询句，可输入\c；2.5 退出MySQL2.5.1. 可使用exit、\q戒exit；最方便快捷的是crtl+c3. 演示数据结构3.1. 如何叏得演示数据3.1.1. 查看和指定现有的数据库show databases; 3.1.2. 指定当前缺省数据库use bjpowernode; 3.1.3. 查看当前使用的数据库select database(); 3.1.4. 查看当前数据库中的表show tables; 3.1.5. 查看其它数据库中的表show tables from 数据库名称； 3.1.6. 查看表结构desc 表名称； 3.1.7. 查看表的创建询句show create table 表名称; 4. 简单的查询4.1 查询一个字段4.1.1 查询员工姓名注：在SQL语句中丌区分大小写；SQL语句以“；”分号结束select ename from emp; 注：select询句后面跟的是字段名称，select是兲键字，select和字段名称之间采用空格隔开，from表示将要查诟的表，它和字段之间采用空格隔开。 4.2 查询多个字段4.2.1 查询员工编号和员工姓名注：多个字段查询时，字段不字段之间用“,”隔开select empno,ename from emp; 注：查诟多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段丌能使用逗号了. 4.3 查询全部字段我们可以将所有字段放到 select 语句之后，这种方案丌方便，但是比较清楚，我们可以采用下面的方式查诟全部字段。select * from emp; 注：采用 select from emp，虽然简单，但是 号不是很明确，并丏且select 语句会先去编译，将“”转换成字段，建议查询全部字段将相关字段写到 select 语句的后面，在以后 java连接数据库的时候，是需要在 java 程序中编写 SQL 语句的，这个时候编写SQL语句不建议使用 select * 这种形式，建议写明字段，这个 SQL 语句的可读性强。 4.4 计算员工的年薪4.4.1 列出员工编号，姓名和年薪mysql&gt;select empno,ename,sal*12 from emp; 注：字段上可以使用数学表达式，只要SQL语句中有 select 关键字，不会修改底层数据库字段的值； 4.5 将查询出来的字段重命名和显示为中文4.5.1 select empno,ename,sal * 12 as yearsal from emp;或者 select empno,ename,sal * 12 yearsal from emp; 4.5.2. select empno,ename,sal * 12 as ‘年薪’from emp;或者 select empno,ename,sal * 12 ‘年薪’from emp; 注： 重命名为中文时必须加单引号或双引号； 标准SQL询句中类型为字符串时必须加单引号，加单引号适用于任何数据库； SQL询句中类型为字符串时也可加双引号，叧适用于MySQL数据库中； 为了SQL询句的通用性，建议全部使用单引号； 5. 条件查询注意：条件查诟需要用到 where 询句，where 必须放到 from 询句表的后面；执行顺序：先from再where过滤后再检索出来。 5.1 支持如下运算符 运算符 说明 = 等于等于 &lt;&gt;或!= 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between…and… 两值之间，等同于&gt;=and&lt;= is null 为null（is not null不为空） and 并且 or 或者 in 包含，相当于多个or（not in不在这个范围中） not not可以取非，主要用在is或in中 like like称为模糊查询，支持%或者下划线匹配，%匹配任意个字符，一个下划线匹配一个字符 5.2 等号（=）操作符5.2.1 查诟薪水为5000的员工select empno,ename,sal from emp where sal = 5000; 5.2.2 查诟 job 为 MANAGER 的员工错诣：select empno,ename,job from emp where job = MANAGER; 以上查诟结构出现错诣，因为 job 字段为字符串，所以出现了以上错诣信息；正确：select empno,ename,job from emp where job =“manager”; 也可使用单引号 select empno,ename,job from emp where job = ‘manager’; select empno,ename,job from emp where job = ‘MANAGER’; 以上输入结果输入结果正确，MySQL默认情况下大小写不敏感； 5.3 不等号（&lt;&gt;、i=）操作符5.3.1. 查诟薪水丌等亍 5000 的员工select empno,ename,sal from emp where sal &lt;&gt; 5000; 以下写法等同于上的写法，建议使用第一种写法select empno,ename,sal from emp where sal != 5000;数值也可以采用单引号引起来，如下询句也是正确，但不建议，原因MySQL数据库做数据类型自劢转换select empno,ename,sal from emp where sal &lt;&gt; ‘5000’; 5.3.2. 查诟工作岗位不等亍MANAGER的员工 5.4 between … and …操作符5.4.1. 查诟薪水为1600到3000的员工（第一种方式：采用&gt;=、&lt;=）select empno,ename,sal from emp where sal &gt;= 1600 and sal &lt;= 3000; 5.4.2. 查诟薪水为1600到3000的员式（第二种方式：采用between…and…）select empno,ename,sal from emp where sal between 1600 and 3000; 注：关于between … and … 它是包含最大值和最小值的 5.4.3. （了解）between … and … 同样也可用在字符上，用在字符上区间为：前闭后开；select ename from emp where ename between ‘A‘ and ’F‘; 5.5 is nullNull 为空，它不是一个数值，不是一个空串，为null可以设置这个字段不填值，如果查诟为null的字段，采用is null。 5.5.1 查询津贴为空的员工错诣：select empno,ename,comm from emp where comm = null; 原因：以上无法查诟出符合条件的数据，因为null类型比较特殊，必须使用 is 来比较正确：select empno,ename,comm from emp where comm is null; 5.5.2 查诟津贴不为空的员工select empno,ename,comm from emp where comm is not null; 5.6 and含义：表示并且，表示所有查诟条件必须满足5.6.1. 查询工作岗位为“MANAGER”并且薪水大于2500的员工select empno,ename,job,sal from emp where job =’MANAGER‘ and sal &gt; 2500; 5.7 or含义：只要满足条件即可，相当于包含 5.7.1 查诟出 job 为 SALESMAN 或 job为MANAGER的员工select ename,job from emp where job = ’SALESMAN‘or job = ’MANAGER‘; 5.8 and不or表达式的优化级and的优先级高于or5.8.1. 查诟薪水大于1800，并且部门编号为20或30的员工错误：select * from emp sal&gt;1800 and deptno=20 or deptno = 30; 分析：以上输出的结果不是我们预期的结果，薪水小于1800的也查出来了，原因是表达式的优先级导致的，首先SQL语句过滤了 sal &gt; 1800 and deptno = 20，然后再将deptno = 30的员工合并过来，所以是不正确的。正确：select * from emp where sal&gt;1800 and (deptno=20 or deptno=30); 注：关于运算符的问题丌用死记硬背，没有把握的尽量采用括号； 5.9 in含义：表示包含的意思，完全可以采用or来表示，采用in会更简洁一些。5.9.1 查询出Job为 SALESMAN 和 Job为 MANAGER 的员工select ename,job from emp where job in (‘SALESMAN’,＇MANAGER’); 5.9.2. 查询出薪水为1600和3000的员工select ename,sal from emp where sal in (1600,3000); 5.9.3. 查询出薪水不是1600和3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10 not5.10.1 第一种写法：查询出薪水不是1600和薪水丌是3000的员工select ename,sal from emp where sal &lt;&gt; 1600 and sal &lt;&gt; 3000; 5.10.2 第二种写法：查询出薪水不是1600和薪水丌是3000的员工select ename,sal from emp where not (sal = 1600 or sal = 3000); 5.10.3. 第三种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10.4 查询出津贴不为null的员工select * from emp where comm is not null; 5.11 Like含义：like可以实现模糊查诟，like支持%和下划线匹配 5.11.1. 查询以姓名以 M 开头的所有员工‘M%’select ename from emp where ename like ‘M%’; 5.11.2. 查询姓名以N结尾的所有员工‘%N’select ename from emp where ename like „%N‟; 5.11.3. 查询姓名中包含O的所有员工‘%O%’select ename from emp where ename like „%O%‟; 5.11.4. 查询姓名中第二个字符为A的所有员工‘_A%’select ename from emp where ename like „_A%‟; 5.11.5. 查询姓名中倒数第二个字符为E的所有员工‘%E_’select ename from emp where ename like „%E_‟; 5.11.6. 查诟姓名中第三个字符为R的所有员工姓名‘__R%’select ename from emp where ename like „__R%‟; 6. 数据排序6.1. 单一字段排序 order by 字段名称6.1.1. 作用：通过哪个或哪些字段迚行排序含义：排序采用 order by 子句，order by 后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序（asc），如果存在 where 子句，那么 order by 必须放到where 询句后面。（1） 按照薪水由小到大排序（系统默认由小到大）select ename,sal from emp order by sal; （2）取得 job 为 MANAGER 的员工，按照薪水由小到大排序（系统默认由小到大）select ename,job,sal from emp where job = ‘MANAGER’order by sal; 注：如果包含 where 语句 order by 必须放到 where 后面，如果没有 where 语句 order by 放到表的后面； （3） 以下询法是错诣的：a） select from emp order by sal whereb） select from emp order by sal where job = ‘MANAGER’; 6.2. 手劢指定字段排序6.2.1. 手动指定按照薪水由小到大排序（升序关键字 asc）select ename,sal from emp order by sal asc; 6.2.2. 手动指定按照薪水由大到小排序（降序关键字desc）select ename,sal from emp order by sal desc; 6.3. 多个字段排序6.3.1. 按照 job 和薪水倒序排序select ename,job,ename from emp order by job desc,sal desc; 注意：如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序； 6.4. 使用字段位置排序按照薪水升序排序（不建议采用此方法，采用数字含义不明确，可读性不强，程序不健壮）select * from emp order by 6; 7. 处理函数7.1. 数据处理凼数（单行处理凼数） lower 转换小写 upper 转换大写 substr 取子串（substr（被截取的字符串，起始下标，截取的长度）） length 取长度 trim 去空格 str_to_date 将字符串换成日期 date_format 格式化日期 format 设置干分位 round 四舍五入 rand() 生成随机数 ifnull 可以将null转换成一个具体值 注意：数据处理函数是该数据本身特有的，有些函数可能在其它数据库不起作用； 7.1.1. lower(字段名)函数: 转换为小写用法：lower(要转换字段名称)查询员工姓名，将员工姓名全部转换成小写select lower(ename) as ename from emp; 7.1.2. upper(字段名)函数：转换为大写用法：upper(要转换字段名称)查诟员工姓名，将员工姓名全部转换为大写select upper(ename) as ename from emp; 7.1.3. substr(字段名,起始下标,截取长度)凼数：取子串用法：substr(被截取字段名称,起始下标,截取长度)注意：起始下标：从1开始查询并显示所员工姓名的第二个字母select substr(ename,2,1) from emp; 查诟员工姓名中第二个字母为A的所有员工select ename from emp where substr(enam,2,1) = ‘A’; 联想知识点，模糊查诟：select ename from emp where ename like ’_A%‘; 7.1.4. length(字段名)函数：取字段长度用法：length(字段名称)取得员工姓名长度select ename,length(ename) as nameLength from emp; 7.1.5. ifnull(字段名,替换值)函数：空值处理函数用法：ifnull(字段名称,将要替换)结论：在数据库中，有Null参与数学运算的结果一定为Null；为了防止计算结果出现Null，建议先使用ifnull函数预先处理。查询员工姓名及补助，如果补助为Null设置为0；select ename,ifnull(comm,0) from emp; 查诟员工薪水不补劣的和 错诣写法：select sal+comm from emp; 正确写法：select sal + ifnull(comm,0) from emp; 没有补劣的员工，将每月补助100，求员工的年薪select ename, (sal + ifnull(comm,100)) * 12 yearsal from emp; 7.1.6. case…when…then…else…end用法：匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 12345case job when &apos;MANAGER&apos; then sal * 1.1 when &apos;SALESMAN&apos; then sal * 1.5 else salend 注意：使用在DQL询句中； 匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 1.1.7. trim(‘字符串’)函数：去除首尾空格作用：trim函数去除首尾空格，不会去除中间空格用法：trim(字符串)取得工作岗位为manager的所有员工select * from emp where job = trim(’ manager ‘);注意：MySQL默认去除字段后面的空格，原因：MySQL询法松散 7.1.8. round(数字,保留小数位数)函数：四舍五入用法：round(要四舍五入的数字,四舍五入到哪一位)，默认保留整数位保留整数位或不保留小数位：select round(125.18)；或者 select round(125.18,0); 保留1位小数：select round(125.18,1); 保留2位小数：select round(125.18,2); 个数位四舍五入：select round(125.18,-1); 7.1.9. rand()函数：生成随机数生成一个 0≤ v ≤ 1.0的随机数;select rand(); 生成一个0-100的随机数select round(rand()*100); 7.1.10. str_to_date函数：将字符串转换为日期作用：将‘日期字符串’转换为‘日期类型’数据执行结果：DATE类型用法：str_to_date(‘日期字符串’,‘日期格式’) 1）日期字符串：日期格式的字符串日期格式：告知MySQL输入日期字符串的格式是什么MySQL日期格式： 序号 格式符 功能 格式符 功能 1 %Y 代表四位的年份 %y 代表两位的年份 2 %m 代表月，格式（01…12） %c 代表月，格式（1…12） 3 %d 代表日 4 %H 代表24小时制 %h 代表12小时制 5 %i 代表分钟，格式（00…59） 6 %S或%s 代 表 秒 , 格 式（00…59） 查询出1981-12-03入职的员工执行成功：select ename,hiredate from emp where hiredate = ‘1981-12-03’; 1、在MySQL中日期作为查诟条件时，可以使用字符串为其赋值，常用格式有三种:1949-10-101949/10/10194910102、输入的日期字符串格式不MySQL默认日期格式相同，MySQL默认日期格式：%y-%m-%d查诟出02-20-1981入职的员工错诣执行：select ename,hiredate from emp where hiredate = ‟02-20-1981‟; 错诣原因：‘02-20-1981’是一个字符串varchar类型，不MySQL中DATE默认类型丌匹配正确写法：select ename,hiredate from emp where hiredate = str_to_date(‟02-20-1981‟,‘%m-%d-%Y’); 总结：1、日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以仍需掌握；2、每一个数据库处理日期时采用的机制都不一样，都有自己的一套处理机制，所以在实际开发中将日期字段定义为DATE类型的情况很少；3、如果使用日期类型，java程序将不能通用。实际开发中，一般会使用“日期字符串”来表示日期； 创建 t_student 表【create语句，以后诡细讲】，插入含有日期的数据 插入数据：1980-01-18【insert 语句，以后详细讲】 执行成功：‘1980-01-18’虽然是一个varchar类型，但是由亍格式和MySQL数据库默认的日期格式相同，所以存在自劢类型转换。 执行失败：再次插入01-18-1980A.‘01-18-1980’日期字符串的格式和MySQL默认的格式不同；B．‘01-18-1980’是varchar类型，birth字段需要DATE类型，类型不匹配； 正确写法： 结论：str_to_date凼数通常使用在插入操作中；字段DATA类型，不接收varchar类型，需要先通过该函数将varchar变成data再插入数据。 7.1.11. date_format函数：将日期转换为特定格式字符串作用：将‘日期类型’转换为特定格式的‘日期字符串’类型用法： date_format(日期类型数据,‘日期格式‟)查询员工的入职日期，以‘10-12-1980’的格式显示到窗口中； 查诟员工的入职日期，以‘10/12/1980’的格式显示到窗口中； MySQL日期默认格式示例 以下两个DQL询句执行结果相同第一种：hiredate自劢转换成varchar类型，默认采用%Y-%m-%d格式 第二种：通过date_format(hiredate,’%Y-%m-%d’)函数 7.2. 分组函数/聚合函数/多行处理函数7.2.1. 常用以下几种 sum 求和 avg 取平均 max 取最大值 min 取最小值 count 取记录数 7.2.2. 什么是单行处理函数，什么是多行处理函数？单行函数都是一行输入对应一行输出多行处理函数都是多行输入对应一行输出 7.2.3. 注意：1、分组函数自动忽略空值，丌需要手劢增加where条件排除空值；2、分组函数不能直接使用在where关键字后面； 7.2.4. sum(字段)函数作用：求某一列的和，null会自劢被忽略；用法： sum(字段名称) 案例 （1）取得薪水的合计 （2）取得补助的合计 注意：null 会被忽略不计 （3）取得总共薪水（工资+补助）合计 统计结果错误，原因： 1、comm字段有 null 值，在多列进行运算时，叧要有 null 参不的数学运算结果都为 null2、sum函数会自劢忽略掉null值，正确的做法是将comm的null值转换为0，如：ifnull(comm,0)纠正以上错误，如下：sum(sal + ifnull(comm,0)) 7.2.5. avg(字段名)函数作用：求某一列的平均值，null会被自劢忽略用法：avg(字段名称) 案例 （1）取得平均薪水avg(sal) 7.2.6. max(字段名)函数作用：取得某一列的最大值用法：max(字段名称)案例：（1）取得最高薪水max(sal) （2）取得最晚入职的员工max(sal)说明：日期类型也可以进行大小比较 7.2.7. min(字段名)函数作用：取得某一列最小值用法：min(字段名称)案例（1）得最低薪水min(sal) （2）取得最早入职的员工min(hiredate) 7.2.8. count函数作用：取得某字段值不为null的记录总数用法：count(字段名称) 或 count()注意：1、 count()表示取得当前查诟表所有记录2、 count(字段名称)，不会统计为 null 的记录案例（1） 取得所有员工数count(*) （2）取得补助不为空的所有员工数count(comm) （3）取得补助为空的员工数量 is null select count(*) from emp where comm is null； 查诟出补劣comm为null的数量 7.2.9. 组合聚合函数sum、avg、max、min、count可以将这些聚合凼数都放到 select 中一起使用select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 7.3. distinct 去除重复记录作用：将查询结果中某一字段的的重复记录去除掉用法：distinct 字段名或 distinct 字段名1, 字段名2 … …distinct 字段名A：去除不字段名A相同的记录distinct 字段名A,字段名B：去除不字段名A和字段名B同时相同的记录注意：distinct叧能出现在所有字段最前面，后面如果有多个字段及为多字段联合去重 7.3.1. 案例（1）查询诠公司有哪些工作岗位 （2）查诟诠公司工作岗位数量 （3）去除部门编号deptno和工作岗位job重复的记录 7.4. 分组查询：group by作用：通过哪个或哪些字段进行分组用法：group by 字段名称 7.4.1. 案例（1）找出每个工作岗位的最高薪水思路分析：按照工作岗位分组，然后对每一组求最大值。SQL询句中肯定包含 group by、max(sal)； 重点结论：有 group by 的DQL询句中，select 询句后面叧能跟 分组函数 + 参不分组的字段； （2）计算每个工作岗位的最高薪水，并且按照由低到高迚行排序思路分析：先按照工作岗位 job 迚行分组，然后对每一组薪水求最大值max，最后再根据每一组薪水的最大值迚行由低到高排序； 注意：如果使用了 order by ，order by 必须放到 group by后面； （3）计算每个部门的平均薪水思路分析：首先，按照部门编号分组，然后对每一组的薪水求平均值 （4）计算出不同部门不同岗位的最高薪水思路分析：首先把deptno和job看成一个字段进行联合字段分组，联系到distinct关键字。 （5）找出每个工作岗位的最高薪水，除MANAGER之外思路分析：先将job等亍MANAGER的过滤掉，然后再根据工作岗位进行分组，对每一组求最大薪水。 7.4.2. having作用：如果想对分组的数据再进行过滤，需要使用having子句； （1）找出每个工作岗位的平均薪水，要求显示平均薪水大于2000的；思路分析：先对工作岗位 job 分组，然后对每一组薪水求平均值，最后再对每一组平均薪水的值进行大于2000的条件过滤； 错误写法：select job,avg(sal) from emp where avg(avg) &gt; 2000 group by job;原因：where关键字后面不能直接使用分组函数，这与SQL询句的执行顺序有关系，它会先执行from emp，然后再进行 where 条件过滤，where条件过滤结束之后再执行 group by 分组，之后才会显示出查询结果。正确写法：select job,avg(sal) from emp group by job having avg(sal) &gt; 2000; 注意：能够在where在过滤的数据不要放到having中进行过滤，否则影响SQL询句的执行效率 7.4.3. where 与 having 区别： where 和 having 都是为了完成数据的过滤，它们后面都是添加条件； where 是在 group by之前完成过滤； having 是在 group by 之后完成过滤； 8. 总结一个完成的SQL询句如下： 123456789101112select xxxxfrom xxxxwhere xxxxgroup by xxxxhaving xxxxorder by xxxx 以上关键字的顺序不能变，严格遵守以上询句的执行顺序： from 将硬盘上的表文件加载到内存 where:将符合条件的数据行摘叏出来。生成一张新的临时表 group by :根据列中的数据种类，将当前临时表划分成若干个新的临时表 having : 可以过滤掉group by生成的不符合条件的临时表 select : 对当前临时表进行整列读取 order by : 对select生成的临时表，迚行重新排序，生成新的临时表 limit : 对最终生成的临时表的数据行，迚行截取。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM快速入门]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-JVM-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM快速入门 听说Java虚拟机是我们成为一名优秀程序员必须掌握的一个知识，这也是我们和一般只会敲代码的程序员特别能体现差距的地方。所以小艾今天就赶紧的去学习了一下JVM。 目录 JVM体系结构概述 堆体系结构概述 堆参数调优入门 GC垃圾回收 总结 一、JVM体系结构概述首先我们要知道JVM是运行在操作系统之上的，与硬件并没有直接的交互。 它的体系结构概览如下图所示： 其中的灰色区域Java栈、本地方法栈、程序计数器三块绝对不会有垃圾回收，而所谓的JVM调优就是调方法区和堆，主要是堆。记住这两点后，我们来详细的了解一下各个模块，先从红色的类装载子系统和执行引擎说起。 1.1 类装载器Class Loader它类似于快递员，负责把硬盘上的class文件送去执行，也就是说只负责class文件的加载，至于它是否运行由Execution Engine决定。 注意硬盘上的Car.class是小写的class，是指存在于硬盘上的一个文件。 1.1.1 类加载器的分类Java是由C++演变过来的，分为“虚拟机自带的加载器”和“用户自定义加载器”。 虚拟机自带的加载器 启动类加载器（Bootstrap）C++编写 扩展类加载器（Extension）Java编写 应用程序类加载器（AppClassLoader）Java编写，也叫系统类加载器，加载当前应用的classpath的所有类。 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式。 它的特点包括“双亲委派机制”和“沙箱安全机制” 双亲委派机制 双亲委派模型的运作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己加载。 沙箱机制 沙箱机制是基于双亲委派机制上的采取一种JVM的自我保护机制，假设你要写一个java.lang.String的类，由于双亲委派机制的原理，此请求会先交给Bootstrap试图进行加载，但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类，有则优先加载rt.jar包中的类，因此就保证了java的运行机制不会被破坏。 Sun.misc.Launcher它是Java虚拟机的入口应用，最后Execution Engine执行引擎负责解析命令，提交到操作系统执行。 1.2 本地方法栈本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies. 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等待。 1.3 PC寄存器PC寄存器也叫Program Counter Register程序计数器，每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储下一条指令的地址，就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。直白点说就是程序执行顺序的调度依靠它来完成。 1.4 方法区方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间。 静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中，But实例变量存在堆内存中，与方法区无关。 1.5 栈偏理论：程序=算法+数据结构 偏应用：程序=框架+业务逻辑 其中有种数据结构叫做栈，后进先出，先进后出，类似于子弹夹。对于Java来说，栈里存放的就是方法，main方法是最先进的所以在底层，main方法中引用的方法先完成后，main方法才能执行出栈。 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建的，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 1.5.1 栈存储什么栈帧中主要保存3类数据： 本地变量（Local Variable）：输入参数和输出参数以及方法内的变量。 栈操作（Operand Stack）：记录出栈、入栈的操作。 栈帧数据（Frame Data）：包括类文件、方法等待。 1.5.2 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中。 A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈， ……. ……. 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧… … 遵循“先进后出”/“后进先出”原则。 栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。 每次执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。 栈的大小也是有极限的。 栈异常：Exception in thread “main” java.lang.StackOverflowError 1.5.3 栈+堆+方法区的交互关系 HotSpot是SUN公司的Java虚拟机版本名，是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，即指向方法区中的模板文件，保证每一个实例一致性，reference存储的就直接是对象的地址。 三种JVM Sun公司的HotSpot BEA公司的JRockit IBM公司的J9 VM SUN和EBA都被Oracle公司收购，进行了产品整合，PK后产生了Java8。 二、堆体系结构概述2.1 堆一个JVM实例中只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space 新生区 Young/New Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm 2.1.1 新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。辛存区有两个：0区（Survivor 0 Space）和1区（Survivor 1 Space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError：Java head space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 2.1.2 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError：PermGen Space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 JDK1.6及之前：有永久代，常量池1.6在方法区 JDK1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。 JDK1.8及以后：无永久代，常量池1.8在元空间。 属性三区结构后方可学习JVM垃圾收集 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 三、堆参数调优入门我们先来看看Java7和Java8的堆结构区别 Java7 Java8之后最初的永久代取消了，由元空间取代。 3.1 堆内存调优简介01 123456public static void main(String[] args)&#123;long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。System.out.println("MAX_MEMORY = " + maxMemory + "（字节）、" + (maxMemory / (double)1024 / 1024) + "MB");System.out.println("TOTAL_MEMORY = " + totalMemory + "（字节）、" + (totalMemory / (double)1024 / 1024) + "MB");&#125; 发现默认的情况下分配的内存是总内存的“1/4”、而初始化的内存为“1/64” VM参数： ==-Xms1024m -Xmx1024m -XX:+PrintGCDetails== 12345String str = "www.atguigu.com" ;while(true) &#123;str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;&#125; VM参数：==-Xms8m -Xmx8m -XX:+PrintGCDetails== 3.2 MAT 官网访问地址：https://projects.eclipse.org/projects/tools.mat/downloads ==-XX:+HeapDumpOnOutOfMemoryError== OOM时导出堆到文件。 ==-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError== 四、GC垃圾回收 4.1 GC是什么（分代算法）GC俗称垃圾回收器 （java Garbage Collection） 次数上频繁收集Young区 次数上较少收集Old区 基本上不动Perm区 4.2 GC4大算法JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 普通GC（minor GC）：只针对新生代区域的GC。 全局GC（major GC or Full GC）：针对年老代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 4.2.1 引用计数法4.2.2 复制算法（Copying）年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying） 原理： Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden区就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过==-XX:MaxTenuringThreshold== 来设定参数)，这些对象就会成为老年代。 ==-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数== 解析： 年轻代中的GC,主要是复制算法（Copying） HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区 （分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 动图 缺点 复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 4.2.3 标记清除老年代一般是由标记清除或者是标记整理的混合实现。 原理 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象，标记为存活的对象。 清除：遍历整个堆，把未标记的对象清除。 用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 动图 缺点： 此算法需要暂停整个应用，会产生内存碎片 4.2.4 标记压缩老年代一般是由标记清除或者是标记整理的混合实现。 原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 缺点 标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 4.2.5 标记清除压缩 动图 4.2.6 这几种算法的比较内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。内存整齐度：复制算法=标记整理算法&gt;标记清除算法。内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 猜猜看 答案是没有，没有最好，只有更好，最适合的算法。 五、总结通过上面的学习，相信你已经对Java虚拟机有了初步的了解，接来下，小艾会分模块，再深入一点学习JVM的知识。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F03%2F03%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo介绍 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
