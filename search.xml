<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL快速入门（上）]]></title>
    <url>%2F2019%2F03%2F17%2F2019-03-17-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[因为有了数据库管理系统，我们操作数据更加的方便直观，不再需要通过IO流的操作进行数据管理。而我们今天就来学习一款比较流行的关系型数据库管理系统——MySQL。 目录 学前准备 常用命令 演示数据结构 简单的查询 条件查询 数据排序 处理函数 总结 1. 学前准备1.1 安装MySQL（省）1.2 启动MySQL的服务1.2.1 可以通过服务管理器管理MySQL的服务停止MySQL服务 关闭MySQL服务 1.2.2 在DOS窗口直接通过命令行的形式进行控制启动MySQL服务：net start mysql 停止MySQL服务：net stop mysql 1.3 MySQL登录配置用户环境变量path:C:\Program Files\MySQL\MySQL Server 5.7\bin，否则如下图显示 提示：’mysql‘不是内部戒外部命令，也丌是可运行的程序戒批处理文件。 配置完成之后，再次运行，提示：ERROR 1045 (28000): Access denied for user ‘ODBC‘@’localhost’ (using password: NO) 打开dos窗口，输入mysql –uusername –ppassword，点击回车登录，看到以“mysql&gt;”说明已经登录成功 1.4 表的定义表是一种结构化的文件，可以用来存储特定类型的数据，如：学生信息、课程信息等，都可以放到表中，另外表都有特定的名称，而且不能重复。表中有以下几个概念：列、行、主键。 （1）列（字段） 列， 通常叫做字段，每一个字段都包含：字段名称、字段数据类型、字段约束、字段长度； （2）行记录 行，通常叫做表中的记录。表中的数据是按行（记录）存储的，表里可以有0条戒多条记录； 1.5 SQL的分类（1）数据库查询语言（DQL） 简称：DQL，Data Query Language 代表关键字：select （2）数据库操作语言（DML） 简称：MQL，Data Manipulation Language 代表关键字：update、delete、insert 增、删、改表中的数据 （3）数据库定义语言（DDL） 简称：DDL，Data Denifition Language 代表关键字：create、drop、alter 创建、删除、修改表的结构 （4）事务控制语言（TCL） 简称：TCL，Transaction ControlLanguage 代表关键字：commit、rollback （5）数据控制语言（DCL） 简称：DCL，Data Controller Language 代表关键字：grant、revoke （6）DML与DDL的区别是什么？ DML是修改数据库表中的数据，而DDL是修改数据中表的结构 1.6 导入演示数据 使用MySQL命令行客户端来装载数据库 (1) 连接MySQL：mysql -uroot -p123 (2) 创建数据库：create database bjpowernode; (3) 选择数据库：use bjpowernode; (4)导入数据库：source D:\bjpowernode.sql (5)删除数据库：drop database bjpowernode; 查看数据库相关命令 (1) 查看数据库管理系统中所有的数据库：show databases; (2) 查看bjpowernode数据库中的所有表格：show tables; (3) 查看描述表的结构：desc 表名; 演示数据表结构描述 (1) 表名称：dept 描述：部门信息表 (2) 表名称：emp 描述：员工信息表 注：DEPTNO是外键，DEPTNO的值来源于dept表的主键，起到了约束的作用 表名称：salgrade 描述：薪水等级信息表 2. 常用命令2.1 查看MySQL版本（进入Mysql前）2.1.1. mysql –versionC:\Users\Administrator&gt;mysql –version 2.1.2. mysql -V（注：大写字母V）C:\Users\Administrator&gt;mysql –V 2.2 查询当前使用数据库及MySQL版本(进入MySQL后)2.2.1. 查看当前使用数据库select database (); 2.2.2. 查看MySQL数据库版本select version(); 2.3 创建数据库2.3.1. create database 数据库名称；mysql&gt;create database bjpowernode; 2.3.2. use 数据库名称；use bjpowernode;注：在数据库中创建表，因些创建表的时候必须要先选择数据库。 2.4 终止一条语句2.4.1. 如果想要终止一条SQL询句，可输入\c；2.5 退出MySQL2.5.1. 可使用exit、\q戒exit；最方便快捷的是crtl+c3. 演示数据结构3.1. 如何叏得演示数据3.1.1. 查看和指定现有的数据库show databases; 3.1.2. 指定当前缺省数据库use bjpowernode; 3.1.3. 查看当前使用的数据库select database(); 3.1.4. 查看当前数据库中的表show tables; 3.1.5. 查看其它数据库中的表show tables from 数据库名称； 3.1.6. 查看表结构desc 表名称； 3.1.7. 查看表的创建询句show create table 表名称; 4. 简单的查询4.1 查询一个字段4.1.1 查询员工姓名注：在SQL语句中丌区分大小写；SQL语句以“；”分号结束select ename from emp; 注：select询句后面跟的是字段名称，select是兲键字，select和字段名称之间采用空格隔开，from表示将要查诟的表，它和字段之间采用空格隔开。 4.2 查询多个字段4.2.1 查询员工编号和员工姓名注：多个字段查询时，字段不字段之间用“,”隔开select empno,ename from emp; 注：查诟多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段丌能使用逗号了. 4.3 查询全部字段我们可以将所有字段放到 select 语句之后，这种方案丌方便，但是比较清楚，我们可以采用下面的方式查诟全部字段。select * from emp; 注：采用 select from emp，虽然简单，但是 号不是很明确，并丏且select 语句会先去编译，将“”转换成字段，建议查询全部字段将相关字段写到 select 语句的后面，在以后 java连接数据库的时候，是需要在 java 程序中编写 SQL 语句的，这个时候编写SQL语句不建议使用 select * 这种形式，建议写明字段，这个 SQL 语句的可读性强。 4.4 计算员工的年薪4.4.1 列出员工编号，姓名和年薪mysql&gt;select empno,ename,sal*12 from emp; 注：字段上可以使用数学表达式，只要SQL语句中有 select 关键字，不会修改底层数据库字段的值； 4.5 将查询出来的字段重命名和显示为中文4.5.1 select empno,ename,sal * 12 as yearsal from emp;或者 select empno,ename,sal * 12 yearsal from emp; 4.5.2. select empno,ename,sal * 12 as ‘年薪’from emp;或者 select empno,ename,sal * 12 ‘年薪’from emp; 注： 重命名为中文时必须加单引号或双引号； 标准SQL询句中类型为字符串时必须加单引号，加单引号适用于任何数据库； SQL询句中类型为字符串时也可加双引号，叧适用于MySQL数据库中； 为了SQL询句的通用性，建议全部使用单引号； 5. 条件查询注意：条件查诟需要用到 where 询句，where 必须放到 from 询句表的后面；执行顺序：先from再where过滤后再检索出来。 5.1 支持如下运算符 运算符 说明 = 等于等于 &lt;&gt;或!= 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between…and… 两值之间，等同于&gt;=and&lt;= is null 为null（is not null不为空） and 并且 or 或者 in 包含，相当于多个or（not in不在这个范围中） not not可以取非，主要用在is或in中 like like称为模糊查询，支持%或者下划线匹配，%匹配任意个字符，一个下划线匹配一个字符 5.2 等号（=）操作符5.2.1 查诟薪水为5000的员工select empno,ename,sal from emp where sal = 5000; 5.2.2 查诟 job 为 MANAGER 的员工错诣：select empno,ename,job from emp where job = MANAGER; 以上查诟结构出现错诣，因为 job 字段为字符串，所以出现了以上错诣信息；正确：select empno,ename,job from emp where job =“manager”; 也可使用单引号 select empno,ename,job from emp where job = ‘manager’; select empno,ename,job from emp where job = ‘MANAGER’; 以上输入结果输入结果正确，MySQL默认情况下大小写不敏感； 5.3 不等号（&lt;&gt;、i=）操作符5.3.1. 查诟薪水丌等亍 5000 的员工select empno,ename,sal from emp where sal &lt;&gt; 5000; 以下写法等同于上的写法，建议使用第一种写法select empno,ename,sal from emp where sal != 5000;数值也可以采用单引号引起来，如下询句也是正确，但不建议，原因MySQL数据库做数据类型自劢转换select empno,ename,sal from emp where sal &lt;&gt; ‘5000’; 5.3.2. 查诟工作岗位不等亍MANAGER的员工 5.4 between … and …操作符5.4.1. 查诟薪水为1600到3000的员工（第一种方式：采用&gt;=、&lt;=）select empno,ename,sal from emp where sal &gt;= 1600 and sal &lt;= 3000; 5.4.2. 查诟薪水为1600到3000的员式（第二种方式：采用between…and…）select empno,ename,sal from emp where sal between 1600 and 3000; 注：关于between … and … 它是包含最大值和最小值的 5.4.3. （了解）between … and … 同样也可用在字符上，用在字符上区间为：前闭后开；select ename from emp where ename between ‘A‘ and ’F‘; 5.5 is nullNull 为空，它不是一个数值，不是一个空串，为null可以设置这个字段不填值，如果查诟为null的字段，采用is null。 5.5.1 查询津贴为空的员工错诣：select empno,ename,comm from emp where comm = null; 原因：以上无法查诟出符合条件的数据，因为null类型比较特殊，必须使用 is 来比较正确：select empno,ename,comm from emp where comm is null; 5.5.2 查诟津贴不为空的员工select empno,ename,comm from emp where comm is not null; 5.6 and含义：表示并且，表示所有查诟条件必须满足5.6.1. 查询工作岗位为“MANAGER”并且薪水大于2500的员工select empno,ename,job,sal from emp where job =’MANAGER‘ and sal &gt; 2500; 5.7 or含义：只要满足条件即可，相当于包含 5.7.1 查诟出 job 为 SALESMAN 或 job为MANAGER的员工select ename,job from emp where job = ’SALESMAN‘or job = ’MANAGER‘; 5.8 and不or表达式的优化级and的优先级高于or5.8.1. 查诟薪水大于1800，并且部门编号为20或30的员工错误：select * from emp sal&gt;1800 and deptno=20 or deptno = 30; 分析：以上输出的结果不是我们预期的结果，薪水小于1800的也查出来了，原因是表达式的优先级导致的，首先SQL语句过滤了 sal &gt; 1800 and deptno = 20，然后再将deptno = 30的员工合并过来，所以是不正确的。正确：select * from emp where sal&gt;1800 and (deptno=20 or deptno=30); 注：关于运算符的问题丌用死记硬背，没有把握的尽量采用括号； 5.9 in含义：表示包含的意思，完全可以采用or来表示，采用in会更简洁一些。5.9.1 查询出Job为 SALESMAN 和 Job为 MANAGER 的员工select ename,job from emp where job in (‘SALESMAN’,＇MANAGER’); 5.9.2. 查询出薪水为1600和3000的员工select ename,sal from emp where sal in (1600,3000); 5.9.3. 查询出薪水不是1600和3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10 not5.10.1 第一种写法：查询出薪水不是1600和薪水丌是3000的员工select ename,sal from emp where sal &lt;&gt; 1600 and sal &lt;&gt; 3000; 5.10.2 第二种写法：查询出薪水不是1600和薪水丌是3000的员工select ename,sal from emp where not (sal = 1600 or sal = 3000); 5.10.3. 第三种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10.4 查询出津贴不为null的员工select * from emp where comm is not null; 5.11 Like含义：like可以实现模糊查诟，like支持%和下划线匹配 5.11.1. 查询以姓名以 M 开头的所有员工‘M%’select ename from emp where ename like ‘M%’; 5.11.2. 查询姓名以N结尾的所有员工‘%N’select ename from emp where ename like „%N‟; 5.11.3. 查询姓名中包含O的所有员工‘%O%’select ename from emp where ename like „%O%‟; 5.11.4. 查询姓名中第二个字符为A的所有员工‘_A%’select ename from emp where ename like „_A%‟; 5.11.5. 查询姓名中倒数第二个字符为E的所有员工‘%E_’select ename from emp where ename like „%E_‟; 5.11.6. 查诟姓名中第三个字符为R的所有员工姓名‘__R%’select ename from emp where ename like „__R%‟; 6. 数据排序6.1. 单一字段排序 order by 字段名称6.1.1. 作用：通过哪个或哪些字段迚行排序含义：排序采用 order by 子句，order by 后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序（asc），如果存在 where 子句，那么 order by 必须放到where 询句后面。（1） 按照薪水由小到大排序（系统默认由小到大）select ename,sal from emp order by sal; （2）取得 job 为 MANAGER 的员工，按照薪水由小到大排序（系统默认由小到大）select ename,job,sal from emp where job = ‘MANAGER’order by sal; 注：如果包含 where 语句 order by 必须放到 where 后面，如果没有 where 语句 order by 放到表的后面； （3） 以下询法是错诣的：a） select from emp order by sal whereb） select from emp order by sal where job = ‘MANAGER’; 6.2. 手劢指定字段排序6.2.1. 手动指定按照薪水由小到大排序（升序关键字 asc）select ename,sal from emp order by sal asc; 6.2.2. 手动指定按照薪水由大到小排序（降序关键字desc）select ename,sal from emp order by sal desc; 6.3. 多个字段排序6.3.1. 按照 job 和薪水倒序排序select ename,job,ename from emp order by job desc,sal desc; 注意：如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序； 6.4. 使用字段位置排序按照薪水升序排序（不建议采用此方法，采用数字含义不明确，可读性不强，程序不健壮）select * from emp order by 6; 7. 处理函数7.1. 数据处理凼数（单行处理凼数） lower 转换小写 upper 转换大写 substr 取子串（substr（被截取的字符串，起始下标，截取的长度）） length 取长度 trim 去空格 str_to_date 将字符串换成日期 date_format 格式化日期 format 设置干分位 round 四舍五入 rand() 生成随机数 ifnull 可以将null转换成一个具体值 注意：数据处理函数是该数据本身特有的，有些函数可能在其它数据库不起作用； 7.1.1. lower(字段名)函数: 转换为小写用法：lower(要转换字段名称)查询员工姓名，将员工姓名全部转换成小写select lower(ename) as ename from emp; 7.1.2. upper(字段名)函数：转换为大写用法：upper(要转换字段名称)查诟员工姓名，将员工姓名全部转换为大写select upper(ename) as ename from emp; 7.1.3. substr(字段名,起始下标,截取长度)凼数：取子串用法：substr(被截取字段名称,起始下标,截取长度)注意：起始下标：从1开始查询并显示所员工姓名的第二个字母select substr(ename,2,1) from emp; 查诟员工姓名中第二个字母为A的所有员工select ename from emp where substr(enam,2,1) = ‘A’; 联想知识点，模糊查诟：select ename from emp where ename like ’_A%‘; 7.1.4. length(字段名)函数：取字段长度用法：length(字段名称)取得员工姓名长度select ename,length(ename) as nameLength from emp; 7.1.5. ifnull(字段名,替换值)函数：空值处理函数用法：ifnull(字段名称,将要替换)结论：在数据库中，有Null参与数学运算的结果一定为Null；为了防止计算结果出现Null，建议先使用ifnull函数预先处理。查询员工姓名及补助，如果补助为Null设置为0；select ename,ifnull(comm,0) from emp; 查诟员工薪水不补劣的和 错诣写法：select sal+comm from emp; 正确写法：select sal + ifnull(comm,0) from emp; 没有补劣的员工，将每月补助100，求员工的年薪select ename, (sal + ifnull(comm,100)) * 12 yearsal from emp; 7.1.6. case…when…then…else…end用法：匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 12345case job when &apos;MANAGER&apos; then sal * 1.1 when &apos;SALESMAN&apos; then sal * 1.5 else salend 注意：使用在DQL询句中； 匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 1.1.7. trim(‘字符串’)函数：去除首尾空格作用：trim函数去除首尾空格，不会去除中间空格用法：trim(字符串)取得工作岗位为manager的所有员工select * from emp where job = trim(’ manager ‘);注意：MySQL默认去除字段后面的空格，原因：MySQL询法松散 7.1.8. round(数字,保留小数位数)函数：四舍五入用法：round(要四舍五入的数字,四舍五入到哪一位)，默认保留整数位保留整数位或不保留小数位：select round(125.18)；或者 select round(125.18,0); 保留1位小数：select round(125.18,1); 保留2位小数：select round(125.18,2); 个数位四舍五入：select round(125.18,-1); 7.1.9. rand()函数：生成随机数生成一个 0≤ v ≤ 1.0的随机数;select rand(); 生成一个0-100的随机数select round(rand()*100); 7.1.10. str_to_date函数：将字符串转换为日期作用：将‘日期字符串’转换为‘日期类型’数据执行结果：DATE类型用法：str_to_date(‘日期字符串’,‘日期格式’) 1）日期字符串：日期格式的字符串日期格式：告知MySQL输入日期字符串的格式是什么MySQL日期格式： 序号 格式符 功能 格式符 功能 1 %Y 代表四位的年份 %y 代表两位的年份 2 %m 代表月，格式（01…12） %c 代表月，格式（1…12） 3 %d 代表日 4 %H 代表24小时制 %h 代表12小时制 5 %i 代表分钟，格式（00…59） 6 %S或%s 代 表 秒 , 格 式（00…59） 查询出1981-12-03入职的员工执行成功：select ename,hiredate from emp where hiredate = ‘1981-12-03’; 1、在MySQL中日期作为查诟条件时，可以使用字符串为其赋值，常用格式有三种:1949-10-101949/10/10194910102、输入的日期字符串格式不MySQL默认日期格式相同，MySQL默认日期格式：%y-%m-%d查诟出02-20-1981入职的员工错诣执行：select ename,hiredate from emp where hiredate = ‟02-20-1981‟; 错诣原因：‘02-20-1981’是一个字符串varchar类型，不MySQL中DATE默认类型丌匹配正确写法：select ename,hiredate from emp where hiredate = str_to_date(‟02-20-1981‟,‘%m-%d-%Y’); 总结：1、日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以仍需掌握；2、每一个数据库处理日期时采用的机制都不一样，都有自己的一套处理机制，所以在实际开发中将日期字段定义为DATE类型的情况很少；3、如果使用日期类型，java程序将不能通用。实际开发中，一般会使用“日期字符串”来表示日期； 创建 t_student 表【create语句，以后诡细讲】，插入含有日期的数据 插入数据：1980-01-18【insert 语句，以后详细讲】 执行成功：‘1980-01-18’虽然是一个varchar类型，但是由亍格式和MySQL数据库默认的日期格式相同，所以存在自劢类型转换。 执行失败：再次插入01-18-1980A.‘01-18-1980’日期字符串的格式和MySQL默认的格式不同；B．‘01-18-1980’是varchar类型，birth字段需要DATE类型，类型不匹配； 正确写法： 结论：str_to_date凼数通常使用在插入操作中；字段DATA类型，不接收varchar类型，需要先通过该函数将varchar变成data再插入数据。 7.1.11. date_format函数：将日期转换为特定格式字符串作用：将‘日期类型’转换为特定格式的‘日期字符串’类型用法： date_format(日期类型数据,‘日期格式‟)查询员工的入职日期，以‘10-12-1980’的格式显示到窗口中； 查诟员工的入职日期，以‘10/12/1980’的格式显示到窗口中； MySQL日期默认格式示例 以下两个DQL询句执行结果相同第一种：hiredate自劢转换成varchar类型，默认采用%Y-%m-%d格式 第二种：通过date_format(hiredate,’%Y-%m-%d’)函数 7.2. 分组函数/聚合函数/多行处理函数7.2.1. 常用以下几种 sum 求和 avg 取平均 max 取最大值 min 取最小值 count 取记录数 7.2.2. 什么是单行处理函数，什么是多行处理函数？单行函数都是一行输入对应一行输出多行处理函数都是多行输入对应一行输出 7.2.3. 注意：1、分组函数自动忽略空值，丌需要手劢增加where条件排除空值；2、分组函数不能直接使用在where关键字后面； 7.2.4. sum(字段)函数作用：求某一列的和，null会自劢被忽略；用法： sum(字段名称) 案例 （1）取得薪水的合计 （2）取得补助的合计 注意：null 会被忽略不计 （3）取得总共薪水（工资+补助）合计 统计结果错误，原因： 1、comm字段有 null 值，在多列进行运算时，叧要有 null 参不的数学运算结果都为 null2、sum函数会自劢忽略掉null值，正确的做法是将comm的null值转换为0，如：ifnull(comm,0)纠正以上错误，如下：sum(sal + ifnull(comm,0)) 7.2.5. avg(字段名)函数作用：求某一列的平均值，null会被自劢忽略用法：avg(字段名称) 案例 （1）取得平均薪水avg(sal) 7.2.6. max(字段名)函数作用：取得某一列的最大值用法：max(字段名称)案例：（1）取得最高薪水max(sal) （2）取得最晚入职的员工max(sal)说明：日期类型也可以进行大小比较 7.2.7. min(字段名)函数作用：取得某一列最小值用法：min(字段名称)案例（1）得最低薪水min(sal) （2）取得最早入职的员工min(hiredate) 7.2.8. count函数作用：取得某字段值不为null的记录总数用法：count(字段名称) 或 count()注意：1、 count()表示取得当前查诟表所有记录2、 count(字段名称)，不会统计为 null 的记录案例（1） 取得所有员工数count(*) （2）取得补助不为空的所有员工数count(comm) （3）取得补助为空的员工数量 is null select count(*) from emp where comm is null； 查诟出补劣comm为null的数量 7.2.9. 组合聚合函数sum、avg、max、min、count可以将这些聚合凼数都放到 select 中一起使用select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 7.3. distinct 去除重复记录作用：将查询结果中某一字段的的重复记录去除掉用法：distinct 字段名或 distinct 字段名1, 字段名2 … …distinct 字段名A：去除不字段名A相同的记录distinct 字段名A,字段名B：去除不字段名A和字段名B同时相同的记录注意：distinct叧能出现在所有字段最前面，后面如果有多个字段及为多字段联合去重 7.3.1. 案例（1）查询诠公司有哪些工作岗位 （2）查诟诠公司工作岗位数量 （3）去除部门编号deptno和工作岗位job重复的记录 7.4. 分组查询：group by作用：通过哪个或哪些字段进行分组用法：group by 字段名称 7.4.1. 案例（1）找出每个工作岗位的最高薪水思路分析：按照工作岗位分组，然后对每一组求最大值。SQL询句中肯定包含 group by、max(sal)； 重点结论：有 group by 的DQL询句中，select 询句后面叧能跟 分组函数 + 参不分组的字段； （2）计算每个工作岗位的最高薪水，并且按照由低到高迚行排序思路分析：先按照工作岗位 job 迚行分组，然后对每一组薪水求最大值max，最后再根据每一组薪水的最大值迚行由低到高排序； 注意：如果使用了 order by ，order by 必须放到 group by后面； （3）计算每个部门的平均薪水思路分析：首先，按照部门编号分组，然后对每一组的薪水求平均值 （4）计算出不同部门不同岗位的最高薪水思路分析：首先把deptno和job看成一个字段进行联合字段分组，联系到distinct关键字。 （5）找出每个工作岗位的最高薪水，除MANAGER之外思路分析：先将job等亍MANAGER的过滤掉，然后再根据工作岗位进行分组，对每一组求最大薪水。 7.4.2. having作用：如果想对分组的数据再进行过滤，需要使用having子句； （1）找出每个工作岗位的平均薪水，要求显示平均薪水大于2000的；思路分析：先对工作岗位 job 分组，然后对每一组薪水求平均值，最后再对每一组平均薪水的值进行大于2000的条件过滤； 错误写法：select job,avg(sal) from emp where avg(avg) &gt; 2000 group by job;原因：where关键字后面不能直接使用分组函数，这与SQL询句的执行顺序有关系，它会先执行from emp，然后再进行 where 条件过滤，where条件过滤结束之后再执行 group by 分组，之后才会显示出查询结果。正确写法：select job,avg(sal) from emp group by job having avg(sal) &gt; 2000; 注意：能够在where在过滤的数据不要放到having中进行过滤，否则影响SQL询句的执行效率 7.4.3. where 与 having 区别： where 和 having 都是为了完成数据的过滤，它们后面都是添加条件； where 是在 group by之前完成过滤； having 是在 group by 之后完成过滤； 8. 总结一个完成的SQL询句如下： 123456789101112select xxxxfrom xxxxwhere xxxxgroup by xxxxhaving xxxxorder by xxxx 以上关键字的顺序不能变，严格遵守以上询句的执行顺序： from 将硬盘上的表文件加载到内存 where:将符合条件的数据行摘叏出来。生成一张新的临时表 group by :根据列中的数据种类，将当前临时表划分成若干个新的临时表 having : 可以过滤掉group by生成的不符合条件的临时表 select : 对当前临时表进行整列读取 order by : 对select生成的临时表，迚行重新排序，生成新的临时表 limit : 对最终生成的临时表的数据行，迚行截取。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM快速入门]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-JVM-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM快速入门 听说Java虚拟机是我们成为一名优秀程序员必须掌握的一个知识，这也是我们和一般只会敲代码的程序员特别能体现差距的地方。所以小艾今天就赶紧的去学习了一下JVM。 目录 JVM体系结构概述 堆体系结构概述 堆参数调优入门 GC垃圾回收 总结 一、JVM体系结构概述首先我们要知道JVM是运行在操作系统之上的，与硬件并没有直接的交互。 它的体系结构概览如下图所示： 其中的灰色区域Java栈、本地方法栈、程序计数器三块绝对不会有垃圾回收，而所谓的JVM调优就是调方法区和堆，主要是堆。记住这两点后，我们来详细的了解一下各个模块，先从红色的类装载子系统和执行引擎说起。 1.1 类装载器Class Loader它类似于快递员，负责把硬盘上的class文件送去执行，也就是说只负责class文件的加载，至于它是否运行由Execution Engine决定。 注意硬盘上的Car.class是小写的class，是指存在于硬盘上的一个文件。 1.1.1 类加载器的分类Java是由C++演变过来的，分为“虚拟机自带的加载器”和“用户自定义加载器”。 虚拟机自带的加载器 启动类加载器（Bootstrap）C++编写 扩展类加载器（Extension）Java编写 应用程序类加载器（AppClassLoader）Java编写，也叫系统类加载器，加载当前应用的classpath的所有类。 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式。 它的特点包括“双亲委派机制”和“沙箱安全机制” 双亲委派机制 双亲委派模型的运作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己加载。 沙箱机制 沙箱机制是基于双亲委派机制上的采取一种JVM的自我保护机制，假设你要写一个java.lang.String的类，由于双亲委派机制的原理，此请求会先交给Bootstrap试图进行加载，但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类，有则优先加载rt.jar包中的类，因此就保证了java的运行机制不会被破坏。 Sun.misc.Launcher它是Java虚拟机的入口应用，最后Execution Engine执行引擎负责解析命令，提交到操作系统执行。 1.2 本地方法栈本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies. 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等待。 1.3 PC寄存器PC寄存器也叫Program Counter Register程序计数器，每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储下一条指令的地址，就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。直白点说就是程序执行顺序的调度依靠它来完成。 1.4 方法区方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间。 静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中，But实例变量存在堆内存中，与方法区无关。 1.5 栈偏理论：程序=算法+数据结构 偏应用：程序=框架+业务逻辑 其中有种数据结构叫做栈，后进先出，先进后出，类似于子弹夹。对于Java来说，栈里存放的就是方法，main方法是最先进的所以在底层，main方法中引用的方法先完成后，main方法才能执行出栈。 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建的，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 1.5.1 栈存储什么栈帧中主要保存3类数据： 本地变量（Local Variable）：输入参数和输出参数以及方法内的变量。 栈操作（Operand Stack）：记录出栈、入栈的操作。 栈帧数据（Frame Data）：包括类文件、方法等待。 1.5.2 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中。 A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈， ……. ……. 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧… … 遵循“先进后出”/“后进先出”原则。 栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。 每次执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。 栈的大小也是有极限的。 栈异常：Exception in thread “main” java.lang.StackOverflowError 1.5.3 栈+堆+方法区的交互关系 HotSpot是SUN公司的Java虚拟机版本名，是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，即指向方法区中的模板文件，保证每一个实例一致性，reference存储的就直接是对象的地址。 三种JVM Sun公司的HotSpot BEA公司的JRockit IBM公司的J9 VM SUN和EBA都被Oracle公司收购，进行了产品整合，PK后产生了Java8。 二、堆体系结构概述2.1 堆一个JVM实例中只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space 新生区 Young/New Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm 2.1.1 新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。辛存区有两个：0区（Survivor 0 Space）和1区（Survivor 1 Space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError：Java head space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 2.1.2 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError：PermGen Space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 JDK1.6及之前：有永久代，常量池1.6在方法区 JDK1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。 JDK1.8及以后：无永久代，常量池1.8在元空间。 属性三区结构后方可学习JVM垃圾收集 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 三、堆参数调优入门我们先来看看Java7和Java8的堆结构区别 Java7 Java8之后最初的永久代取消了，由元空间取代。 3.1 堆内存调优简介01 123456public static void main(String[] args)&#123;long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。System.out.println("MAX_MEMORY = " + maxMemory + "（字节）、" + (maxMemory / (double)1024 / 1024) + "MB");System.out.println("TOTAL_MEMORY = " + totalMemory + "（字节）、" + (totalMemory / (double)1024 / 1024) + "MB");&#125; 发现默认的情况下分配的内存是总内存的“1/4”、而初始化的内存为“1/64” VM参数： ==-Xms1024m -Xmx1024m -XX:+PrintGCDetails== 12345String str = "www.atguigu.com" ;while(true) &#123;str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;&#125; VM参数：==-Xms8m -Xmx8m -XX:+PrintGCDetails== 3.2 MAT 官网访问地址：https://projects.eclipse.org/projects/tools.mat/downloads ==-XX:+HeapDumpOnOutOfMemoryError== OOM时导出堆到文件。 ==-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError== 四、GC垃圾回收 4.1 GC是什么（分代算法）GC俗称垃圾回收器 （java Garbage Collection） 次数上频繁收集Young区 次数上较少收集Old区 基本上不动Perm区 4.2 GC4大算法JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 普通GC（minor GC）：只针对新生代区域的GC。 全局GC（major GC or Full GC）：针对年老代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 4.2.1 引用计数法4.2.2 复制算法（Copying）年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying） 原理： Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden区就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过==-XX:MaxTenuringThreshold== 来设定参数)，这些对象就会成为老年代。 ==-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数== 解析： 年轻代中的GC,主要是复制算法（Copying） HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区 （分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 动图 缺点 复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 4.2.3 标记清除老年代一般是由标记清除或者是标记整理的混合实现。 原理 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象，标记为存活的对象。 清除：遍历整个堆，把未标记的对象清除。 用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 动图 缺点： 此算法需要暂停整个应用，会产生内存碎片 4.2.4 标记压缩老年代一般是由标记清除或者是标记整理的混合实现。 原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 缺点 标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 4.2.5 标记清除压缩 动图 4.2.6 这几种算法的比较内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。内存整齐度：复制算法=标记整理算法&gt;标记清除算法。内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 猜猜看 答案是没有，没有最好，只有更好，最适合的算法。 五、总结通过上面的学习，相信你已经对Java虚拟机有了初步的了解，接来下，小艾会分模块，再深入一点学习JVM的知识。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F03%2F03%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo介绍 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
