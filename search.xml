<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM快速入门]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-JVM-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM快速入门 听说Java虚拟机是我们成为一名优秀程序员必须掌握的一个知识，这也是我们和一般只会敲代码的程序员特别能体现差距的地方。所以小艾今天就赶紧的去学习了一下JVM。 目录 JVM体系结构概述 堆体系结构概述 堆参数调优入门 GC垃圾回收 总结 一、JVM体系结构概述首先我们要知道JVM是运行在操作系统之上的，与硬件并没有直接的交互。 它的体系结构概览如下图所示： 其中的灰色区域Java栈、本地方法栈、程序计数器三块绝对不会有垃圾回收，而所谓的JVM调优就是调方法区和堆，主要是堆。记住这两点后，我们来详细的了解一下各个模块，先从红色的类装载子系统和执行引擎说起。 1.1 类装载器Class Loader它类似于快递员，负责把硬盘上的class文件送去执行，也就是说只负责class文件的加载，至于它是否运行由Execution Engine决定。 注意硬盘上的Car.class是小写的class，是指存在于硬盘上的一个文件。 1.1.1 类加载器的分类Java是由C++演变过来的，分为“虚拟机自带的加载器”和“用户自定义加载器”。 虚拟机自带的加载器 启动类加载器（Bootstrap）C++编写 扩展类加载器（Extension）Java编写 应用程序类加载器（AppClassLoader）Java编写，也叫系统类加载器，加载当前应用的classpath的所有类。 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式。 它的特点包括“双亲委派机制”和“沙箱安全机制” 双亲委派机制 双亲委派模型的运作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己加载。 沙箱机制 沙箱机制是基于双亲委派机制上的采取一种JVM的自我保护机制，假设你要写一个java.lang.String的类，由于双亲委派机制的原理，此请求会先交给Bootstrap试图进行加载，但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类，有则优先加载rt.jar包中的类，因此就保证了java的运行机制不会被破坏。 Sun.misc.Launcher它是Java虚拟机的入口应用，最后Execution Engine执行引擎负责解析命令，提交到操作系统执行。 1.2 本地方法栈本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies. 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等待。 1.3 PC寄存器PC寄存器也叫Program Counter Register程序计数器，每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储下一条指令的地址，就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。直白点说就是程序执行顺序的调度依靠它来完成。 1.4 方法区方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间。 静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中，But实例变量存在堆内存中，与方法区无关。 1.5 栈偏理论：程序=算法+数据结构 偏应用：程序=框架+业务逻辑 其中有种数据结构叫做栈，后进先出，先进后出，类似于子弹夹。对于Java来说，栈里存放的就是方法，main方法是最先进的所以在底层，main方法中引用的方法先完成后，main方法才能执行出栈。 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建的，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 1.5.1 栈存储什么栈帧中主要保存3类数据： 本地变量（Local Variable）：输入参数和输出参数以及方法内的变量。 栈操作（Operand Stack）：记录出栈、入栈的操作。 栈帧数据（Frame Data）：包括类文件、方法等待。 1.5.2 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中。 A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈， ……. ……. 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧… … 遵循“先进后出”/“后进先出”原则。 栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。 每次执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。 栈的大小也是有极限的。 栈异常：Exception in thread “main” java.lang.StackOverflowError 1.5.3 栈+堆+方法区的交互关系 HotSpot是SUN公司的Java虚拟机版本名，是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，即指向方法区中的模板文件，保证每一个实例一致性，reference存储的就直接是对象的地址。 三种JVM Sun公司的HotSpot BEA公司的JRockit IBM公司的J9 VM SUN和EBA都被Oracle公司收购，进行了产品整合，PK后产生了Java8。 二、堆体系结构概述2.1 堆一个JVM实例中只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space 新生区 Young/New Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm 2.1.1 新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。辛存区有两个：0区（Survivor 0 Space）和1区（Survivor 1 Space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError：Java head space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 2.1.2 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError：PermGen Space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 JDK1.6及之前：有永久代，常量池1.6在方法区 JDK1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。 JDK1.8及以后：无永久代，常量池1.8在元空间。 属性三区结构后方可学习JVM垃圾收集 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 三、堆参数调优入门我们先来看看Java7和Java8的堆结构区别 Java7 Java8之后最初的永久代取消了，由元空间取代。 3.1 堆内存调优简介01 123456public static void main(String[] args)&#123;long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。System.out.println("MAX_MEMORY = " + maxMemory + "（字节）、" + (maxMemory / (double)1024 / 1024) + "MB");System.out.println("TOTAL_MEMORY = " + totalMemory + "（字节）、" + (totalMemory / (double)1024 / 1024) + "MB");&#125; 发现默认的情况下分配的内存是总内存的“1/4”、而初始化的内存为“1/64” VM参数： ==-Xms1024m -Xmx1024m -XX:+PrintGCDetails== 12345String str = "www.atguigu.com" ;while(true) &#123;str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;&#125; VM参数：==-Xms8m -Xmx8m -XX:+PrintGCDetails== 3.2 MAT 官网访问地址：https://projects.eclipse.org/projects/tools.mat/downloads ==-XX:+HeapDumpOnOutOfMemoryError== OOM时导出堆到文件。 ==-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError== 四、GC垃圾回收 4.1 GC是什么（分代算法）GC俗称垃圾回收器 （java Garbage Collection） 次数上频繁收集Young区 次数上较少收集Old区 基本上不动Perm区 4.2 GC4大算法JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 普通GC（minor GC）：只针对新生代区域的GC。 全局GC（major GC or Full GC）：针对年老代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 4.2.1 引用计数法4.2.2 复制算法（Copying）年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying） 原理： Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden区就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过==-XX:MaxTenuringThreshold== 来设定参数)，这些对象就会成为老年代。 ==-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数== 解析： 年轻代中的GC,主要是复制算法（Copying） HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区 （分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 动图 缺点 复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 4.2.3 标记清除老年代一般是由标记清除或者是标记整理的混合实现。 原理 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象，标记为存活的对象。 清除：遍历整个堆，把未标记的对象清除。 用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 动图 缺点： 此算法需要暂停整个应用，会产生内存碎片 4.2.4 标记压缩老年代一般是由标记清除或者是标记整理的混合实现。 原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 缺点 标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 4.2.5 标记清除压缩 动图 4.2.6 这几种算法的比较内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。内存整齐度：复制算法=标记整理算法&gt;标记清除算法。内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 猜猜看 答案是没有，没有最好，只有更好，最适合的算法。 五、总结通过上面的学习，相信你已经对Java虚拟机有了初步的了解，接来下，小艾会分模块，再深入一点学习JVM的知识。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F03%2F03%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo介绍 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
