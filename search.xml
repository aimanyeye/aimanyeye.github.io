<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring中的AOP]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-Spring%E4%B8%AD%E7%9A%84AOP%2F</url>
    <content type="text"><![CDATA[目录 Spring中的AOP的细节 基于XML的AOP配置 基于注解的AOP配置 1. Spring中的AOP的细节1.1 说明我们学习 spring 的 aop，就是通过配置的方式，实现上一章节的功能。 1.2 AOP相关术语123456789101112131415161718Joinpoint( 连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。Pointcut( 切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。Advice( 通知/ 增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction( 引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。Target( 目标对象):代理的目标对象。Weaving( 织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。Proxy （代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。Aspect( 切面):是切入点和通知（引介）的结合。 1.3 学习Spring中的AOP要明确的事123456a 、开发阶段（我们做的）编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP 编程人员来做。在配置文件中，声明切入点与通知间的关系，即切面。：AOP 编程人员来做。b 、运行阶段（Spring 框架完成的）Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 1.4 关于代理的选择在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 2. 基于XML的AOP配置123示例： 我们在学习 spring 的 aop 时，采用账户转账作为示例。 并且把 spring 的 ioc 也一起应用进来。 2.1 环境搭建2.1.1 第一步：准备必要的代码此处包含了实体类，业务层和持久层代码。我们沿用上一章节中的代码即可。 2.1.2 第二步：拷贝必备的jar包到工程的lib目录此处要拷贝 spring 的 ioc 和 aop 两组 jar 包 2.1.3 第三步：创建Spring的配置文件并导入约束此处要导入 aop 的约束 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 2.1.4 第四步：配置Spring的IOC123456789101112131415161718192021222324&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据库操作对象 --&gt;&lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 指定 connection 和线程绑定 --&gt; &lt;property name="useCurrentConnection" value="true"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 2.1.5 第五步：抽取公共代码制作成通知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class TransactionManager &#123; //定义一个 DBAssit private DBAssit dbAssit ; public void setDbAssit(DBAssit dbAssit) &#123; this.dbAssit = dbAssit; &#125; //开启事务 public void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //提交事务 public void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //回滚事务 public void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //释放资源 public void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.2 配置步骤2.2.1 第一步：把通知类bean标签配置起来1234&lt;!-- 配置通知 --&gt;&lt;bean id="txManager" class="com.itheima.utils.TransactionManager"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2 第二步：使用aop:config声明aop配置aop:config:作用：用于声明开始 aop 的配置 123&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt;&lt;/aop:config&gt; 2.2.3 第三步：使用aop:aspect配置切面aop:aspect:作用：用于配置切面。属性：id：给切面提供一个唯一标识。ref：引用配置好的通知类 bean 的 id。 123&lt;aop:aspect id="txAdvice" ref="txManager"&gt; &lt;!--配置通知的类型要写在此处--&gt;&lt;/aop:aspect&gt; 2.2.4 第四步：使用aop:pointcut配置切入点表达式aop:pointcut ：作用：用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。属性：expression：用于定义切入点表达式。id：用于给切入点表达式提供一个唯一标识 1234&lt;aop:pointcut expression="execution( public void com.itheima.service.impl.AccountServiceImpl.transfer( java.lang.String, java.lang.String, java.lang.Float))" id="pt1"/&gt; 2.2.5 第五步：使用aop:xxx配置对应的通知类型aop:before作用：用于配置前置通知。指定增强的方法在切入点方法之前执行属性：method:用于指定通知类中的增强方法名称ponitcut-ref：用于指定切入点的表达式的引用poinitcut：用于指定切入点表达式执行时间点：切入点方法执行之前执行 1&lt;aop:before method="beginTransaction" pointcut-ref="pt1"/&gt; aop:after-returning 作用：用于配置后置通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 1&lt;aop:after-returning method="commit" pointcut-ref="pt1"/&gt; aop:after-throwing作用：用于配置异常通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个 1&lt;aop:after-throwing method="rollback" pointcut-ref="pt1"/&gt; aop:after作用：用于配置最终通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 1&lt;aop:after method="release" pointcut-ref="pt1"/&gt; 2.3 切入点表达式说明123456789101112131415161718192021222324252627execution:匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式：public void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 访问修饰符可以省略void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 返回值可以使用*号，表示任意返回值* com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 包名可以使用*号，表示任意包，但是有几级包，需要写几个** *.*.*.*.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 使用..来表示当前包，及其子包* com..AccountServiceImpl.saveAccount(com.itheima.domain.Account) 类名可以使用*号，表示任意类* com..*.saveAccount(com.itheima.domain.Account) 方法名可以使用*号，表示任意方法* com..*.*( com.itheima.domain.Account) 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数* com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型* com..*.*(..) 全通配方式：* *..*.*(..)注： 通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。 execution(* com.itheima.service.impl.*.*(..)) 2.4 环绕通知配置方式: 12345678&lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))"id="pt1"/&gt; &lt;aop:aspect id="txAdvice" ref="txManager"&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method="transactionAround" pointcut-ref="pt1"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567891011aop:around ： 作用： 用于配置环绕通知 属性： method：指定通知中方法的名称。 pointcut：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 说明： 它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意： 通常情况下，环绕通知都是独立使用的 1234567891011121314151617181920212223242526272829/*** 环绕通知* @param pjp* spring 框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。* 在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。* @return*/public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3. 基于注解的AOP配置3.1 环境搭建3.1.1 第一步：准备必要的代码和jar包拷贝上一小节的工程即可。 3.1.2 第二步：再配置文件中导入context的名称空间123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置数据库操作对象 --&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 指定 connection 和线程绑定 --&gt; &lt;property name="useCurrentConnection" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.1.3 第三步：把资源使用注解配置123456789101112/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao;&#125; 123456789101112/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private DBAssit dbAssit ;&#125; 3.1.4 第四步：在配置文件指定Spring要扫描的包12&lt;!-- 告知 spring，在创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; 3.2 配置步骤3.2.1 第一步：把通知类也使用注解配置123456789101112/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("txManager")public class TransactionManager &#123; //定义一个 DBAssit @Autowired private DBAssit dbAssit ;&#125; 3.2.2 第二步：在通知类使用@Aspect注解声明为切面作用：把当前类声明为切面类。 1234567891011121314/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("txManager")@Aspect//表明当前类是一个切面类public class TransactionManager &#123; //定义一个 DBAssit @Autowired private DBAssit dbAssit ;&#125; 3.2.3 第三步：在增强的方法上使用注解配置通知12345@Before 作用： 把当前方法看成是前置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 123456789//开启事务@Before("execution(* com.itheima.service.impl.*.*(..))")public void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@AfterReturning 作用： 把当前方法看成是后置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//提交事务@AfterReturning("execution(* com.itheima.service.impl.*.*(..))")public void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@AfterThrowing 作用： 把当前方法看成是异常通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//回滚事务@AfterThrowing("execution(* com.itheima.service.impl.*.*(..))")public void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@After 作用： 把当前方法看成是最终通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//释放资源@After("execution(* com.itheima.service.impl.*.*(..))")public void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.2.4 第四步：在Spring配置文件中开启Spring对注解AOP的支持12&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;&lt;aop:aspectj-autoproxy/&gt; 3.3 环绕通知注解配置12345@Around 作用： 把当前方法看成是环绕通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 12345678910111213141516171819202122232425262728/*** 环绕通知* @param pjp* @return*/@Around("execution(* com.itheima.service.impl.*.*(..))")public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3.4 切入点表达式注解12345@Pointcut 作用： 指定切入点表达式 属性： value：指定表达式的内容 12@Pointcut("execution(* com.itheima.service.impl.*.*(..))")private void pt1() &#123;&#125; 引用方式： 12345678910111213141516171819202122232425262728/*** 环绕通知* @param pjp* @return*/@Around("pt1()")// 注意：千万别忘了写括号public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3.5 不使用XML的配置方式12345@Configuration@ComponentScan(basePackages="com.itheima")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP的相关概念]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-02-AOP%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[目录 AOP概述 AOP的具体应用 1. AOP概述1.1 什么是AOPAOP：全称是 Aspect Oriented Programming 即：面向切面编程。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 1.2 AOP的作用及优势作用：在程序运行期间，不修改源码对已有方法进行增强。优势：减少重复代码提高开发效率维护方便 1.3 AOP的实现方式使用动态代理技术 2. AOP的具体应用2.1 案例中问题这是我们昨天做的增删改查例子。下面是客户的业务层实现类。我们能看出什么问题吗? 客户的业务层实现类 123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void saveAccount(Account account) throws SQLException &#123; accountDao.save(account); &#125; @Override public void updateAccount(Account account) throws SQLException&#123; accountDao.update(account); &#125; @Override public void deleteAccount(Integer accountId) throws SQLException&#123; accountDao.delete(accountId); &#125; @Override public Account findAccountById(Integer accountId) throws SQLException &#123; return accountDao.findById(accountId); &#125; @Override public List&lt;Account&gt; findAllAccount() throws SQLException&#123; return accountDao.findAll(); &#125;&#125; 问题就是：事务被自动控制了。换言之，我们使用了 connection 对象的 setAutoCommit(true)此方式控制事务，如果我们每次都执行一条 sql 语句，没有问题，但是如果业务方法一次要执行多条 sql语句，这种方式就无法实现功能了。 请看下面的示例：我们在业务层中多加入一个方法。 业务层接口 1234567/*** 转账* @param sourceName* @param targetName* @param money*/void transfer(String sourceName,String targetName,Float money); 业务层实现类： 12345678910111213@Overridepublic void transfer(String sourceName, String targetName, Float money) &#123; //根据名称查询两个账户信息 Account source = accountDao.findByName(sourceName); Account target = accountDao.findByName(targetName); //转出账户减钱，转入账户加钱 source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); //更新两个账户 accountDao.update(source); int i=1/0; //模拟转账异常 accountDao.update(target);&#125; 当我们执行时，由于执行有异常，转账失败。但是因为我们是每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性） 2.2 问题的解决解决办法：让业务层来控制事务的提交和回滚。 改造后的业务层实现类： 注：此处没有使用 spring 的 的 IoC. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl(); @Override public void saveAccount(Account account) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.save(account); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; &#125; @Override public void updateAccount(Account account) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.update(account); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125;&#125; @Override public void deleteAccount(Integer accountId) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.delete(accountId); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125;&#125; @Override public Account findAccountById(Integer accountId) &#123; Account account = null; try &#123; TransactionManager.beginTransaction(); account = accountDao.findById(accountId); TransactionManager.commit(); return account; &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; return null; &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; List&lt;Account&gt; accounts = null; try &#123; TransactionManager.beginTransaction(); accounts = accountDao.findAll(); TransactionManager.commit(); return accounts; &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; return null; &#125; @Override public void transfer(String sourceName, String targetName, Float money) &#123; try &#123; TransactionManager.beginTransaction(); Account source = accountDao.findByName(sourceName); Account target = accountDao.findByName(targetName); source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); accountDao.update(source); int i=1/0; accountDao.update(target); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; &#125;&#125; TransactionManager 类的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class TransactionManager &#123; //定义一个 DBAssit private static DBAssit dbAssit = new DBAssit(C3P0Utils.getDataSource(),true); //开启事务 public static void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //提交事务 public static void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //回滚事务 public static void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //释放资源 public static void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.3 新的问题上一小节的代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了一个新的问题：业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了。试想一下，如果我们此时提交，回滚，释放资源中任何一个方法名变更，都需要修改业务层的代码，况且这还只是一个业务层实现类，而实际的项目中这种业务层实现类可能有十几个甚至几十个。思考：这个问题能不能解决呢？答案是肯定的，使用下一小节中提到的技术。 2.4 动态代理回顾2.4.1 动态代理的特点字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 2.4.2 动态代理常用的两种方式1234567基于接口的动态代理提供者：JDK 官方的 Proxy 类。要求：被代理类最少实现一个接口。基于子类的动态代理提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。要求：被代理类不能用 final 修饰的类（最终类）。 2.4.3 使用JDK官方的Proxy类创建代理对象此处我们使用的是一个演员的例子：在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。 12345678910111213141516/*** 一个经纪公司的要求:* 能做基本的表演和危险的表演*/public interface IActor &#123; /** * 基本演出 * @param money */ public void basicAct(float money); /** * 危险演出 * @param money */ public void dangerAct(float money);&#125; 12345678910111213/*** 一个演员*///实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求public class Actor implements IActor&#123; public void basicAct(float money)&#123; System.out.println("拿到钱，开始基本的表演："+money); &#125; public void dangerAct(float money)&#123; System.out.println("拿到钱，开始危险的表演："+money); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Client &#123; public static void main(String[] args) &#123; //一个剧组找演员： final Actor actor = new Actor();//直接 /** * 代理： * 间接。 * 获取代理对象： * 要求： * 被代理类最少实现一个接口 * 创建的方式 * Proxy.newProxyInstance(三个参数) * 参数含义： * ClassLoader：和被代理对象使用相同的类加载器。 * Interfaces：和被代理对象具有相同的行为。实现相同的接口。 * InvocationHandler：如何代理。 * 策略模式：使用场景是： * 数据有了，目的明确。 * 如何达成目标，就是策略。 * */ IActor proxyActor = (IActor) Proxy.newProxyInstance( actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。 * 此方法有拦截的功能。 * * 参数： * proxy：代理对象的引用。不一定每次都用得到 * method：当前执行的方法对象 * args：执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String name = method.getName(); Float money = (Float) args[0]; Object rtValue = null; //每个经纪公司对不同演出收费不一样，此处开始判断 if("basicAct".equals(name))&#123; //基本演出，没有 2000 不演 if(money &gt; 2000)&#123; //看上去剧组是给了 8000，实际到演员手里只有 4000 //这就是我们没有修改原来 basicAct 方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; if("dangerAct".equals(name))&#123; //危险演出,没有 5000 不演 if(money &gt; 5000)&#123; //看上去剧组是给了 50000，实际到演员手里只有 25000 //这就是我们没有修改原来 dangerAct 方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); //没有经纪公司的时候，直接找演员。 // actor.basicAct(1000f); // actor.dangerAct(5000f); //剧组无法直接联系演员，而是由经纪公司找的演员 proxyActor.basicAct(8000f); proxyActor.dangerAct(50000f); &#125;&#125; 2.4.4 使用CGLib的Enhancer类创建代理对象还是那个演员的例子，只不过不让他实现接口。 123456789101112/*** 一个演员*/public class Actor&#123;//没有实现任何接口 public void basicAct(float money)&#123; System.out.println("拿到钱，开始基本的表演："+money); &#125; public void dangerAct(float money)&#123; System.out.println("拿到钱，开始危险的表演："+money); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Client &#123; /** * 基于子类的动态代理 * 要求： * 被代理对象不能是最终类 * 用到的类： * Enhancer * 用到的方法： * create(Class, Callback) * 方法的参数： * Class：被代理对象的字节码 * Callback：如何代理 * @param args */ public static void main(String[] args) &#123; final Actor actor = new Actor(); Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何 方法进行增强。 * * 参数： * 前三个和基于接口的动态代理是一样的。 * MethodProxy：当前执行方法的代理对象。 * 返回值： * 当前执行方法的返回值 */ @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; String name = method.getName(); Float money = (Float) args[0]; Object rtValue = null; if("basicAct".equals(name))&#123; //基本演出 if(money &gt; 2000)&#123; rtValue = method.invoke(actor, money/2); &#125; &#125; if("dangerAct".equals(name))&#123; //危险演出 if(money &gt; 5000)&#123; rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); cglibActor.basicAct(10000); cglibActor.dangerAct(100000); &#125;&#125; 思考：这个故事（示例）讲完之后，我们从中受到什么启发呢？它到底能应用在哪呢？ 2.5 解决案例中的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过我们此处不做那么繁琐）* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class BeanFactory &#123; /** * 创建账户业务层实现类的代理对象 * @return */ public static IAccountService getAccountService() &#123; //1.定义被代理对象 final IAccountService accountService = new AccountServiceImpl(); //2.创建代理对象 IAccountService proxyAccountService = (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(),new InvocationHandler() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。 * 此处添加事务控制 */ @Override public Object invoke(Object proxy, Method method,Object[] args) throws Throwable &#123; Object rtValue = null; try &#123; //开启事务 TransactionManager.beginTransaction(); //执行业务层方法 rtValue = method.invoke(accountService, args); //提交事务 TransactionManager.commit(); &#125;catch(Exception e) &#123; //回滚事务 TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; //释放资源 TransactionManager.release(); &#125; return rtValue; &#125; &#125;); return proxyAccountService; &#125;&#125; 当我们改造完成之后，业务层用于控制事务的重复代码就都可以删掉了。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在虚拟机上部署Web项目]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2Web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[目录 获取虚拟机的IP地址 使用putty连接Linux 在Linux上安装JDK 在Linuxs上安装Mysql 在Linux上安装tomcat 部署项目war包到tomcat 1. 获取虚拟机的IP地址如果我们想用工具来连接linux来进行操作，首先要获取虚拟机的IP地址，使用ifconfig命令，如果没有IP地址，则是没有设置开机时启动网上,设置操作如下： 1vim /etc/sysconfig/network-scripts/ifcfg-eth0 123TYPE=Ethernet #以太网BOOTPROTO=DHCP #dhcp方式分配网址 ONBOOT=yes #启动网卡 改完保存wq reboot [重启]之后才会生效 在本地ping一下：ping 192.168.228.129 2. 使用putty连接Linux 点击save可以保存一个设置，下次打开就可以直接用了。 选中gyf_centos01点击load按钮 然后输入账号密码就可以连接上虚拟机了 3. 在Linux上安装JDK3.1 卸载OpenJDKRPM 是RPM Package Manager（RPM软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。 1234执行命令查看:rpm -qa 是查看所有安装的软件 --nodeps 不验证软件包的依赖关系 -e 删除软件 1rpm –qa | grep java 查看和java相关的包 1rpm -e --nodeps java-1.60-openjdk-1.6.0.0-1.66.1 卸载OpenJDK 卸载完毕 3.2 创建JDK的安装路径12在/usr/local/ 创建文件夹javamkdir java 3.3 上传安装文件到Linux使用FileZilla-3.7.3上传 3.3.1 先连接到Linux 3.3.2 把下面的几个文件，拖到root目录下 12cd ~ll 3.4 解压tar.gz123首先需要安装依赖： yum install glibc.i686 【前提得能上网】 tar –xvf xxx.tar.gz –C /usr/local/java 3.5 配置环境变量1234567vim /etc/profile #set java environment JAVA_HOME=/usr/local/java/jdk1.7.0_72 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 12重新加载配置文件：source /etc/profile 4. 在Linuxs上安装Mysql4.1 卸载自带MySQL1234先查看有没有安装mysqlrpm -qa | grep mysql删除rpm -e --nodeps mysql-libs-5.1.71-1.el6.i686 4.2 创建MySQL的安装路径 4.3 解压MySQL1tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql 4.4 安装依赖（可选）12yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6yum update libstdc++-4.4.7-4.el6.x86_64 4.5 安装MySQL的服务端1rpm -ivh MySQL-server-5.5.49-1.linux2.6.i386.rpm 4.6 安装MySQL的客户端1rpm -ivh MySQL-client-5.5.49-1.linux2.6.i386.rpm 4.7 启动MySQL的服务12service mysql statusservice mysql start 4.8 登录MySQL1mysql –u root -p 12修改密码：set password = password(&apos;123456&apos;); 4.9 设置开机自动启动MySQL1234加入到系统服务：chkconfig --add mysql自动启动：chkconfig mysql on 4.10 开启远程服务123登录mysql授权可以远程访问:grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;123456&apos;;flush privileges; 4.11 设置Linux的防火墙1233306端口放行 且将该设置添加到防火墙的规则中/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save 配置完成以后，我们就在本地测试一下 5. 在Linux上安装tomcat5.1 创建tomcat的安装路径1在/usr/local 下mkdir tomcat 5.2 解压tomcat1tar –xvf xxx.tar.gz –C /usr/local/tomcat 5.3 设置防护墙12/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save 5.4 启动tomcat12进入到tomcat/bin执行 ./startup.sh 在本地访问一下tomcat 12关闭tomcat执行 ./shutdown.sh 6. 部署项目war包到tomcat先在linux的mysql创建表，初始化数据 把SSM web项目打包成war 1234567上传到linux的tomcat的webapps中导入windows的mysql数据和数据window导出mysqldump -uroot -p123456 bos &gt; C:/Users/guoyongfeng/Desktop/bos.sqllinux导入mysql&gt; source /root/bos.sql 访问项目 1234查看tomcat的进程idps -ef | grep java杀死tomcatkill 3355]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚拟机</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于注解的IoC配置和整合Junit]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IoC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%95%B4%E5%90%88Junit%2F</url>
    <content type="text"><![CDATA[目录 明确：写在前面 环境搭建 常用注解 Spring管理对象细节 Spring的纯注解配置 测试类中的问题和解决思路 配置步骤 为什么不把测试类配置到xml中 1. 明确：写在前面学习基于注解的 IoC 配置，大家脑海里首先得有一个认知，即注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握。 2. 环境搭建2.1 第一步：拷贝必备jar包到工程的lib目录注意：在基于注解的配置中，我们还要多拷贝一个 aop 的 jar 包。如下图： 2.2 第二步：使用@Component注解配置管理的资源123456789101112131415161718192021222324252627/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("accountService")public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125;&#125;/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("accountDao")public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit;&#125; 注意：当我们使用注解注入时，set 方法不用写 2.3 第三步：创建Spring的xml配置文件并开启对注解的支持 注意：基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。由于我们使用了注解配置，此时不能在继承 JdbcDaoSupport，需要自己配置一个 JdbcTemplate 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 告知 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置 dbAssit --&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 常用注解3.1 用于创建对象的 相当于：&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 3.1.1 @Componet作用：把资源让 spring 来管理。相当于在 xml 中配置一个 bean。属性：value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。 3.1.2 @Controller @Service @Repository他们三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。他们只不过是提供了更加明确的语义化。 123@Controller ：一般用于表现层的注解。@Service ：一般用于业务层的注解。@Repository ：一般用于持久层的注解。 细节：如果注解中有且只有一个属性 要赋值时是 ，且名称是 value ，value 3.2 用于注入数据的相当于：&lt;property name=&quot;&quot; ref=&quot;&quot;&gt;、&lt;property name=&quot;&quot; value=&quot;&quot;&gt; 3.2.1 @Autowired作用：自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他 bean 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 3.2.2 @Qualifier作用：在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用。属性：value：指定 bean 的 id。 3.2.3 @Resource作用：直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。属性：name：指定 bean 的 id。 3.2.4 @Value作用：注入基本数据类型和 String 类型数据的属性：value：用于指定值 3.3 用于改变作用范围的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt; 3.3.1 @Scope作用：指定 bean 的作用范围。属性：value：指定范围的值。取值：singleton prototype request session globalsession 3.4 和生命期相关的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot; /&gt; 3.4.1 @PostConstruct作用：用于指定初始化方法。 3.4.2 @PreDestroy作用：用于指定销毁方法。 3.5 关于Spring注解和XML的选择问题注解的优势：配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。XML 的优势：修改时，不用改源码。不涉及重新编译和部署。Spring 管理 Bean 方式的比较： 4. Spring管理对象细节基于注解的 spring IoC 配置中，bean 对象的特点和基于 XML 配置是一模一样的。 5. Spring的纯注解配置写到此处，基于注解的 IoC 配置已经完成，但是大家都发现了一个问题：我们依然离不开 spring 的 xml 配置文件，那么能不能不写这个 bean.xml，所有配置都用注解来实现呢？ 当然，同学们也需要注意一下，我们选择哪种配置的原则是简化开发和配置方便，而非追求某种技术。 5.1 待改造的问题我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置： 12&lt;!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中 --&gt;&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; 如果他要也能用注解配置，那么我们就离脱离 xml 文件又进了一步。 另外，数据源和 JdbcTemplate 的配置也需要靠注解来实现。 123456789101112&lt;!-- 配置 dbAssit --&gt;&lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 5.2 新注解说明5.2.1 @Configuration作用：用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration 注解的类.class)。属性：value:用于指定配置类的字节码 示例代码： 123456789/*** spring 的配置类，相当于 bean.xml 文件* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Configuration public class SpringConfiguration &#123;&#125; 注意：我们已经把配置文件用类来代替了，但是如何配置创建容器时要扫描的包呢？请看下一个注解。 5.2.2 @ComponentScan作用：用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;是一样的。属性：basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。示例代码： 12345678910/*** spring 的配置类，相当于 bean.xml 文件* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Configuration@ComponentScan("com.itheima") public class SpringConfiguration &#123;&#125; 注意：我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？请看下一个注解。 5.2.3 @Bean作用：该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。属性：name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。 示例代码： 123456789101112131415161718192021222324252627282930313233343536/*** 连接数据库的配置类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class JdbcConfig &#123; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setUser("root"); ds.setPassword("1234"); ds.setDriverClass("com.mysql.jdbc.Driver"); ds.setJdbcUrl("jdbc:mysql:///spring_day02"); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 创建一个 DBAssit，并且也存入 spring 容器中 * @param dataSource * @return */ @Bean(name="dbAssit") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSource); &#125;&#125; 注意:我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？请看下一个注解。 5.2.4 @PropertySource作用：用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。属性：value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath: 示例代码： 12345678910111213141516171819202122232425262728293031323334/*** 连接数据库的配置类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; jdbc.properties 文件： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/day44_ee247_springjdbc.username=rootjdbc.password=1234 注意：此时我们已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？请看下一个注解。 5.2.5 @Import作用：用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。属性：value[]：用于指定其他配置类的字节码。示例代码： 12345678910@Configuration@ComponentScan(basePackages = "com.itheima.spring")@Import(&#123; JdbcConfig.class&#125;)public class SpringConfiguration &#123;&#125;@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig&#123;&#125; 注意：我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？请看下一小节。 5.2.6 通过注解获取容器12ApplicationContext ac =new AnnotationConfigApplicationContext(SpringConfiguration.class); 5.3 工程结构图 6. 测试类中的问题和解决思路6.1 问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");IAccountService as = ac.getBean("accountService",IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 6.2 解决思路分析针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建spring 容器，我们就无须手动创建了，问题也就解决了。我们都知道，junit 单元测试的原理（在 web 阶段课程中讲过），但显然，junit 是无法实现的，因为它自己都无法知晓我们是否使用了 spring 框架，更不用说帮我们创建 spring 容器了。不过好在，junit 给我们暴露了一个注解，可以让我们替换掉它的运行器。这时，我们需要依靠 spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。 7. 配置步骤7.1 第一步：拷贝整合junit的必备jar包到lib目录此处需要注意的是，导入 jar 包时，需要导入一个 spring 中 aop 的 jar 包。 7.2 第二步：使用@RunWith注解替换原有运行器123456789/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)public class AccountServiceTest &#123;&#125; 7.3 第三步：使用@ContextConfiguration指定Spring配置文件的位置12345678910/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;)public class AccountServiceTest &#123;&#125; @ContextConfiguration 注解：locations 属性：用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明classes 属性：用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。 7.4 第四步：使用@Autowired给测试类中的变量注入数据12345678910111213/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;)public class AccountServiceTest &#123; @Autowired private IAccountService as ;&#125; 8. 为什么不把测试类配置到xml中在解释这个问题之前，先解除大家的疑虑，配到 XML 中能不能用呢？答案是肯定的，没问题，可以使用。那么为什么不采用配置到 xml 中的方式呢？这个原因是这样的：第一：当我们在 xml 中配置了一个 bean，spring 加载配置文件创建容器时，就会创建对象。第二：测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。所以，基于以上两点，我们不应该把测试配置到 xml 文件中。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyUI快速入门]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31-EasyUI%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 什么是EasyUI 第一个HelloWorld程序 创建和配置的方式 linkbutton的初始化原理 核心 常用的组件 综合案例 1. 什么是EasyUIjQuery EasyUI是一组基于jQuery的UI插件集合，而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript，也不需要对css样式有深入的了解，开发者只有需要了解一些简单的html标签。 jQuery EasyUI为我们提供了大多数UI控件的使用，如：accordion，combobox，menu，dialog，tabs，tree，validatebox，window等等。 特点: 上手很简单 功能丰富 美观的UI界面. 2. 第一个HelloWorld程序1234567891011121314步骤:1.导入相关的资源2.在页面中引入相关的配置信息&lt;link rel="stylesheet" type="text/css" href="../jquery-easyui/themes/default/easyui.css"&gt;&lt;!-- 样式文件 --&gt; &lt;link rel="stylesheet" type="text/css" href="../jquery-easyui/themes/icon.css"&gt; &lt;!-- 图标样式 --&gt; &lt;script type="text/javascript" src="../jquery-easyui/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- jQuery核心库 --&gt; &lt;script type="text/javascript" src="../jquery-easyui/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;!-- EasyUI核心库 --&gt;3.在页面添加对应的标签.每个组件都有对应的标签例如按钮就必须是&lt;a&gt;标签4.在标签上添加class=”easyui-插件名”,插件名必须全小写的.5.可以使用data-options来配置组件 3. 创建和配置的方式创建方式： 1.在页面标签中直接使用class=”easyui-插件名”来初始化组件. 1&lt;input class="easyui-datebox" name="time"&gt; 2.使用JS的初始化方式(推荐使用) 页面中： 1&lt;div id="myPanel" title="新新的标题头" data-options="width:800"&gt;EasyUI的面板&lt;/div&gt; JS中: 123456$(function()&#123; $("#myPanel").panel(&#123; height:800, title:'js中的标题' &#125;);&#125;); 配置方式： 1.在标签体重使用data-options配置信息. 1&lt;div class="easyui-panel" data-options="title:'EasyUI面板'" style="width:200px;height: 200px;"&gt;EasyUI的面板&lt;/div&gt; 2.直接在标签上配置属性,&lt;div title=&quot;标题&quot; class=&quot;easyui-panel&quot;&gt;&lt;div&gt; 3.在JS中最配置(推荐使用) 页面中： 1&lt;div id=&quot;myPanel&quot; title=&quot;标题&quot;&gt;&lt;/div&gt; JS中： 123456$(function()&#123; $("#myPanel").panel(&#123; height:800, title:'js中的标题' &#125;);&#125;); 注意:三种方式都是可以混合使用的.JS中的配置会覆盖页面中的配置. 4. linkbutton的初始化原理1.所有的标签都以class=”easyui-插件名“,通过筛选器可以找到这些标签. 2.在EasyUI代码中,准备好了一大堆的模板和样式类. 3.根据到底是什么标签,给对应的标签加上模板和样式类. 12345678910111213//放在页面加载完毕后执行$(function()&#123; //1.先获取到需要初始化的组件 var myBtn = $(".myButton"); //2.拿到一开始定义文本信息 var text = myBtn.html(); //3.定义模板 var temp = '&lt;span class="l-btn-left"&gt;&lt;span class="l-btn-text"&gt;'+text+'&lt;/span&gt;&lt;/span&gt;'; //4.在标签中插入模板 myBtn.html(temp); //5.给组件添加样式 myBtn.addClass("easyui-linkbutton l-btn");&#125;); 5. 核心5.1 属性所有的属性都定义在jQuery.fn.{plugin}.defaults里面。例如，对话框属性定义在jQuery.fn.dialog.defaults里面。 Panel（面板） 使用$.fn.panel.defaults重写默认值对象。 面板作为承载其它内容的容器。这是构建其他组件的基础（比如：layout,tabs,accordion等）。它还提供了折叠、关闭、最大化、最小化和自定义行为。面板可以很容易地嵌入到web页面的任何位置。 常用属性: 1234567891011121314151617title:设置标题iconCls :设置一个16x16图标的CSS类ID显示在面板左上角。 headerCls：添加一个CSS类ID到面板头部。 null bodyCls ： 添加一个CSS类ID到面板正文部分。 fit:当设置为true的时候面板大小将自适应父容器border boolean 定义是否显示面板边框。 collapsible boolean 定义是否显示可折叠按钮。 false minimizable boolean 定义是否显示最小化按钮。 false maximizable boolean 定义是否显示最大化按钮。 false closable boolean 定义是否显示关闭按钮。 collapsed boolean 定义是否在初始化的时候折叠面板。 false minimized boolean 定义是否在初始化的时候最小化面板。 false maximized boolean 定义是否在初始化的时候最大化面板。 false closed boolean 定义是否在初始化的时候关闭面板。 href:从远程加载文本内容cache：如果为true，在超链接载入时缓存面板内容。loadingMessage string 在加载远程数据的时候在面板内显示一条消息 使用$.fn.panel.defaults给组件添加默认值. 给组件添加默认标题. $.fn.panel.defaults.title=”默认标题”; 5.2 事件所有的事件（回调函数）也都定义在jQuery.fn.{plugin}.defaults里面。 fn大多都是以on开头的,大部分复杂组件,都可以在初始化时,使用onxxx属性配置,值为事件响应 onCollapse 折叠是触发 onExpand 展开时触发 小部分简单组件,还是使用JQuery事件监听方式,使用on方法添加事件.例如linkbutton linkButton没有事件，需要通过jquery的方式去处理.$(“#button”).on(“click”,functtion(){}); 5.3 方法调用方法的语法：$(‘selector’).plugin(‘method’, parameter); 和我们以前的调用方法的方式有些不同. 调用panel的打开方法 $(“#myPanel”).panel(“open”); $(“组件”).插件名(“方法名”,方法参数) 6. 常用的组件6.1 LinkButton(按钮)使用$.fn.linkbutton.defaults重写默认值对象。 按钮组件使用超链接按钮创建。它使用一个普通的&lt;a&gt;标签进行展示。它可以同时显示一个图标和文本,或只有图标或文字。按钮的宽度可以动态和折叠/展开以适应它的文本标签。 常用属性： iconCls：配置图标信息 plain:简洁风格 常用方法: enable：变亮按钮 disable：变灰按钮 6.2 Window(窗口)扩展自$.fn.panel.defaults。使用$.fn.window.defaults重写默认值对象。 窗口控件是一个浮动和可拖拽的面板可以用作应用程序窗口。默认情况下,窗口可以移动,调整大小和关闭。它的内容也可以被定义为静态html或要么通过ajax动态加载 常用属性: draggable boolean 定义是否能够拖拽窗口。 true resizable boolean 定义是否能够改变窗口大小。 true modal:定义是否将窗体显示为模式化窗口。 （起到遮蔽的效果） 6.3 Dialog(对话窗口)扩展自$.fn.window.defaults。使用$.fn.dialog.defaults重写默认值对象。 该对话框是一种特殊类型的窗口，它在顶部有一个工具栏，在底部有一个按钮栏。对话框窗口右上角只有一个关闭按钮用户可以配置对话框的行为显示其他工具,如collapsible,minimizable,maximizable工具等。 6.4 Dialog上的按钮创建按钮的方式: 1.array:通过数组的方式配置按钮 12345678910111213141516171819$(function()&#123; $("#myDialog").dialog(&#123; width:200, height:200, tools:[ &#123; iconCls:'icon-add', handler:function()&#123; alert("add"); &#125;, &#123; iconCls:'icon-edit', handler:function()&#123; alert("edit"); &#125; &#125; ] &#125;);&#125;); 2.selector:通过选择器的方式 1.工具栏按钮(tools)： 页面： 1234&lt;div id="tt"&gt; &lt;a class="icon-add" onclick="javascript:alert('iconadd')"&gt;&lt;/a&gt; &lt;a class="icon-remove" onclick="javascript:alert('iconremove')"&gt;&lt;/a&gt;&lt;/div&gt; JS中： 12345$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt'&#125;); 2.顶部按钮（toolbar）： 12345&lt;!--配置顶部按钮--&gt;&lt;div id="tb"&gt; &lt;a class="easyui-linkbutton" iconCls="icon-add" plain="true"&gt;新增&lt;/a&gt; &lt;a class="easyui-linkbutton" iconCls="icon-edit" plain="true"&gt;编辑&lt;/a&gt;&lt;/div&gt; 123456$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt', toolbar:'#tb'&#125;); 3.底部按钮 1234&lt;div id="bb"&gt; &lt;a href="#" class="easyui-linkbutton" iconCls="icon-save"&gt;保存&lt;/a&gt; &lt;a href="#" class="easyui-linkbutton" iconCls="icon-cancel"&gt;关闭&lt;/a&gt;&lt;/div&gt; 1234567$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt', toolbar:'#tb', buttons:'#bt'&#125;); 6.5 Tabs(选项卡)使用$.fn.tabs.defaults重写默认值对象。 选项卡显示一批面板。但在同一个时间只会显示一个面板。每个选项卡面板都有头标题和一些小的按钮工具菜单，包括关闭按钮和其他自定义按钮。 1234567891011121314151617181920212223//放在页面加载完毕后执行$(function() &#123; // 获取组件 var myTabs = $("#myTabs"); myTabs.tabs(&#123; width:500, height:'auto' &#125;); // 获取所有panel集合 var panelArr = myTabs.tabs("tabs"); // 循环 for ( var i = 0; i &lt; panelArr.length; i++) &#123; var panelUI = panelArr[i]; var title = panelUI.panel("options").tab; console.debug(panelUI.panel("options")); // 找到头部信息,添加鼠标移入事件 title.off().on("mouseenter", &#123;index : i&#125;, function(e) &#123; // 选中面板 myTabs.tabs("select", e.data.index); &#125;) &#125;&#125;); 动态添加选项卡和删除选项卡. 12345678910111213141516171819202122232425262728//放在页面加载完毕后执行$(function() &#123; // 获取组件 var myTabs = $("#myTabs"); myTabs.tabs(&#123; width:500, height:400, tools:'#tab-tools' &#125;);&#125;);var index = 0;function addPanel() &#123; // 往tabs动图添加选项卡 var myTabs = $("#myTabs"); myTabs.tabs("add", &#123; title : '面板'+(++index), closable : true, content : '面板' &#125;);&#125;function removePanel() &#123; // 目前哪个选中,就删除哪个. var myTabs = $("#myTabs"); var tabs = myTabs.tabs("getSelected"); var index = myTabs.tabs('getTabIndex', tabs); console.debug(index); myTabs.tabs("close", index);&#125; 6.6 DataGrid(数据表格)扩展自$.fn.panel.defaults。使用$.fn.datagrid.defaults重写默认值对象。 数据表格以表格形式展示数据，并提供了丰富的选择、排序、分组和编辑数据的功能支持。数据表格的设计用于缩短开发时间，并且使开发人员不需要具备特定的知识。它是轻量级的且功能丰富。单元格合并、多列标题、冻结列和页脚只是其中的一小部分功能。 常用属性: 1234567title:'数据表格',url:'data.json',//从远程地址获取对应的数据，对数据格式有要求,必须是要求格式.striped:true,//斑马线效果singleSelect:true,//单选操作toolbar:'#tb',//顶部按钮pagination:true,//配置分页栏信息fitColumns:true//表头自适应网格,需要和表头中width配合使用,此时width表示比例 列常用属性: 12345field:'listprice',//映射后台那个数据formatter:priceFormatter,//格式化函数width:1//如果没有和fitColumns配合使用表示普通的px值,如果和fitColumns配合使用,表示比例.rowspan:2//行合并colspan:5:列合并. 12345&lt;thead data-options="frozen:true"&gt; &lt;tr&gt; &lt;th data-options="field:'productid',rowspan:2,halign:'center'"&gt;产品ID&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; JS中配置表头 123456789101112131415161718frozenColumns:[ [ &#123;field:'productid',title:'产品ID',rowspan:2&#125; ] ], columns:[ [ &#123;field:'productname',title:'产品名称',width:1,rowspan:2&#125;, &#123;title:'汇总信息',width:1,colspan:5&#125; ], [ &#123;field:'unitcost',title:'成本单价',width:1&#125;, &#123;field:'status',title:'状态',width:1&#125;, &#123;field:'listprice',title:'售价',width:1&#125;, &#123;field:'attr1',title:'属性',width:1&#125;, &#123;field:'itemid',title:'分类ID',width:1&#125; ] ] 效果图： 6.7 Tree(树)使用$.fn.tree.defaults重写默认值对象。 树控件在web页面中一个将分层数据以树形结构进行显示。它提供用户展开、折叠、拖拽、编辑和异步加载等功能。 常用属性: 1234567url:远程地址,数据是要求的.标准JSON格式formatter：格式化函数lines:true,//节点之间通过线条连接animate:true,//展开收缩有动画效果. 常用事件: 123onClick：点击触发onDblClick：双击触发onSelect：选中触发. 12345678910111213141516171819202122232425262728293031323334353637$(function()&#123; //完成功能,双击自动展开或者收缩节点 //1,监听鼠标双击的事件. //2.判断节点的状态 // 如果是展开展开,让节点收缩 // 如果节点为收缩,让节点展开. $("#myTree").tree(&#123; url:'tree.json', animate:true, checkbox:true, lines:true, dnd:true, onDblClick:function(node)&#123; console.log(node); if(node.state=='open')&#123; //调用tree组件的收缩方法 $("#myTree").tree("collapse",node.target); &#125;else&#123; //调用tree组件的展开方法 $("#myTree").tree("expand",node.target); &#125; &#125;, formatter:function(node)&#123; //需要判断一下节点是否有子元素 if(node.children)&#123; //如果有 //返回的内容修改 return node.text+"("+node.children.length+")"; &#125;else&#123; //如果没有 //返回原样内容 return node.text; &#125; &#125; &#125;);&#125;); 7. 综合案例1234567891011121314151.对页面进行布局.&lt;div class=”easyui-layou”&gt; &lt;div data-options=”region:&apos;north&apos;”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;east&apos;”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;center”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;sourth&apos;”&gt;&lt;/div&gt;&lt;/div&gt;2.设置logo和版权信息.3.在左侧添加手风琴效果+树组件。4.在中间部分添加tabs组件,显示对应的数据.5.菜单添加对应的点击事件. 7.1 员工新增1.定义datagrid展示员工的数据 2.添加分页栏+顶部按钮. 3.添加员工新增的对话框(默认隐藏) 4.给新增按钮添加对应的时间,触发对话的显示. 5.监听保存按钮的事件，通过异步的方式提交数据到后台 7.2 员工编辑1.编辑的时候需要打开对话框. 2.对内容进行回显(基于同名匹配规则) 7.3 员工删除1.判断用户是否有选中数据. 2.让用户确定是否需要删除该数据. 3.调用ajax请求,把id传递到后台,进行删除. 4.提示操作反馈信息，刷新数据表格. 7.4 集成到首页中注意:href只加载body部分的内容.会发生页面不对的情况.建议使用content]]></content>
      <categories>
        <category>前端</category>
        <category>EasyUI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>EasyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring的IoC实现账户的CRUD]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31-%E4%BD%BF%E7%94%A8Spring%E7%9A%84IoC%E5%AE%9E%E7%8E%B0%E8%B4%A6%E6%88%B7%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[目录 需求和技术要求 环境搭建 配置步骤 测试案例 1. 需求和技术要求1.1 需求实现账户的CRUD操作 1.2 技术要求 使用 spring 的 IoC 实现对象的管理使用 DBAssit 作为持久层解决方案使用 c3p0 数据源 2. 环境搭建2.1 拷贝jar包 2.2 创建数据库和编写实体类123456789create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci;insert into account(name,money) values(&apos;aaa&apos;,1000);insert into account(name,money) values(&apos;bbb&apos;,1000);insert into account(name,money) values(&apos;ccc&apos;,1000); 12345678910111213141516171819202122232425262728293031/*** 账户的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 2.3 编写持久层代码123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存 * @param account */ void save(Account account); /** * 更新 * @param account */ void update(Account account); /** * 删除 * @param accountId */ void delete(Integer accountId); /** * 根据 id 查询 * @param accountId * @return */ Account findById(Integer accountId); /** * 查询所有 * @return */ List&lt;Account&gt; findAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit; public void setDbAssit(DBAssit dbAssit) &#123; this.dbAssit = dbAssit; &#125; @Override public void save(Account account) &#123; dbAssit.update("insert into account(name,money)values(?,?)",account.getName(),account.getMoney()); &#125; @Override public void update(Account account) &#123; dbAssit.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId()); &#125; @Override public void delete(Integer accountId) &#123; dbAssit.update("delete from account where id=?",accountId); &#125; @Override public Account findById(Integer accountId) &#123; return dbAssit.query("select * from account where id=?",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; @Override public List&lt;Account&gt; findAll() &#123; return dbAssit.query("select * from account where id=?",new BeanListHandler&lt;Account&gt;(Account.class)); &#125;&#125; 2.4 编写业务层代码123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户 * @param account */ void saveAccount(Account account); /** * 更新账户 * @param account */ void updateAccount(Account account); /** * 删除账户 * @param account */ void deleteAccount(Integer accountId); /** * 根据 id 查询账户 * @param accountId * @return */ Account findAccountById(Integer accountId); /** * 查询所有账户 * @return */ List&lt;Account&gt; findAllAccount();&#125; 123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void saveAccount(Account account) &#123; accountDao.save(account); &#125; @Override public void updateAccount(Account account) &#123; accountDao.update(account); &#125; @Override public void deleteAccount(Integer accountId) &#123; accountDao.delete(accountId); &#125; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findById(accountId); &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAll(); &#125;&#125; 2.5 创建并编写配置文件 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 3. 配置步骤3.1 配置对象123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 service --&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 dao --&gt; &lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 dbAssit 此处我们只注入了数据源，表明每条语句独立事务--&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4. 测试案例4.1 测试类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceTest &#123; /** * 测试保存 */ @Test public void testSaveAccount() &#123; Account account = new Account(); account.setName("黑马程序员"); account.setMoney(100000f); ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.saveAccount(account); &#125; /** * 测试查询一个 */ @Test public void testFindAccountById() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); Account account = as.findAccountById(1); System.out.println(account); &#125; /** * 测试更新 */ @Test public void testUpdateAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); Account account = as.findAccountById(1); account.setMoney(20301050f); as.updateAccount(account); &#125; /** * 测试删除 */ @Test public void testDeleteAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.deleteAccount(1); &#125; /** * 测试查询所有 */ @Test public void testFindAllAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); List&lt;Account&gt; list = as.findAllAccount(); for(Account account : list) &#123; System.out.println(account); &#125; &#125;&#125; 4.2 分析测试中的问题通过上面的测试类，我们可以看出，每个测试方法都重新获取了一次 spring 的核心容器，造成了不必要的重复代码，增加了我们开发的工作量。这种情况，在开发中应该避免发生。有些同学可能想到了，我们把容器的获取定义到类中去。例如： 12345678910/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceTest &#123; private ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); private IAccountService as = ac.getBean("accountService",IAccountService.class);&#125; 这种方式虽然能解决问题，但是扔需要我们自己写代码来获取容器。能不能测试时直接就编写测试方法，而不需要手动编码来获取容器呢？]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架概述]]></title>
    <url>%2F2019%2F05%2F30%2F2019-05-30-Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 Spring框架概述 Ioc的概念和作用 案例的前期准备 基于XML的配置 Spring基于XML的IoC细节 Spring配置文件中提示的配置 1. Spring框架概述1.1 Spring是什么Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 1.2 Spring的发展历程1997 年 IBM提出了EJB 的思想1998 年，SUN制定开发标准规范 EJB1.01999 年，EJB1.1 发布2001 年，EJB2.0 发布2003 年，EJB2.1 发布2006 年，EJB3.0 发布Rod Johnson （ spring 之父）Expert One-to-One J2EE Design and Development(2002)阐述了 J2EE 使用EJB 开发设计的优点及解决方案Expert One-to-One J2EE Development without EJB(2004)阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）2017 年 9 9 月份发布了 g spring 的最新版本 0 spring 5.0 通用版 (GA) 1.3 Spring的优势方便解耦，简化开发通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。AOP 编程的支持通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。方便集成各种优秀框架Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。低降低 JavaEE API 的使用难度Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。Java 源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 1.4 Spring的体系结构 2. 程序的耦合和解耦2.1 什么是程序的耦合耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚低耦合。 它有如下分类： （1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 我们在开发 中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码： 123456789/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();&#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决。 再比如：早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采用 Class.forName 的方式？ 123456789101112131415161718public class JdbcDemo1 &#123; /** * @author 黑马程序员 * @Company http://www.ithiema.com * @Version 1.0 * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName("com.mysql.jdbc.Driver"); //2.获取连接 //3.获取预处理 sql 语句对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 原因就是：我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要修改源码来重新数据库驱动。这显然不是我们想要的。 2.2 解决程序耦合的思路当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： 1Class.forName("com.mysql.jdbc.Driver");//此处只是一个字符串 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。 2.3 工厂模式解耦在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来 并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 2.4 控制反转-Inversion Of Control上一小节解耦的思路有 2 个问题：1 、存哪去？分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。所以我们的答案就是在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 map 称之为 容器。2、还是没解释什么是工厂？工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。原来：我们在获取对象时，都是采用 new 的方式。是主动的。 现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。 明确 ioc 的作用：削减计算机程序的耦合(解除我们代码中的依赖关系)。 3. 案例的前期准备本章我们使用的案例是，账户的业务层和持久层的依赖关系解决。在开始 spring 的配置之前，我们要先准备一下环境。由于我们是使用 spring 解决依赖关系，并不是真正的要做增删改查操作，所以此时我们没必要写实体类。并且我们在此处使用的是 java 工程，不是 java web 工程。 3.1 尊卑Spring的开发包官网：http://spring.io/下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring 目录结构:) docs :API 和开发规范. libs :jar 包和源码. schema :约束. 我们使用的版本是 是 spring5.0.2 。特别说明：spring5 版本是用 jdk8 编写的，所以要求我们的 jdk 版本是 8 及以上。时 同时 tomcat 的版本要求 8.5 3.2 创建业务接口和实现类123456789101112/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户（此处只是模拟，并不是真的要保存） */ void saveAccount();&#125; 123456789101112131415/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();// 此处的依赖关系有待解决 @Override public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 3.3 创建持久层接口和实现类123456789101112/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存账户 */ void saveAccount();&#125; 123456789101112/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountDaoImpl implements IAccountDao &#123; @Override public void saveAccount() &#123; System.out.println("保存了账户"); &#125;&#125; 4. 基于XML的配置4.1 第一步：拷贝必备的jar包到工程的lib目录中 4.2 第二步：在类的根路径下创建一个任意名称的xml文件（不能是中文） 给配置文件导入约束： /spring-framework-5.0.2.RELEASE/docs/spring-framework-reference/html5/core.html 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 4.3 第三步：让Spring管理资源，在配置文件中配置service和dao12345678&lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中 id 属性：对象的唯一标识。 class 属性：指定要创建对象的全限定类名--&gt;&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt; 4.4 测试配置是否成功123456789101112131415161718192021/*** 模拟一个表现层* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Client &#123; /** * 使用 main 方法获取容器测试执行 */ public static void main(String[] args) &#123; //1.使用 ApplicationContext 接口，就是在获取 spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 bean 的 id 获取对象 IAccountService aService = (IAccountService) ac.getBean("accountService"); System.out.println(aService); IAccountDao aDao = (IAccountDao) ac.getBean("accountDao"); System.out.println(aDao); &#125;&#125; 运行结果： 5. Spring基于XML的IoC细节5.1 Spring中工厂的类结构图 5.1.1 BeanFactory和ApplicationContext的区别BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。BeanFactory 和 ApplicationContext 的区别：创建对象的时间点不一样。ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。BeanFactory：什么时候使用什么时候创建对象。 5.1.2 ApplicationContext接口的实现类123456ClassPathXmlApplicationContext ：它是从类的根路径下加载配置文件 推荐使用这种FileSystemXmlApplicationContext ：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 5.2 IoC中bean标签和管理对象细节5.2.1 bean标签作用：用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性：id：给对象在容器中提供一个唯一标识。用于获取对象。class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。scope：指定对象的作用范围。 singleton :默认值，单例的. prototype :多例的. request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session. init-method：指定类中的初始化方法名称。destroy-method：指定类中销毁方法名称。 5.2.2 bean的作用范围和生命周期单例对象：scope=&quot;singleton&quot;一个应用只有一个对象的实例。它的作用范围就是整个引用。生命周期：对象出生：当应用加载，创建容器时，对象就被创建了。对象活着：只要容器在，对象一直活着。对象死亡：当应用卸载，销毁容器时，对象就被销毁了。多例对象：scope=&quot;prototype&quot;每次访问对象时，都会重新创建对象实例。生命周期：对象出生：当使用对象时，创建新的对象实例。对象活着：只要对象在使用中，就一直活着。对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 5.2.3 实例化Bean的三种方式第一种方式：使用默认无参构造函数 1234&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"/&gt; 第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象 1234567891011121314151617/*** 模拟一个静态工厂，创建业务层实现类*/public class StaticFactory &#123; public static IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器 id 属性：指定 bean 的 id，用于从容器中获取 class 属性：指定静态工厂的全限定类名 factory-method 属性：指定生产对象的静态方法--&gt;&lt;bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象 12345678910111213141516171819/*** 模拟一个实例工厂，创建业务层实现类* 此工厂创建对象，必须现有工厂实例对象，再调用方法*/public class InstanceFactory &#123; public IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是： 先把工厂的创建交给 spring 来管理。 然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。 factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id="instancFactory" class="com.itheima.factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instancFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 5.3 Spring的依赖注入5.3.1 依赖注入的概念依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 5.3.2 构造函数注入顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。具体代码如下： 12345678910111213141516171819/***/public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 12345678910111213141516171819202122&lt;!-- 使用构造函数的方式，给 service 中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 用这个找给谁赋值=======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和 String 类型 ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg name="name" value=" 张三 "&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 5.3.3 set方法注入顾名思义，就是在类中提供需要注入成员的 set 方法。具体代码如下： 123456789101112131415161718192021public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 12345678910111213141516&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式 涉及的标签： property 属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发中，此种方式用的较多。--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 5.3.4 使用p名称空间注入数据（本质还是调用set方法）此种方式是通过在 xml中导入 p名称空间，使用 p:propertyName 来注入数据，它的本质仍然是调用类中的set 方法实现注入功能。Java 类代码： 123456789101112131415161718192021222324/*** 使用 p 名称空间注入，本质还是调用类中的 set 方法*/public class AccountServiceImpl4 implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 配置文件代码： 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl4" p:name="test" p:age="21" p:birthday-ref="now"/&gt;&lt;/beans&gt; 5.3.5 注入集合属性顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 12345678910111213141516171819202122232425262728293031323334/***/public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- 注入集合数据 List 结构的： array,list,set Map 结构的 map,entry,props,prop--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name="myStrs"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入 list 集合数据 --&gt; &lt;property name="myList"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 注入 set 集合数据 --&gt; &lt;property name="mySet"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入 Map 数据 --&gt; &lt;property name="myMap"&gt; &lt;props&gt; &lt;prop key="testA"&gt;aaa&lt;/prop&gt; &lt;prop key="testB"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入 properties 数据 --&gt; &lt;property name="myProps"&gt; &lt;map&gt; &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt; &lt;entry key="testB"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 6. Spring配置文件中提示的配置]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解开发]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-Mybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[目录 mybatis的常用注解说明 使用Mybatis注解实现基本CRUD 使用注解实现复杂关系映射开发 mybatis基于注解的二级缓存 这几年来注解开发越来越流行，Mybatis 也可以使用注解开发方式，这样我们就可以减少编写 Mapper 映射文件了。本次我们先围绕一些基本的 CRUD 来学习，再学习复杂映射关系及延迟加载。 1. mybatis的常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用 2. 使用Mybatis注解实现基本CRUD单表的 CRUD 操作是最基本的操作，前面我们的学习都是基于 Mybaits 的映射文件来实现的。 2.1 编写实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 注意：此处我们故意和数据库表的列名不一致。 2.2 使用注解方式开发持久层接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据 id 查询一个用户 * @param userId * @return */ @Select("select * from user where id = #&#123;uid&#125; ") @ResultMap("userMap") User findById(Integer userId); /** * 保存操作 * @param user * @return */ @Insert("insert into user(username,sex,birthday,address)values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125; )") @SelectKey(keyColumn="id",keyProperty="id",resultType=Integer.class,before = false, statement = &#123; "select last_insert_id()" &#125;) int saveUser(User user); /** * 更新操作 * @param user * @return */ @Update("update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id =#&#123;id&#125; ") int updateUser(User user); /** * 删除用户 * @param userId * @return */ @Delete("delete from user where id = #&#123;uid&#125; ") int deleteUser(Integer userId); /** * 查询使用聚合函数 * @return */ @Select("select count(*) from user ") int findTotal(); /** * 模糊查询 * @param name * @return */ @Select("select * from user where username like #&#123;username&#125; ") List&lt;User&gt; findByName(String name);&#125; 通过注解方式，我们就不需要再去编写 UserDao.xml 映射文件了。 2.3 编写SqlMapConfig配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 properties 文件的位置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置别名的注册 --&gt; &lt;typeAliases&gt; &lt;package name="com.itheima.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型是 JDBC --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射信息 --&gt; &lt;mappers&gt; &lt;!-- 配置 dao 接口的位置，它有两种方式 第一种：使用 mapper 标签配置 class 属性 第二种：使用 package 标签，直接指定 dao 接口所在的包 --&gt; &lt;package name="com.itheima.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4 编写测试方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/**** &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt;* &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisAnnotationCRUDTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试查询一个 */ @Test public void testFindById() &#123; User user = userDao.findById(41); System.out.println(user); &#125; /** * 测试保存 */ @Test public void testSave() &#123; User user = new User(); user.setUserName("mybatis annotation"); user.setUserSex("男"); user.setUserAddress("北京市顺义区"); user.setUserBirthday(new Date()); int res = userDao.saveUser(user); System.out.println("影响数据库记录的行数："+res); System.out.println("插入的主键值："+user.getUserId()); &#125; /** * 测试更新 */ @Test public void testUpdate() &#123; User user = userDao.findById(63); user.setUserBirthday(new Date()); user.setUserSex("女"); int res = userDao.updateUser(user); System.out.println(res); &#125; /** * 测试删除 */ @Test public void testDelete() &#123; int res = userDao.deleteUser(63); System.out.println(res); &#125; /** * 测试查询使用聚合函数 */ @Test public void testFindTotal() &#123; int res = userDao.findTotal(); System.out.println(res); &#125; /** * 测试模糊查询 */ @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findByName("%m%"); for(User user : users) &#123; System.out.println(user); &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit 的注解 public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in); //3.创建 session session = factory.openSession(); //4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123; //提交事务 session.commit(); //释放资源 session.close(); //关闭流 in.close(); &#125; &#125; 3. 使用注解实现复杂关系映射开发实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，在使用注解开发时我们需要借助@Results 注解，@Result 注解，@One 注解，@Many 注解。 3.1 复杂关系映射的注解说明12345678910111213141516171819202122232425262728@Results 注解代替的是标签&lt;resultMap&gt;该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（&#123;@Result（），@Result（）&#125;）或@Results（@Result（））@Resutl 注解代替了 &lt;id&gt; 标签和&lt;result&gt; 标签@Result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解（@Result（one=@One）（））） many 需要使用的@Many 注解（@Result（many=@many）（）））@One 注解（一对一） 代替了&lt;assocation&gt; 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One 注解属性介绍： select 指定用的 来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。使用格式： @Result(column=" ",property="",one=@One(select=""))@Many 注解（多对一） 代替了&lt;Collection&gt; 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType（一般为 ArrayList）但是注解中可以不定义；使用格式： @Result(property="",column="",many=@Many(select="")) 3.2 使用注解实现一对一复杂关系映射及延迟加载需求：加载账户信息时并且加载该账户的用户信息，根据情况可实现延迟加载。（注解方式实现） 3.2.1 添加User实体类及Account实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一关系映射：从表方应该包含一个主表方的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 3.2.2 添加账户的持久层接口并使用注解配置1234567891011121314151617181920212223242526/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，采用延迟加载的方式查询账户的所属用户 * @return */ @Select("select * from account") @Results(id="accountMap", value= &#123; @Result(id=true,column="id",property="id"), @Result(column="uid",property="uid"), @Result(column="money",property="money"), @Result(column="uid", property="user", one=@One(select="com.itheima.dao.IUserDao.findById", fetchType=FetchType.LAZY) ) &#125;) List&lt;Account&gt; findAll();&#125; 3.2.3 添加用户的持久层接口并使用注解配置1234567891011121314151617181920212223242526272829303132/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据 id 查询一个用户 * @param userId * @return */ @Select("select * from user where id = #&#123;uid&#125; ") @ResultMap("userMap") User findById(Integer userId);&#125; 3.2.4 测试一对一关联及延迟加载12345678910111213141516/**** &lt;p&gt;Title: AccountTest&lt;/p&gt;* &lt;p&gt;Description: 账户的测试类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll(); // for(Account account : accounts) &#123; // System.out.println(account); // System.out.println(account.getUser()); // &#125;&#125; 3.3 使用注解实现一对多复杂关系映射需求：查询用户信息时，也要查询他的账户列表。使用注解方式实现。分析：一个用户具有多个账户信息，所以形成了用户(User)与账户(Account)之间的一对多关系。 3.3.1 User实体类加入List&lt;Account&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; //一对多关系映射：主表方法应该包含一个从表方的集合引用 private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 3.3.2 编写用户的持久层接口并使用注解配置1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday"), @Result(column="id",property="accounts", many=@Many( select="com.itheima.dao.IAccountDao.findByUid", fetchType=FetchType.LAZY ) ) &#125;) List&lt;User&gt; findAll();&#125; @Many:相当于&lt;collection&gt;的配置select 属性：代表将要执行的 sql 语句fetchType 属性：代表加载方式，一般如果要延迟加载都设置为 LAZY 的值 3.3.3 编写账户的持久层接口并使用注解配置123456789101112131415/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 根据用户 id 查询用户下的所有账户 * @param userId * @return */ @Select("select * from account where uid = #&#123;uid&#125; ") List&lt;Account&gt; findByUid(Integer userId);&#125; 3.3.4 添加测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**** &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt;* &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); // for(User user : users) &#123; // System.out.println("-----每个用户的内容-----"); // System.out.println(user); // System.out.println(user.getAccounts()); // &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit 的注解 public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in); //3.创建 session session = factory.openSession(); //4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123; //提交事务 session.commit(); //释放资源 session.close(); //关闭流 in.close(); &#125;&#125; 4. mybatis基于注解的二级缓存4.1 在SqlMapConfig中开启二级缓存支持12345&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 4.2 在持久层接口中使用注解配置二级缓存12345678/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis延迟加载策略与缓存]]></title>
    <url>%2F2019%2F05%2F28%2F2019-05-28-Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[目录 何为延迟加载 实现需求 使用assocation实现延迟加载 使用Collection实现延迟加载 Mybatis一级缓存 Mybatis二级缓存 通过前面的学习，我们已经掌握了 Mybatis 中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。 1. 何为延迟加载延迟加载：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处 ：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 2. 实现需求需求：查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。 昨天实现多表操作时，我们使用了resultMap来实现一对一，一对多，多对多关系的操作。主要是通过 association、collection 实现一对一及一对多映射。association、collection 具备延迟加载功能。 3. 使用assocation实现延迟加载需求：查询账户信息同时查询用户信息。 3.1 账户的持久层DAO接口12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，同时获取账户的所属用户名称以及它的地址信息 * @return */ List&lt;Account&gt; findAll();&#125; 3.2 账户的持久层映射文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 建立对应关系 --&gt; &lt;resultMap type="account" id="accountMap"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt; &lt;association property="user" javaType="user" select="com.itheima.dao.IUserDao.findById" column="uid"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="accountMap"&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; select ： 填写我们要调用的 select 映射的 idcolumn ： 填写我们要传递给 select 映射的参数 3.3 用户的持久层接口和映射文件1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 id 查询 * @param userId * @return */ User findById(Integer userId);&#125; 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 根据 id 查询 --&gt; &lt;select id="findById" resultType="user" parameterType="int" &gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 3.4 开启Mybatis的延迟加载策略进入 Mybaits 的官方文档，找到 settings 的说明信息： 我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 12345&lt;!-- 开启延迟加载的支持 --&gt;&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 3.5 编写测试只查询账户信息而不查用户信息12345678910111213141516171819202122232425262728293031323334353637383940/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IAccountDao accountDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;Account&gt; accounts = accountDao.findAll(); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 accountDao = session.getMapper(IAccountDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们发现，因为本次只是将Account对象查询出来放入List集合中，并没有涉及到User对象，所以就没有发出 SQL 语句查询账户所关联的 User 对象的查询。 4. 使用Collection实现延迟加载同样我们也可以在一对多关系配置的&lt;collection&gt;结点中配置延迟加载策略。&lt;collection&gt;结点中也有 select 属性，column 属性。 需求：完成加载用户对象时，查询该用户所拥有的账户信息。 4.1 在User实体类中加入List&lt;Account&gt;属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 4.2 编写用户和账户持久层接口的方法12345/*** 查询所有用户，同时获取出每个用户下的所有账户信息* @return*/List&lt;User&gt; findAll(); 123456/*** 根据用户 id 查询账户信息* @param uid* @return*/List&lt;Account&gt; findByUid(Integer uid); 4.3 编写用户持久层映射配置123456789101112131415161718192021&lt;resultMap type="user" id="userMap"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称） column 是用于指定使用哪个字段的值作为条件查询 --&gt; &lt;collection property="accounts" ofType="account" select="com.itheima.dao.IAccountDao.findByUid" column="id"&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user&lt;/select&gt; &lt;collection&gt; 标签 ：主要用于加载关联的集合对象select 属性 ：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性 ：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 4.4 编写账户持久层映射配置1234&lt;!-- 根据用户 id 查询账户信息 --&gt;&lt;select id="findByUid" resultType="account" parameterType="int"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; 4.5 测试只加载用户信息1234567891011121314151617181920212223242526272829303132333435363738394041/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;User&gt; users = userDao.findAll(); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们发现并没有加载 Account 账户信息。 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。Mybatis 中缓存分为一级缓存，二级缓存。 5. Mybatis一级缓存5.1 证明一级缓存的存在一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 5.1.1 编写用户持久层Dao接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 id 查询 * @param userId * @return */ User findById(Integer userId);&#125; 5.1.2 编写用户持久层映射文件12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 根据 id 查询 --&gt; &lt;select id="findById" resultType="User" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 5.1.3 编写测试方法1234567891011121314151617181920212223242526272829303132333435363738394041424344/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindById() &#123; //6.执行操作 User user = userDao.findById(41); System.out.println("第一次查询的用户："+user); User user2 = userDao.findById(41); System.out.println("第二次查询用户："+user2); System.out.println(user == user2); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 5.2 一级缓存的分析一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 5.3 测试一级缓存的清空123456789101112131415161718192021222324252627282930313233343536/*** 测试一级缓存*/@Testpublic void testFirstLevelCache()&#123; User user1 = userDao.findById(41); System.out.println(user1); // sqlSession.close(); //再次获取 SqlSession 对象 // sqlSession = factory.openSession(); sqlSession.clearCache();//此方法也可以清空缓存 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125;/*** 测试缓存的同步*/@Testpublic void testClearlCache()&#123; //1.根据 id 查询用户 User user1 = userDao.findById(41); System.out.println(user1); //2.更新用户信息 user1.setUsername("update user clear cache"); user1.setAddress("北京市海淀区"); userDao.updateUser(user1); //3.再次查询 id 为 41 的用户 User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 当执行sqlSession.close()后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。 6. Mybatis二级缓存二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 6.1 二级缓存结构图 首先开启 mybatis 的二级缓存。 sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。 sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 6.2 二级缓存的开启与关闭6.2.1 第一步：在SqlMapConfig.xml文件开启二级缓存1234&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 6.2.2 第二步：配置相关的Mapper映射文件&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; 6.2.3 第三步：配置statement上面的useCache属性1234&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="user" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 6.3 二级缓存测试123456789101112131415161718192021222324252627282930313233343536373839404142/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class SecondLevelCacheTest &#123; private InputStream in; private SqlSessionFactory factory; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; in.close(); &#125; /** * 测试一级缓存 */ @Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125;&#125; 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。 6.4 二级缓存注意事项当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这样就可以使用序列化方式来保存对象。 12345678910111213/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多表查询之一对多与多对多]]></title>
    <url>%2F2019%2F05%2F27%2F2019-05-27-Mybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[目录 一对一查询（多对一） 一对多查询 实现Role到User的多对多 实现User到Role的多对多 本次案例主要以最为简单的用户和账户的模型来分析Mybatis多表关系。用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。具体关系如下： 1. 一对一查询（多对一）需求： 查询所有账户信息，关联查询下单用户信息。注意： 因为一个账户信息只能供某个用户使用，所以从查询账户信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。 1.1 方式一1.1.1 定义账户信息的实体类1234567891011121314151617181920212223242526272829303132333435/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 1.1.2 编写Sql语句实现查询账户信息时，也要查询账户所对应的用户信息。 12345678SELECT account.*, user.username, user.addressFROM account, userWHERE account.uid = user.id 在 MySQL 中测试的查询结果如下： 1.1.3 定义 AccountUser类为了能够封装上面 SQL 语句的查询结果，定义 AccountCustomer 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 AccountUser 类时可以继承 User 类。 123456789101112131415161718192021222324252627/**** &lt;p&gt;Title: AccountUser&lt;/p&gt;* &lt;p&gt;Description: 它是 account 的子类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountUser extends Account implements Serializable &#123; private String username; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return super.toString() + " AccountUser [username=" + username + ", address=" + address + "]"; &#125;&#125; 1.1.4 定义账户的持久层Dao接口12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123;/*** 查询所有账户，同时获取账户的所属用户名称以及它的地址信息* @return*/List&lt;AccountUser&gt; findAll();&#125; 1.1.5 定义AccountDao.xml文件中的查询配置信息12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 配置查询所有操作--&gt; &lt;select id="findAll" resultType="accountuser"&gt; select a.*,u.username,u.address from account a,user u where a.uid =u.id; &lt;/select&gt;&lt;/mapper&gt; 注意：因为上面查询的结果中包含了账户信息同时还包含了用户信息，所以我们的返回值类型 returnType的值设置为 AccountUser 类型，这样就可以接收账户信息和用户信息了。 1.1.6 创建AccountTest测试类12345678910111213141516171819202122232425262728293031323334353637383940414243/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IAccountDao accountDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;AccountUser&gt; accountusers = accountDao.findAll(); for(AccountUser au : accountusers) &#123; System.out.println(au); &#125; &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 accountDao = session.getMapper(IAccountDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 1.1.7 小结定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。 1.2 方式二使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。 通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。 1.2.1 修改Account类在 Account 类中加入 User 类的对象作为 Account 类的一个属性。 123456789101112131415161718192021222324252627282930313233343536373839404142/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 1.2.2 修改AccountDao接口中的方法12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，同时获取账户的所属用户名称以及它的地址信息 * @return */ List&lt;Account&gt; findAll();&#125; 注意：第二种方式，将返回值改 为了 Account 类型。因为 Account 类中包含了一个 User 类的对象，它可以封装账户所对应的用户信息。 1.2.3 重新定义AccountDao.xml文件1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 建立对应关系 --&gt; &lt;resultMap type="account" id="accountMap"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt; &lt;association property="user" javaType="user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="accountMap"&gt; select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id; &lt;/select&gt;&lt;/mapper&gt; 1.2.4 在AccountTest类中加入测试方法12345678@Testpublic void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll(); for(Account au : accounts) &#123; System.out.println(au); System.out.println(au.getUser()); &#125; &#125; 2. 一对多查询需求：查询所有用户信息及用户关联的账户信息。 分析：用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，我们想到了左外连接查询比较合适。 2.1 编写SQL语句1234567SELECT u.*, acc.id id, acc.uid, acc.moneyFROM user uLEFT JOIN account acc ON u.id = acc.uid 测试该 SQL 语句在 MySQL 客户端工具的查询结果如下： 2.2 User类加入List&lt;Account&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 2.3 在持久层Dao接口中加入查询方法12345/*** 查询所有用户，同时获取出每个用户下的所有账户信息* @return*/List&lt;User&gt; findAll(); 2.4 在持久层Dao映射文件配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;resultMap type="user" id="userMap"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 --&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultMap="userMap"&gt; select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid &lt;/select&gt;&lt;/mapper&gt; collection 部分定义了用户关联的账户信息。表示关联查询结果集property=&quot;accList&quot; ： 关联查询的结果集存储在 User 对象的上哪个属性。ofType=&quot;account&quot; ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 2.5 测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println("-------每个用户的内容---------"); System.out.println(user); System.out.println(user.getAccounts()); &#125; &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 3. 实现Role到User的多对多通过前面的学习，我们使用 Mybatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系。 3.1 用户与角色的关系模型用户与角色的多对多关系模型如下： 在 MySQL 数据库中添加角色表，用户角色的中间表。 角色表 用户角色中间表 3.2 业务要求及实现SQL需求：实现查询所有对象并且加载它所分配的用户信息。分析：查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中间表(USER_ROLE 表)才能关联到用户信息。 下面是实现的 SQL 语句： 1234567891011121314SELECT r.*,u.id uid, u.username username, u.birthday birthday, u.sex sex, u.address addressFROM ROLE rINNER JOIN USER_ROLE urON ( r.id = ur.rid)INNER JOIN USER uON (ur.uid = u.id); 3.3 编写角色实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; public Integer getRoleId() &#123; return roleId; &#125; public void setRoleId(Integer roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleDesc() &#123; return roleDesc; &#125; public void setRoleDesc(String roleDesc) &#123; this.roleDesc = roleDesc; &#125; @Override public String toString() &#123; return "Role&#123;" + "roleId=" + roleId + ", roleName='" + roleName + '\'' + ", roleDesc='" + roleDesc + '\'' + '&#125;'; &#125;&#125; 3.4 编写Role持久层接口1234567891011/*** @author 黑马程序员* @Company http://www.ithiema.com*/public interface IRoleDao &#123; /** * 查询所有角色 * @return */ List&lt;Role&gt; findAll();&#125; 3.5 编写映射文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IRoleDao"&gt; &lt;!--定义 role 表的 ResultMap--&gt; &lt;resultMap id="roleMap" type="role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--查询所有--&gt; &lt;select id="findAll" resultMap="roleMap"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt;&lt;/mapper&gt; 3.6 编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class RoleTest &#123; private InputStream in; private SqlSession sqlSession; private IRoleDao roleDao; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取 SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取 SqlSession 对象 sqlSession = factory.openSession(true); //4.获取 dao 的代理对象 roleDao = sqlSession.getMapper(IRoleDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; //提交事务 // sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;Role&gt; roles = roleDao.findAll(); for(Role role : roles)&#123; System.out.println("---每个角色的信息----"); System.out.println(role); System.out.println(role.getUsers()); &#125; &#125;&#125; 4. 实现User到Role的多对多4.1 User到Role的多对多从 User 出发，我们也可以发现一个用户可以具有多个角色，这样用户到角色的关系也还是一对多关系。这样我们就可以认为 User 与 Role 的多对多关系，可以被拆解成两个一对多关系来实现。 4.2 实现User到Role的一对多查询需求：实现查询所有用户信息并关联查询出每个用户的角色列表。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的动态SQL片段]]></title>
    <url>%2F2019%2F05%2F26%2F2019-05-26-Mybatis%E7%9A%84%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[目录 动态SQL之&lt;if&gt;标签 动态SQL之&lt;where&gt;标签 动态标签之&lt;foreach&gt;标签 Mybatis中简化编写的SQL片段 Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 1. 动态SQL之&lt;if&gt;标签我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1.1 持久层Dao接口123456/*** 根据用户信息，查询用户列表* @param user* @return*/List&lt;User&gt; findByUser(User user); 1.2 持久层Dao映射配置123456789&lt;select id="findByUser" resultType="user" parameterType="user"&gt; select * from user where 1=1 &lt;if test="username!=null and username != '' "&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test="address != null"&gt; and address like #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 注意：标签的 test 属性中写的是对象的属性名，如果是包装类的对象要使用 OGNL 表达式的写法。另外要注意 where 1=1 的作用~！ 1.3 测试1234567891011@Testpublic void testFindByUser() &#123; User u = new User(); u.setUsername("%王%"); u.setAddress("%顺义%"); //6.执行操作 List&lt;User&gt; users = userDao.findByUser(u); for(User user : users) &#123; System.out.println(user); &#125; &#125; 2. 动态SQL之&lt;where&gt;标签为了简化上面where 1=1的条件拼装，我们可以采用&lt;where&gt;标签来简化开发。 2.1 持久层Dao映射配置123456789101112&lt;!-- 根据用户信息查询 --&gt;&lt;select id="findByUser" resultType="user" parameterType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="username!=null and username != '' "&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test="address != null"&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3. 动态标签之&lt;foreach&gt;标签3.1 需求传入多个 id 查询用户信息，用下边两个 sql 实现： SELECT FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16)SELECT FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。这样我们将如何进行参数的传递？ 3.2 在QueryVo中加入一个List集合用于封装参数1234567891011121314151617/**** &lt;p&gt;Title: QueryVo&lt;/p&gt;* &lt;p&gt;Description: 查询的条件&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125;&#125; 3.3 持久层Dao接口123456/*** 根据 id 集合查询用户* @param vo* @return*/List&lt;User&gt; findInIds(QueryVo vo); 3.4 持久层Dao映射配置123456789101112&lt;!-- 查询所有用户在 id 的集合之中 --&gt;&lt;select id="findInIds" resultType="user" parameterType="queryvo"&gt;&lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="ids != null and ids.size() &gt; 0"&gt; &lt;foreach collection="ids" open="id in ( " close=")" item="uid" separator=","&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; SQL 语句：select 字段 from user where id in (?) &lt;foreach&gt;标签用于遍历集合，它的属性：collection:代表要遍历的集合元素，注意编写时不要写#{}open:代表语句的开始部分close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名sperator:代表分隔符 3.5 编写测试方法12345678910111213141516@Testpublic void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(41); ids.add(42); ids.add(43); ids.add(46); ids.add(57); vo.setIds(ids); //6.执行操作 List&lt;User&gt; users = userDao.findInIds(vo); for(User user : users) &#123; System.out.println(user); &#125; &#125; 4. Mybatis中简化编写的SQL片段Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。 4.1 定义代码片段1234&lt;!-- 抽取重复的语句代码片段 --&gt;&lt;sql id="defaultSql"&gt; select * from user&lt;/sql&gt; 4.2 引用代码块12345678910&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt;&lt;/select&gt;&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="User" parameterType="int"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; where id = #&#123;uid&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis连接池与事务深入]]></title>
    <url>%2F2019%2F05%2F25%2F2019-05-25-Mybatis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[目录 Mybatis的连接池技术 Mybatis的事务控制 1. Mybatis的连接池技术Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现 Mybatis 中连接池的配置。 1.1 Mybatis连接池的分类在 Mybatis 中我们将它的数据源 dataSource 分为以下几类： 可以看出 Mybatis 将它自己的数据源分为三类：UNPOOLED 不使用连接池的数据源POOLED 使用连接池的数据源JNDI 使用 JNDI 实现的数据源具体结构如下： 相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 在这三种数据源中，我们一般采用的是 POOLED 数据源（很多时候我们所说的数据源就是为了更好的管理数据库连接，也就是我们所说的连接池技术）。 1.2 Mybatis 中数据源的配置我们的数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下： 1234567&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; MyBatis 在初始化时，根据的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 1.3 Mybatis中DataSource的存取MyBatis 是通过工厂模式来创建数据源 DataSource 对象的， MyBatis 定义了抽象的工厂接口:org.apache.ibatis.datasource.DataSourceFactory,通过其 getDataSource()方法返回数据源DataSource。 下面是 DataSourceFactory 源码，具体如下： 12345678910111213package org.apache.ibatis.datasource;import java.util.Properties;import javax.sql.DataSource;/*** @author Clinton Begin*/public interface DataSourceFactory &#123; void setProperties(Properties props); DataSource getDataSource();&#125; MyBatis 创建了 DataSource 实例后，会将其放到 Configuration 对象内的 Environment 对象中， 供以后使用。 具体分析过程如下： 1.先进入 XMLConfigBuilder 类中，可以找到如下代码： 2.分析 configuration 对象的 environment 属性，结果如下： 1.4 Mybatis中连接的获取过程分析当我们需要创建 SqlSession 对象并需要执行 SQL 语句时，这时候 MyBatis 才会去调用 dataSource 对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。 12345678@Testpublic void testSql() throws Exception &#123; InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = factory.openSession(); List&lt;User&gt; list = sqlSession.selectList("findUserById",41); System.out.println(list.size());&#125; 只有当第 4 句sqlSession.selectList(“findUserById”)，才会触发 MyBatis 在底层执行下面这个方法来创建 java.sql.Connection 对象。 如何证明它的加载过程呢？ 我们可以通过断点调试，在 PooledDataSource 中找到如下 popConnection()方法，如下所示： 分析源代码，得出 PooledDataSource 工作原理如下： 下面是连接获取的源代码： 最后我们可以发现，真正连接打开的时间点，只是在我们执行SQL语句时，才会进行。其实这样做我们也可以进一步发现，数据库连接是我们最为宝贵的资源，只有在要用到的时候，才去获取并打开连接，当我们用完了就再立即将数据库连接归还到连接池中。 2. Mybatis的事务控制2.1 JDBC中事务的回顾在 JDBC 中我们可以通过手动方式将事务的提交改为手动方式，通过 setAutoCommit()方法就可以调整。通过 JDK 文档，我们找到该方法如下： 那么我们的 Mybatis 框架因为是对 JDBC 的封装，所以 Mybatis 框架的事务控制方式，本身也是用 JDBC的setAutoCommit()方法来设置事务提交方式的。 2.2 Mybatis中事务提交方式Mybatis 中事务的提交方式，本质上就是调用 JDBC 的 setAutoCommit()来实现事务控制。我们运行之前所写的代码： 1234567891011121314151617181920212223242526272829303132@Testpublic void testSaveUser() throws Exception &#123; User user = new User(); user.setUsername("mybatis user09"); //6.执行操作 int res = userDao.saveUser(user); System.out.println(res); System.out.println(user.getId());&#125;@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.提交事务 session.commit(); //8.释放资源 session.close(); in.close();&#125; 观察在它在控制台输出的结果： 这是我们的 Connection 的整个变化过程，通过分析我们能够发现之前的 CUD 操作过程中，我们都要手动进行事务的提交，原因是 setAutoCommit()方法，在执行时它的值被设置为 false 了，所以我们在 CUD 操作中，必须通过 sqlSession.commit()方法来执行提交操作。 2.3 Mybatis自动提交事务的设置通过上面的研究和分析，现在我们一起思考，为什么 CUD 过程中必须使用 sqlSession.commit()提交事务？主要原因就是在连接池中取出的连接，都会将调用 connection.setAutoCommit(false)方法，这样我们就必须使用 sqlSession.commit()方法，相当于使用了 JDBC 中的 connection.commit()方法实现事务提交。 明白这一点后，我们现在一起尝试不进行手动提交，一样实现 CUD 操作。 1234567891011121314151617181920@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(true); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close();&#125; 所对应的 DefaultSqlSessionFactory 类的源代码： 运行的结果如下： 我们发现，此时事务就设置为自动提交了，同样可以实现CUD操作时记录的保存。虽然这也是一种方式，但就编程而言，设置为自动提交方式为 false再根据情况决定是否进行提交，这种方式更常用。因为我们可以根据业务情况来决定提交是否进行提交。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件系统功能设计概述]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 什么是软件功能设计 功能设计在整个软件设计中的层次 功能设计在整个软件设计中的地位 功能设计与设计模式的关系 功能设计与详细设计的关系 功能设计要考虑的东西/评价标准 功能设计的实战方法——经验总结 关于软件设计的一些思考 1. 什么是软件功能设计所谓软件的功能设计，指的是：针对软件中某一个具体的功能，所进行的设计。包括这个功能的实现方式、实现的基本结构、类的组成、职责的划分等。是软件设计中最重要的基本功。 我们看一下一个仿QQ软件所需要设计的功能： 2. 功能设计在整个软件设计中的层次软件设计的层次很多，不同的软件设计过程有不同的划分方式，大致可分为：架构设计、api/spi设计、数据库设计、功能设计、类设计、方法设计。 从难度上说：公共类库&gt;公共框架&gt;基础平台/框架&gt;应用（产品&gt;项目） 3. 功能设计在整个软件设计中的地位功能设计从属详细设计，是整个系统功能实现的基石。 4. 功能设计与设计模式的关系功能设计通常会综合应用多种设计模式，是各种设计思想的具体体现的载体。由于功能千变万化，因而要有较高的设计技巧和功力，才能设计出正确的、易用的、灵活的、扩展性高的、高性能实现。 设计模式是业界公认的，优秀的设计经验和设计理念，理解、掌握、融会贯通、并能熟练变形应用设计模式，对于功能设计是有极大的帮助的。 5. 功能设计与详细设计的关系功能设计只是详细设计中的一个部分，详细设计还包括很多其他的设计，比如：流程设计、对API/SPI的完善和细化、对数据库设计的完善和细化、对多个功能交互的控制、事务的规划、权限/安全的规划、例外的控制……很多很多 6. 功能设计要考虑的东西/评价标准这个业界并没有统一的标准，而且不同类型、不同业务的系统考虑的东西并不一样，但还是有一些通常要考虑的东西： 正确性、易用性、可扩展性、复杂性（易理解、开发难度等）、易维护、安全、性能、可复用、可测试…… 当然还有很多其他需要考虑的，比如：多线程、分布式、可靠性、稳定性、对资源的利用和消耗、可伸缩、可配置、可移植、可定制…… 7. 功能设计的实战方法——经验总结 基本的功能实现方式，并进行细化 分析每个步骤，每个细节中，哪些是可变的，哪些是不可变的。通常分析3个部分：数据输入、具体实现、数据产出。 分析这个细节步骤的功能和其他步骤的关系，比如：顺序、平行、依赖等，以确定这些职责的粒度和分离方式，从而考虑他们之间的组合方式，也需要分离这些组合方式的变与不变。 根据前面分析的结果，进行相应的类、方法的设计、进行职责的划分，并通过合适的方式把他们组织起来。通常这个时候，就会融合进一个或多个设计模式的应用。当然也可能是没有现成的设计模式，需要自己来灵活组织和实现。 按照前面讲述的评价标准，进行系统的思考和调度，以形成最终的设计。 8. 关于软件设计的一些思考 设计的基本技巧：发现和封装变化，进行抽象和封装，实现高内聚和低耦合。 设计就是危险的平衡艺术，尽可能的找到最佳平衡点。 没有完美的设计，设计总是在不断演变中。 设计是没有标准答案的，只要能更好的实现功能，更好的满足那些评价标准，就是好东西。 不要过度设计不等于不设计，而是更要精巧设计。 关于重构的思考 关于敏捷的思考 设计是否增加了复杂度 设计是否增加了软件成本 关于训练功能设计的意义]]></content>
      <categories>
        <category>软件工程</category>
        <category>系统功能设计</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>系统功能设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis输入参数和输出结果封装]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24-Mybatis%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目录 parameterType配置参数 传递pojo包装对象 resultType配置结果类型 resultMap结果类型 SqlMapConfig.xml配置内容 properties（属性） typeAliases(类型别名) mappers(映射器) 1. parameterType配置参数1.1 使用说明我们在上一章节中已经介绍了 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类，本章节将介绍如何使用实体类的包装类作为参数传递。 1.2 注意事项基 本类 型和 String 我 们可 以直接 写类型 名称 ，也 可以 使用包 名 . 类名的 方式 ，例如 ：java.lang.String。 实体类类型，目前我们只能使用全限定类名。 究其原因，是 mybaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。在今天课程的最后一个章节中将讲解如何注册实体类的别名。 在 mybatis 的官方文档的说明(第 19 页) 这些都是支持的默认别名。我们也可以从源码角度来看它们分别都是如何定义出来的。可以参考 TypeAliasRegistery.class 的源码。 2. 传递pojo包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。 Pojo 类中包含 pojo。 需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。 2.1 编写QueryVo1234567891011121314151617/**** &lt;p&gt;Title: QueryVo&lt;/p&gt;* &lt;p&gt;Description: 查询条件对象&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class QueryVo implements Serializable &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 2.2 编写持久层接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 QueryVo 中的条件查询用户 * @param vo * @return */ List&lt;User&gt; findByVo(QueryVo vo);&#125; 2.3 持久层接口的映射文件1234&lt;!-- 根据用户名称模糊查询，参数变成一个 QueryVo 对象了 --&gt;&lt;select id="findByVo" resultType="com.itheima.domain.User" parameterType="com.itheima.domain.QueryVo"&gt; select * from user where username like #&#123;user.username&#125;;&lt;/select&gt; 2.4 测试包装类作为参数1234567891011@Testpublic void testFindByQueryVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName("%王%"); vo.setUser(user); List&lt;User&gt; users = userDao.findByVo(vo); for(User u : users) &#123; System.out.println(u); &#125;&#125; 3. resultType配置结果类型resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。 我们在前面的 CRUD 案例中已经对此属性进行过应用了。 需要注意的是，它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如：我们的实体类此时必须是全限定类名（今天最后一个章节会讲解如何配置实体类的别名） 同时，当是实体类名称时，还有一个要求，实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。 3.1 基本类型示例3.1.1 Dao接口12345/*** 查询总记录条数* @return*/int findTotal(); 3.1.2 映射配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; select count(*) from user;&lt;/select&gt; 3.2 实体类类型示例3.2.1 Dao接口12345/*** 查询所有用户* @return*/List&lt;User&gt; findAll(); 3.2.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user&lt;/select&gt; 3.3 特殊情况示例3.3.1 修改实体类实体类代码如下：（此时的实体类属性和数据库表的列名已经不一致了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 3.3.2 Dao接口12345/*** 查询所有用户* @return*/List&lt;User&gt; findAll(); 3.3.3 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user&lt;/select&gt; 3.3.4 测试查询结果1234567@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125;&#125; 运行结果： 为什么名称会有值呢？ 因为：mysql 在 在 windows 系统中不区分大小写！ 3.3.5 修改映射配置使用别名查询 12345&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select id as userId,username as userName,birthday as userBirthday, sex as userSex,address as userAddress from user&lt;/select&gt; 运行结果： 思考：如果我们的查询很多，都使用别名的话写起来岂不是很麻烦，有没有别的解决办法呢？ 请看下一小节。 4. resultMap结果类型resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 4.1 定义resultMap1234567891011&lt;!-- 建立 User 实体和数据库表的对应关系type 属性：指定实体类的全限定类名id 属性：给定一个唯一标识，是给查询 select 标签引用用的。--&gt;&lt;resultMap type="com.itheima.domain.User" id="userMap"&gt; &lt;id column="id" property="userId"/&gt; &lt;result column="username" property="userName"/&gt; &lt;result column="sex" property="userSex"/&gt; &lt;result column="address" property="userAddress"/&gt; &lt;result column="birthday" property="userBirthday"/&gt;&lt;/resultMap&gt; id 标签：用于指定主键字段result 标签：用于指定非主键字段column 属性：用于指定数据库列名property 属性：用于指定实体类属性名称 4.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user&lt;/select&gt; 4.3 测试结果1234567@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125;&#125; 运行结果： 5. SqlMapConfig.xml配置内容5.1 SqlMapConfig.xml中配置的内容和顺序1234567891011121314151617-properties （属性） --property-settings（全局配置参数） --setting-typeAliases （类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers （映射器） --mapper --package 6. properties（属性）在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。 6.1 第一种123456&lt;properties&gt; &lt;property name="jdbc.driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbc.url" value="jdbc:mysql://localhost:3306/eesy"/&gt; &lt;property name="jdbc.username" value="root"/&gt; &lt;property name="jdbc.password" value="1234"/&gt;&lt;/properties&gt; 6.2 第二种6.2.1 在classpath下定义da.properties文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=1234 6.2.2 properties标签配置1234567891011121314&lt;!-- 配置连接数据库的信息resource 属性：用于指定 properties 配置文件的位置，要求配置文件必须在类路径下resource="jdbcConfig.properties"url 属性：URL： Uniform Resource Locator 统一资源定位符http://localhost:8080/mystroe/CategoryServlet URL协议 主机 端口 URIURI：Uniform Resource Identifier 统一资源标识符/mystroe/CategoryServlet它是可以在 web 应用中唯一定位一个资源的路径--&gt;&lt;properties url= file:///D:/IdeaProjects/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.properties"&gt;&lt;/properties&gt; 6.2.3 此时我们的dataSource标签就变成了引用上面的配置123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; 7. typeAliases(类型别名)在前面我们讲的 Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发。 7.1 自定义别名在SqlMapConfig.xml中配置： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="user" type="com.itheima.domain.User"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name="com.itheima.domain"/&gt; &lt;package name=" 其它包 "/&gt;&lt;/typeAliases&gt; 8. mappers(映射器)8.1 &lt;mapper resource=” “使用相对于类路径的资源 如： 1&lt;mapper resource="com/itheima/dao/IUserDao.xml" /&gt; 8.2 &lt;mapper class=” “使用 mapper 接口类路径 如： 1&lt;mapper class="com.itheima.dao.UserDao"/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 8.3 &lt;package name=””注册指定包下的所有 mapper 接口 如： 1&lt;package name="cn.itcast.mybatis.mapper"/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于代理Dao实现CRUD操作]]></title>
    <url>%2F2019%2F05%2F23%2F2019-05-23-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86Dao%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[目录 自定义流程再分析 Mybatis环境搭建步骤 根据ID查询 保存操作 用户更新 用户删除 用户模糊查询 查询使用聚合函数 Mybatis与JDBC编程的比较 1. 自定义流程再分析 2. Mybatis环境搭建步骤第一步：创建maven工程 第二步：导入坐标 第三步：编写必要代码（实体类和持久层接口） 第四步：编写SqlMapConfig.xml 第五步：编写映射配置文件 第六步：编写测试类 使用要求： 1、持久层接口和持久层接口的映射配置必须在相同的包下 2、持久层映射配置中mapper标签的namespace属性必须是持久层接口的全限定类名 3、SQL语句的配置标签 ,,, 的id属性必须和持久层接口的方法名相同。 3. 根据ID查询3.1 在持久层接口中添加findById方法123456/*** 根据 id 查询* @param userId* @return*/User findById(Integer userId); 3.2 在用户的映射配置文件中配置1234&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="com.itheima.domain.User" parameterType="int"&gt;select * from user where id = #&#123;uid&#125;&lt;/select&gt; 细节： resultType属性：用于指定结果集的类型。 parameterType属性：用于指定传入参数的类型。 sql语句中使用#{ }字符：它代表占位符，相当于原来jdbc中所学的？，都是用于执行语句时替换实际的数据。具体的数据是由#{ }里面的内容决定的。 #{ }中内容的写法：由于数据类型是基本类型，所以此处可以随意写。 3.3 在测试类中添加测试123456789101112131415161718192021222324252627282930313233343536373839404142/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的 crud 操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybastisCRUDTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindOne() &#123; //6.执行操作 User user = userDao.findById(41); System.out.println(user); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 4. 保存操作4.1 在持久层接口中添加saveUser方法123456/*** 保存用户* @param user* @return 影响数据库记录的行数*/int saveUser(User user); 4.2 在用户的映射配置文件中配置12345&lt;!-- 保存用户--&gt;&lt;insert id="saveUser" parameterType="com.itheima.domain.User"&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 细节： parameterType属性：代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。 sql语句中使用#{ }字符：它代表占位符，相当于原来jdbc中所学的？，都是用于执行语句时替换实际的数据。具体的数据是由#{ }里面的内容决定的。 #{ }中内容的写法：由于我们保存方法的参数是一个User对象，此处要写User对象中的属性名称。它用的是ognl表达式。ognl表达式：它是apache提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言 它是按照一定的语法格式来获取数据的。语法格式就是使用#{对象.对象}的方式#{user.username}它会先去找user对象，然后在user对象中找到username属性，并调用getUsername()方法把值取出来。但是我们在parameterType属性上指定了实体类名称，所以可以省略user.而直接写username。 4.3 添加测试类中的测试方法123456789101112@Testpublic void testSave()&#123; User user = new User(); user.setUsername("modify User property"); user.setAddress("北京市顺义区"); user.setSex("男"); user.setBirthday(new Date()); System.out.println("保存操作之前："+user); //5.执行保存方法 userDao.saveUser(user); System.out.println("保存操作之后："+user);&#125; 打开 Mysql 数据库发现并没有添加任何记录，原因是什么？ 这一点和 jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在 mybatis 中如何控制事务提交呢？ 可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下： 1234567@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close();&#125; 4.4 问题扩展：新增用户id的返回值新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。 12345678&lt;insert id="saveUser" parameterType="USER"&gt; &lt;!-- 配置保存时获取插入的 id --&gt; &lt;selectKey keyColumn="id" keyProperty="id" resultType="int"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 5. 用户更新5.1 在持久层接口中添加updateUser方法123456/*** 更新用户* @param user* @return 影响数据库记录的行数*/int updateUser(User user); 5.2 在用户的映射配置文件中配置1234&lt;!-- 更新用户 --&gt;&lt;update id="updateUser" parameterType="com.itheima.domain.User"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 5.3 加入更新的测试方法123456789@Testpublic void testUpdateUser()throws Exception&#123; //1.根据 id 查询 User user = userDao.findById(52); //2.更新操作 user.setAddress("北京市顺义区"); int res = userDao.updateUser(user); System.out.println(res);&#125; 6. 用户删除6.1 在持久层接口中添加deleteUser方法123456/*** 根据 id 删除用户* @param userId* @return*/int deleteUser(Integer userId); 6.2 在用户的映射配置文件中配置1234&lt;!-- 删除用户 --&gt;&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; delete from user where id = #&#123;uid&#125;&lt;/delete&gt; 6.3 加入删除的测试方法123456@Testpublic void testDeleteUser() throws Exception &#123; //6.执行操作 int res = userDao.deleteUser(52); System.out.println(res);&#125; 7. 用户模糊查询7.1 在持久层接口中添加findByName方法123456/*** 根据名称模糊查询* @param username* @return*/List&lt;User&gt; findByName(String username); 7.2 在用户的映射配置文件中配置1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" resultType="com.itheima.domain.User" parameterType="String"&gt; select * from user where username like #&#123;username&#125;&lt;/select&gt; 7.3 加入模糊查询的测试方法12345678@Testpublic void testFindByName()&#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName("%王%"); for(User user : users)&#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 我们在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以 SQL 语句显示为“？”。 7.4 模糊查询的另一种配置方式第一步：修改 SQL 语句的配置，配置如下： 1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" parameterType="string" resultType="com.itheima.domain.User"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。 第二步：测试，如下： 1234567891011/*** 测试模糊查询操作*/@Testpublic void testFindByName()&#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName("王"); for(User user : users)&#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行的语句是不一样的。 7.5 #{}与${}的区别#{}表示一个占位符 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 ${} 表示拼接 sql 串 通过${}可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 7.6 模糊查询的${value}源码分析我们一起来看 TextSqlNode 类的源码： 这就说明了源码中指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字了。 8. 查询使用聚合函数8.1 在持久层接口中添加findTotal()方法12345/*** 查询总记录条数* @return*/int findTotal(); 8.2 在用户的映射配置文件中配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; select count(*) from user;&lt;/select&gt; 8.3 加入聚合查询的测试方法123456@Testpublic void testFindTotal() throws Exception &#123; //6.执行操作 int res = userDao.findTotal(); System.out.println(res);&#125; 9. Mybatis与JDBC编程的比较1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 3.向sql语句传参数麻烦，因为sql语句的where 条件不一定，可能多也可能少，占位符需要和参数对应。 解决：Mybatis自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。 4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。 解决：Mybatis自动将 sql执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写Mybatis框架]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-22-%E6%89%8B%E5%86%99Mybatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目录 自定义Mybatis框架的分析 前期准备 基于XML的自定义Mybatis框架 基于注解方式定义Mybatis框架 自定义Mybatis的设计模式说明 1. 自定义Mybatis框架的分析1.1 涉及知识点介绍本章我们将使用前面所学的基础知识来构建一个属于自己的持久层框架，将会涉及到的一些知识点：工厂模式（Factory 工厂模式）、构造者模式（Builder 模式）、代理模式，反射，自定义注解，注解的反射，xml 解析，数据库元数据，元数据的反射等。 1.2 分析流程 2. 前期准备2.1 创建maven工程创建 mybatis02 的工程，工程信息如下： Groupid:com.itheimaArtifactId:mybatis02Packing:jar 2.2 引入相关坐标12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 日志坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解析 xml 的 dom4j --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dom4j 的依赖包 jaxen --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 引入工具类到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/*** @author 黑马程序员* @Company http://www.ithiema.com* 用于解析配置文件*/public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到 DefaultSqlSession 所需要的地方 * 使用的技术： * dom4j+xpath * @param session */ public static void loadConfiguration(DefaultSqlSession session,InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis 的配置对象） Configuration cfg = new Configuration(); //1.获取 SAXReader 对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取 Document 对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用 xpath 中选择指定节点的方式，获取所有 property 节点 List&lt;Element&gt; propertyElements = root.selectNodes("//property"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出 name 属性的值 String name = propertyElement.attributeValue("name"); if("driver".equals(name))&#123; //表示驱动 //获取 property 标签 value 属性的值 String driver = propertyElement.attributeValue("value"); cfg.setDriver(driver); &#125; if("url".equals(name))&#123; //表示连接字符串 //获取 property 标签 value 属性的值 String url = propertyElement.attributeValue("value"); cfg.setUrl(url); &#125; if("username".equals(name))&#123; //表示用户名 //获取 property 标签 value 属性的值 String username = propertyElement.attributeValue("value"); cfg.setUsername(username); &#125; if("password".equals(name))&#123; //表示密码 //获取 property 标签 value 属性的值 String password = propertyElement.attributeValue("value"); cfg.setPassword(password); &#125; &#125; //取出 mappers 中的所有 mapper 标签，判断他们使用了 resource 还是 class 属性 List&lt;Element&gt; mapperElements = root.selectNodes("//mappers/mapper"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断 mapperElement 使用的是哪个属性 Attribute attribute = mapperElement.attribute("resource"); if(attribute != null)&#123; System.out.println("使用的是 XML"); //表示有 resource 属性，用的是 XML //取出属性的值 String mapperPath = attribute.getValue();// 获 取 属 性 的 值"com/itheima/dao/IUserDao.xml" //把映射配置文件的内容获取出来，封装成一个 map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println("使用的是注解"); //表示没有 resource 属性，用的是注解 //获取 class 属性的值 String daoClassPath = mapperElement.attributeValue("class"); //根据 daoClassPath 获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); &#125; &#125; //把配置对象传递给 DefaultSqlSession session.setCfg(cfg); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析 XML，并且封装到 Map 中 * @param mapperPath 映射配置文件的位置 * @return map 中包含了获取的唯一标识（key 是由 dao 的全限定类名和方法名组成） * 以及执行所需的必要信息（value 是一个 Mapper 对象，里面存放的是执行的 SQL 语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取 Document 对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的 namespace 属性取值 String namespace = root.attributeValue("namespace");//是组成 map 中 key 的部分 //5.获取所有的 select 节点 List&lt;Element&gt; selectElements = root.selectNodes("//select"); //6.遍历 select 节点集合 for(Element selectElement : selectElements)&#123; //取出 id 属性的值 组成 map 中 key 的部分 String id = selectElement.attributeValue("id"); //取出 resultType 属性的值 组成 map 中 value 的部分 String resultType = selectElement.attributeValue("resultType"); //取出文本内容 组成 map 中 value 的部分 String queryString = selectElement.getText(); //创建 Key String key = namespace+"."+id; //创建 Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把 key 和 value 存入 mappers 中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到 dao 中所有被 select 注解标注的方法。 * 根据方法名称和类名，以及方法上注解 value 属性的值，组成 Mapper 的必要信息 * @param daoClassPath * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到 dao 接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到 dao 接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历 Method 数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有 select 注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建 Mapper 对象 Mapper mapper = new Mapper(); //取出注解的 value 属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断 type 是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取 domainClass 的类名 String resultType = domainClass.getName(); //给 Mapper 赋值 mapper.setResultType(resultType); &#125; //组装 key 的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+"."+methodName; //给 map 赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** @author 黑马程序员* @Company http://www.ithiema.com* 负责执行 SQL 语句，并且封装结果集*/public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出 mapper 中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType);//User.class //2.获取 PreparedStatement 对象 pstm = conn.prepareStatement(queryString); //3.执行 SQL 语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance();//User 对象 //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从 1 开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给 obj 赋值：使用 Java 内省机制（借助 PropertyDescriptor 实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod();//setUsername(String username); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125;&#125; private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223/**** &lt;p&gt;Title: DataSourceUtil&lt;/p&gt;* &lt;p&gt;Description: 数据源的工具类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DataSourceUtil &#123; /** * 获取连接 * @param cfg * @return */ public static Connection getConnection(Configuration cfg) &#123; try &#123; Class.forName(cfg.getDriver()); Connection conn = DriverManager.getConnection(cfg.getUrl(),cfg.getUsername() , cfg.getPassword()); return conn; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.4 编写 SqlMapConfig.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///eesy" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 注意：此处我们直接使用的是 mybatis 的配置文件，但是由于我们没有使用 mybatis 的 jar 包，所以要把配置文件的约束删掉否则会报错（如果电脑能接入互联网，不删也行） 2.5 编写读取配置文件类12345678910111213141516171819/**** &lt;p&gt;Title: Resources&lt;/p&gt;* &lt;p&gt;Description: 用于读取配置文件的类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Resources &#123; /** * 用于加载 xml 文件，并且得到一个流对象 * @param xmlPath * @return * 在实际开发中读取配置文件: * 第一：使用类加载器。但是有要求：a 文件不能过大。 b 文件必须在类路径下(classpath) * 第二：使用 ServletContext 的 getRealPath() */ public static InputStream getResourceAsStream(String xmlPath) &#123; return Resources.class.getClassLoader().getResourceAsStream(xmlPath); &#125;&#125; 2.6 编写 Mapper 类123456789101112131415161718192021222324252627/**** &lt;p&gt;Title: Mapper&lt;/p&gt;* &lt;p&gt;Description: 用于封装查询时的必要信息：要执行的 SQL 语句和实体类的全限定类名&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Mapper &#123; private String queryString;//sql private String resultType;//结果类型的全限定类名 public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; 2.7 编写 Configuration 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 核心配置类* 1.数据库信息* 2.sql 的 map 集合*/public class Configuration &#123; private String username; //用户名 private String password;//密码 private String url;//地址 private String driver;//驱动 //map 集合 Map&lt;唯一标识，Mapper&gt; 用于保存映射文件中的 sql 标识及 sql 语句 private Map&lt;String,Mapper&gt; mappers; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123; this.mappers = mappers; &#125;&#125; 2.8 编写User实体类1234567891011121314public class User implements Serializable &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 //省略 getter 与 setter @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", sex=" + sex + ", birthday=" + birthday + ", address=" + address + "]"; &#125;&#125; 3. 基于XML的自定义Mybatis框架3.1 编写持久层接口和 IUserDao.xml12345678910111213/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注意：此处我们使用的也是 mybatis 的配置文件，所以也要把约束删除了 3.2 编写构建者类12345678910111213141516171819/**** &lt;p&gt;Title: SqlSessionFactoryBuilder&lt;/p&gt;* &lt;p&gt;Description: 用于构建 SqlSessionFactory 的&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class SqlSessionFactoryBuilder &#123; /** * 根据传入的流，实现对 SqlSessionFactory 的创建 * @param in 它就是 SqlMapConfig.xml 的配置以及里面包含的 IUserDao.xml 的配置 * @return */ public SqlSessionFactory build(InputStream in) &#123; DefaultSqlSessionFactory factory = new DefaultSqlSessionFactory(); //给 factory 中 config 赋值 factory.setConfig(in); return factory; &#125;&#125; 3.3 编写 SqlSessionFactory 接口和实现类12345678910111213/**** &lt;p&gt;Title: SqlSessionFactory&lt;/p&gt;* &lt;p&gt;Description: SqlSessionFactory 的接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface SqlSessionFactory &#123; /** * 创建一个新的 SqlSession 对象 * @return */ SqlSession openSession();&#125; 12345678910111213141516171819/**** &lt;p&gt;Title: DefaultSqlSessionFactory&lt;/p&gt;* &lt;p&gt;Description:SqlSessionFactory 的默认实现 &lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private InputStream config = null; public void setConfig(InputStream config) &#123; this.config = config; &#125; @Override public SqlSession openSession() &#123; DefaultSqlSession session = new DefaultSqlSession(); //调用工具类解析 xml 文件 XMLConfigBuilder.loadConfiguration(session, config); return session; &#125;&#125; 3.4 编写 SqlSession 接口和实现类123456789101112131415161718/**** &lt;p&gt;Title: SqlSession&lt;/p&gt;* &lt;p&gt;Description: 操作数据库的核心对象&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface SqlSession &#123; /** * 创建 Dao 接口的代理对象 * @param daoClass * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoClass); /** * 释放资源 */ void close();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/**** &lt;p&gt;Title: DefaultSqlSession&lt;/p&gt;* &lt;p&gt;Description: SqlSession 的具体实现&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DefaultSqlSession implements SqlSession &#123; //核心配置对象 private Configuration cfg; public void setCfg(Configuration cfg) &#123; this.cfg = cfg; &#125; //连接对象 private Connection conn; //调用 DataSourceUtils 工具类获取连接 public Connection getConn() &#123; try &#123; conn = DataSourceUtil.getDataSource(cfg).getConnection(); return conn; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 动态代理： * 涉及的类：Proxy * 使用的方法：newProxyInstance * 方法的参数： * ClassLoader：和被代理对象使用相同的类加载器,通常都是固定的 * Class[]：代理对象和被代理对象要求有相同的行为。（具有相同的方法） * InvocationHandler：如何代理。需要我们自己提供的增强部分的代码 */ @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; daoClass) &#123; conn = getConn(); System.out.println(conn); T daoProxy = (T) Proxy.newProxyInstance(daoClass.getClassLoader(),new Class[] &#123;daoClass&#125;, new MapperProxyFactory(cfg.getMappers(),conn)); return daoProxy; &#125; //释放资源 @Override public void close() &#123; try &#123; System.out.println(conn); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //查询所有方法 public &lt;E&gt; List&lt;E&gt; selectList(String statement)&#123; Mapper mapper = cfg.getMappers().get(statement); return new Executor().selectList(mapper,conn); &#125;&#125; 3.5 编写用于创建 Dao 接口代理对象的类12345678910111213141516171819202122232425262728293031323334353637383940414243/**** &lt;p&gt;Title: MapperProxyFactory&lt;/p&gt;* &lt;p&gt;Description: 用于创建代理对象是增强方法&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MapperProxyFactory implements InvocationHandler &#123; private Map&lt;String,Mapper&gt; mappers; private Connection conn; public MapperProxyFactory(Map&lt;String, Mapper&gt; mappers,Connection conn) &#123; this.mappers = mappers; this.conn = conn; &#125; /** * 对当前正在执行的方法进行增强 * 取出当前执行的方法名称 * 取出当前执行的方法所在类 * 拼接成 key * 去 Map 中获取 Value（Mapper) * 使用工具类 Executor 的 selectList 方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; //1.取出方法名 String methodName = method.getName(); //2.取出方法所在类名 String className = method.getDeclaringClass().getName(); //3.拼接成 Key String key = className+"."+methodName; //4.使用 key 取出 mapper Mapper mapper = mappers.get(key); if(mapper == null) &#123; throw new IllegalArgumentException("传入的参数有误，无法获取执行的必要条件"); &#125; //5.创建 Executor 对象 Executor executor = new Executor(); return executor.selectList(mapper, conn); &#125;&#125; 3.6 运行测试类1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: MybatisTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的环境&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; //7.释放资源 session.close(); in.close(); &#125;&#125; 4. 基于注解方式定义Mybatis框架4.1 自定义@Select注解1234567891011/**** &lt;p&gt;Title: Select&lt;/p&gt;* &lt;p&gt;Description: 自定义查询注解&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; String value();&#125; 4.2 修改持久层接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 4.3 修改 SqlMapConfig.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee50"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper class="com.itheima.dao.IUserDao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5. 自定义Mybatis的设计模式说明5.1 工厂模式（SqlSessionFactory） 5.2 代理模式（MapperProxyFactory） 代理模式分为静态和动态代理。静态代理，我们通常都很熟悉。有一个写好的代理类，实现与要代理的类的一个共同的接口，目的是为了约束也为了安全。具体不再多说。 这里主要想说的是关于动态代理。我们知道静态代理若想代理多个类，实现扩展功能，那么它必须具有多个代理类分别取代理不同的实现类。这样做的后果是造成太多的代码冗余。那么我们会思考如果做，才能既满足需求，又没有太多的冗余代码呢？——————动态代理。通过前面的课程我们已经学过了基于 JDK 的动态代理实现方式，今天我们就会使用 JDK 动态代理方式来编写 MapperProxyFactory 类。 动态代理模型图： 5.3 构建者模式（SqlSessionFactoryBuilder） 具体设计模式的模型图如下： 从图中我们可以看出，创建者模式由四部分组成。 抽象创建者角色：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体创建者角色。具体创建者必须实现这个接口的两种方法：一是建造方法，比如图中的 buildPart1 和 buildPart2 方法；另一种是结果返回方法，即图中的 getProduct 方法。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少零件，就有多少相应的建造方法。 具体创建者角色：他们在应用程序中负责创建产品的实例。这个角色要完成的任务包括：1、实现抽象创建者所声明的抽象方法，给出一步一步的完成产品创建实例的操作。2、在创建完成后，提供产品的实例。 导演者角色：这个类调用具体创建者角色以创建产品对象。但是导演者并没有产品类的具体知识，真正拥有产品类的具体知识的是具体创建者角色。 产品角色：产品便是建造中的复杂对象。一般说来，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以使不相关联的。 5.4 小结通过自定义 Mybatis 框架的学习，我们将前面的基础知识很好的结合在一起，并且强化了我们的设计模式及使用。希望大家能够抽时间多练习，这也是系统架构师的必由之路。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架快速入门]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21-Mybatis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 Mybatis框架开发的准备 搭建Mybatis开发环境 小结 基于注解的Mybatis使用 1. Mybatis框架开发的准备1.1 官网下载 Mybatis 框架从百度中“mybatis download”可以下载最新的 Mybatis 开发包。 进入选择语言的界面，进入中文版本的开发文档。 我们可以看到熟悉的中文开发文档了。 下载相关的 jar 包或 maven 开发的坐标。 下载的 zip 文件如下 我们所使用的 Mybatis 版本是 3.4.5 版本。 2. 搭建 Mybatis 开发环境2.1 创建maven工程创建 mybatis01 的工程，工程信息如下： Groupid:com.itheimaArtifactId:mybatis01Packing:jar 2.2 添加 Mybatis3.4.5 的坐标在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 编写User实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 2.4 编写持久层接口IUserDaoIUserDao 接口就是我们的持久层接口（也可以写成 UserDao 或者 UserMapper）,具体代码如下： 12345678910111213/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; 2.5 编写持久层接口的映射文件IUserDao.xml要求： 创建位置：必须和持久层接口在相同的包中。 名称：必须以持久层接口名称命名文件名，扩展名是.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.6 编写 SqlMapConfig.xml 配置文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee50"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper resource="com/itheima/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.7 编写测试类1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: MybatisTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的环境&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; //7.释放资源 session.close(); in.close(); &#125;&#125; 3. 小结通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。） 但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。 这些问题我们在自定义 mybatis 框架的章节，通过层层剥离的方式，给大家讲解。 请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有一个认识。 4. 基于注解的 Mybatis 使用4.1 在持久层接口中添加注解1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") List&lt;User&gt; findAll();&#125; 4.2 修改 SqlMapConfig.xml1234&lt;!-- 告知 mybatis 映射配置的位置 --&gt;&lt;mappers&gt; &lt;mapper class="com.itheima.dao.IUserDao"/&gt;&lt;/mappers&gt; 4.3 注意事项在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件项目需求分析到详细设计]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%88%B0%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[目录 软件生命周期 需求分析 详细设计 1. 软件生命周期1.1 什么是软件生命周期软件生命周期又称为软件生存周期或系统开发生命周期，是指从软件的产生直到报废的整个过程。 软件生命周期过程包括： 问题定义： 用户需要计算机解决的问题是什么？ 电商系统：要计算机实现一个平台，商家通过平台销售自己的商品，一般用户通过平台购买商品。 可行性分析 用户需要计算机解决的问题是否可行？需要进行可行性分析。 市场可行性分析，是否有市场价值。 技术可行性分析，使用什么技术解决用户提出的问题。 需求分析（重点） 将用户提出的问题进行细化。 先确定大模块：比如电商系统包括：前台（用户购买商品），后台（商家维护商品）。 对每一个大模块进行细化。。。。。 直到细化到不能细化为止（可以对需求分析的结果进行设计 ）。 设计（次重点） 确定细化问题的实现方法（比如：要设计什么接口，设计功能什么技术实现。。。）。 编码 去解决问题，依据需求和设计 文档进行开发。 测试 验证是否已经解决用户提出的问题。 单元测试（通过在开发阶段由开发人员进行测试）。 集成测试（测试业务整体流程）。 功能用例测试（对每个细化 的功能点进行测试）。 性能测试(使用专业工具进行压力和稳定性测试)。 维护（占整个软件生命周期很大的比重） 修改性维护：前期没有测试出的问题，正式上线运行后bug（缺陷）显示出来了，对这些bug进行修改。 完善性维护：在现有功能的基础上增加或完善功能。 预防性维护：后期根据正式运行的情况对系统进行优化，避免一些问题的发生。 1.2 常用的开发模型企业开发中对上边开发阶段常使用一些模型： 1.2.1 瀑布模型 强调：开发的每个阶段是顺序执行，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈（为了解决问题需要重复执行），如何在某个阶段出现问题，需要从上一个阶段甚至更早的阶段去解决排查问题。 适用场合：需求明确，解决方案明确，常在一些中小型项目中使用。 1.2.2 原型模型 强调：逐步求精（每一次修改对上次原型的完善）对原型 进行修改优化，开发阶段围绕着原型（当成样品）进行实施。 适用场合：前期需求不确定，采用原型方法方便搜集需求。 1.2.3 增量模型 增量模型：瀑布模型加上原型模型，增量模型融合了瀑布模型的基本成分（重复应用）和原型实现的迭代特征。 每一次增量经过了开发的每一个阶段（瀑布模型经过的所有阶段） 每一次增量对功能进行完善（原型模型的逐步求精） 适用场合：大型项目，需求不明确。 2. 需求分析（重点）2.1 什么是需求分析需求分析是在问题定义及可行性分析完成后细化用户对软件的功能和性能的要求，即用户希望软件能做什么事情，完成什么样的功能，达到什么性能。 包括：需求调研、需求描述（重要）、需求评审。 重要性：需求分析是软件工发的开端，我们设计的软件产品存在不完整性、不正确性大部分原因是需求分析错误所导致的，因此，需求分析是软件生命周期中最重要的过程。 2.2 需求调研目标：挖掘用户需求 过程：首先确定目标用户，开发人员和目标用户确定一个问题领域，并定义一个描述该问题的系统，用户在这个问题领域和系统下提出需求，需求类型包括：功能需求、质量需求、用户体验需求等。 需求调研方法： 根据不同的项目、不同的用户群体采用不同的方法： 与客户交谈，向用户提问题 参观用户工作流程，观察用户操作 向用户发调查问卷（通常是以选择题和是非题为主） 与同行、专家交谈，听取他们的意见 分析已经存在的软件产品，提取需求 从行业标准、规划中提取需求 上网搜索相关资料 成果物：需求调研报告.doc 2.3 需求描述(重要)通过需求调研对收集到的资料进行分析、鉴别、综合和建模，清除用户需求的模糊性、歧义性和不一致性，分析系统的数据要求，为原始问题及目标软件建立逻辑模型。 分析人员需要编写“软件需求说明书”并与用户进行交流确认。 成果物：“软件需求说明书”或“软件需求规格说明书” 重要性： 需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书 软件开发人员需要根据“软件需求规格说明书”进行设计和编码。 软件需求规格说明书的内容也是根据公司的项目管理水平而定。 内容基本包括：系统概述、运行环境、功能模块图、功能用例、性能需求、接口需求、其它需求等。 功能模块图/功能架构图：通常使用visio画。 使用powerDesigner画用例图： 描述 了每类用户所操作的功能点。 功能用例： 描述功能点的具体内容。 接口需求： 系统对外接口： 接口描述内容：商品支付接口 接口功能描述： 电商网站需要调用网银支付接口进行支付 接口方向： 电商网站–&gt;网银 接口协议：https 接口数据描述(重点)： 开发人员依据接口数据描述开发程序。 电商网站要向网银发送什么数据格式（常用格式有xml或json） （包括请求和响应两部分数据） 建议：企业开发必须经过正规的需求分析过程。 2.4 需求评审由架构师、技术经理、需求分析人员、设计人员、开发人员对“需求规格说明书”进行审核。 审核内容： 1、看需求规格说明书是否符合文档规范。 2、需求描述 是否详细（设计人员可以依据需求说明书进行设计） 3 设计根据软件需求说明书进行设计，设计系统整体架构、系统外部和内部接口、实现算法和核心代码编写等，总之包括两个阶段：总体设计（概要设计 ）、详细设计。 3.1 概要设计概要设计内容： 总体结构和模块间的关系； 系统架构包括：技术架构和功能架构。 技术架构： 系统使用什么技术完成哪些模块的功能。 javaEE常用技术架构： ssh：struts2+spring+hibernate 主要开发中小型的传统企业应用系统。 ssm：springmvc+mybatis 主要开发分布式联系网项目。 功能架构 就是需求描述的功能框图 业务流程图： 使用visio画核心业务流程图： 系统网络部署结构 定义系统的外部接口、及模块间的接口； 接口描述内容：商品支付接口 接口功能描述： 电商网站需要调用网银支付接口进行支付 接口方向： 电商网站–&gt;网银 接口协议：https 接口数据描述(重点)： 开发人员依据接口数据描述开发程序。 电商网站要向网银发送什么数据格式（常用格式有xml或json） （包括请求和响应两部分数据） 3.2 详细设计详细设计内容： ​ 详细设计的主要任务是设计每个模块的类接口、所需的局部数据结构、物理数据模型、页面原型等。 注意：一般情况下公司根据人力现状不写详细设计文档的，可以在需求分析阶段和概要设计 阶段对详细设计的内容进行描述。 每个模块的类接口： 通过伪代码实现，描述接口参数、接口功能。 局部数据结构：需要自定义什么数据类型。。 物理数据模型（重点）： 使用powerDesigner设计物理数据模型(根据公司要求可能在需求分析阶段或概要设计 阶段实现) 通过powerDesigner创建数据库表、存储过程等元素。]]></content>
      <categories>
        <category>软件工程</category>
        <category>需求分析与详细设计</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>需求分析</tag>
        <tag>详细设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架概述]]></title>
    <url>%2F2019%2F05%2F20%2F2019-05-20-Mybatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 什么是框架 JDBC编程的分析 1. 什么是框架1.1 什么是框架框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 1.2 框架要解决的问题框架要解决的最重要的一个问题是技术整合的问题，在 J2EE 的 框架中，有着各种各样的技术，不同的软件企业需要从 J2EE 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。 框架一般处在低层应用平台（如 J2EE）和高层业务逻辑之间的中间层 。 1.3 软件开发的分层重要性框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。 我们常见的MVC 软件设计思想就是很好的分层思想。 1.4 分层开发下的常见框架 1.5 MyBatis 框架概述mybatis是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis通过 xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。 2. JDBC 编程的分析2.1 jdbc 程序的回顾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); //通过驱动管理类获取数据库链接 connection = DriverManager .getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8","root", "root"); //定义 sql 语句 ?表示占位符 String sql = "select * from user where username = ?"; //获取预处理 statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的参数值 preparedStatement.setString(1, "王五"); //向数据库发出 sql 执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString("id")+" "+resultSet.getString("username")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 上边使用 jdbc 的原始方法（未经封装）实现了查询数据库表记录的操作。 2.2 jdbc 问题分析1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java代码。3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo 对象解析比较方便。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（下）]]></title>
    <url>%2F2019%2F03%2F21%2F2019-03-21-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（中）的学习，小艾对MySQL的多表查询有了更深刻的了解，掌握前面的内容，其实对于我们一般的开发也就足够了，今天就学习MySQL原理性一点的内容。 目录 存储引擎 事务 索引 视图 DBA命令 数据库设计三大范式 1. 存储引擎 存储引擎是MySQL特有的，其它数据库没有 1.1 存储引擎的本质 通过采用不同的技术将数据存储在文件戒内存中； 每一种技术都有不同的存储机制，不同的存储机制提供不同的功能和能力； 通过选择不同的技术，可以获得额外的速度戒功能，改善我们的应用； 1.2 MySQL支持很多种存储引擎常见命令： 1.2.1.show engines\G (1)在创建表时，可使用Engines选项为CREATE TABLE语句显示指定存储引擎 例如： 123CREATE TABLE table_name( NO INT)ENGINE = MyISAM; (2)如果创建表时没有指定存储引擎，则使用当前默认的存储引擎； (3)默认的存储引擎可在 my.ini 配置文件中使用 default-storage-engin 选项指定； (4)修改表的存储引擎使用：ALTER TABLE 表名 ENGINE **= 存储引擎名称; (5)查看表使用的存储引擎，命令如下： SHOW CREATE TABLE emp\G; SHOW TABLE STATUS LIKE ‘emp’\G; 1.3 常用的存储引擎1.3.1 MyISAM存储引擎MyISAM引擎是MySQL数据库最常用的； 它管理的表具有以下特性： 使用三个文件表示每个表： 格式文件 — 存储表的结构（mytable.frm）数据文件 — 存储表的数据（mytable.MYD）索引文件 — 存储表的索引（mytable.MYI） 可转换为压缩、叧读表来节省空间 1.3.2 InnoDB存储引擎InnoDB存储引擎是MySQL数据库的缺省引擎； 它管理的表具体有以下特征： a) 每个InnoDB表在数据库目录中以.frm格式文件表示b) InnoDB表空间tablespace被用亍存储表的内容c) 提供一组用来记录事务性活劢的日志文件d) 用COMMIT（提交）、SAVEPOINT及ROLLBACK（回滚）支持事务处理e) 提供全部ACID兼容f) 在MySQL服务器崩溃后提供自劢恢复g) 多版本（MVCC）和行级锁定h) 支持外键及引用的完整性，包括级联更新和删除 1.3.3 MEMORY存储引擎使用MEMORY存储引擎的表，因为数据存储在内存中，且行的长度固定，所以使得MEMORY存储引擎非常快； MEMORY存储引擎管理的表具有下列特征： a) 在数据库目录内，每个表均以.frm格式文件表示；b) 表数据及索引被存储在内存中；c) 表级锁机制；d) 字段属性不能包含TEXT戒BLOB字段； MEMORY存储引擎以前被称为HEAP引擎； 1.4 选择合适的存储引擎MyISAM表最适合于大量的数据读而少量数据更新的混合操作。MyISAM表的另一种适用情形是使用压缩的只读表。 如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为数据读取和更新的混合提供了良好的并发机制。 使用MEMORY存储引擎存储非永丽需要的数据，戒者是能够从基于磁盘的表中重新生成的数据。 2. 事务2.1 事务是什么（5点） 一个最小的不可再分的工作单元； 通常一个事务对应一个完整的业务；（如：银行转账业务） 而一个完整的业务需要批量的DML（insert、update、delete）语句共同完成 事务只和DML语句有关系，戒者说叧有DML语句才有事务； 以上所描述的批量DML语句共有多少DML诧句，这个和业务逻辑有关系，业务逻辑不同DML语句个数不同 ； 2.1.1 关与银行转账业务银行转账业务：是一个完整的业务，最小的单元，不可再分，也就是说银行转账业务是一个完整的事务。 示例：账户转账 t_act账户表：actno，balance actno balance act-001 50000.0 act-002 10000.0 act-001转10000.0给act-002，操作如下： update t_act set balance = 40000.0 where actno = ‘act-001’; update t_act set balance = 20000.0 where actno = ‘act-002’; 分析： （1）以上两条DML语句必须同时成功戒者同时失败，因为它为最小业务单元，不可拆分； （2）当第一条DML语句执行成功之后，并不能将底层数据库中的第一个账户的数据修改，而是将操作记录了一下，这个记录是在内存中完成的。 （3）当第二条DML与句执行成功之后，和底层数据库文件中的数据完成同步。 （4）若第二条DML语句执行失败，将清空所有的历史操作记录。 结论：要完成以上功能，必须借助事务 transaction。 2.2 概述事务可以保证多个操作原子性，要举全成功，要举全失败。对亍数据库来说，事务保证批量的DML要举全成功，要么全失败。 2.2.1 事务具有四个特征ACID：（1）原子性（Atomicity）事务是最小单元，不可再分； （2）一致性（Consistency）事务要求所有的DML语句操作的时候，必须保证同时成功或同时失败； （3）隔离性（Isolation）一个事务不会影响其它事务的运行； （4）持久性（Durability）在事务完成之后，该事务对数据库所作的更改将持久地保存在数据库中，并不会被回滚； 2.2.2 事务中的一些概念（1）开启事务：start transaction （2）结束事务：end transaction （3）提交事务：commit transaction （4）回滚事务：rollback transaction 2.3.3 和事务有关的两条SQL语句【TCL】COMMIT； 提交 ROLLBACK； 回滚 2.3.4 事务开启和结束的标志是什么 ？开始的标志 任何一条DML语句执行，标志事务的开启； 结束的标志 提交（commit）或者回滚（rollback） 提交：成功的结束，将所有的DML与句操作记录和底层硬盘文件中数据进行一次同步； 回滚：失败的结束，将所有DML语句操作记录全部清空； 2.3.5 重点（1）在事务进行过程中，未结束之前，DML语句是不会修改底层数据库文件中的数据。 （2）叧是将历史操作记录一下，在内存中完成记录。 （3）叧有在事务结束的，而且是成功结束的时候才会修改底层硬盘文件中的数据。 2.3.6 MySQL事务的提交和回滚的演示MySQL默认事务：自劢提交 show variables like ‘%commit%’; 在MySQL数据库管理系统中，默认情况下，事务是自动提交的；也就是说，叧要执行一条DML语句，就开启了事务，并且提交了事务； 第一种：关闭MySQL事务自动提交 事务成功用法：start transaction；commit; 第一步：start transaction; 手动开启事务第二步：DML诧句…. 执行批量DML语句 .第三步：commit; 手动提交事务【事务成功结束】 演示例子：在t_user表中插入数据：事务成功提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询原表数据 第二步：窗口1，手动开启事务 start transaction，插入数据，查询数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，手动提交事务commit 第五步：窗口2，查询 t_user 表 回滚提交用法：start transaction; rollback;第一步：start transaction; 手动开启事务第二步：DML语句….. 批量DML语句 演示例子：在 t_user表中插入数据，事务失败提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询 t_user 表数据 第二步：窗口1，开启事务start transaction，并向t_user表插入数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，rollback 回滚事务，并查询t_user表数据 第五步：窗口2，查询t_user表数据 第二种：关闭MySQL事务自劢提交：只对当前会话有效 两种关闭自动提交事务a） set autocommit = offb） set session autocommit = off 两种打开自劢提交事务a） set autocommit = onb） set session autocommit = on注：以上打开戒关闭事务叧对当前窗口有效； 查询事务状态： show variables like ‘%commit%’; 2.3.7 事务的隔离级别事务四个特性ACID之一：隔离性（isolation） 隔离性有四个隔离级别： 1） read uncommitted 读未提交2） read committed 读已提交3） repeatable read 可重复读4） serializable 串行化 read committed 读未提交（级别最低） 1） 事务A和和事务B，事务A未提交的数据，事务B可以读取2） 这里读取到的数据可以叨做“脏数据”戒“脏读 Dirty Read”3） 读未提交隔离级别最低，这种级别一般叧在理论上存在，数据库默认隔离级别一般都高于该隔离级别； read committed 读已提交 1） 事务A和事务B，事务A提交的数据，事务B才可读取到；2） 该隔离级别高亍“读未提交”级别3） 换句话说：对方事务提交之后的数据，当前事务才可读取到。4） 该隔离级别可以避免脏数据；5） 该隔离级别能够导致“不可重复读取”6） Oracle数据库管理系统默认隔离级别为“可重复读” repeatable read 可重复读 1） 事务A和事务B，事务A提交之后的数据，事务B读取不到2） 事务B是可重复读到数据的3） 这种隔离级别高于“读已提交”4） 换句话说，对方提交之后的数据，还是读取不到5） 这种隔离级别可以避免“脏读和不可重复读”，达到“重复读取”；6） MySQL数据库管理系统默认隔离级别为：可重复读7） 虽然可以达到“可重复读”效果，但是会导致“幻象读” serializable 串行化 1） 事务A和事务B，事务A在操作数据库表中数据的时候，事务B叧能排队等待；2） 这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好；3） 这种隔离级别可以避免“幻象读”，每一次读取都是数据库表中真实的记录；4） 事务A和事务B不再并发； 查看隔离级别 1） 查看当前会话级隔离级别select @@tx_isolation;select @@session.tx_isolation; 2） 查看当前全局隔离级别： @@global.tx_isolation;select @@global.tx_isolation; 设置服务器缺省隔离级别 第一种：修改my.ini配置文件在 my.ini 文件中的[mysqld]下面添加：————————-my.ini——————————-[mysqld]transaction-isolation = READ-COMMITTED————————–my.ini——————————-a） 隔离级别可选项为：– READ-UNCOMMITTED– READ-COMMITTED– REPEATABLE-READ– SERIALIZABLE 第二种：通过命令方式设置事务隔离级别a） SET TRANSACTION ISOLATION LEVEL isolation-level;b） isolation-level 可选值：– READ UNCOMMITTED– READ COMMITTED– REPEATABLE READ– SERIALIZABLE 设置隔离级别作用的范围 1） 事务隔离级别的作用范围分为两种：会话级、全局级a） 会话级（session）：叧对当前会话有效b） 全局级（global）：对所有会话有效2） 使用方法如下 a） 会话级：SET TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;SET SESSION TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;b） 全局级SET GLOBAL TRANSACTION ISOLATION LEVEL; 隔离级别不一致性问题的关系 隔离级别 脏读 不可重复地 幻象读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 隔离级别不一致性问题的关系 1） 读未提交 READ UNCOMMITTED 会话一 会话二 set global transaction isolation level read uncommitted; 退出DOS窗口 use bjpowernode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpowernode; start transaction; start transaction; insert into t_user(name) values(‘king’); select * from t_user; 2） 读已提交 READ COMMITTED 会话一 会话二 set global transaction isolation level read committed; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; insert into t_user(name) values(‘allen’); select * from t_user; commit; select * from t_user; 3） 可重复读 REPEATABLE READ 会话一 会话二 set global transaction isolation level repeatable read; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; 4） 串行化 SERIALIZABLE 会话一 会话二 use bjpowernode; Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32));insert into t_user(name) values(‘zhangsan’);insert into t_user(name) values(‘lisi’); set global transaction isolation level serializable; 退出DOS窗口 use bjpownode; use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; commit; 3.索引3.1 索引原理3.1.1 什么索引索引对应的英语单词：index 索引作用： 相当于一本字典目录，提高程序的检索 / 查询效率；表中每一个字段都可添加索引 主键自动添加索引： 能够通过主键查询的尽量通过主键查询，效率较高； 索引和表相同，存储在硬盘文件中 索引和表相同，都是一个对象，表是存储在硬盘文件中的，那举索引也是表的一部分，索引也存储在硬盘文件中； MySQL数据库中表的检索方式有2种： 第一种：全表扫描（效率较低） 举例：查询ename=’KING’假设有一张表：emp 员工表，select from emp where ename = ‘KING’;若ename没有添加索引，那举通过ename过滤数据的时候，ename字段会全表扫描；假设有一张表：dept 部门表，select from dept where dname = ‘ACCOUNTING’；若dname没有添加索引，那举通过dname过滤数据的时候，dname字段会全表扫描； 第二种：通过索引检索（提高查询效率） 3.1.2 什么情况下适合给表中字段添加索引1） 该字段数据量庞大2） 该字段很少的DML操作（由亍索引也需要维护，DML操作多的话，也影响检索效率）3） 该字段经常出现在where条件中注：实际开发中会根据项目需求或客户需求等综合因素来做调整 3.1.3 索引的应用创建索引 1） 语法结构：a） create index 索引名 on 表名（列名）b） create unique index 索引名 on 表名（列名）注：添加unique表示在该表中的该列添加一个唯一性约束示例：create index dept_dname_index on dept(dname); 查看索引 1） 语法结构：a） show index from 表名示例：show index from dept; 删除索引 1） 语法结构：a） drop index 索引名 on 表名;示例：drop index dept_dname_index on dept; 4.视图4.1 什么是视图1） 视图对应英文单词：view2） 视图在数据库管理系统中也是一个对象，也是以文件形式存在的3） 视图也对应了一个查询结果，叧是从不同的角度查看数据 4.2 创建视图语法结构：create view 视图名称 as 查询语句； 例子：从emp表查询empno,ename,sal，结果当作视图展示 4.3 删除视图语法结构：drop view if exists 视图名称; 示例：删除myview视图：drop view if exists myview; 4.4 修改视图语法结构：alter view 视图名称 as 查询语句 示例：将myview视图修改为deptno,ename,job,sal 4.5 视图作用4.5.1 面向视图查询，可以提高查询效率例如 1） 单独执行：select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;2） 将上面执行结果当作视图对象创建create view myview as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;3） 面向视图查询：没有迚行表连接，提高检索效率select * from myview;【非常重要】隐藏表的实现细节 1、 create view myview as select empno a,ename b,sal c from emp;2、面向视图查询，叧知道myview视图中有a,b,c三个字段，不知道该视图背后真实表的结构是什么 5.DBA命令5.1 新建用户CREATE USER username IDENTIFIED BY ‘password’; username：你将创建的用户名,password：该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.示例：create user p361 identified by ‘123’;–可以登录但是叧可以看见一个库 information_schema 5.2 授权命令详解 示例：grant all privileges on dbname.tbname to ‘username‘@’login ip’ identified by ‘password’ with grant option; 1) dbname=表示所有数据库2) tbname=表示所有表3) login ip=%表示任何ip4) password为空，表示不需要密码即可登录5) with grant option; 表示该用户还可以授权给其他用户细粒度授权1、首先以root用户进入mysql2、然后键入命令：grant select,insert,update,delete on . to p361 @localhost Identified by “123”;3、如果希望该用户能够在任何机器上登陆mysql，则将localhost改为 “%” 。 粗粒度授权我们测试用户一般使用该命令授权：GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123”;注意：用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123” WITH GRANT OPTION;用户权限privileges包括：1） alter：修改数据库的表2） create：创建新的数据库戒表3） delete：删除表数据4） drop：删除数据库/表5） index：创建/删除索引6） insert：添加表数据7） select：查询表数据8） update：更新表数据9） all：允许任何操作10） usage：叧允许登录 5.3 回收授权命令详解 revoke privileges on dbname[.tbname] from username;revoke all privileges on . from p361; use mysqlselect * from user进入 mysql库中修改密码; update user set password = password(‘qwe’) where user = ‘p646’;刷新权限;flush privileges 5.4 导入导出导出：mysqldump 导出整个数据库C: \Administrator&gt; mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123导出指定库下的指定表C: \Administrator&gt;mysqldump bjpowernode emp&gt; D:\ bjpowernode.sql -uroot -p123 导入：source 登录MySQL数据库管理系统之后执行：mysql&gt;source D:\ bjpowernode.sql 6.数据库设计三范式定义：设计数据库的时候所依据的规范，共有三个规范； 6.1 第一范式：主键、字段不能再分定义：要求有主键，数据库中不能出现重复记录，每一个字段是原子性不能再分； 示例：不符合第一范式 学生编号 学生姓名 联系方式 1001 张三 zs@gmail.com,1359999999 1002 李四 ls@gmail.com,13699999999 1001 王五 ww@163.net,13488888888 分析以上设计存在的问题：1） 数据存在重复记录，数据不唯一，没有主键2） 联系方式可以再分，不是原子性修改以上设计方案： 学生编号(pk) 学生姓名 email 联系电话 1001 张三 zs@gmail.com 1359999999 1002 李四 ls@gmail.com 13699999999 1003 王五 ww@163.net 13488888888 结论：关于第一范式 1、 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，2、 主键主要通常采用数值型或定长字符串表示3、 关亍列丌可再分，应根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段了； 6.2 第二范式：非主键字段完成依赖主键定义：第二范式是建立在第一范式基础之上，要求数据库中所有非主键字段完全依赖主键，不能产生部分依赖；（严格意义上说：尽量不要使用联合主键） 示例一：数据仍然可能重复 学生编号 学生姓名 教师编号 教师姓名 1001 张三 001 王老师 1002 李四 002 赵老师 1003 王五 001 王老师 1001 张三 002 超老师 示例二：确定主键，学生编号、教师编号，出现冗余 学生编号（PK） 教师编号(PK) 学生姓名 教师姓名 1001 001 张三 王老师 1002 002 李四 赵老师 1003 001 王五 王老师 1001 002 张三 赵老师 综合分析：1、 以上虽然确定了主键，但此表会出现大量冗余，主要涉及到的冗余字段为“学生姓名”和“教师姓名”；2、 出现冗余的原因在亍：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。 解决方案如下： 学生信息表： 学生编号（PK） 学生姓名 1001 张三 1002 李四 1003 王五 教师信息表： 教师编号（PK） 教师姓名 001 王老师 002 赵老师 教师和学生的关系表： 学生编号(PK) fk-&gt;学生表的学生编号 教师编号(PK) fk-&gt;教师表的教师编号 1001 001 1002 002 1003 001 1001 002 结论：一种典型的“多对多”的设计 6.3 第三范式定义：建立在第二范式基础之上，要求非主键字段不能产生传递依赖于主键字段； 示例一：学生信息表 学生编号（PK） 学生姓名 班级编号 班级名称 1001 张三 01 一年一班 1002 李四 02 一年二班 1003 王五 03 一年三班 1004 六 03 一年三班 综合分析：1、从表中看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键2、班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖， 解决方案：1、 将冗余字段单独拿出来建立表2、 如下表所示：学生信息表中班级编号设为外键FK学生信息表： 学生编号（PK） 学生姓名 班级编号（FK） 1001 张三 01 1002 李四 02 1003 王五 03 1004 赵六 03 班级信息表： 班级编号（PK） 班级名称 01 一年一班 02 一年二班 03 一年三班 结论： 典型的一对多以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键 6.4 三范式总结6.4.1 一对一第一种方案：分两张表存储，共享主键 1） 示例：t_husband 和 t_wife两张表丈夫表 ：t_husband hno（PK） hname 1 Zhangsan 2 Wangwu 3 zhaoliu 妻子表：t_wife wno（PK）【同时也是外键FK，引用t_husband的主键】 wname 3 a 2 b 1 c 第二种方案：分两张表存储，外键唯一 示例：t_husband 和 t_wife两张表 **丈夫表 ：t_husband hno（PK） hname Wifeno（FK - unique） 1 Zhangsan 100 2 Wangwu 200 3 zhaoliu 300 妻子表：t_wife wno（PK） wname 100 a 200 b 300 c 6.4.2 一对多分两张表存储，在多的一方添加外键，这个外键字段引用一的一方中的主键字段例如：学生信息表和班级信息表，请参考：20.3.2 示例一 6.4.3 多对多例如：分三张表存储，在学生表中存储学生信息，在课程表中存储课程信息，在选课表中存储学生选课信息，请参考：20.2 6.5 实际开发中是怎么的？1） 数据库设计尽量遵循三范式2） 根据实际需求迚行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。 好，终于学完MySQL了，那么MySQL的学习就暂告一段落了。这么多东西，小艾要去休息休息消化消化一下才行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（中）]]></title>
    <url>%2F2019%2F03%2F19%2F2019-03-19-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%AD)%20%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（上）的学习，小艾已经有初步对MySQL的了解，前面学习的内容还是比较简单的，今天，就再深入的学习MySQL的查询吧。 目录 连接查询 子查询 union合并集合 limit使用 表 1. 连接查询在实际开发中，数据往往不是存放储一张表中，而是同时存储在多张表中，这些表与表存在着关系，我们在检索数据的时候往往需要多张表联合起来检索，这种多表联合检索被称为连表查询或跨表查询。 1.1 笛卡尔积现象含义：若两张表迚行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录的乘积，该现在称为笛卡尔积现象。 1.1.1 显示每个员工信息，并显示所属部门名称 1.2连接查询根据：年代分类1.2.1 SQL92语法语法结构：select xxxx from A表名,B表名 where 表连接条件 and 数据查询条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e,dept d where e.deptno = d.deptno; 缺点：表连接条件与查询条件放在一起，没有分离； 1.2.2 SQL99语法【只掌握SQL99】语法结构：select xxxx from A表名 join B表名 on 表的连接条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e join dept d on e.deptno = d.deptno; 优点：表连接独立，结构清晰，如果结果数据不满足要求，可再追加where条件进行过滤； 1.3连接查询根据：连接方式分类1.3.1 内连接定义：只连接匹配的行，即A表不B表相连接，能够匹配的记录查询出来。 （1）等值连接 示例：查询员工的名称和员工所对应的部门名称 select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;注：inner可忽略 （2）非等值连接 示例：查询员工的工资等级 select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可忽略 （3）自连接 示例：查询员工的名称和员工对应的领导名称 select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno;注：inner可忽略 1.3.2 外连接定义：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录时，会自动模拟出null值与之匹配；注意：外连接的查询结果条数 &gt;= 内连接的查询结果条数 （1）左外连接（左连接） 定义：包含左边表的全部行（不管右边的表中是否存在不它们匹配的行），以及右边表中全部匹配的行； （2）右外连接（右连接） 定义：包含右边表的全部行（不管左边的表中是否存在不它们匹配的行），以及左边表中全部匹配的行； （3）全连接（了解） 定义：包含左、右两个表的全部行，不管另外一边的表中是否存在不它们匹配的行。 1.4七大案例详解1.4.1 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（笛卡尔积）注意：多张表查询时，通常会对表起别名，若两张表中有相同名称的字段时，该相同名称字段不知道属亍哪张表中，这时需要通过对表起别名来限制该字段属于哪张表，并且提高SQL语句的效率，可读性也高。 思路分析：（1） Step 1：先查询出员工姓名和部门编号；emp员工表 （2）Step 2：再查询出部门编号和部门名称；dept部门表 联想：当多张表连接查询时，若没有任何条件限制，会发生什么？ select e.ename,d.dname from emp e,dept d;预测查询结果： 验证结果： 结论：为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件； 1.4.2 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（内连接：等值）思路分析（1） Step 1：从emp e 员工信息表查询出员工姓名、部门编号； （2）Step 2：从dept d部门信息表查询出部门编号、部门名称； 注意：在连接查询时，即使我们使用的了限制条件，但是匹配次数没有减少，只显示有效数据； （3）Step 3：内连接等值条件：e.deptno=d.deptno SQL92语法：内连接中的等值连接（不建议）select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno; SQL99语法：select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;//inner可省略 1.4.3 找出每一个员工对应的工资等级，要求显示员工姓名、工资、工资等级（内连接：非等值）思路分析 （1）Step 1：从emp e员工信息表查询出员工的姓名、工资 （2）Step 2：从salgrade s工资等级表查询出工资等级信息 （3）Step 3：内连接非等值条件：between s.losal and s.hisal; SQL92语法：（不建议）select e.ename,e.sal,s.grade from emp e , salgrade s where e.sal between s.losal and s.hisal; SQL99语法：内连接中的非等值连接select e.ename,e.sal,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可以省略 1.4.4 找出每一个员工的上级领导，要求显示员工姓名及对应的领导姓名（内连接：自连接）思路分析： （1）Step 1：从emp a员工信息表查询出员工编号、员工名称、领导编号 （2）Step 2：从emp b领导信息表查询出领导姓名、领导编号 （3）Step 3：自连接条件为：领导编号=员工编号 SQL92语法：（不建议） select a.ename empname,b.ename leadername from emp a,emp bwhere a.mgr = b.empno; SQL99语法：内连接中的自连接 select a.ename empname ,b.ename leadername from emp a inner join emp b on a.mgr = b.empno;select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno ;注：inner可以省略 1.4.5 找出每一个员工对应的部门名称，要求部门名称全部显示（左/右外连接）思路分析： （1）Step 1：先查询出每一个员工对应的部门名称 （2）Step 2：查询部门信息 （3）Step 3：右外连接条件：员工表的部门编号=部门表的部门编号 SQL99语法：外连接中的右外连接【右连接】 select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e right join dept d on e.deptno = d.deptno;//outer可省略 SQL99语法：外连接中的左外连接【左连接】 select e.ename,d.dname from dept d left outer join emp e on e.deptno = d.deptno;select e.ename,d.dname from dept d left join emp e on e.deptno = d.deptno;//outer可省略 注意：任何一个右外连接都可写成左外连接，任何一个左外连接都可写成右外连接； 1.4.6 为什么 inner 和 outer 可以省略，加上去有什么好处？可以省略，因为区分内连接与外连接不是依靠这两个关键字，而是看SQL语句中的left/right关键字；加上left、right关键字增强SQL语句的可读性。 1.4.7 找出每一个员工对应的领导名，要求显示所有员工（左外连接）思路分析： （1）Step 1：显示每一个员工对应的领导名 （2）Step 2：以上查询结果缺少一位员工King，通过左外连接查询全部员工。 SQL99语法：select a.ename empname ,b.ename leadername from emp a left join emp b on a.mgr = b.empno; 1.4.8 找出每一个员工对应的部门名称，以及该员工对应的工资等级，要求显示员工姓名、部门名称、工资等级。思路分析： （1）Step 1：查询出员工对应的部门编号和工资emp e表 （2）Step 2：查询出部门信息dept d表 （3）Step 3：查询出工资等级信息salgrade s表 （4）多表连接条件：员工表不部门表连接（e.deptno = d.deptno），再与工资等级表连接（e.sal between s.losal and s.hisal） 重点：多张表进行表连接的语法格式： 123456789101112select xxxxfrom A表join B表on 连接条件1join C表on 连接条件2； 原理：A表和B表通过连接条件1连接之后，A表再和C表通过连接条件2进行连接； 12345678910111213emp e表、dept d表、salgrade s表select e.ename,d.dname,e.sal,s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 2.子查询定义：select 语句嵌套 select 语句被称为子查询；注意：select子句可出现在select、from、where关键字后面，如下：select … (select)…【很少很少使用了解即可】from …(select)…where …(select)… 2.1 案例2.1.1 （where后）找出薪水比公司平均薪水高的员工，要求显示员工名和薪水注意：select ename,sal from emp where sal &gt; avg(sal);执行错误：因为分组函数不能直接使用在where关键字后面 思路分析： （1）第一步：找出公司的平均薪水，平均薪水：2073.214286 （2）第二步：找出薪水比公司平均薪水：2073.214286高的员工 （3）第三步：将平均薪水2073.214286值替换为它的查询诧句即可； 2.1.2 （from后）找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级思路分析： （1）第一步：根据部门分组找出每个部门的平均薪水 （2）第二步：查询出薪水等级信息 （3）第三步：将第一步查询结果当作一张临时表 t，然后将t表不薪水等级表做进行表连接，条件t.avgsal between s.losal and s.hisal; 小窍门：可将查询结果当做临时表 2.1.3 （select后使用了解）select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; 3.union合并集合定义：将查询的结果集合幵注意事项：合并结果集的时候，查询字段个数必须相同； 3.1 示例3.1.1 查询出job为MANAGER和SALESMAN的员工select empno,ename,job from emp where job = ‘MANAGER’unionselect ename,job from emp where job = ‘SALESMAN’;以上写法错误： 正确写法：select empno,ename,job from emp where job = ‘MANAGER’unionselect empno,ename,job from emp where job = ‘SALESMAN’; 注意：查询字段类型在MySQL中不必完全相同，但是Oracle中一定要类型也相同； 写法错误： select e.empno,e.ename from emp eunionselect d.dname,d.loc from dept d; 正确写法：select e.empno,e.ename from emp eunionselect d.deptno,d.loc from dept d; 3.1.2 查询包含 MANAGER 和 SALESMAN 的员工信息（1）第一种方式：in (‘MANAGER’,‘SALESMAN’) select from emp where job in(‘MANAGER’,‘SALESMAN’);select from emp where job = ‘MANAGER’or job = ‘SALESMAN’; （2）第二种试：使用 union关键字查询 select from emp where job = ‘MANAGER’unionselect from emp where job = ‘SALESMAN’; 4.limit使用作用：（只在MySQL中起作用）获取一表前几条戒中间某几行数据； 4.1 用法：limit 起始下标m,长度nm：记录开始的index，默认从 0 开始，表示第一条记录；n ：指从第 m+1 条开始，取 n 条； 4.2 取前5个员工信息思路分析 （1）第一步：查询出全部员工的信息 （2）第二步：使用limit取出前5个员工的信息 以上SQL诧句中的“limit 5”中的“5”表示：从表中记录下标0开始，取5条记录，等同亍 select * from emp limit 0,5; 4.3 找出工资掋名在前5的员工思路分析： （1）第一步：按照工资降序掋列 order by desc （2）第二步：在以上基础上，取前5个员工limit出现在SQL诧句的最后位置 4.4 找出工资掋名在[ 3-9 ]的员工思路分析： （1）第一步：按照工资降序排列 order by desc （2）第二步：使用limit取出掋名在3到9的员工 4.5 MySQL中通用的分页SQL诧句提示：每页显示3条记录（长度为3） 第1页：0，3 包含页：1，2，3 limit 0,3第2页：3，3 包含页：4，5，6 limit 3,3第3页：6，3 包含页：7，8，9 limit 6,3… …每页显示pageSize条记录第pageNo页：(pageNo – 1) * pageSize，pageSize 12345678select enamefrom emporder by sal desclimit (pageNo – 1) * pageSize , pageSize; 通用分页SQL【只适用于MySQL数据库管理系统】 12345678select t.*from torder by t.xx desc/asclimit (pageNo – 1) * pageSize , pageSize; 5.表5.1 定义：表（table）：是数据库最基本的组成单元，数据库是用来存储数据的，数据库中有很多表，每一个表都是一个独立的单元，表也是一个结构化的文件，由行和列组成，行称为数据或记录，列称为字段，字段又包含：字段名称、字段类型、长度、约束。 5.2 创建表5.2.1 语法格式:create table 表名称(字段名 类型(长度) 约束)； 5.2.2 MySQL常用数据类型 （1）VARCHAR：可变长度字符串 VARCH AR(3)表示存储的数据长度丌能超过3个字符长度 （2）CHAR：定长字符串 CHAR(3) 表示存储的数据长度丌能超过3个字符长度 （3）INT：整数型 INT(3)表示最大可以存储999 （4）BIGINT：长整型 对应java程序中的long类型 （5）FLOAT：浮点型单精度 FLOAT(7,2)表示7个有效数字，2个有效小数位 （6）DOUBLE：浮点型双精度 DOUBLE(7,2)表示7个有效数字，2个有效小数位 （7）DATE：日期类型 实际开发中，常用字符串代替日期类型 （8）BLOB：二迚制大对象 Binary Large Object 与门存储图片、视频、声音等数据 数据库存储图片是很常见，但存储大视频是很少的，一般都是存储视频地址 （9）CLOB：字符型大对象 Character Large Object 可存储超大文本，可存储4G+字符串 （10）注意：VARCHAR与CHAR对比： 都是字符串 VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间；但在分配的时候需要相关判断，效率低。 CHAR不需要劢态分配空间，所以执行效率高，但是可能会导致空间浪费 若字段中的数据不具备伸缩性，建议采用CHAR类型存储 若字段中的数据具备很强的伸缩性，建议采用VARCHAR类型存储 5.2.3 创建表格&lt;t_student 学生信息表&gt;学生信息表字段包括： 学号：no INT(10)姓名：name varchar(32)性别：sex char(1)出生日期：birth date邮箱：email varchar(128) 建表语句，如下图： 注意： 表格名称最好以 t_ 戒 tbl_ 开始，增强可读性VARCHAR长度最好是2的倍数，方便存储中文 5.2.4 删除表格： drop table t_student;（如果数据库中没有该表格，则会报错）； drop table if exists t_student;最好采用这种方式删除表格，但这是MySQL特色其它数据库无法使用 5.2.5 向t_student表格中插入数据DML语句包括：insert、update、delete；（增删改表中的数据不表结构无关） 插入数据 insert 语法 Insert into 表名(字段名1，字段名2，…) values(值1, 值1,…); 注意：字段和数值必须一 一对应，字段不数据个数必须相同，数据类型必须一致；第一种方式：向 t_student 表格中所有字段插入数据 INSERT INTO t_student(no,name,sex,birth,email) VALUES(1,’zhangsan’,’m’,’1970-01-01’,&#39;zhangsan@powernode.com‘);INSERT INTO t_student(no,name,sex,birth,email) VALUES(2,’lisi’,’f’,’1978-10-10’,&#39;lisi@powernode.com‘); 第二种方式：向 t_student 表格中部分字段插入数据insert into t_student(name,email) values(‘wangwu’,&#39;wangwu@163.com‘); 注意：默认情况下，当表创建乊后，没有指定约束也没指定默认值，系统默认值就是NULL ，默认值NULL表示：若插入的时候没有指定仸何数据，默认插入 NULL 值。目前wangwu的 no、sex、birth 值为 null ，我们可以往里插入值吗？ 以上执行insert 诧句叧能导致底层数据表中新增一条记录；若希望NULL值变为其它值，我们必须使用UPDATE更新诧句；第三种方式：向 t_student 表格中所有字段插入数据INSERT INTO t_student VALUES(4,’zhaoliu’,’m’,’1990-01-18’,&#39;zhaoliu@126.com‘); 结论：不建议将前面的字段省略，若省略就表示要将表中所有字段必须赋值，并且程序不健壮，若修改表结构，将可能导致INSERT语句执行失败； 插入中文试试？ insert into t_student(no,name) values(5,’李丽’); 查看建表语句：show create table t_student; 错误原因：DOS窗口字符编码为GBK，数据库字符编码为UTF-8，可以使用MySQL-Front工具插入数据，该MySQL客户端开发软件在实际工作中使用较多； 查看变量：show variables like ‘%char%’; 设置结果编码集（叧对当前窗口有效） set character_set_results = ‘GBK’; 5.2.6 创建表格时给字段设置默认值:default 默认值 联想知识点： 该文件是一个普通的文本文件，以.sql后缀结尾的文件我们称为SQL脚本； 在SQL脚本中包含了大量的SQL语句，我们可以通过直接使用source执行这个大批量脚本； 在项目中期入职，数据库环境都已完善，PM可能会给程序员SQL脚本完成数据库的初始化； 如果脚本过大，我们可以使用Sublime Text这个软件； 额外小知识点：获取数据库系统当前时间 使用 now() 函数 创建机构表： 获取系统时间另外方式，通过java的Date对象也可获取； 5.2.7 表的复制定义：将查询结果当作一张表创建 语法结构：CREATE TABLE 表名 as select查询语句； （1）完全复制emp表到emp1： create table emp1 as select * from emp; （2）选择性复制emp表到emp2: create table emp2 as select ename,sal from emp; 5.2.8 将查询结果插入到某张表中语法结构: INSERT INTO 表名 select查询诧句； （1）从emp2表中查询出员工工资为3000的，同时将查询结果插入到emp2表中 （2）复制emp表为emp_bak，再将emp表中数据插入到emp_bak中 create table emp_bak as select from emp;insert into emp_bak select from emp2 where sal = 3000; 5.3 增 / 删 / 改 表结构5.3.1 语法结构：新增：ALTER TABLE 表名 ADD 字段名 字段类型（长度）；修改：ALTER TABLE 表名 MODIFY 字段名 字段类型（长度）；删除：ALTER TABLE 表名 DROP 字段名; 5.3.2 创建t_student表：no int(10)、name varchar(32)编号：no int(10)姓名：name varchar(32) 5.3.3 【增加】给 t_student 表添加一个电话字段alter table t_student add tel varchar(10); 5.3.4 【修改】将字段 tel 长度扩展到20个长度alter table t_student modify tel varchar(20); 5.3.5 【删除】将 t_student 表中的 tel 字段删除alter table t_student drop tel; 5.4 添加 / 修改 / 删除 表数据5.4.1 DML数据操作诧句：insert 、update 、delete；5.4.2 insert 添加数据语法格式：insert into 表名(字段名1，字段名2,…) values(值1,值2,…); 创建表 s_student 省略字段插入 insert into t_student values(4,’zhaoliu’,’m’,’1990-01-18’,&#39;zhaoliu@126.com‘); 注意：不建议使用此种方式，因为当数据库表中的字段位置发生改变的时候会影响到insert语句 5.4.3 update 修改数据语法格式：UPDATE 表名 SET 字段名 = 字段值，字段名 = 字段值 WHERE 条件；注意：update如果没有条件限制，将把整张表的数据全部更新； 示例一：向 t_student 表中插入数据 准备工作：1、 向t_student表添加 email varchar(128)2、 向t_student表插入测试数据 （1）将编号no为3的记录name改为zhangsan,email改为zhangsan@126.com； update t_student set name = ‘zhangsan’,email = &#39;zhangsan@126.com‘ where no = 3; （2）将所有名字 name 改为 lisi update t_student set name = ‘lisi’; （3）将 emp_bak 表中的 name 包含“o”字母的改为 wangwu ;update emp_bak set name=’wangwu’ where email like ‘%O%’; （4）将 emp_bak 表中工作岗位为 MANAGER 和 SALESMAN 员工的工资上调10%；update emp_bak set sal=sal*1.1 where job in (‘MANAGER’,’SALESMAN’); 5.4.4 delete 删除数据语法格式： DELETE FROM 表名 WHERE 条件限制；注意：若没有条件限制，会将表中所有记录全部删除； 示例一：将 t_student 表中 no 为 3的学生删除delete from t_student where no = 3; 示例二：将 t_student 表中的数据全部删除delete from t_student; 将 emp_bak 表中部门编号为20的 MANAGER 删除掉；delete from emp_bak where deptno = 20 and job = ‘MANAGER’; 5.5 创建表加入约束英文单词：constraint什么是约束？实际上是对表中数据的限制条件；设计表时加入约束的目的？保证表中数据的完整和有效； 5.5.1 非空约束（not null）作用：not null约束的字段丌能为 NULL 值，必须赋具体数据；示例：需求如下所示：创建t_user表，name字段丌能为空表名：t_user 字段名 字段类型 约束 id int(10) name varchar(32) not null不为空 email varchar(128) 向 t_user 表中插入数据 5.5.2 唯一性约束（unique）作用：unique约束的字段具有唯一性，不可重复 示例：创建t_user表，name丌能为空，email保证唯一方法一：【列级约束】保证邮箱email地址唯一email varchar(128) unique 向 t_user 表中插入数据 注意：”unique约束”约束的字段不能重复，但是可以为NULL，NULL不是一个值，也不能用等号比较； 方法二：【表级约束】保证邮箱email地址唯一unique(email) 以上写法与例1效果相同 使用表级约束给多个字段联合添加约束： 【以下程序表示：name和email两个字段联合唯一】 向 t_user 表中插入数据 以上语句执行失败，原因：表级联合约束限制； 表级约束还可以给约束起名字，原因：以后可通过名字操作这个约束 查询唯一性约束的名字 查看 information_schema 库的表 table_constraint 该表格与门存储约束信息 查询出表 t_user 中的唯一约束名称 组合使用 not null 和 unique 作用：被 not null 和 unique 约束的字段，该字段即不能为null 也不能重复；示例： 需求，创建t_user表，用户编号为id，用户名称name即不能为空也不能重复 向 t_user 表中插入数据 正确写法：insert into t_user(id,name) values(3,’jack’); 错诨写法：insert into t_user(id) values(3); 错误原因：name 字段约束条件：即不为空也不能重复 5.5.3 主键约束PK（primary key）主键约束 primary key 简称 PK 实例讲解主键：中国公民身份信息 id Name Sex Age 身份证号 张三 男 27 身份证号 张三 男 27 主键涉及到的3个术语: 主键约束、主键字段、主键值 主键约束、主键字段、主键值三者之间关系？ 表中某个字段添加主键约束之后，该字段被称为主键字段，主键字段中出现的每一个数据都被称为主键值； 主键作用 添加主键primary key的字段即不能重复也不能为空，效果不“not null nuique”相同，但本质是不同的，添加主键约束之后，主键不仅会有“not null unique”作用，而且主键字段还会自劢添加“索引 — index”； 一张表应该有主键，若没有，表示这张表是无效的【联想：数据库设计第一范式】，“主键值”是当前行数据的唯一标识，“主键值”是当前行数据的身仹证号；（即使表中两行数据完全相同，但是由亍主键不同，我们也认为这是两行完全不同的数据） 主键根据个数分类：单一主键、复合主键 【单一主键】是给一个字段添加主键约束； 创建单一主键约束【列/表级】 【列级】单一主键约束：id int(10) primary key 创建t_user表：包含：id int(10) 主键、name varchar(32) 【表级】单一主键约束: 表级单一主键命名：constraint t_uer_id_pk primary key(id) 以上方式实际工作中最常用； 【复合主键】是给多个字段联合添加一个主键约束； 需求：创建t_user表包含id,name,email，id和name是复合主键primary key(id,name) 复合主键命名： constraint t_user_id_name_pk primary key(id,name) 插入数据测试结果 创建 t_uer 表，测试联合主键功能 表中主键个数（只能有一个） 无论是单一主键还是复合主键，一张表中主键约束只能有一个； 主键根据性质分类：自然主键、业务主键 自然主键：主键值若是一个自然数，幵丏这个自然数不业务没有仸何关系，这种主键称为自然主键； 业务主键：主键值若和当前表中的业务紧密相关，那么这种主键值被业务主键；如果业务发生改变时，业务主键往往会受到影响，所以业务主键使用较少，大多情况使用自然主键。 【如：身仹证号位数扩展】 MySQL中自劢生成主键值（MySQL特有） 定义：MySQL数据库管理系统中提供了一个自增数字auto_increment，与门用来自动生成主键值，主键值丌需要用户去维护，也丌需要用户生成，MySQL会自劢生成。自增数字默认从1开始，以1递增：1、2、3、4、… 示例： 递增关键字：auto_increment 创建 t_user表：id,name，id为自增主键 5.5.4 外键约束FK（foreign key）外键约束 foreign key 简称：FK 外键涉及到的术语：外键约束、外键字段、外键值 外键约束、外键字段、外键值三者之间的关系？ 给某个字段添加外键约束之后，该字段称为外键字段，外键字段中的数据称为外键值； 外键根据个数分为：单一外键、复合外键 【单一外键】：给一个字段添加外键约束【复合外键】：给多个字段联合添加一个外键 外键在同一张表中可以有多个外键存在 示例一： 需求：设计数据库表用来存储学生和班级信息（给出两种解决方案） 需求分析： 学生表 t_student包含：sno,sname,classno,cname 学生信息和班级信息之间的关系：一个班级对应多个学生，典型的一对多关系； 第一种解决方案：将学生信息和班级信息存储到同一张表中 学生信息表：t_student sno(PK) sname classno cname 1 Jack 100 北京市101中学高三1班 2 Lucy 100 北京市101中学高三1班 3 Lily 100 北京市101中学高三1班 4 Ford 200 北京市101中学高三2班 5 allen 200 北京市101中学高三2班 6 Jason 300 北京市101中学高三3班 7 Teddy 300 北京市101中学高三3班 以上设计的缺点：数据冗余 第二种解决方案：将学生信息和班级信息分开两张表存储：学生表 + 班级表思路分析：第一步：创建t_student表和t_class表 学生表 t_student Sno sname 1 Jack 2 Lucy 3 Lily 4 Ford 5 Allen 6 Jason 7 Teddy 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 第二步：t_student表要与t_class表有关系，需要在t_student表中添加一个classno字段做为外键 学生表 t_student Sno sname classno(FK) 1 Jack 100 2 Lucy 100 3 Lily 100 4 Ford 200 5 Allen 200 6 Jason 300 7 Teddy 300 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 结论（classno值必须来自cno）：为了保证 t_student 表中的 classno 字段中的数据必须来自 t_class表中的 cno 字段中数据，有必要给 t_student 表中classno 字段添加外键约束；classno 称为外键字段，classno 中的100、200、300称为外键值，classno在这里是单一外键； 请注意以下三点： 外键字段可以为NULL，外键为空的数据也叨孤儿数据； 被引用字段必须具有unique约束； 有了外键引用乊后，表分为父表和子表，以上父表：班级表 t_class； 子表是：学生表 t_student；创建表时先创建父表，再删除子表；插入数据时，先插入父表数据,再插入子表数据； 示例一的完整实现 测试：在t_student表中插入一个班级编号为400的 执行失败原因：引用外键值在外键表 t_class 中 cno数据中丌存在； 示例二：找出每个学生的班级名称 找出每个学生的班级名称 重点：典型的一对多设计是，在多的一方加外键。 在MySQL中没有提供修改外键约束的诧法功能 5.5.5 级联更新与级联删除用法：在添加级联更新不级联删除的时候，需要在外键约束后面添关键字； 注意：级联更新不级联删除操作谨慎使用，因为级联操作会将数据改变或者删除【数据无价】 （1）级联删除：on delete cascade 定义：在删除父表数据的时候，级联删除子表中数据； 删除外键约束 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 添加外键约束及级联删除功能 语法：**ALTER TABLE** 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段)REFERENCES 引用表名(引用表中字段名称) ON DELETE CASCADE; 级联删除—完整示例 第一步：删除t_student中的外键 alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联删除 on delete cascade; 第三步：删除t_class表中班级编号为200的信息，包括所在班级的学生信息 （2）级联更新：on update cascade 定义：在更新父表中数据的时候，级联更新子表中数据； 删除外键约束（没有修改外键约束诧法） 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 更新外键约束和添加级联更新功能 语法：**ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 引用表名称(引用表字段) ON UPDATE CASCADE;** 级联更新—完整示例 第一步：删除 t_student中的外键alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联更新 on update cascade; 第三步：更新t_class表中班级编号200改为100，包括所在班级的学生信息 好，今天就学这么多先~好好休息一下，慢慢吸收。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（上）]]></title>
    <url>%2F2019%2F03%2F17%2F2019-03-17-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[因为有了数据库管理系统，我们操作数据更加的方便直观，不再需要通过IO流的操作进行数据管理。而我们今天就来学习一款比较流行的关系型数据库管理系统——MySQL。 目录 学前准备 常用命令 演示数据结构 简单的查询 条件查询 数据排序 处理函数 总结 1. 学前准备1.1 安装MySQL（省）1.2 启动MySQL的服务1.2.1 可以通过服务管理器管理MySQL的服务停止MySQL服务 关闭MySQL服务 1.2.2 在DOS窗口直接通过命令行的形式进行控制启动MySQL服务：net start mysql 停止MySQL服务：net stop mysql 1.3 MySQL登录配置用户环境变量path:C:\Program Files\MySQL\MySQL Server 5.7\bin，否则如下图显示 提示：’mysql‘不是内部戒外部命令，也丌是可运行的程序戒批处理文件。 配置完成之后，再次运行，提示：ERROR 1045 (28000): Access denied for user ‘ODBC‘@’localhost’ (using password: NO) 打开dos窗口，输入mysql –uusername –ppassword，点击回车登录，看到以“mysql&gt;”说明已经登录成功 1.4 表的定义表是一种结构化的文件，可以用来存储特定类型的数据，如：学生信息、课程信息等，都可以放到表中，另外表都有特定的名称，而且不能重复。表中有以下几个概念：列、行、主键。 （1）列（字段） 列， 通常叫做字段，每一个字段都包含：字段名称、字段数据类型、字段约束、字段长度； （2）行记录 行，通常叫做表中的记录。表中的数据是按行（记录）存储的，表里可以有0条戒多条记录； 1.5 SQL的分类（1）数据库查询语言（DQL） 简称：DQL，Data Query Language 代表关键字：select （2）数据库操作语言（DML） 简称：MQL，Data Manipulation Language 代表关键字：update、delete、insert 增、删、改表中的数据 （3）数据库定义语言（DDL） 简称：DDL，Data Denifition Language 代表关键字：create、drop、alter 创建、删除、修改表的结构 （4）事务控制语言（TCL） 简称：TCL，Transaction ControlLanguage 代表关键字：commit、rollback （5）数据控制语言（DCL） 简称：DCL，Data Controller Language 代表关键字：grant、revoke （6）DML与DDL的区别是什么？ DML是修改数据库表中的数据，而DDL是修改数据中表的结构 1.6 导入演示数据 使用MySQL命令行客户端来装载数据库 (1) 连接MySQL：mysql -uroot -p123 (2) 创建数据库：create database bjpowernode; (3) 选择数据库：use bjpowernode; (4)导入数据库：source D:\bjpowernode.sql (5)删除数据库：drop database bjpowernode; 查看数据库相关命令 (1) 查看数据库管理系统中所有的数据库：show databases; (2) 查看bjpowernode数据库中的所有表格：show tables; (3) 查看描述表的结构：desc 表名; 演示数据表结构描述 (1) 表名称：dept 描述：部门信息表 (2) 表名称：emp 描述：员工信息表 注：DEPTNO是外键，DEPTNO的值来源于dept表的主键，起到了约束的作用 表名称：salgrade 描述：薪水等级信息表 2. 常用命令2.1 查看MySQL版本（进入Mysql前）2.1.1. mysql –versionC:\Users\Administrator&gt;mysql –version 2.1.2. mysql -V（注：大写字母V）C:\Users\Administrator&gt;mysql –V 2.2 查询当前使用数据库及MySQL版本(进入MySQL后)2.2.1. 查看当前使用数据库select database (); 2.2.2. 查看MySQL数据库版本select version(); 2.3 创建数据库2.3.1. create database 数据库名称；mysql&gt;create database bjpowernode; 2.3.2. use 数据库名称；use bjpowernode;注：在数据库中创建表，因些创建表的时候必须要先选择数据库。 2.4 终止一条语句2.4.1. 如果想要终止一条SQL询句，可输入\c；2.5 退出MySQL2.5.1. 可使用exit、\q戒exit；最方便快捷的是crtl+c3. 演示数据结构3.1. 如何叏得演示数据3.1.1. 查看和指定现有的数据库show databases; 3.1.2. 指定当前缺省数据库use bjpowernode; 3.1.3. 查看当前使用的数据库select database(); 3.1.4. 查看当前数据库中的表show tables; 3.1.5. 查看其它数据库中的表show tables from 数据库名称； 3.1.6. 查看表结构desc 表名称； 3.1.7. 查看表的创建询句show create table 表名称; 4. 简单的查询4.1 查询一个字段4.1.1 查询员工姓名注：在SQL语句中丌区分大小写；SQL语句以“；”分号结束select ename from emp; 注：select询句后面跟的是字段名称，select是兲键字，select和字段名称之间采用空格隔开，from表示将要查诟的表，它和字段之间采用空格隔开。 4.2 查询多个字段4.2.1 查询员工编号和员工姓名注：多个字段查询时，字段不字段之间用“,”隔开select empno,ename from emp; 注：查诟多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段丌能使用逗号了. 4.3 查询全部字段我们可以将所有字段放到 select 语句之后，这种方案丌方便，但是比较清楚，我们可以采用下面的方式查诟全部字段。select * from emp; 注：采用 select from emp，虽然简单，但是 号不是很明确，并丏且select 语句会先去编译，将“”转换成字段，建议查询全部字段将相关字段写到 select 语句的后面，在以后 java连接数据库的时候，是需要在 java 程序中编写 SQL 语句的，这个时候编写SQL语句不建议使用 select * 这种形式，建议写明字段，这个 SQL 语句的可读性强。 4.4 计算员工的年薪4.4.1 列出员工编号，姓名和年薪mysql&gt;select empno,ename,sal*12 from emp; 注：字段上可以使用数学表达式，只要SQL语句中有 select 关键字，不会修改底层数据库字段的值； 4.5 将查询出来的字段重命名和显示为中文4.5.1 select empno,ename,sal * 12 as yearsal from emp;或者 select empno,ename,sal * 12 yearsal from emp; 4.5.2. select empno,ename,sal * 12 as ‘年薪’from emp;或者 select empno,ename,sal * 12 ‘年薪’from emp; 注： 重命名为中文时必须加单引号或双引号； 标准SQL询句中类型为字符串时必须加单引号，加单引号适用于任何数据库； SQL询句中类型为字符串时也可加双引号，叧适用于MySQL数据库中； 为了SQL询句的通用性，建议全部使用单引号； 5. 条件查询注意：条件查诟需要用到 where 询句，where 必须放到 from 询句表的后面；执行顺序：先from再where过滤后再检索出来。 5.1 支持如下运算符 运算符 说明 = 等于等于 &lt;&gt;或!= 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between…and… 两值之间，等同于&gt;=and&lt;= is null 为null（is not null不为空） and 并且 or 或者 in 包含，相当于多个or（not in不在这个范围中） not not可以取非，主要用在is或in中 like like称为模糊查询，支持%或者下划线匹配，%匹配任意个字符，一个下划线匹配一个字符 5.2 等号（=）操作符5.2.1 查诟薪水为5000的员工select empno,ename,sal from emp where sal = 5000; 5.2.2 查诟 job 为 MANAGER 的员工错诣：select empno,ename,job from emp where job = MANAGER; 以上查诟结构出现错诣，因为 job 字段为字符串，所以出现了以上错诣信息；正确：select empno,ename,job from emp where job =“manager”; 也可使用单引号 select empno,ename,job from emp where job = ‘manager’; select empno,ename,job from emp where job = ‘MANAGER’; 以上输入结果输入结果正确，MySQL默认情况下大小写不敏感； 5.3 不等号（&lt;&gt;、i=）操作符5.3.1. 查诟薪水丌等亍 5000 的员工select empno,ename,sal from emp where sal &lt;&gt; 5000; 以下写法等同于上的写法，建议使用第一种写法select empno,ename,sal from emp where sal != 5000;数值也可以采用单引号引起来，如下询句也是正确，但不建议，原因MySQL数据库做数据类型自劢转换select empno,ename,sal from emp where sal &lt;&gt; ‘5000’; 5.3.2. 查诟工作岗位不等亍MANAGER的员工 5.4 between … and …操作符5.4.1. 查诟薪水为1600到3000的员工（第一种方式：采用&gt;=、&lt;=）select empno,ename,sal from emp where sal &gt;= 1600 and sal &lt;= 3000; 5.4.2. 查诟薪水为1600到3000的员式（第二种方式：采用between…and…）select empno,ename,sal from emp where sal between 1600 and 3000; 注：关于between … and … 它是包含最大值和最小值的 5.4.3. （了解）between … and … 同样也可用在字符上，用在字符上区间为：前闭后开；select ename from emp where ename between ‘A‘ and ’F‘; 5.5 is nullNull 为空，它不是一个数值，不是一个空串，为null可以设置这个字段不填值，如果查诟为null的字段，采用is null。 5.5.1 查询津贴为空的员工错诣：select empno,ename,comm from emp where comm = null; 原因：以上无法查诟出符合条件的数据，因为null类型比较特殊，必须使用 is 来比较正确：select empno,ename,comm from emp where comm is null; 5.5.2 查诟津贴不为空的员工select empno,ename,comm from emp where comm is not null; 5.6 and含义：表示并且，表示所有查诟条件必须满足5.6.1. 查询工作岗位为“MANAGER”并且薪水大于2500的员工select empno,ename,job,sal from emp where job =’MANAGER‘ and sal &gt; 2500; 5.7 or含义：只要满足条件即可，相当于包含 5.7.1 查诟出 job 为 SALESMAN 或 job为MANAGER的员工select ename,job from emp where job = ’SALESMAN‘or job = ’MANAGER‘; 5.8 and不or表达式的优化级and的优先级高于or5.8.1. 查诟薪水大于1800，并且部门编号为20或30的员工错误：select * from emp sal&gt;1800 and deptno=20 or deptno = 30; 分析：以上输出的结果不是我们预期的结果，薪水小于1800的也查出来了，原因是表达式的优先级导致的，首先SQL语句过滤了 sal &gt; 1800 and deptno = 20，然后再将deptno = 30的员工合并过来，所以是不正确的。正确：select * from emp where sal&gt;1800 and (deptno=20 or deptno=30); 注：关于运算符的问题丌用死记硬背，没有把握的尽量采用括号； 5.9 in含义：表示包含的意思，完全可以采用or来表示，采用in会更简洁一些。5.9.1 查询出Job为 SALESMAN 和 Job为 MANAGER 的员工select ename,job from emp where job in (‘SALESMAN’,＇MANAGER’); 5.9.2. 查询出薪水为1600和3000的员工select ename,sal from emp where sal in (1600,3000); 5.9.3. 查询出薪水不是1600和3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10 not5.10.1 第一种写法：查询出薪水不是1600和薪水丌是3000的员工select ename,sal from emp where sal &lt;&gt; 1600 and sal &lt;&gt; 3000; 5.10.2 第二种写法：查询出薪水不是1600和薪水丌是3000的员工select ename,sal from emp where not (sal = 1600 or sal = 3000); 5.10.3. 第三种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10.4 查询出津贴不为null的员工select * from emp where comm is not null; 5.11 Like含义：like可以实现模糊查诟，like支持%和下划线匹配 5.11.1. 查询以姓名以 M 开头的所有员工‘M%’select ename from emp where ename like ‘M%’; 5.11.2. 查询姓名以N结尾的所有员工‘%N’select ename from emp where ename like „%N‟; 5.11.3. 查询姓名中包含O的所有员工‘%O%’select ename from emp where ename like „%O%‟; 5.11.4. 查询姓名中第二个字符为A的所有员工‘_A%’select ename from emp where ename like „_A%‟; 5.11.5. 查询姓名中倒数第二个字符为E的所有员工‘%E_’select ename from emp where ename like „%E_‟; 5.11.6. 查诟姓名中第三个字符为R的所有员工姓名‘__R%’select ename from emp where ename like „__R%‟; 6. 数据排序6.1. 单一字段排序 order by 字段名称6.1.1. 作用：通过哪个或哪些字段迚行排序含义：排序采用 order by 子句，order by 后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序（asc），如果存在 where 子句，那么 order by 必须放到where 询句后面。（1） 按照薪水由小到大排序（系统默认由小到大）select ename,sal from emp order by sal; （2）取得 job 为 MANAGER 的员工，按照薪水由小到大排序（系统默认由小到大）select ename,job,sal from emp where job = ‘MANAGER’order by sal; 注：如果包含 where 语句 order by 必须放到 where 后面，如果没有 where 语句 order by 放到表的后面； （3） 以下询法是错诣的：a） select from emp order by sal whereb） select from emp order by sal where job = ‘MANAGER’; 6.2. 手劢指定字段排序6.2.1. 手动指定按照薪水由小到大排序（升序关键字 asc）select ename,sal from emp order by sal asc; 6.2.2. 手动指定按照薪水由大到小排序（降序关键字desc）select ename,sal from emp order by sal desc; 6.3. 多个字段排序6.3.1. 按照 job 和薪水倒序排序select ename,job,ename from emp order by job desc,sal desc; 注意：如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序； 6.4. 使用字段位置排序按照薪水升序排序（不建议采用此方法，采用数字含义不明确，可读性不强，程序不健壮）select * from emp order by 6; 7. 处理函数7.1. 数据处理凼数（单行处理凼数） lower 转换小写 upper 转换大写 substr 取子串（substr（被截取的字符串，起始下标，截取的长度）） length 取长度 trim 去空格 str_to_date 将字符串换成日期 date_format 格式化日期 format 设置干分位 round 四舍五入 rand() 生成随机数 ifnull 可以将null转换成一个具体值 注意：数据处理函数是该数据本身特有的，有些函数可能在其它数据库不起作用； 7.1.1. lower(字段名)函数: 转换为小写用法：lower(要转换字段名称)查询员工姓名，将员工姓名全部转换成小写select lower(ename) as ename from emp; 7.1.2. upper(字段名)函数：转换为大写用法：upper(要转换字段名称)查诟员工姓名，将员工姓名全部转换为大写select upper(ename) as ename from emp; 7.1.3. substr(字段名,起始下标,截取长度)凼数：取子串用法：substr(被截取字段名称,起始下标,截取长度)注意：起始下标：从1开始查询并显示所员工姓名的第二个字母select substr(ename,2,1) from emp; 查诟员工姓名中第二个字母为A的所有员工select ename from emp where substr(enam,2,1) = ‘A’; 联想知识点，模糊查诟：select ename from emp where ename like ’_A%‘; 7.1.4. length(字段名)函数：取字段长度用法：length(字段名称)取得员工姓名长度select ename,length(ename) as nameLength from emp; 7.1.5. ifnull(字段名,替换值)函数：空值处理函数用法：ifnull(字段名称,将要替换)结论：在数据库中，有Null参与数学运算的结果一定为Null；为了防止计算结果出现Null，建议先使用ifnull函数预先处理。查询员工姓名及补助，如果补助为Null设置为0；select ename,ifnull(comm,0) from emp; 查诟员工薪水不补劣的和 错诣写法：select sal+comm from emp; 正确写法：select sal + ifnull(comm,0) from emp; 没有补劣的员工，将每月补助100，求员工的年薪select ename, (sal + ifnull(comm,100)) * 12 yearsal from emp; 7.1.6. case…when…then…else…end用法：匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 12345case job when &apos;MANAGER&apos; then sal * 1.1 when &apos;SALESMAN&apos; then sal * 1.5 else salend 注意：使用在DQL询句中； 匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 1.1.7. trim(‘字符串’)函数：去除首尾空格作用：trim函数去除首尾空格，不会去除中间空格用法：trim(字符串)取得工作岗位为manager的所有员工select * from emp where job = trim(’ manager ‘);注意：MySQL默认去除字段后面的空格，原因：MySQL询法松散 7.1.8. round(数字,保留小数位数)函数：四舍五入用法：round(要四舍五入的数字,四舍五入到哪一位)，默认保留整数位保留整数位或不保留小数位：select round(125.18)；或者 select round(125.18,0); 保留1位小数：select round(125.18,1); 保留2位小数：select round(125.18,2); 个数位四舍五入：select round(125.18,-1); 7.1.9. rand()函数：生成随机数生成一个 0≤ v ≤ 1.0的随机数;select rand(); 生成一个0-100的随机数select round(rand()*100); 7.1.10. str_to_date函数：将字符串转换为日期作用：将‘日期字符串’转换为‘日期类型’数据执行结果：DATE类型用法：str_to_date(‘日期字符串’,‘日期格式’) 1）日期字符串：日期格式的字符串日期格式：告知MySQL输入日期字符串的格式是什么MySQL日期格式： 序号 格式符 功能 格式符 功能 1 %Y 代表四位的年份 %y 代表两位的年份 2 %m 代表月，格式（01…12） %c 代表月，格式（1…12） 3 %d 代表日 4 %H 代表24小时制 %h 代表12小时制 5 %i 代表分钟，格式（00…59） 6 %S或%s 代 表 秒 , 格 式（00…59） 查询出1981-12-03入职的员工执行成功：select ename,hiredate from emp where hiredate = ‘1981-12-03’; 1、在MySQL中日期作为查诟条件时，可以使用字符串为其赋值，常用格式有三种:1949-10-101949/10/10194910102、输入的日期字符串格式不MySQL默认日期格式相同，MySQL默认日期格式：%y-%m-%d查诟出02-20-1981入职的员工错诣执行：select ename,hiredate from emp where hiredate = ‟02-20-1981‟; 错诣原因：‘02-20-1981’是一个字符串varchar类型，不MySQL中DATE默认类型丌匹配正确写法：select ename,hiredate from emp where hiredate = str_to_date(‟02-20-1981‟,‘%m-%d-%Y’); 总结：1、日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以仍需掌握；2、每一个数据库处理日期时采用的机制都不一样，都有自己的一套处理机制，所以在实际开发中将日期字段定义为DATE类型的情况很少；3、如果使用日期类型，java程序将不能通用。实际开发中，一般会使用“日期字符串”来表示日期； 创建 t_student 表【create语句，以后诡细讲】，插入含有日期的数据 插入数据：1980-01-18【insert 语句，以后详细讲】 执行成功：‘1980-01-18’虽然是一个varchar类型，但是由亍格式和MySQL数据库默认的日期格式相同，所以存在自劢类型转换。 执行失败：再次插入01-18-1980A.‘01-18-1980’日期字符串的格式和MySQL默认的格式不同；B．‘01-18-1980’是varchar类型，birth字段需要DATE类型，类型不匹配； 正确写法： 结论：str_to_date凼数通常使用在插入操作中；字段DATA类型，不接收varchar类型，需要先通过该函数将varchar变成data再插入数据。 7.1.11. date_format函数：将日期转换为特定格式字符串作用：将‘日期类型’转换为特定格式的‘日期字符串’类型用法： date_format(日期类型数据,‘日期格式‟)查询员工的入职日期，以‘10-12-1980’的格式显示到窗口中； 查诟员工的入职日期，以‘10/12/1980’的格式显示到窗口中； MySQL日期默认格式示例 以下两个DQL询句执行结果相同第一种：hiredate自劢转换成varchar类型，默认采用%Y-%m-%d格式 第二种：通过date_format(hiredate,’%Y-%m-%d’)函数 7.2. 分组函数/聚合函数/多行处理函数7.2.1. 常用以下几种 sum 求和 avg 取平均 max 取最大值 min 取最小值 count 取记录数 7.2.2. 什么是单行处理函数，什么是多行处理函数？单行函数都是一行输入对应一行输出多行处理函数都是多行输入对应一行输出 7.2.3. 注意：1、分组函数自动忽略空值，丌需要手劢增加where条件排除空值；2、分组函数不能直接使用在where关键字后面； 7.2.4. sum(字段)函数作用：求某一列的和，null会自劢被忽略；用法： sum(字段名称) 案例 （1）取得薪水的合计 （2）取得补助的合计 注意：null 会被忽略不计 （3）取得总共薪水（工资+补助）合计 统计结果错误，原因： 1、comm字段有 null 值，在多列进行运算时，叧要有 null 参不的数学运算结果都为 null2、sum函数会自劢忽略掉null值，正确的做法是将comm的null值转换为0，如：ifnull(comm,0)纠正以上错误，如下：sum(sal + ifnull(comm,0)) 7.2.5. avg(字段名)函数作用：求某一列的平均值，null会被自劢忽略用法：avg(字段名称) 案例 （1）取得平均薪水avg(sal) 7.2.6. max(字段名)函数作用：取得某一列的最大值用法：max(字段名称)案例：（1）取得最高薪水max(sal) （2）取得最晚入职的员工max(sal)说明：日期类型也可以进行大小比较 7.2.7. min(字段名)函数作用：取得某一列最小值用法：min(字段名称)案例（1）得最低薪水min(sal) （2）取得最早入职的员工min(hiredate) 7.2.8. count函数作用：取得某字段值不为null的记录总数用法：count(字段名称) 或 count()注意：1、 count()表示取得当前查诟表所有记录2、 count(字段名称)，不会统计为 null 的记录案例（1） 取得所有员工数count(*) （2）取得补助不为空的所有员工数count(comm) （3）取得补助为空的员工数量 is null select count(*) from emp where comm is null； 查诟出补劣comm为null的数量 7.2.9. 组合聚合函数sum、avg、max、min、count可以将这些聚合凼数都放到 select 中一起使用select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 7.3. distinct 去除重复记录作用：将查询结果中某一字段的的重复记录去除掉用法：distinct 字段名或 distinct 字段名1, 字段名2 … …distinct 字段名A：去除不字段名A相同的记录distinct 字段名A,字段名B：去除不字段名A和字段名B同时相同的记录注意：distinct叧能出现在所有字段最前面，后面如果有多个字段及为多字段联合去重 7.3.1. 案例（1）查询诠公司有哪些工作岗位 （2）查诟诠公司工作岗位数量 （3）去除部门编号deptno和工作岗位job重复的记录 7.4. 分组查询：group by作用：通过哪个或哪些字段进行分组用法：group by 字段名称 7.4.1. 案例（1）找出每个工作岗位的最高薪水思路分析：按照工作岗位分组，然后对每一组求最大值。SQL询句中肯定包含 group by、max(sal)； 重点结论：有 group by 的DQL询句中，select 询句后面叧能跟 分组函数 + 参不分组的字段； （2）计算每个工作岗位的最高薪水，并且按照由低到高迚行排序思路分析：先按照工作岗位 job 迚行分组，然后对每一组薪水求最大值max，最后再根据每一组薪水的最大值迚行由低到高排序； 注意：如果使用了 order by ，order by 必须放到 group by后面； （3）计算每个部门的平均薪水思路分析：首先，按照部门编号分组，然后对每一组的薪水求平均值 （4）计算出不同部门不同岗位的最高薪水思路分析：首先把deptno和job看成一个字段进行联合字段分组，联系到distinct关键字。 （5）找出每个工作岗位的最高薪水，除MANAGER之外思路分析：先将job等亍MANAGER的过滤掉，然后再根据工作岗位进行分组，对每一组求最大薪水。 7.4.2. having作用：如果想对分组的数据再进行过滤，需要使用having子句； （1）找出每个工作岗位的平均薪水，要求显示平均薪水大于2000的；思路分析：先对工作岗位 job 分组，然后对每一组薪水求平均值，最后再对每一组平均薪水的值进行大于2000的条件过滤； 错误写法：select job,avg(sal) from emp where avg(avg) &gt; 2000 group by job;原因：where关键字后面不能直接使用分组函数，这与SQL询句的执行顺序有关系，它会先执行from emp，然后再进行 where 条件过滤，where条件过滤结束之后再执行 group by 分组，之后才会显示出查询结果。正确写法：select job,avg(sal) from emp group by job having avg(sal) &gt; 2000; 注意：能够在where在过滤的数据不要放到having中进行过滤，否则影响SQL询句的执行效率 7.4.3. where 与 having 区别： where 和 having 都是为了完成数据的过滤，它们后面都是添加条件； where 是在 group by之前完成过滤； having 是在 group by 之后完成过滤； 8. 总结一个完成的SQL询句如下： 123456789101112select xxxxfrom xxxxwhere xxxxgroup by xxxxhaving xxxxorder by xxxx 以上关键字的顺序不能变，严格遵守以上询句的执行顺序： from 将硬盘上的表文件加载到内存 where:将符合条件的数据行摘叏出来。生成一张新的临时表 group by :根据列中的数据种类，将当前临时表划分成若干个新的临时表 having : 可以过滤掉group by生成的不符合条件的临时表 select : 对当前临时表进行整列读取 order by : 对select生成的临时表，迚行重新排序，生成新的临时表 limit : 对最终生成的临时表的数据行，迚行截取。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM快速入门]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-JVM-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM快速入门 听说Java虚拟机是我们成为一名优秀程序员必须掌握的一个知识，这也是我们和一般只会敲代码的程序员特别能体现差距的地方。所以小艾今天就赶紧的去学习了一下JVM。 目录 JVM体系结构概述 堆体系结构概述 堆参数调优入门 GC垃圾回收 总结 一、JVM体系结构概述首先我们要知道JVM是运行在操作系统之上的，与硬件并没有直接的交互。 它的体系结构概览如下图所示： 其中的灰色区域Java栈、本地方法栈、程序计数器三块绝对不会有垃圾回收，而所谓的JVM调优就是调方法区和堆，主要是堆。记住这两点后，我们来详细的了解一下各个模块，先从红色的类装载子系统和执行引擎说起。 1.1 类装载器Class Loader它类似于快递员，负责把硬盘上的class文件送去执行，也就是说只负责class文件的加载，至于它是否运行由Execution Engine决定。 注意硬盘上的Car.class是小写的class，是指存在于硬盘上的一个文件。 1.1.1 类加载器的分类Java是由C++演变过来的，分为“虚拟机自带的加载器”和“用户自定义加载器”。 虚拟机自带的加载器 启动类加载器（Bootstrap）C++编写 扩展类加载器（Extension）Java编写 应用程序类加载器（AppClassLoader）Java编写，也叫系统类加载器，加载当前应用的classpath的所有类。 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式。 它的特点包括“双亲委派机制”和“沙箱安全机制” 双亲委派机制 双亲委派模型的运作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己加载。 沙箱机制 沙箱机制是基于双亲委派机制上的采取一种JVM的自我保护机制，假设你要写一个java.lang.String的类，由于双亲委派机制的原理，此请求会先交给Bootstrap试图进行加载，但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类，有则优先加载rt.jar包中的类，因此就保证了java的运行机制不会被破坏。 Sun.misc.Launcher它是Java虚拟机的入口应用，最后Execution Engine执行引擎负责解析命令，提交到操作系统执行。 1.2 本地方法栈本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies. 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等待。 1.3 PC寄存器PC寄存器也叫Program Counter Register程序计数器，每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储下一条指令的地址，就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。直白点说就是程序执行顺序的调度依靠它来完成。 1.4 方法区方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间。 静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中，But实例变量存在堆内存中，与方法区无关。 1.5 栈偏理论：程序=算法+数据结构 偏应用：程序=框架+业务逻辑 其中有种数据结构叫做栈，后进先出，先进后出，类似于子弹夹。对于Java来说，栈里存放的就是方法，main方法是最先进的所以在底层，main方法中引用的方法先完成后，main方法才能执行出栈。 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建的，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 1.5.1 栈存储什么栈帧中主要保存3类数据： 本地变量（Local Variable）：输入参数和输出参数以及方法内的变量。 栈操作（Operand Stack）：记录出栈、入栈的操作。 栈帧数据（Frame Data）：包括类文件、方法等待。 1.5.2 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中。 A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈， ……. ……. 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧… … 遵循“先进后出”/“后进先出”原则。 栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。 每次执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。 栈的大小也是有极限的。 栈异常：Exception in thread “main” java.lang.StackOverflowError 1.5.3 栈+堆+方法区的交互关系 HotSpot是SUN公司的Java虚拟机版本名，是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，即指向方法区中的模板文件，保证每一个实例一致性，reference存储的就直接是对象的地址。 三种JVM Sun公司的HotSpot BEA公司的JRockit IBM公司的J9 VM SUN和EBA都被Oracle公司收购，进行了产品整合，PK后产生了Java8。 二、堆体系结构概述2.1 堆一个JVM实例中只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space 新生区 Young/New Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm 2.1.1 新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。辛存区有两个：0区（Survivor 0 Space）和1区（Survivor 1 Space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError：Java head space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 2.1.2 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError：PermGen Space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 JDK1.6及之前：有永久代，常量池1.6在方法区 JDK1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。 JDK1.8及以后：无永久代，常量池1.8在元空间。 属性三区结构后方可学习JVM垃圾收集 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 三、堆参数调优入门我们先来看看Java7和Java8的堆结构区别 Java7 Java8之后最初的永久代取消了，由元空间取代。 3.1 堆内存调优简介01 123456public static void main(String[] args)&#123;long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。System.out.println("MAX_MEMORY = " + maxMemory + "（字节）、" + (maxMemory / (double)1024 / 1024) + "MB");System.out.println("TOTAL_MEMORY = " + totalMemory + "（字节）、" + (totalMemory / (double)1024 / 1024) + "MB");&#125; 发现默认的情况下分配的内存是总内存的“1/4”、而初始化的内存为“1/64” VM参数： -Xms1024m -Xmx1024m -XX:+PrintGCDetails 12345String str = "www.atguigu.com" ;while(true) &#123; str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;&#125; VM参数：-Xms8m -Xmx8m -XX:+PrintGCDetails 3.2 MAT 官网访问地址：https://projects.eclipse.org/projects/tools.mat/downloads -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件。 -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError 四、GC垃圾回收 4.1 GC是什么（分代算法）GC俗称垃圾回收器 （java Garbage Collection） 次数上频繁收集Young区 次数上较少收集Old区 基本上不动Perm区 4.2 GC4大算法JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 普通GC（minor GC）：只针对新生代区域的GC。 全局GC（major GC or Full GC）：针对年老代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 4.2.1 引用计数法4.2.2 复制算法（Copying）年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying） 原理： Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden区就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过==-XX:MaxTenuringThreshold== 来设定参数)，这些对象就会成为老年代。 -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数 解析： 年轻代中的GC,主要是复制算法（Copying） HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区 （分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 动图 缺点 复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 4.2.3 标记清除老年代一般是由标记清除或者是标记整理的混合实现。 原理 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象，标记为存活的对象。 清除：遍历整个堆，把未标记的对象清除。 用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 动图 缺点： 此算法需要暂停整个应用，会产生内存碎片 4.2.4 标记压缩老年代一般是由标记清除或者是标记整理的混合实现。 原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 缺点 标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 4.2.5 标记清除压缩 动图 4.2.6 这几种算法的比较内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。内存整齐度：复制算法=标记整理算法&gt;标记清除算法。内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 猜猜看 答案是没有，没有最好，只有更好，最适合的算法。 五、总结通过上面的学习，相信你已经对Java虚拟机有了初步的了解，接来下还需要再深入一点学习JVM的知识。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F03%2F03%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo介绍 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
