<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM整合]]></title>
    <url>%2F2019%2F06%2F20%2F2019-06-20-SSM%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[目录 环境准备 整合步骤 1. 环境准备1.1 创建数据库和表结构123456create database ssm;create table account( id int primary key auto_increment, name varchar(100), money double(7,2),); 1.2 创建Maven工程创建父工程： 12345创建子模块： ssm_domain jar ssm_dao jar ssm_service jar ssm_web war 1.3 导入坐标并建立依赖注意 MyBatis 和 和 Spring 的版本对应关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188&lt;project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;ssm&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;shiro.version&gt;1.2.3&lt;/shiro.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; &lt;modules&gt; &lt;module&gt;ssm_domain&lt;/module&gt; &lt;module&gt;ssm_dao&lt;/module&gt; &lt;module&gt;ssm_service&lt;/module&gt; &lt;module&gt;ssm_web&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 1.4 编写实体类12345678910111213141516171819202122232425262728293031323334/*** 账户的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", name=" + name + ", money=" + money + "]"; &#125;&#125; 1.5 编写业务层接口123456789101112131415161718/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户 * @param account */ void saveAccount(Account account); /** * 查询所有账户 * @return */ List&lt;Account&gt; findAllAccount();&#125; 1.6 编写持久层接口123456789101112131415161718/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存 * @param account */ void save(Account account); /** * 查询所有 * @return */ List&lt;Account&gt; findAll();&#125; 2. 整合步骤2.1 保证Spring框架在web工程中独立运行2.1.1 第一步:编写Spring配置文件并导入约束123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt; &lt;!--制定扫包规则，不扫描@Controller 注解的 JAVA 类，其他的还是要扫描 --&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 2.1.2 第二步：使用注解配置业务层和持久层123456789101112131415161718/*** 账户的业务层实现类*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; @Override public void saveAccount(Account account) &#123; accountDao.saveAccount &#125;&#125; 持久层实现类代码：此时不要做任何操作，就输出一句话。目的是测试 spring框架搭建的结果。 123456789101112131415/*** 账户的持久层实现类*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Override public List&lt;Account&gt; findAllAccount() &#123; System.out.println("查询了所有账户"); return null; &#125; @Override public void saveAccount(Account account) &#123; System.out.println("保存了账户"); &#125;&#125; 2.1.3 第三步：测试Spring能否独立运行12345678910111213/*** 测试 spring 环境搭建是否成功* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Test01Spring &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.findAllAccount(); &#125;&#125; 运行结果： 2.2 保证 SpringMVC 在 在 web 工程中独立运行2.2.1 第一步：在web.xml中配置核心控制器（DispatcherServlet）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns="http://java.sun.com/xml/ns/javaee"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"version="2.5"&gt;&lt;display-name&gt;ssm_web&lt;/display-name&gt; &lt;!-- 配置 spring mvc 的核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvcDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取 springmvc 的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。取值只能是非 0 正整数，表示启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvcDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置 springMVC 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 过滤所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 2.2.2 第 二 步：编写 SpringMVC的配置文件12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置创建 spring 容器要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt; &lt;!-- 制定扫包规则 ,只扫描使用@Controller 注解的 JAVA 类 --&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 2.2.3 第三写步：编写 Controller 和 和 jsp页面jsp代码： 12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;主页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="account/findAllAccount"&gt;访问查询账户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 控制器代码： 123456789101112131415/*** 账户的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("accountController")@RequestMapping("/account")public class AccountController &#123; @RequestMapping("/findAllAccount") public String findAllAccount() &#123; System.out.println("执行了查询账户"); return "success"; &#125;&#125; 运行结果： 2.3 整合Spring和SpringMVC2.3.1 第一步：配置监听器实现启动服务创建容器123456789101112&lt;!-- 配置 spring 提供的监听器，用于启动服务时加载容器 。该间监听器只能加载 WEB-INF 目录中名称为 applicationContext.xml 的配置文件 --&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 手动指定 spring 配置文件位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 2.4 保证 MyBatis 框架在 web 工程中独立运行2.4.1 第一步：编写 AccountDao 映射配置文件注意： 我们使理 用代理 dao 的方式来操作持久层，所以此处 Dao 的实现类就是多余的了。 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 查询所有账户 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.Account"&gt; select * from account &lt;/select&gt; &lt;!-- 新增账户 --&gt; &lt;insert id="save" parameterType="com.itheima.domain.Account"&gt; insert into account(name,money) values(#&#123;name&#125;,#&#123;money&#125;); &lt;/insert&gt;&lt;/mapper&gt; 2.4.2 第二步：编写SqlMapConfig 配置文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="pooled"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/itheima/dao/AccountDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; properties 文件中的内容： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=1234 2.4.3 第三步：测试运行结果测试类代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 测试 MyBatis 独立使用* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Test02MyBatis &#123; /** * 测试保存 * @param args * @throws Exception */ @Test public void testSave() throws Exception &#123; Account account = new Account(); account.setName("test"); account.setMoney(5000f); InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session= factory.openSession(); IAccountDao aDao = session.getMapper(IAccountDao.class); aDao.save(account); session.commit(); session.close(); in.close(); &#125; /** * 测试查询 * @param args * @throws Exception */ @Test public void testFindAll() throws Exception&#123; InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session= factory.openSession(); IAccountDao aDao = session.getMapper(IAccountDao.class); List&lt;Account&gt; list = aDao.findAll(); System.out.println(list); session.close(); in.close(); &#125;&#125; 2.5 整合Spring和MyBatis整合思路：把 mybatis 配置文件（SqlMapConfig.xml）中内容配置到 spring 配置文件中同时，把 mybatis 配置文件的内容清掉。 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 注意：由于我们使用的是代理 Dao的模式，Dao具体实现类由 MyBatis 使用代理方式创建，所以此时 mybatis配置文件不能删。当我们整合 spring 和 mybatis 时，mybatis 创建的 Mapper.xml 文件名必须和 Dao 接口 文件名一致。 2.5.1 第一步：Spring 接管 MyBatis 的 的 Session 工厂123456789101112131415161718&lt;!-- 加载配置文件 --&gt;&lt;context:property-placeholder location="classpath:jdbcConfig.properties" /&gt;&lt;!-- 配置 MyBatis 的 Session 工厂 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载 mybatis 的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml" /&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 2.5.2 第二步：配置自动扫描所有 Mapper 接口和文件1234&lt;!-- 配置 Mapper 扫描器 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.itheima.dao"/&gt;&lt;/bean&gt; 2.5.3 第三步：配置 spring 的事务1234567891011121314151617181920&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置 aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))" id="pt1"/&gt; &lt;!-- 建立通知和切入点表达式的关系 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt;&lt;/aop:config&gt; 2.5.4 第三步：测试整合结果123456789101112131415161718192021222324252627/*** 测试 spring 整合 mybatis* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:applicationContext.xml"&#125;)public class Test03SpringMabatis &#123; @Autowired private IAccountService accountService; @Test public void testFindAll() &#123; List list = accountService.findAllAccount(); System.out.println(list); &#125; @Test public void testSave() &#123; Account account = new Account(); account.setName("测试账号"); account.setMoney(1234f); accountService.saveAccount(account); &#125;&#125; 2.6 测试SSM整合结果2.6.1 编写测试jsp请求发起页面： 123456789101112131415161718&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="account/findAllAccount"&gt;访问查询账户&lt;/a&gt;&lt;hr/&gt;&lt;form action="account/saveAccount" method="post"&gt; 账户名称：&lt;input type="text" name="name"/&gt;&lt;br/&gt; 账户金额：&lt;input type="text" name="money"&gt;&lt;br/&gt;&lt;input type="submit" value=" 保存 "/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 响应结果页面： 1234567891011121314151617181920212223242526&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;账户的列表页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border="1" width="300px"&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;账户名称&lt;/th&gt; &lt;th&gt;账户金额&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;accounts&#125;" var="account" varStatus="vs"&gt; &lt;tr&gt; &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;account.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;account.money &#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 2.6.2 修改控制器中的方法12345678910111213141516171819202122232425262728293031323334353637/*** 账户的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("accountController")@RequestMapping("/account")public class AccountController &#123; @Autowired private IAccountService accountService; /** * 查询所有账户 * @return */ @RequestMapping("/findAllAccount") public ModelAndView findAllAccount() &#123; List&lt;Account&gt; accounts = accountService.findAllAccount(); ModelAndView mv = new ModelAndView(); mv.addObject("accounts", accounts); mv.setViewName("accountlist"); return mv; &#125; /** * 保存账户 * @param account * @return */ @RequestMapping("/saveAccount") public String saveAccount(Account account) &#123; accountService.saveAccount(account); return "redirect:findAllAccount"; &#125;&#125; 2.6.3 测试运行结果]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的拦截器]]></title>
    <url>%2F2019%2F06%2F19%2F2019-06-19-SpringMVC%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目录 拦截器的作用 自定义拦截器的步骤 拦截器的细节 正常流程测试 中断流程测试 拦截器的简单案例（验证用户是否登录） 1. 拦截器的作用Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 谈到拦截器，还要向大家提一个词——拦截器链（Interceptor Chain）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 说到这里，可能大家脑海中有了一个疑问，这不是我们之前学的过滤器吗？是的它和过滤器是有几分相似，但是也有区别，接下来我们就来说说他们的区别： 1234过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。 它也是 AOP 思想的具体应用。我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口。 2. 自定义拦截器的步骤2.1 第一步：编写一个普通类实现 HandlerInterceptor 接口123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("preHandle 拦截器拦截了"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler,ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion 方法执行了"); &#125;&#125; 2.2 第二步：配置拦截器12345678&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 2.3 测试运行结果: 3. 拦截器的细节3.1 拦截器的放行放行的含义是指，如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个，则执行控制器中的方法。 3.2 拦截器中方法的说明12345678910111213141516171819202122232425262728293031323334353637383940public interface HandlerInterceptor &#123; /** * 如何调用： * 按拦截器定义顺序调用 * 何时调用： * 只要配置了都会调用 * 有什么用： * 如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去 * 进行处理，则返回 true。 * 如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。 */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * 如何调用： * 按拦截器定义逆序调用 * 何时调用： * 在拦截器链内所有拦截器返成功调用 * 有什么用： * 在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用， * 在该方法中对用户请求 request 进行处理。 */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable ModelAndView modelAndView) throws Exception &#123; &#125; /** * 如何调用： * 按拦截器定义逆序调用 * 何时调用： * 只有 preHandle 返回 true 才调用 * 有什么用： * 在 DispatcherServlet 完全处理完请求后被调用， * 可以在该方法中进行一些资源清理的操作。 */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable Exception ex) throws Exception &#123; &#125;&#125; 思考：如果有多个拦截器，这时拦截器 1 的 preHandle 方法返回 true，但是拦截器 2 的 preHandle 方法返回 false，而此时拦截器 1 的 afterCompletion 方法是否执行？ 3.3 拦截器的作用路径作用路径可以通过在配置文件中配置。 123456789&lt;!-- 配置拦截器的作用范围 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;mvc:exclude-mapping path=""/&gt;&lt;!-- 用于指定排除的 url--&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 3.4 多个拦截器的执行顺序多个拦截器是按照配置的顺序决定的。 4. 正常流程测试4.1 配置文件：12345678910111213&lt;!-- 配置拦截器的作用范围 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean id="handlerInterceptorDemo2" class="com.itheima.web.interceptor.HandlerInterceptorDemo2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 4.2 拦截器1的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 1：preHandle 拦截器拦截了"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 1：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 1：afterCompletion 方法执行了"); &#125;&#125; 4.3 拦截器2的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo2 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 2：preHandle 拦截器拦截了"); return true;&#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 2：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 2：afterCompletion 方法执行了"); &#125;&#125; 4.4 运行结果： 5. 中断流程测试5.1 配置文件：12345678910111213&lt;!-- 配置拦截器的作用范围 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt;&lt;!-- 用于指定对拦截的 url --&gt; &lt;bean id="handlerInterceptorDemo1" class="com.itheima.web.interceptor.HandlerInterceptorDemo1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;bean id="handlerInterceptorDemo2" class="com.itheima.web.interceptor.HandlerInterceptorDemo2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 5.2 拦截器1的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo1 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 1：preHandle 拦截器拦截了"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 1：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 1：afterCompletion 方法执行了"); &#125;&#125; 5.3 拦截器2的代码：123456789101112131415161718192021222324252627/*** 自定义拦截器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class HandlerInterceptorDemo2 implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponseresponse, Object handler) throws Exception &#123; System.out.println("拦截器 2：preHandle 拦截器拦截了"); return false; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("拦截器 2：postHandle 方法执行了"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) throws Exception &#123; System.out.println("拦截器 2：afterCompletion 方法执行了"); &#125;&#125; 5.4 运行结果： 6. 拦截器的简单案例（验证用户是否登录）6.1 实现思路123456781、有一个登录页面，需要写一个 controller 访问页面2、登录页面有一提交表单的动作。需要在 controller 中处理。 2.1、判断用户名密码是否正确 2.2、如果正确 向 session 中写入用户信息 2.3、返回登录成功。3、拦截用户请求，判断用户是否登录 3.1、如果用户已经登录。放行 3.2、如果用户未登录，跳转到登录页面 6.2 控制器代码123456789101112131415161718192021//登陆页面@RequestMapping("/login")public String login(Model model)throws Exception&#123; return "login";&#125;//登陆提交//userid：用户账号，pwd：密码@RequestMapping("/loginsubmit")public String loginsubmit(HttpSession session,String userid,String pwd)throwsException&#123; //向 session 记录用户身份信息 session.setAttribute("activeUser", userid); return "redirect:/main.jsp";&#125;//退出@RequestMapping("/logout")public String logout(HttpSession session)throws Exception&#123; //session 过期 session.invalidate(); return "redirect:index.jsp";&#125; 6.3 拦截器代码123456789101112131415161718192021public class LoginInterceptor implements HandlerInterceptor&#123; @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //如果是登录页面则放行 if(request.getRequestURI().indexOf("login.action")&gt;=0)&#123; return true; &#125; HttpSession session = request.getSession(); //如果用户已登录也放行 if(session.getAttribute("user")!=null)&#123; return true; &#125; //用户没有登录挑战到登录页面 request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request,response); return false; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中的异常处理]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-18-SpringMVC%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[目录 异常处理的思路 实现步骤 1. 异常处理的思路系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端控制器交由异常处理器进行异常处理，如下图： 2. 实现步骤2.1 编写异常类和错误页面123456789101112131415161718/*** 自定义异常* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class CustomException extends Exception &#123; private String message; public CustomException(String message) &#123; this.message = message; &#125; public String getMessage() &#123; return message; &#125;&#125; jsp页面： 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;执行失败&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 执行失败！ $&#123;message &#125; &lt;/body&gt;&lt;/html&gt; 2.2 自定义异常处理器123456789101112131415161718192021222324252627/*** 自定义异常处理器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class CustomExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; ex.printStackTrace(); CustomException customException = null; //如果抛出的是系统自定义异常则直接转换 if(ex instanceof CustomException)&#123; customException = (CustomException)ex; &#125;else&#123; //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。 customException = new CustomException("系统错误，请与系统管理 员联系！"); &#125; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("message", customException.getMessage()); modelAndView.setViewName("error"); return modelAndView; &#125;&#125; 2.3 配置异常处理器123&lt;!-- 配置自定义异常处理器 --&gt;&lt;bean id="handlerExceptionResolver" class="com.itheima.exception.CustomExceptionResolver"/&gt; 2.4 运行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC实现文件上传]]></title>
    <url>%2F2019%2F06%2F13%2F2019-06-13-SpringMVC%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[目录 文件上传的回顾 SpringMVC传统方式的文件上传 SpringMVC跨服务器方式的文件上传 1. 文件上传的回顾1.1 文件上传的必要前提12345A form 表单的 enctype 取值必须是：multipart/form-data (默认值是:application/x-www-form-urlencoded) enctype:是表单请求正文的类型B method 属性取值必须是 PostC 提供一个文件选择域&lt;input type=”file” /&gt; 1.2 文件上传的原理分析当 form 表单的 enctype 取值不是默认值后，request.getParameter()将失效。 当enctype=”application/x-www-form-urlencoded”时，form 表单的正文内容是：key=value&amp;key=value&amp;key=value 当 form 表单的 enctype 取值为 Mutilpart/form-data 时，请求正文内容就变成： 每一部分都是 MIME 类型描述的正文 123456789-----------------------------7de1a433602ac 分界符Content-Disposition: form-data; name=&quot;userName&quot; 协议头aaa 协议的正文-----------------------------7de1a433602acContent-Disposition: form-data; name=&quot;file&quot;;filename=&quot;C:\Users\zhy\Desktop\fileupload_demofile\b.txt&quot;Content-Type: text/plain 协议的类型（MIME 类型）bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb-----------------------------7de1a433602ac-- 1.3 借助第三方组件实现文件上传使用 Commons-fileupload 组件实现文件上传，需要导入该组件相应的支撑 jar 包：Commons-fileupload 和commons-io。commons-io 不属于文件上传组件的开发 jar 文件，但Commons-fileupload 组件从 1.1 版本开始，它工作时需要 commons-io 包的支持。 2. SpringMVC传统方式的文件上传2.1 说明传统方式的文件上传，指的是我们上传的文件和访问的应用存在于同一台服务器上。并且上传完成之后，浏览器可能跳转。 2.2 实现步骤2.2.1 第一步：拷贝文件上传的jar包到工程的lib目录 2.2.2 第二步：编写jsp页面12345&lt;form action="/fileUpload" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"/&gt;&lt;br/&gt; 图片：&lt;input type="file" name="uploadFile"/&gt;&lt;br/&gt; &lt;input type="submit" value=" 上传 "/&gt;&lt;/form&gt; 2.2.3 第三步：编写控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 文件上传的的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("fileUploadController")public class FileUploadController &#123; /** * 文件上传 */ @RequestMapping("/fileUpload") public String testResponseJson(String picname,MultipartFile uploadFile,HttpServletRequest request) throws Exception&#123; //定义文件名 String fileName = ""; //1.获取原始文件名 String uploadFileName = uploadFile.getOriginalFilename(); //2.截取文件扩展名 String extendName = uploadFileName.substring(uploadFileName.lastIndexOf(".")+1, uploadFileName.length()); //3.把文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace("-", "").toUpperCase(); //4.判断是否输入了文件名 if(!StringUtils.isEmpty(picname)) &#123; fileName = uuid+"_"+picname+"."+extendName; &#125;else &#123; fileName = uuid+"_"+uploadFileName; &#125; System.out.println(fileName); //2.获取文件路径 ServletContext context = request.getServletContext(); String basePath = context.getRealPath("/uploads"); //3.解决同一文件夹中文件过多问题 String datePath = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); //4.判断路径是否存在 File file = new File(basePath+"/"+datePath); if(!file.exists()) &#123; file.mkdirs(); &#125; //5.使用 MulitpartFile 接口中方法，把上传的文件写到指定位置 uploadFile.transferTo(new File(file,fileName)); return "success"; &#125;&#125; 2.2.4 第四步：配置文件解析器12345678&lt;!-- 配置文件上传解析器 --&gt;&lt;bean id="multipartResolver" &lt;!-- id 的值是固定的--&gt; class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为 5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 注意：器 文件上传的解析器 id 是固定的，不能起别的名称，否则无法实现请求参数的绑定。（不光是文件，其他字段也将无法绑定） 3. SpringMVC跨服务器方式的文件上传3.1 分服务器的目的在实际开发中，我们会有很多处理不同功能的服务器。例如：应用服务器：负责部署我们的应用数据库服务器：运行我们的数据库缓存和消息服务器：负责处理大并发访问的缓存和消息文件服务器：负责存储用户上传文件的服务器。分服务器处理的目的是让服务器各司其职，从而提高我们项目 的运行效率。 3.2 准备两个tomcat服务器，并创建一个用于存放图片的web工程 在文件服务器的 tomcat 配置中加入，允许读写操作。文件位置： 加入内容： 加入此行的含义是：接收文件的目标服务器可以支持写入操作。 3.3 拷贝jar包在我们负责处理文件上传的项目中拷贝文件上传的必备 jar 包 3.4 编写控制器实现上传图片1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 响应 json 数据的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("fileUploadController2")public class FileUploadController2 &#123; public static final String FILESERVERURL ="http://localhost:9090/day06_spring_image/uploads/"; /** * 文件上传，保存文件到不同服务器 */ @RequestMapping("/fileUpload2") public String testResponseJson(String picname,MultipartFile uploadFile) throws Exception&#123; //定义文件名 String fileName = ""; //1.获取原始文件名 String uploadFileName = uploadFile.getOriginalFilename(); //2.截取文件扩展名 String extendName = uploadFileName.substring(uploadFileName.lastIndexOf(".")+1, uploadFileName.length()); //3.把文件加上随机数，防止文件重复 String uuid = UUID.randomUUID().toString().replace("-", "").toUpperCase(); //4.判断是否输入了文件名 if(!StringUtils.isEmpty(picname)) &#123; fileName = uuid+"_"+picname+"."+extendName; &#125;else &#123; fileName = uuid+"_"+uploadFileName; &#125; System.out.println(fileName); //5.创建 sun 公司提供的 jersey 包中的 Client 对象 Client client = Client.create(); //6.指定上传文件的地址，该地址是 web 路径 WebResource resource = client.resource(FILESERVERURL+fileName); //7.实现上传 String result = resource.put(String.class,uploadFile.getBytes()); System.out.println(result); return "success"; &#125;&#125; 3.5 编写jsp页面12345&lt;form action="fileUpload2" method="post" enctype="multipart/form-data"&gt; 名称：&lt;input type="text" name="picname"/&gt;&lt;br/&gt; 图片：&lt;input type="file" name="uploadFile"/&gt;&lt;br/&gt; &lt;input type="submit" value="上传"/&gt;&lt;/form&gt; 3.6 配置解析器12345678&lt;!-- 配置文件上传解析器 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设置上传文件的最大尺寸为 5MB --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven高级]]></title>
    <url>%2F2019%2F06%2F11%2F2019-06-11-Maven%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[目录 回顾 maven构建SSM工程 分模块构建工程 maven私服 把第三方jar包放入本地仓库或私服 1. 回顾1.1 Maven的好处1234节省磁盘空间可以一键构建可以跨平台应用在大型项目时可以提高开发效率 1.2 安装配置maven1注意：3.3+版本需要 jdkj.7+以上的支持 1.3 三种仓库123本地仓库远程仓库（私服）中央仓库 1.4 常见的命令123456CompileTestPackageInstallDeployClean 1.5 坐标的书写规范123groupId 公司或组织域名的倒序artifactId 项目名或模块名version 版本号 1.6 如何添加坐标121、在本地仓库中搜索2、互联网上搜，推荐网址 http://www.mvnrepository.com/ 1.7 依赖范围1234CompileTestRuntimeProvided 2. maven构建SSM工程2.1 需求实现 SSM 工程构建，规范依赖管理。场景：根据 id展示商品信息 2.2 准备数据库导入以下语句 1234567891011121314151617181920212223SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `items`-- ----------------------------DROP TABLE IF EXISTS `items`;CREATE TABLE `items` ( `id` int(10) NOT NULL auto_increment, `name` varchar(20) default NULL, `price` float(10,0) default NULL, `pic` varchar(40) default NULL, `createtime` datetime default NULL, `detail` varchar(200) default NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;-- ------------------------------ Records of items-- ----------------------------INSERT INTO `items` VALUES (&apos;1&apos;, &apos;传智播客&apos;, &apos;1000&apos;, null, &apos;2018-03-13 09:29:30&apos;, &apos;带我走上人生巅峰&apos;);INSERT INTO `items` VALUES (&apos;2&apos;, &apos;黑马310&apos;, null, null, &apos;2018-03-28 10:05:52&apos;, &apos;插入测试&apos;);INSERT INTO `items` VALUES (&apos;3&apos;, &apos;黑马307&apos;, &apos;199&apos;, null, &apos;2018-03-07 10:08:04&apos;, &apos;插入测试&apos;);INSERT INTO `items` VALUES (&apos;7&apos;, &apos;插入测试&apos;, null, null, null, null);INSERT INTO `items` VALUES (&apos;8&apos;, &apos;插入测试&apos;, null, null, null, null); 2.3 创建一个 maven 工程1.新建一个 ssm_maven 项目,使用下图选中的骨架 2.填写坐标 3.查看是否使用的自己的私服 4.在 main 目录下新建 java 和 resources文件夹 5.把 java 和 resources文件夹转成source root 6.修改编译版本，在 pom.xml 文件中添加 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;!-- 设置编译版本为 1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version &gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.4 知识点准备2.4.1 什么是依赖传递先添加 springmvc的核心依赖的坐标 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 会发现出现除了 spring-webmvc 以外的其他 jar。因为我们的项目依赖 spring-webmv.jar，而spring-webmv.jar 会依赖spring-beans.jar 等等，所以 spring-beans.jar 这些 jar 包也出现在了我们的 maven 工程中，这种现象我们称为依赖传递。从下图中可看到他们的关系：（请注意spring-beans 的版本） 2.4.2 依赖冲突的解决接着添加一个依赖 我们会发现这两个 jar 包同时都依赖了 spring-beans 但是spring-webmvc 依赖 spirng-beans-4.2.4，spring-context 依赖 spring-beans-5.0.2，但是发现spirng-beans-4.2.4 加入到工程中 而我们希望 spring-beans-5.0.2 加入工程。这就造成了依赖冲突。解决依赖冲突有以下原则： 2.4.3 依赖调解原则maven 自动按照下边的原则调解： 1.第一声明者优先原则 在 pom 文件定义依赖，先声明的依赖为准。 1234测试：如果将上边 spring-webmvc 和 spring-context 顺序颠倒，系统将导入 spring-beans-5.0.2。分析：由于 spring-webmvc 在前边以 spring-webmvc 依赖的 spring-beans-5.0.2 为准，所以最终spring-beans-5.0.2 添加到了工程中。 2.路径近者优先原则 例如：还是上述情况，spring-contex 和 spring-webmvc 都会传递过来 spirng-beans，那如果直接把 spring-beans 的依赖直接写到 pom 文件中，那么项目就不会再使用其他依赖传递来的 spring-beans，因为自己直接在 pom 中定义 spring-beans要比其他依赖传递过来的路径要近。 在本工程中的 pom 中加入 spirng-beans-5.0.2 的依赖，根据路径近者优先原则，系统将导入spirng-beans-5.0.2： 2.4.4 排除依赖上边的问题也可以通过排除依赖方法辅助依赖调解，如下：比如在依赖 spring-webmvc 的设置中添加排除依赖，排除 spring-beans，下边的配置表示：依赖 spring-webmvc，但排除 spring-webmvc 所依赖的 spring-beans。 2.4.5 锁定版本面对众多的依赖，有一种方法不用考虑依赖路径、声明优化等因素可以采用直接锁定版本的方法确定依赖构件的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中，此方法在企业开发中常用。 如下的配置是锁定了 spring-beans 和 spring-context 的版本： 还可以把版本号提取出来，使用标签设置成变量。 注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加&lt;dependencies&gt;&lt;/dependencies&gt;标签，如下： 上边添加的依赖并没有指定版本，原因是已在&lt;dependencyManagement&gt;中锁定了版本，所以在&lt;dependency&gt;下不需要再指定版本。 2.5 定义pom.xmlmaven 工程首先要识别依赖，web 工程实现 SSM 整合，需要依赖 spring-webmvc5.0.2、spring5.0.2、mybatis3.4.5等，在 pom.xml 添加工程如下依赖： （在实际企业开发中会有架构师专门来编写 pom.xml） 分两步： （1）锁定依赖版本 （2）添加依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.ssm_maven&lt;/groupId&gt; &lt;artifactId&gt;ssm_maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;springmvc.version&gt;5.0.2.RELEASE&lt;/springmvc.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;!--锁定依赖版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--添加依赖--&gt; &lt;dependencies&gt; &lt;!-- Mybatis 和 mybatis 与 spring 的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC 核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- junit 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 设置编译版本为 1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version &gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.6 Dao层在 src/main/java中定义 dao接口，实现根据 id 查询商品信息： 2.6.1 pojo模型类在 src/main/java创建模型类 12345678910public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; ………&#125; 2.6.2 dao层代码 2.6.3 配置文件注意配置文件的位置 内容如下 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="cn.itcast.ssm.dao.ItemsMapper" &gt; &lt;select id="findById" parameterType="int" resultType="items"&gt; select * from items where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在 src/main/resources 创建applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!-- 驱动 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- url --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/maven" /&gt; &lt;!-- 用户名 --&gt; &lt;property name="username" value="root" /&gt; &lt;!-- 密码 --&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;!-- mapper 配置 --&gt; &lt;!-- 让 spring 管理 sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="typeAliasesPackage" value="cn.itcast.ssm.pojo"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- mapper 扫描器 ：用来产生代理对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.itcast.ssm.dao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在 src/main/resources 配置 log4j.properties 123456789101112### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to&apos;debug&apos; ####在开发阶段日志级别使用 debuglog4j.rootLogger=debug, stdout### 在日志中输出 sql 的输入参数 ###log4j.logger.org.hibernate.type=TRACE 2.6.4 单元测试在 src/test/java 创建单元测试类 12345678910111213public class ItemsMapperTest &#123; @Test public void testFindItemsById() &#123; //获取 spring 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); //获取 Mapper ItemsMapper itemsMapper = applicationContext.getBean(ItemsMapper.class); //调用 Mapper 方法 Items items = itemsMapper.findById(1); System.out.println(items); &#125;&#125; 2.7 Service层2.7.1 代码1234567891011@Service@Transactionalpublic class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsMapper itemsMapper; @Override public Items findById(int itemId) &#123; return itemsMapper.findById(itemId); &#125;&#125; 2.7.2 配置文件在 applicationContext.xml中配置 service 1&lt;context:component-scan base-package="cn.itcast.ssm.service"/&gt; 2.8 Web层2.8.1 代码12345678910111213@Controller@RequestMapping("/items/")public class ItemsController &#123; @Autowired private ItemsService itemsService ; // 展示商品信息页面 @RequestMapping("/showItem") public String showItem(int id,Model model)&#123; Items items = itemsService.findById(id); model.addAttribute("item", items); return "viewItem"; &#125;&#125; 2.8.2 配置文件springmvc.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd"&gt; &lt;context:component-scan base-package="cn.itcast.ssm.controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器的前缀和后缀 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml 加载 spring容器，配置 springmvc前端控制器 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns="http://java.sun.com/xml/ns/javaee"xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID"version="2.5"&gt; &lt;!-- 前端控制器 加载springmvc容器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 监听器 加载 spring 容器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 2.9 jsp/WEB-INF/jsp/viewItem.jsp 如下： 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;商品信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt; &lt;table width="100%" border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt; $&#123;item.name &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt; $&#123;item.price &#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;生成日期&lt;/td&gt; &lt;td&gt; &lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;商品简介&lt;/td&gt; &lt;td&gt;$&#123;item.detail&#125; &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.10 运行与调试添加 tomcat7插件，双击右侧tomcat7 运行 运行结果如下： 3. 分模块构建工程基于上边的三个工程分析继承：创建一个 parent 工程将所需的依赖都配置在 pom 中聚合：聚合多个模块运行。 3.1 需求1234将 SSM 工程拆分为多个模块开发： ssm_dao ssm_service ssm_web 理解继承和聚合 通常继承和聚合同时使用。 何为继承？ 继承是为了消除重复，如果将 dao、service、web 分开创建独立的工程则每个工程的 pom.xml文件中的内容存在重复，比如：设置编译版本、锁定 spring的版本的等，可以将这些重复的配置提取出来在父工程的 pom.xml 中定义。 何为聚合？ 项目开发通常是分组分模块开发，每个模块开发完成要运行整个工程需要将每个模块聚合在一起运行，比如：dao、service、web 三个工程最终会打一个独立的war 运行。 3.2 案例实现3.2.1 maven-parent父模块3.2.1.1 创建父工程1.选择骨架创建父工程 2.填写坐标 3.确认使用的是本地仓库 4.注意代码所在的路径（默认） 5.设置项目的打包方式 3.2.1.2 定义 pom.xml在父工程的 pom.xml 中抽取一些重复的配置的，比如：锁定 jar 包的版本、设置编译版本等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;springmvc.version&gt;5.0.4.RELEASE&lt;/springmvc.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.2.1.3 将父工程发布至仓库父工程创建完成执行 install 将父工程发布到仓库方便子工程继承： 3.2.2 ssm_dao 子模块3.2.2.1 创建dao子模块1.在父工程上右击创建 maven 模块： 2.选择“跳过骨架选择”： 3.填写模块名称 4.下一步，确定项目的目录 5.打包方式是 jar 3.2.2.2 定义 pom.xml只添加到层的 pom，mybatis 和 spring 的整合相关依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;dependencies&gt; &lt;!-- Mybatis 和mybatis 与 spring 的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.2.3 dao代码把文件夹转成 sources root 将 ssm_maven 工程中的 dao接口、映射文件及 pojo 类拷贝到 src/main/java 中： 3.2.2.4 配置文件将 applicationContext.xml拆分出一个applicationContext-dao.xml，此文件中只配置 dao 相关 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:context="http://www.springframework.org/schema/context"xmlns:p="http://www.springframework.org/schema/p"xmlns:aop="http://www.springframework.org/schema/aop"xmlns:tx="http://www.springframework.org/schema/tx"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-4.0.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context-4.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-4.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-4.0.xsdhttp://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util-4.0.xsd"&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!-- 驱动 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;!-- url --&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/maven" /&gt; &lt;!-- 用户名 --&gt; &lt;property name="username" value="root" /&gt; &lt;!-- 密码 --&gt; &lt;property name="password" value="root" /&gt; &lt;/bean&gt; &lt;!-- mapper 配置 --&gt; &lt;!-- 让 spring 管理 sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="typeAliasesPackage" value="cn.itcast.ssm.pojo"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- mapper 扫描器 ：用来产生代理对象--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.itcast.ssm.dao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.2.2.5 单元测试1.首先在 dao 模块的 pom.xml添加 junit 的依赖，添加时 Scope 选择 test 2.编写 junit 测试代码 12345678910111213public class ItemsMapperTest &#123; @Test public void testFindItemsById() &#123; //获取 spring 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext-dao.xml"); //获取 Mapper ItemsMapper itemsMapper = applicationContext.getBean(ItemsMapper.class); //调用 Mapper 方法 Items items = itemsMapper.findById(1); System.out.println(items); &#125;&#125; 3.2.2.6 把 dao 模块 install 到本地仓库调过测试，install 到本地仓库 3.2.3 ssm_service 子模块3.2.3.1 创建 service 子模块方法同 ssm_dao 模块创建方法，模块名称为 ssm_service。 3.2.3.2 定义 pom.xmlssm_service 模块的 pom.xml 文件中需要继承父模块，ssm_service 依赖 ssm_dao 模块，添加spring相关的依赖： 1234567891011121314151617&lt;dependencies&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- dao 层的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm_dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.2.3.3 service 接口将 ssm_maven 工程中的service接口拷贝到 src/main/java中： 3.2.3.4 配置文件创建 applicationContext-service.xml，此文件中定义的service。 1&lt;context:component-scan base-package="cn.itcast.ssm"/&gt; 3.2.3.5 依赖范围对传递依赖的影响（了解）问题描述 当在写 junit 测试时发现，代码报出没有找不到类的错误信息： 是因为没有 junit.jar 引起的!为什么会这样呢？我们 ssm_dao 模块中有 junit 依赖而ssm_service 模块依赖了 ssm_dao，难道 junit 不应该传递过来吗？ 依赖范围对传递依赖的影响 是因为依赖会有依赖范围，依赖范围对传递依赖也有影响，例如有 A、B、C，A 依赖 B、B依赖 C，C可能是 A的传递依赖，如下图： 最左边一列为直接依赖，理解为 A 依赖 B 的范围，最顶层一行为传递依赖，理解为 B依赖 C 的范围，行与列的交叉即为 A传递依赖 C的范围。 举例 1：比如 A 对 B 有 compile 依赖，B 对 C 有 runtime 依赖，那么根据表格所示 A 对 C 有runtime 依赖。 ssm_dao依赖 junit，scop为 testssm_service 依赖 ssm_dao.查看下图红色框内所示传递依赖范围： 所以 ssm_dao工程所依赖的 junit 的 jar 没有加入到 ssm_service 工程。 举例 2：如果修改 ssm_dao 工程依赖 junit 的 scop 为 compile，ssm_dao 工程所依赖的 junit的 jar 包会加入到 ssm_service 工程中，符合上边表格所示，查看下图红色框内所示： 3.2.3.6 单元测试遇到依赖没有传递过来的问题我们通常的解决方案是在本工程中直接添加依赖：把如下依赖添加到 ssm_service的工程中： 再看测试代码也不报错了 3.2.3.7 Install 到本地仓库 3.2.4 ssm_web 子模块3.2.4.1 创建 web 子模块1.选择骨架创建web 子模块 2.确认使用自己的本地仓库 3.填写模块名称 使用骨架创建 web 项目会花费些时间，请耐心等待 4.创建 java 和 resources 文件夹，转成source root 5.添加打包方式war 3.2.4.2 定义 pom.xmlssm_web 模块的 pom.xml 文件中需要继承父模块，ssm_web 依赖 ssm_service 模块,和springmvc 的依赖 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ssm_parent&lt;/artifactId&gt; &lt;groupId&gt;cn.itcast.ssm&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;ssm_web&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 依赖service --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast.ssm&lt;/groupId&gt; &lt;artifactId&gt;ssm_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.4.3 controller将 ssm_web 工程中的controller 代码拷贝到src/main/java 中： 3.2.4.4 配置文件拷贝 ssm_web 工程中如下配置文件： 3.2.5 运行调试方法 1：在ssm_web 工程的 pom.xml 中配置 tomcat 插件运行运行 ssm_web 工程它会从本地仓库下载依赖的 jar 包，所以当 ssm_web 依赖的 jar 包内容修改了必须及时发布到本地仓库，比如：ssm_web 依赖的 ssm_service 修改了，需要及时将ssm_service 发布到本地仓库。 方法 2：在父工程的 pom.xml 中配置 tomcat插件运行，自动聚合并执行推荐方法2，如果子工程都在本地，采用方法2则不需要子工程修改就立即发布到本地仓库，父工程会自动聚合并使用最新代码执行。 注意：如果子工程和父工程中都配置了tomcat 插件，运行的端口和路径以子工程为准。 3.3 分模块构建工程- 依赖整合每个模块都需要 spring 或者 junit 的 jar，况且最终 package 打完包最后生成的项目中的jar 就是各个模块依赖的整合，所以我们可以把项目中所需的依赖都可以放到父工程中,模块中只留模块和模块之间的依赖，那父工程的 pom.xml 可以如下配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;properties&gt;&lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;&lt;springmvc.version&gt;5.0.2.RELEASE&lt;/springmvc.version&gt;&lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!-- Mybatis 和mybatis 与 spring 的整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springmvc.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring 相关 事务相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4. maven私服4.1 需求123正式开发，不同的项目组开发不同的工程。ssm_dao工程开发完毕，发布到私服。ssm_service 从私服下载 dao 4.2 分析公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内部的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接私服服务器，员工将自己开发的项目打成 jar 并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件（jar）。 私服还充当一个代理服务器，当私服上没有 jar 包会从互联网中央仓库自动下载，如下图： 4.3 搭建私服环境4.3.1 下载nexusNexus 是 Maven 仓库管理器，通过 nexus 可以搭建 maven 仓库，同时 nexus 还提供强大的仓库管理功能，构件搜索功能等。 下载 Nexus， 下载地址：http://www.sonatype.org/nexus/archived/ 下载：nexus-2.12.0-01-bundle.zip 4.3.2 安装 nexus解压 nexus-2.12.0-01-bundle.zip，本教程将它解压在 F 盘，进入 bin目录： cmd进入 bin目录，执行 nexus.bat install 安装成功在服务中查看有 nexus 服务： 4.3.3 卸载 nexuscmd进入 nexus 的 bin目录，执行：nexus.bat uninstall 查看 window 服务列表 nexus 已被删除。 4.3.4 启动 nexus方法 1：cmd 进入 bin目录，执行 nexus.bat start 方法 2： 直接启动 nexus 服务 查看 nexus 的配置文件conf/nexus.properties 12345678# Jetty sectionapplication-port=8081 # nexus 的访问端口配置application-host=0.0.0.0 # nexus 主机监听配置(不用修改)nexus-webapp=$&#123;bundleBasedir&#125;/nexus # nexus 工程目录nexus-webapp-context-path=/nexus # nexus 的 web 访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus # nexus 仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus 运行程序目录 访问：http://localhost:8081/nexus/ 使用 Nexus 内置账户admin/admin123 登陆：点击右上角的 Log in，输入账号和密码 登陆 登陆成功： 4.3.5 仓库类型查看 nexus 的仓库： nexus 的仓库有 4 种类型： hosted，宿主仓库，部署自己的 jar 到这个类型的仓库，包括 releases 和 snapshot 两部分，Releases公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 proxy，代理仓库，用于代理远程的公共仓库，如 maven 中央仓库，用户连接私服，私服自动去中央仓库下载 jar 包或者插件。 group，仓库组，用来合并多个 hosted/proxy 仓库，通常我们配置自己的 maven 连接仓库组。 virtual(虚拟)：兼容 Maven1 版本的 jar 或者插件 nexus 仓库默认在 sonatype-work 目录中： central ：代理仓库，代理中央仓库 apache-snapshots ：代理仓库存储 snapshots 构件，代理地址 https://repository.apache.org/snapshots/central-m1 ：virtual 类型仓库，兼容 Maven1 版本的 jar 或者插件releases ： 本地仓库，存储 releases 构件。snapshots ： 本地仓库，存储 snapshots 构件。thirdparty ：第三方仓库public：仓库组 4.4 将项目发布到私服4.4.1 需求企业中多个团队协作开发通常会将一些公用的组件、开发模块等发布到私服供其它团队或模块开发人员使用。 本例子假设多团队分别开发 ssm_dao、ssm_service、ssm_web，某个团队开发完在ssm_dao会将 ssm_dao 发布到私服供 ssm_service团队使用，本例子会将 ssm_dao 工程打成jar 包发布到私服。 4.4.2 配置第一步： 需要在客户端即部署 ssm_dao工程的电脑上配置 maven环境，并修改 settings.xml文件，配置连接私服的用户和密码 。此用户名和密码用于私服校验，因为私服需要知道上传的账号和密码是否和私服中的账号和密码一致。 12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; releases 连接发布版本项目仓库snapshots 连接测试版本项目仓库 第二步： 配置项目 pom.xml配置私服仓库的地址，本公司的自己的 jar 包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为 release 则上传到私服的 release 仓库，如果版本为snapshot 则上传到私服的 snapshot仓库 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt;&lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt;&lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 注意：pom.xml 这里&lt;id&gt; 和 settings.xml 配置 &lt;id&gt; 对应！ 4.4.3 测试将项目 dao 工程打成 jar 包发布到私服：1、首先启动 nexus2、对 ssm_dao工程执行 deploy 命令 根据本项目pom.xml中version定义决定发布到哪个仓库，如果version定义为snapshot，执行deploy后查看nexus的snapshot仓库，如果version定义为release则项目将发布到nexus的 release仓库，本项目将发布到 snapshot仓库： 也可以通过 http方式查看： 4.5 从私服下载 jar 包4.5.1 需求没有配置 nexus 之前，如果本地仓库没有，去中央仓库下载，通常在企业中会在局域网内部署一台私服服务器，有了私服本地项目首先去本地仓库找 jar，如果没有找到则连接私服从私服下载 jar 包，如果私服没有 jar 包私服同时作为代理服务器从中央仓库下载 jar 包，这样做的好处是一方面由私服对公司项目的依赖 jar 包统一管理，一方面提高下载速度，项目连接私服下载 jar 包的速度要比项目连接中央仓库的速度快的多。 本例子测试从私服下载 ssm_dao 工程 jar 包。 4.5.2 管理仓库组nexus中包括很多仓库，hosted中存放的是企业自己发布的jar包及第三方公司的jar包，proxy 中存放的是中央仓库的 jar，为了方便从私服下载 jar 包可以将多个仓库组成一个仓库组，每个工程需要连接私服的仓库组下载 jar 包。 打开 nexus 配置仓库组，如下图： 上图中仓库组包括了本地仓库、代理仓库等。 4.5.3 在 setting.xml 中配置仓库在客户端的 setting.xml 中配置私服的仓库，由于 setting.xml 中没有 repositories 的配置标签需要使用 profile 定义仓库。 1234567891011121314151617181920212223242526272829&lt;profile&gt; &lt;!--profile 的 id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库 id，repositories 可以配置多个仓库，保证 id 不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即 nexus 仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载 releases 构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载 snapshots 构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven 的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的 id 不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/profile&gt; 使用 profile 定义仓库需要激活才可生效。 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 配置成功后通过 eclipse 查看有效 pom，有效 pom 是 maven 软件最终使用的 pom 内容，程序员不直接编辑有效 pom，打开有效 pom 有效 pom 内容如下：下边的 pom 内容中有两个仓库地址，maven 会先从前边的仓库的找，如果找不到 jar 包再从下边的找，从而就实现了从私服下载 jar 包。 123456789101112131415161718192021222324252627282930313233343536373839&lt;repositories&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;updatePolicy&gt;never&lt;/updatePolicy&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Central Repository&lt;/name&gt; &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt; 4.5.4 测试从私服下载jar包测试 1：局域网环境或本地网络即可在 ssm_service 工程中添加以上配置后，添加 ssm_dao 工程的依赖，删除本地仓库中 ssm_dao工程，同时在 eclipse 中关闭 ssm_dao工程。观察控制台： 项目先从本地仓库找 ssm_dao，找不到从私服找，由于之前执行 deploy 将 ssm_dao 部署到私服中，所以成功从私服下载 ssm_dao 并在本地仓库保存一份。如果此时删除私服中的 ssm_dao，执行 update project 之后是否正常？如果将本地仓库的 ssm_dao 和私服的 ssm_dao 全部删除是否正常？测试 2：需要互联网环境在项目的 pom.xml 添加一个依赖，此依赖在本地仓库和私服都不存在，maven 会先从本地仓库找，本地仓库没有再从私服找，私服没有再去中央仓库下载，jar 包下载成功在私服、本地仓库分别存储一份。 5. 把第三方jar包放入本地仓库或私服5.1 导入本地库随便找一个 jar 包测试，可以先 CMD进入到 jar包所在位置，运行mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dfile= fastjson-1.1.37.jar -Dpackaging=jar 5.2 导入私服需要在 maven 软件的核心配置文件 settings.xml 中配置第三方仓库的 server 信息 12345&lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 才能执行一下命令mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37-Dpackaging=jar -Dfile=fastjson-1.1.37.jar-Durl=http://localhost:8081/nexus/content/repositories/thirdparty/-DrepositoryId=thirdparty 5.3 参数说明DgroupId 和 DartifactId 构成了该 jar 包在 pom.xml 的坐标，项目就是依靠这两个属性定位。自己起名字也行。Dfile 表示需要上传的 jar 包的绝对路径。Durl 私服上仓库的位置，打开 nexus——&gt;repositories菜单，可以看到该路径。DrepositoryId 服务器的表示 id，在 nexus 的configuration 可以看到。Dversion 表示版本信息，关于 jar 包准确的版本：包的名字上一般会带版本号，如果没有那可以解压该包，会发现一个叫 MANIFEST.MF 的文件， 这个文件就有描述该包的版本信息。比如 Specification-Version: 2.2 可以知道该包的版本了。上传成功后，在 nexus 界面点击3rd party 仓库可以看到这包。]]></content>
      <categories>
        <category>协作开发工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>协作开发工具</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven基础]]></title>
    <url>%2F2019%2F06%2F10%2F2019-06-10-Maven%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[目录 Maven介绍 Maven的使用 Maven常用命令 Maven工程运行调试 总结 1. Maven介绍1.1 什么是Maven1.1.1 什么是MavenMaven 的正确发音是[ˈmevən]，而不是“马瘟”以及其他什么瘟。Maven 在美国是一个口语化的词语，代表专家、内行的意思。一个对 Maven 比较正式的定义是这么说的：Maven 是一个项目管理工具，它包含了一个 项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 1.1.2 Maven能解决什么问题可以用更通俗的方式来说明。我们知道，项目开发不仅仅是写写代码而已，期间会伴随着各种必不可少的事情要做，下面列举几个感受一下： 1、我们需要引用各种 jar 包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用到一种 jar 包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的 jar 包冲突，版本冲突。 2、我们辛辛苦苦写好了 Java 文件，可是只懂 0 和 1 的白痴电脑却完全读不懂，需要将它编译成二进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代码即时编译。当然，如果你嫌生命漫长，何不铺张，也可以用记事本来敲代码，然后用 javac 命令一个个地去编译，逗电脑玩。 3、世界上没有不存在 bug的代码，计算机喜欢 bug就和人们总是喜欢美女帅哥一样。为了追求美为了减少 bug，因此写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 4、再优雅的代码也是要出来卖的。我们后面还需要把代码与各种配置文件、资源整合到一起，定型打包，如果是 web项目，还需要将之发布到服务器，供人蹂躏。 试想，如果现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理 jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站点，你会心动吗？Maven 就可以解决上面所提到的这些问题。 1.1.3 Maven的优势举例前面我们通过 Web 阶段项目，要能够将项目运行起来，就必须将该项目所依赖的一些 jar 包添加到工程中，否则项目就不能运行。试想如果具有相同架构的项目有十个，那么我们就需要将这一份 jar包复制到十个不同的工程中。我们一起来看一个CRM项目的工程大小。 使用传统 Web 项目构建的 CRM 项目如下： 原因主要是因为上面的 WEB 程序要运行，我们必须将项目运行所需的 Jar 包复制到工程目录中，从而导致了工程很大。 同样的项目，如果我们使用 Maven 工程来构建，会发现总体上工程的大小会少很多。如下图: 小结：可以初步推断它里面一定没有 jar 包，继续思考，没有 jar 包的项目怎么可能运行呢？ 1.2 Maven的两个经典作用1.2.1 Maven的依赖管理Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 传统的 WEB 项目中，我们必须将工程所依赖的 jar 包复制到工程中，导致了工程的变得很大。那么maven 工程是如何使得工程变得很少呢？ 分析如下： 通过分析发现：maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从而找到这些 jar 包，再把这些 jar 包拿去运行。 那么问题来了 第一：”存放 jar 包的仓库”长什么样？第二：通过读取 pom.xml 文件中的坐标，再到仓库中找到 jar 包，会不会很慢？从而导致这种方式不可行！ 第一个问题：存放 jar 包的仓库长什么样，这一点我们后期会分析仓库的分类，也会带大家去看我们的本地的仓库长什么样。第二个问题：通过 pom.xml 文件配置要引入的 jar 包的坐标，再读取坐标并到仓库中加载 jar 包，这样我们就可以直接使用 jar 包了，为了解决这个过程中速度慢的问题，maven 中也有索引的概念，通过建立索引，可以大大提高加载 jar 包的速度，使得我们认为 jar 包基本跟放在本地的工程文件中再读取出来的速度是一样的。这个过程就好比我们查阅字典时，为了能够加快查找到内容，书前面的目录就好比是索引，有了这个目录我们就可以方便找到内容了，一样的在 maven 仓库中有了索引我们就可以认为可以快速找到 jar 包。 1.2.2 项目的一键构建我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 什么是构建？ 指的是项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个过程称为构建。 一键构建，指的是整个构建过程，使用 maven 一个命令可以轻松完成整个工作。 Maven 规范化构建流程如下： 我们一起来看 Hello-Maven 工程的一键运行的过程。通过 tomcat:run 的这个命令，我们发现现在的工程编译，测试，运行都变得非常简单。 2. Maven的使用2.1 Maven的安装2.1.1 Maven软件的下载为了使用 Maven 管理工具，我们首先要到官网去下载它的安装软件。通过百度搜索“Maven“如下： 点击 Download 链接，就可以直接进入到 Maven 软件的下载页面： 目前最新版是 apache-maven-3.5.3 版本，我们当时使用的是apache-maven-3.5.2 版本，大家也可以下载最新版本。 Apache-maven-3.5.2 下载地址：http://archive.apache.org/dist/maven/maven-3/下载后的版本如下: 2.1.2 Maven软件的安装Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如 D:\software\maven 下面。解压后目录结构如下： 1234bin:存放了 maven 的命令，比如我们前面用到的mvn tomcat:runboot:存放了一些 maven 本身的引导程序，如类加载器等conf:存放了 maven 的一些配置文件，如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包 至此我们的 maven 软件就可以使用了，前提是你的电脑上之前已经安装并配置好了 JDK。 2.1.3 JDK的准备及统一我们所使用工具软件的统一，JDK 使用 JDK8版本 JDK 环境: 2.1.4 Maven及JDK配置电脑上需安装 java 环境，安装 JDK1.7 + 版本 （将JAVA_HOME/bin 配置环境变量 path ），我们使用的是JDK8 相关版本 配置 MAVEN_HOME ，变量值就是你的 maven 安装 的路径（bin目录之前一级目录） 上面配置了我们的 Maven 软件，注意这个目录就是之前你解压 maven 的压缩文件包在的的目录，最好不要有中文和空格。 再次检查 JDK 的安装目录，如下图： 2.1.5 Maven软件版本测试通过 mvn -v命令检查 maven 是否安装成功，看到 maven 的版本为 3.5.2 及 java 版本为 1.8 即为安装成功。找开 cmd 命令，输入 mvn –v命令，如下图： 我们发现 maven 的版本，及 jdk 的版本符合要求，这样我们的 maven 软件安装就成功了。 2.2 Maven仓库2.1.1 Maven仓库的分类maven 的工作需要从仓库下载一些 jar 包，如下图所示，本地的项目 A、项目 B 等都会通过 maven软件从远程仓库（可以理解为互联网上的仓库）下载 jar 包并存在本地仓库，本地仓库 就是本地文件夹，当第二次需要此 jar 包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 下图描述了 maven 中仓库的类型： 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包，优先从本地仓库查找默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows 用户目录。 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包含了世界上大部分流行的开源项目构件。 2.2.2 Maven本地仓库的配置在无网的状态下学习，需要配置提前提供的本地仓库，将 “repository.rar”解压至自己的电脑上，我们解压在 D:\repository 目录下（可以放在没有中文及空格的目录下）。 在 MAVE_HOME/conf/settings.xml 文件中配置本地仓库位置（maven 的安装目录下）： 打开 settings.xml文件，配置如下： 2.2.3 全局setting与用户settingmaven 仓库地址、私服等配置信息需要在 setting.xml 文件中配置，分为全局配置和用户配置。在 maven 安装目录下的有 conf/setting.xml 文件，此 setting.xml 文件用于 maven 的所有 projec项目，它作为 maven 的全局配置。如需要个性配置则需要在用户配置中设置，用户配置的 setting.xml 文件默认的位置在：${user.dir}/.m2/settings.xml 目录中,${user.dir} 指windows 中的用户目录。maven会先找用户配置，如果找到则以用户配置文件为准，否则使用全局配置文件。 2.3 Maven工程的认识2.3.1 Maven工程的目录结构 作为一个 maven 工程，它的 src目录和 pom.xml 是必备的。进入 src目录后，我们发现它里面的目录结构如下： 123456src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类src/test/resources —— 测试资源文件target —— 项目输出位置，编译后的class 文件会输出到此目录pom.xml——maven 项目核心配置文件 注意：如果是普通的 java 项目，那么就没有webapp 目录。 2.3.2 Maven工程的运行进入 maven 工程目录（当前目录有 pom.xml 文件），运行 tomcat:run 命令。 根据上边的提示信息，通过浏览器访问：http://localhost:8080/maven-helloworld/ 2.3.3 问题处理如果本地仓库配置错误会报下边的错误 分析：maven 工程运行先从本地仓库找 jar 包，本地仓库没有再从中央仓库找，上边提示 downloading…表示 从中央仓库下载 jar，由于本地没有联网，报错。 解决：在 maven 安装目录的conf/setting.xml 文件中配置本地仓库，参考： “maven 仓库/配置本地仓库章节”。 3. Maven常用命令我们可以在cmd 中通过一系列的 maven 命令来对我们的 maven-helloworld 工程进行编译、测试、运行、打包、安装、部署。 3.1 常用命令3.1.1 compilecompile 是 maven 工程的编译命令，作用是将 src/main/java 下的文件编译为 class 文件输出到 target目录下。 cmd 进入命令状态，执行mvn compile，如下图提示成功： 查看 target 目录，class 文件已生成，编译完成。 3.1.2 testtest 是 maven 工程的测试命令 mvn test，会执行src/test/java下的单元测试类。 cmd 执行 mvn test 执行 src/test/java 下单元测试类，下图为测试结果，运行 1 个测试用例，全部成功。 3.1.3 cleanclean 是 maven 工程的清理命令，执行 clean 会删除 target 目录及内容。 3.1.4 packagepackage 是 maven 工程的打包命令，对于 java 工程执行 package 打成 jar 包，对于web 工程打成war包。 3.1.5 installinstall 是 maven 工程的安装命令，执行 install 将 maven 打成 jar 包或 war 包发布到本地仓库。从运行结果中，可以看出：当后面的命令执行时，前面的操作过程也都会自动执行. 3.1.6 Maven指令的生命周期maven 对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： 123Clean Lifecycle 在进行真正的构建之前进行一些清理工作。Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle 生成项目报告，站点，发布站点。 3.1.7 Maven的概念模型Maven 包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目对象模型 (Project Object Model) 一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统(Dependency Management System) 通过 maven 的依赖管理对项目所依赖的 jar 包进行统一管理。 比如：项目依赖 junit4.9，通过在 pom.xml 中定义 junit4.9 的依赖即使用 junit4.9，如下所示是 junit4.9的依赖定义： 1234567891011121314&lt;!-- 依赖关系 --&gt;&lt;dependencies&gt; &lt;!-- 此项目运行使用 junit，所以此项目依赖 junit --&gt; &lt;dependency&gt; &lt;!-- junit 的项目名称 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;!-- junit 的模块名称 --&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!-- junit 版本 --&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;!-- 依赖范围：单元测试时使用 junit --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 一个项目生命周期(Project Lifecycle) 使用 maven 完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven 将这些过程规范为一个生命周期，如下所示是生命周期的各各阶段： maven 通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行 mvn compile 执行编译、执行 mvn clean 执行清理。 一组标准集合 maven将整个项目管理过程定义一组标准，比如：通过 maven 构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件(plugin)目标(goal) maven 管理项目生命周期过程都是基于插件完成的。 3.2 idea开发maven项目在实战的环境中，我们都会使用流行的工具来开发项目。 3.2.1 idea的maven配置 打开–&gt;File–&gt;Settings 配置 maven 依据图片指示，选择本地 maven 安装目录，指定 maven 安装目录下conf文件夹中 settings 配置文件。 3.2.2 idea中创建一个maven的web工程打开 idea，选择创建一个新工程 选择 idea提供好的 maven 的web 工程模板 点击 Next填写项目信息 点击 Next，此处不做改动。 点击 Next选择项目所在目录 点击 Finish后开始创建工程，耐心等待，直到出现如下界面。 手动添加 src/main/java 目录，如下图右键 main 文件夹–&gt;New–&gt;Directory 创建一个新的文件夹命名为 java 点击 OK 后，在新的文件夹 java 上右键–&gt;Make Directory as–&gt;Sources Root 创建一个 Servlet src/java/main 创建了一个 Servlet，但报错 要解决问题，就是要将 servlet-api-xxx.jar 包放进来，作为 maven 工程应当添加 servlet的坐标，从而导入它的 jar 在 pom.xml 文件添加坐标 直接打开 hello_maven 工程的 pom.xml 文件，再添加坐标 添加 jar 包的坐标时，还可以指定这个 jar 包将来的作用范围。 每个 maven 工程都需要定义本工程的坐标，坐标是 maven 对 jar 包的身份定义，比如：入门程序的坐标定义如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;hello_maven&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging &gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 坐标的来源方式 添加依赖需要指定依赖 jar 包的坐标，但是很多情况我们是不知道 jar 包的的坐标，可以通过如下方式查询： 从互联网搜索http://search.maven.org/http://mvnrepository.com/ 网站搜索示例： 3.2.3 依赖范围A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括： 12345678910compile：编译范围，指 A在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以test范围依赖不会被打包。system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。 在 maven-web 工程中测试各各 scop。 123456测试总结：默认引入 的 jar 包 ------- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）servlet-api 、jsp-api ------- provided （编译、测试 有效， 运行时无效 防止和 tomcat 下 jar 冲突）jdbc 驱动 jar 包 ---- runtime （测试、运行 有效 ）junit ----- test （测试有效）依赖范围由强到弱的顺序是：compile&gt;provided&gt;runtime&gt;test 3.2.4 项目中添加的坐标 3.2.5 设置jdk编译版本我们使用 jdk1.8，需要设置编译版本为 1.8，这里需要使用 maven 的插件来设置：在 pom.xml 中加入： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3.2.6 编写servlet在 src/main/java中创建 ServletTest 内容如下: 3.2.7 编写jsp 3.2.8 在web.xml中配置servlet访问路径 3.2.9 添加tomcat7插件在 pom 文件中添加如下内容 此时点击 idea最右侧 Maven Projects，就可以看到我们新添加的tomcat7 插件双击 tomcat7插件下tomcat7:run 命令直接运行项目 也可以直接点击如图按钮，手动输入 tomc7:run 命令运行项目 点击后弹出如下图窗口 3.2.10 运行结果 4. Maven工程运行调试4.1 端口占用处理重新执行 tomcat:run 命令重启工程，重启之前需手动停止 tomcat，否则报下边的错误： 4.2 断点调试点击如图所示选项 在弹出框中点击如图加号按钮找到 maven 选项 在弹出窗口中填写如下信息 完成后先 Apply 再 OK 结束配置后，可以在主界面找到我们刚才配置的操作名称。 如上图红框选中的两个按钮，左侧是正常启动，右侧是 debug启动。 5. 总结5.1 maven仓库1231、maven 仓库的类型有哪些？2、maven 工程查找仓库的流程是什么？3、本地仓库如何配置？ 5.2 常用的maven命令12345compile：编译clean：清理test：测试package：打包install：安装 5.3 坐标定义在 pom.xml 中定义坐标，内容包括：groupId、artifactId、version，详细内容如下： 12345678910&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt;&lt;!-- 模块名称 --&gt;&lt;artifactId&gt;maven-first&lt;/artifactId&gt;&lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging &gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 5.4 pom基本配置pom.xml 是 Maven 项目的核心配置文件，位于每个工程的根目录，基本配置如下： 12345678910&lt;project &gt; ：文件的根节点 .&lt;modelversion &gt; ： pom.xml 使用的对象模型版本&lt;groupId &gt; ：项目名称，一般写项目的域名&lt;artifactId &gt; ：模块名称，子项目名或模块名称&lt;version &gt; ：产品的版本号 .&lt;packaging &gt; ：打包类型，一般有 jar、war、pom 等&lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;description &gt; ：项目描述，常用于 Maven 生成的文档&lt;dependencies&gt; ：项目依赖构件配置，配置项目依赖构件的坐标&lt;build&gt; ：项目构建配置，配置编译、运行插件等。 ##]]></content>
      <categories>
        <category>协作开发工具</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>协作开发工具</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应数据和结果视图]]></title>
    <url>%2F2019%2F06%2F10%2F2019-06-10-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BB%93%E6%9E%9C%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[目录 返回值分类 转发和重定向 RequestBody响应json数据 1. 返回值分类1.1 字符串controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 123456//指定逻辑视图名，经过视图解析器解析为 jsp 物理路径：/WEB-INF/pages/success.jsp@RequestMapping("/testReturnString")public String testReturnString() &#123; System.out.println("AccountController 的 testReturnString 方法执行了。。。。"); return "success";&#125; 运作结果： 1.2 void我们知道 Servlet 原始 API 可以作为控制器中方法的参数： 1234@RequestMapping("/testReturnVoid")public void testReturnVoid(HttpServletRequest request,HttpServletResponse response)throws Exception &#123;&#125; 在controller 方法形参上可以定义 request和 response，使用 request 或 response 指定响应结果： 1 、使用 request 转向页面，如下： 1request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response); 2 、也可以通过 response 页面重定向： 1response.sendRedirect("testRetrunString") 3 、也可以通过 response 指定响应结果，例如响应 json 数据： 123response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("n json 串" "); 1.3 ModelAndViewModelAndView 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。该对象中有两个方法： 示例代码： 1234567891011/*** 返回 ModeAndView* @return*/@RequestMapping("/testReturnModelAndView")public ModelAndView testReturnModelAndView() &#123; ModelAndView mv = new ModelAndView(); mv.addObject("username", "张三"); mv.setViewName("success"); return mv;&#125; 响应的 jsp 代码： 1234567891011121314&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;执行成功&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 执行成功！ $&#123;requestScope.username&#125; &lt;/body&gt;&lt;/html&gt; 输出结果： 注意：我们在页面上上获取使用的是 requestScope.username 取的，所以返回 ModelAndView 类型时，浏览器跳转只能是请求转发。 2. 转发和重定向2.1 forward转发controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成： 123456789/*** 转发* @return*/@RequestMapping("/testForward")public String testForward() &#123; System.out.println("AccountController 的 testForward 方法执行了。。。。"); return "forward:/WEB-INF/pages/success.jsp";&#125; 需要注意的是，如果用了 formward ：则路径必须写成实际视图 url，不能写逻辑视图。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。 2.2 redirect重定向contrller 方法提供了一个 String 类型返回值之后，它需要在返回值里使用:redirect: 123456789*** 重定向* @return*/@RequestMapping("/testRedirect")public String testRedirect() &#123; System.out.println("AccountController 的 testRedirect 方法执行了。。。。"); return "redirect:testReturnModelAndView";&#125; 它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到。 3. RequestBody响应json数据3.1 使用说明123作用： 该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端 3.2 使用示例12345需 求： 使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端。前置知识点： Springmvc 默认用 MappingJacksonHttpMessageConverter 对 json 数据进行转换，需要加入jackson 的包。(注意：2.7.0 以下的版本用不了) jsp 中的代码： 1234567891011121314151617181920&lt;script type="text/javascript"src="$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; $("#testJson").click(function()&#123; $.ajax(&#123; type:"post", url:"$&#123;pageContext.request.contextPath&#125;/testResponseJson", contentType:"application/json;charset=utf-8", data:'&#123;"id":1,"name":"test","money":999.0&#125;', dataType:"json", success:function(data)&#123; alert(data); &#125; &#125;); &#125;); &#125;)&lt;/script&gt;&lt;!-- 测试异步请求 --&gt;&lt;input type="button" value=" 测试 ajax 请求 json 和响应 json" id="testJson"/&gt; 控制器中的代码： 1234567891011121314151617/*** 响应 json 数据的控制器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("jsonController")public class JsonController &#123; /** * 测试响应 json 数据 */ @RequestMapping("/testResponseJson") public @ResponseBody Account testResponseJson(@RequestBody Account account) &#123; System.out.println("异步请求："+account); return account; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求参数的绑定与常用注解]]></title>
    <url>%2F2019%2F06%2F09%2F2019-06-09-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目录 绑定说明 特殊情况 RequestParam RequestBody PathVaribale RequestHeader CookieValue ModelAttribute SessionAttribute 1. 绑定说明1.1 绑定的机制我们都知道，表单中请求参数都是基于 key=value 的。SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。例如： 1&lt;a href="account/findAccount?accountId=10"&gt;查询账户&lt;/a&gt; 请求参数是：accountId=10 123456789/*** 查询账户* @return*/@RequestMapping("/findAccount")public String findAccount(Integer accountId) &#123; System.out.println("查询了账户。。。。"+accountId); return "success";&#125; 1.2 支持的数据类型1234567基本类型参数 ： 包括基本类型和 String 类型POJO 类型参数 ： 包括实体类，以及关联的实体类数组和集合类型参数 ： 包括 List 结构和 Map 结构的集合（包括数组）SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。 1.3 使用要求123456789101112131415161718192021222324252627282930313233如果是基本类型或者 String 类型： 要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)是 如果是 POJO 类型 ，或者 它的关联对象 ： 要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。如果是集合类型, 有两种方式 ： 第一种： 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。 第二种： 接收的请求参数是 json 格式数据。需要借助一个注解实现。 注意: 它还可以实现一些数据类型自动转换。内置转换器全都在： org.springframework.core.convert.support 包下。有： java.lang.Boolean -&gt; java.lang.String : ObjectToStringConverter java.lang.Character -&gt; java.lang.Number : CharacterToNumberFactory java.lang.Character -&gt; java.lang.String : ObjectToStringConverter java.lang.Enum -&gt; java.lang.String : EnumToStringConverter java.lang.Number -&gt; java.lang.Character : NumberToCharacterConverter java.lang.Number -&gt; java.lang.Number : NumberToNumberConverterFactory java.lang.Number -&gt; java.lang.String : ObjectToStringConverter java.lang.String -&gt; java.lang.Boolean : StringToBooleanConverter java.lang.String -&gt; java.lang.Character : StringToCharacterConverter java.lang.String -&gt; java.lang.Enum : StringToEnumConverterFactory java.lang.String -&gt; java.lang.Number : StringToNumberConverterFactory java.lang.String -&gt; java.util.Locale : StringToLocaleConverter java.lang.String -&gt; java.util.Properties : StringToPropertiesConverter java.lang.String -&gt; java.util.UUID : StringToUUIDConverter java.util.Locale -&gt; java.lang.String : ObjectToStringConverter java.util.Properties -&gt; java.lang.String : PropertiesToStringConverter java.util.UUID -&gt; java.lang.String : ObjectToStringConverter ...... 如遇特殊类型转换要求，需要我们自己编写自定义类型转换器。 1.4 使用示例1.4.1 基本类型和String类型作为参数jsp 代码： 12&lt;!-- 基本类型示例 --&gt;&lt;a href="account/findAccount?accountId=10&amp;accountName=zhangsan"&gt;查询账户&lt;/a&gt; 控制器代码： 123456789/*** 查询账户* @return*/@RequestMapping("/findAccount")public String findAccount(Integer accountId,String accountName) &#123; System.out.println("查询了账户。。。。"+accountId+","+accountName); return "success";&#125; 运行结果： 1.4.2 POJO类型作为参数实体类代码： 1234567891011121314/*** 账户信息* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; private Address address; //getters and setters&#125; 123456789101112*** 地址的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Address implements Serializable &#123; private String provinceName; private String cityName; //getters and setters&#125; jsp 代码： 12345678&lt;!-- pojo 类型演示 --&gt;&lt;form action="account/saveAccount" method="post"&gt; 账户名称：&lt;input type="text" name="name" &gt;&lt;br/&gt; 账户金额：&lt;input type="text" name="money" &gt;&lt;br/&gt; 账户省份：&lt;input type="text" name="address.provinceName" &gt;&lt;br/&gt; 账户城市：&lt;input type="text" name="address.cityName" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制器代码： 12345678910/*** 保存账户* @param account* @return*/@RequestMapping("/saveAccount")public String saveAccount(Account account) &#123; System.out.println("保存了账户。。。。"+account); return "success";&#125; 运行结果： 1.4.3 POJO类中包含集合类型参数实体类代码： 12345678910111213141516171819202122/*** 用户实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class User implements Serializable &#123; private String username; private String password; private Integer age; private List&lt;Account&gt; accounts; private Map&lt;String,Account&gt; accountMap; //getters and setters @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + ", age=" + age + ",\n accounts=" + accounts + ",\n accountMap=" + accountMap + "]"; &#125;&#125; jsp代码： 123456789101112131415&lt;!-- POJO 类包含集合类型演示 --&gt;&lt;form action="account/updateAccount" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; 账户 1 名称：&lt;input type="text" name="accounts[0].name" &gt;&lt;br/&gt; 账户 1 金额：&lt;input type="text" name="accounts[0].money" &gt;&lt;br/&gt; 账户 2 名称：&lt;input type="text" name="accounts[1].name" &gt;&lt;br/&gt; 账户 2 金额：&lt;input type="text" name="accounts[1].money" &gt;&lt;br/&gt; 账户 3 名称：&lt;input type="text" name="accountMap['one'].name" &gt;&lt;br/&gt; 账户 3 金额：&lt;input type="text" name="accountMap['one'].money" &gt;&lt;br/&gt; 账户 4 名称：&lt;input type="text" name="accountMap['two'].name" &gt;&lt;br/&gt; 账户 4 金额：&lt;input type="text" name="accountMap['two'].money" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制器： 123456789/*** 更新账户* @return*/@RequestMapping("/updateAccount")public String updateAccount(User user) &#123; System.out.println("更新了账户。。。。"+user); return "success";&#125; 运行结果： 1.4.4 请求参数乱码问题post 请求方式：在 web.xml 中配置一个过滤器 12345678910111213141516171819202122&lt;!-- 配置 springMVC 编码过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;!-- 设置过滤器中的属性值 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 过滤所有请求 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在 springmvc 的配置文件中可以配置，静态资源不过滤： 1234&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt;&lt;mvc:resources location="/images/" mapping="/images/**"/&gt;&lt;mvc:resources location="/scripts/" mapping="/javascript/**"/&gt; get 请求方式：tomacat 对 GET和 POST 请求处理方式是不同的，GET请求的编码问题，要改 tomcat 的 server.xml配置文件，如下： 12&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; 改为: 123&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" useBodyEncodingForURI="true"/&gt; 如果遇到 ajax 请求仍然乱码，请把： 1useBodyEncodingForURI=&quot;true&quot;改为 URIEncoding=&quot;UTF-8&quot; 2. 特殊情况2.1 自定义类型转换器2.1.1 使用场景：jsp代码： 12&lt;!-- 特殊情况之：类型转换问题 --&gt;&lt;a href="account/deleteAccount?date=2018-01-01"&gt;根据日期删除账户&lt;/a&gt; 控制器代码: 123456789/*** 删除账户* @return*/@RequestMapping("/deleteAccount")public String deleteAccount(String date) &#123; System.out.println("删除了账户。。。。"+date); return "success";&#125; 运行结果： 当我们把控制器中方法参数的类型改为 Date 时： 123456789/*** 删除账户* @return*/@RequestMapping("/deleteAccount")public String deleteAccount(Date date) &#123; System.out.println("删除了账户。。。。"+date); return "success";&#125; 运行结果： 异常提示： 1234Failed to bind request element:org.springframework.web.method.annotation.MethodArgumentTypeMismatchException:Failed to convert value of type &apos;java.lang.String&apos; to required type &apos;java.util.Date&apos;; nested exception is org.springframework.core.convert.ConversionFailedException:Failed to convert from type [java.lang.String] to type [java.util.Date] for value &apos;2018-01-01&apos;; nested exception is java.lang.IllegalArgumentException 2.1.2 使用步骤第一步：定义一个类，实现 Converter 接口，该接口有两个泛型。 1234567public interface Converter&lt;S, T&gt; &#123;//S:表示接受的类型，T：表示目标类型 /** * 实现类型转换的方法 */ @Nullable T convert(S source);&#125; 12345678910111213141516171819202122232425/*** 自定义类型转换器* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; /** * 用于把 String 类型转成日期类型 */ @Override public Date convert(String source) &#123; DateFormat format = null; try &#123; if(StringUtils.isEmpty(source)) &#123; throw new NullPointerException("请输入要转换的日期"); &#125; format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(source); return date; &#125; catch (Exception e) &#123; throw new RuntimeException("输入日期有误"); &#125; &#125;&#125; 第二步：在 spring 配置文件中配置类型转换器。 spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。 1234567891011&lt;!-- 配置类型转换器工厂 --&gt;&lt;bean id="converterService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;!-- 给工厂注入一个新的类型转换器 --&gt; &lt;property name="converters"&gt; &lt;array&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean class="com.itheima.web.converter.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 第三步：在 annotation-driven 12&lt;!-- 引用自定义类型转换器 --&gt;&lt;mvc:annotation-driven conversion-service="converterService"&gt;&lt;/mvc:annotation-driven&gt; 运行结果： 2.2 使用ServletAPI对象作为方法参数1234567891011SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 ServletAPI 对象有：HttpServletRequestHttpServletResponseHttpSessionjava.security.PrincipalLocaleInputStreamOutputStreamReaderWriter我们可以把上述对象，直接写在控制的方法参数中使用。 部分示例代码：jsp 代码： 12&lt;!-- 原始 ServletAPI 作为控制器参数 --&gt;&lt;a href=&quot;account/testServletAPI&quot;&gt;测试访问 ServletAPI&lt;/a&gt; 控制器中的代码： 12345678910111213/*** 测试访问 testServletAPI* @return*/@RequestMapping("/testServletAPI")public String testServletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session) &#123; System.out.println(request); System.out.println(response); System.out.println(session); return "success";&#125; 执行结果： 3. RequestParam3.1 使用说明12345作用： 把请求中指定名称的参数给控制器中的形参赋值。属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 3.2 使用示例jsp 中的代码： 12&lt;!-- requestParams 注解的使用 --&gt;&lt;a href="springmvc/useRequestParam?name=test"&gt;requestParam 注解&lt;/a&gt; 控制器中的代码： 1234567891011/*** requestParams 注解的使用* @param username* @return*/@RequestMapping("/useRequestParam")public String useRequestParam(@RequestParam("name")String username, @RequestParam(value="age",required=false)Integer age)&#123; System.out.println(username+","+age); return "success";&#125; 运行结果： 4. RequestBody4.1 使用说明12345作用： 用于获取请求体内容。直接使用得到是 key=value&amp;key=value...结构的数据。 get 请求方式不适用。属性： required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。 4.2 使用示例post 请求 jsp代码： 1234567&lt;!-- request body 注解 --&gt;&lt;form action="springmvc/useRequestBody" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户密码：&lt;input type="password" name="password" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; get 请求 jsp 代码： 1&lt;a href="springmvc/useRequestBody?body=test"&gt;requestBody 注解 get 请求&lt;/a&gt; 控制器代码： 12345678910/*** RequestBody 注解* @param user* @return*/@RequestMapping("/useRequestBody")public String useRequestBody(@RequestBody(required=false) String body)&#123; System.out.println(body); return "success";&#125; post 请求运行结果： get 请求运行结果： 5. PathVaribale5.1 使用说明123456作用： 用于绑定 url 中的占位符。例如：请求 url 中 /delete/&#123;id&#125;，这个&#123;id&#125;就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。属性： value：用于指定 url 中占位符名称。 required：是否必须提供占位符。 5.2 使用示例jsp代码： 12&lt;!-- PathVariable 注解 --&gt;&lt;a href="springmvc/usePathVariable/100"&gt;pathVariable 注解&lt;/a&gt; 控制器代码： 12345678910/*** PathVariable 注解* @param user* @return*/@RequestMapping("/usePathVariable/&#123;id&#125;")public String usePathVariable(@PathVariable("id") Integer id)&#123; System.out.println(id); return "success";&#125; 运行结果： 5.3 REST风格URL1234567891011121314151617181920什么是 rest ： REST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之一。在目前主流的三种 Web 服务交互方案中，REST 相比于 SOAP（Simple Object Access protocol，简单对象访问协议）以及 XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码，REST 都倾向于用更加简单轻量的方法设计和实现。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。 它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口。 restful 的优点 它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 restful 的特性： 资源（ Resources）：网络上的一个实体，或者说是网络上的一个具体信息。 它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。 表现层（ Representation）：把资源具体呈现出来的形式，叫做它的表现层 （ Representation）。 比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。 状态转化（ State Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。 HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生 “状态转化 ”（ State Tran sfer）。而这种转化是建立在表现层之上的，所以就是 “表现层状态转化 ”。具体说，就是 HTTP 协议里面，四个表示操作方式的动词： GET、 POST、 PUT、DELETE。它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。 restful 的示例： /account/1 HTTP GET ： 得到 id = 1 的 account /account/1 HTTP DELETE： 删除 id = 1 的 account /account/1 HTTP PUT： 更新 id = 1 的 account /account HTTP POST： 新增 account 5.4 基于 HiddentHttpMethodFilter 的示例123456作用： 由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT与 DELETE 请求。使用方法： 第一步：在 web.xml 中配置该过滤器。 第二步：请求方式必须使用 post 请求。 第三步：按照要求提供_method 请求参数，该参数的取值就是我们需要的请求方式。 源码分析： jsp 中示例代码： 12345678910111213141516171819202122232425&lt;!-- 保存 --&gt;&lt;form action="springmvc/testRestPOST" method="post"&gt; 用户名称：&lt;input type="text" name="username"&gt;&lt;br/&gt; &lt;!-- &lt;input type="hidden" name="_method" value="POST"&gt; --&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt;&lt;hr/&gt;&lt;!-- 更新 --&gt;&lt;form action="springmvc/testRestPUT/1" method="post"&gt; 用户名称：&lt;input type="text" name="username"&gt;&lt;br/&gt; &lt;input type="hidden" name="_method" value="PUT"&gt; &lt;input type="submit" value=" 更新 "&gt;&lt;/form&gt;&lt;hr/&gt;&lt;!-- 删除 --&gt;&lt;form action="springmvc/testRestDELETE/1" method="post"&gt; &lt;input type="hidden" name="_method" value="DELETE"&gt; &lt;input type="submit" value=" 删除 "&gt;&lt;/form&gt;&lt;hr/&gt;&lt;!-- 查询一个 --&gt;&lt;form action="springmvc/testRestGET/1" method="post"&gt; &lt;input type="hidden" name="_method" value="GET"&gt; &lt;input type="submit" value=" 查询 "&gt;&lt;/form&gt; 控制器中示例代码： 12345678910/*** post 请求：保存* @param username* @return*/@RequestMapping(value="/testRestPOST",method=RequestMethod.POST)public String testRestfulURLPOST(User user)&#123; System.out.println("rest post"+user); return "success";&#125; 12345678910/*** put 请求：更新* @param username* @return*/@RequestMapping(value="/testRestPUT/&#123;id&#125;",method=RequestMethod.PUT)public String testRestfulURLPUT(@PathVariable("id")Integer id,User user)&#123; System.out.println("rest put "+id+","+user); return "success";&#125; 12345678910/*** post 请求：删除* @param username* @return*/@RequestMapping(value="/testRestDELETE/&#123;id&#125;",method=RequestMethod.DELETE)public String testRestfulURLDELETE(@PathVariable("id")Integer id)&#123; System.out.println("rest delete "+id); return "success";&#125; 12345678910/*** post 请求：查询* @param username* @return*/@RequestMapping(value="/testRestGET/&#123;id&#125;",method=RequestMethod.GET)public String testRestfulURLGET(@PathVariable("id")Integer id)&#123; System.out.println("rest get "+id); return "success";&#125; 运行结果： 6. RequestHeader6.1 使用说明1234567作用： 用于获取请求消息头。属性： value：提供消息头名称 required：是否必须有此消息头注： 在实际开发中一般不怎么用。 6.2 使用示例jsp 中代码： 12&lt;!-- RequestHeader 注解 --&gt;&lt;a href="springmvc/useRequestHeader"&gt;获取请求消息头&lt;/a&gt; 控制器中代码： 1234567891011/*** RequestHeader 注解* @param user* @return*/@RequestMapping("/useRequestHeader")public String useRequestHeader(@RequestHeader(value="Accept-Language", required=false)String requestHeader)&#123; System.out.println(requestHeader); return "success";&#125; 运行结果： 7. CookieValue7.1 使用说明12345作用： 用于把指定 cookie 名称的值传入控制器方法参数。属性： value：指定 cookie 的名称。 required：是否必须有此 cookie。 7.2 使用示例jsp 中的代码： 12&lt;!-- CookieValue 注解 --&gt;&lt;a href="springmvc/useCookieValue"&gt;绑定 cookie 的值&lt;/a&gt; 控制器中的代码： 1234567891011/*** Cookie 注解注解* @param user* @return*/@RequestMapping("/useCookieValue")public String useCookieValue(@CookieValue(value="JSESSIONID",required=false) String cookieValue)&#123; System.out.println(cookieValue); return "success";&#125; 运行结果： 8. ModelAttribute8.1 使用说明12345678910作用： 该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。属性： value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。应用场景： 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。 8.2 使用示例8.2.1 基于POJO属性的基本使用jsp代码： 12&lt;!-- ModelAttribute 注解的基本使用 --&gt;&lt;a href="springmvc/testModelAttribute?username=test"&gt;测试 modelattribute&lt;/a&gt; 控制器代码： 12345678/*** 被 ModelAttribute 修饰的方法* @param user*/@ModelAttributepublic void showModel(User user) &#123; System.out.println("执行了 showModel 方法"+user.getUsername());&#125; 12345678910/*** 接收请求的方法* @param user* @return*/@RequestMapping("/testModelAttribute")public String testModelAttribute(User user) &#123; System.out.println("执行了控制器的方法"+user.getUsername()); return "success";&#125; 运行结果： 8.2.2 基于 Map 的应用场景示例 1 ：ModelAttribute 修饰方法带返回值需求：修改用户信息，要求用户的密码不能修改 jsp的代码： 123456&lt;!-- 修改用户信息 --&gt;&lt;form action="springmvc/updateUser" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制的代码： 1234567891011/*** 查询数据库中用户信息* @param user*/@ModelAttributepublic User showModel(String username) &#123; //模拟去数据库查询 User abc = findUserByName(username); System.out.println("执行了 showModel 方法"+abc); return abc;&#125; 12345678910/*** 模拟修改用户方法* @param user* @return*/@RequestMapping("/updateUser")public String testModelAttribute(User user) &#123; System.out.println("控制器中处理请求的方法：修改用户："+user); return "success";&#125; 123456789101112/*** 模拟去数据库查询* @param username* @return*/private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword("123456"); return user;&#125; 运行结果： 8.2.3 基于 Map 的应用场景示例 1 ：ModelAttribute 修饰方法 不带返回值需求：修改用户信息，要求用户的密码不能修改 jsp中的代码： 123456&lt;!-- 修改用户信息 --&gt;&lt;form action="springmvc/updateUser" method="post"&gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &lt;input type="submit" value=" 保存 "&gt;&lt;/form&gt; 控制器中的代码： 1234567891011/*** 查询数据库中用户信息* @param user*/@ModelAttributepublic void showModel(String username,Map&lt;String,User&gt; map) &#123; //模拟去数据库查询 User user = findUserByName(username); System.out.println("执行了 showModel 方法"+user); map.put("abc",user);&#125; 12345678910/*** 模拟修改用户方法* @param user* @return*/@RequestMapping("/updateUser")public String testModelAttribute(@ModelAttribute("abc")User user) &#123; System.out.println("控制器中处理请求的方法：修改用户："+user); return "success";&#125; 123456789101112/*** 模拟去数据库查询* @param username* @return*/private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword("123456"); return user;&#125; 运行结果： 9. SessionAttribute9.1 使用说明12345作用： 用于多次执行控制器方法间的参数共享。属性： value：用于指定存入的属性名称 type：用于指定存入的数据类型。 9.2 使用示例jsp中的代码： 123456&lt;!-- SessionAttribute 注解的使用 --&gt;&lt;a href="springmvc/testPut"&gt;存入 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href="springmvc/testGet"&gt;取出 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href="springmvc/testClean"&gt;清除 SessionAttribute&lt;/a&gt; 控制器中的代码： 123456789101112131415161718192021222324252627282930313233343536373839/*** SessionAttribute 注解的使用* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("sessionAttributeController")@RequestMapping("/springmvc")@SessionAttributes(value =&#123;"username","password"&#125;,types=&#123;Integer.class&#125;)public class SessionAttributeController &#123; /** * 把数据存入 SessionAttribute * @param model * @return * Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap * 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类 */ @RequestMapping("/testPut") public String testPut(Model model)&#123; model.addAttribute("username", "泰斯特"); model.addAttribute("password","123456"); model.addAttribute("age", 31); //跳转之前将数据保存到 username、password 和 age 中，因为注解@SessionAttribute 中有 这几个参数 return "success"; &#125; @RequestMapping("/testGet") public String testGet(ModelMap model)&#123;System.out.println(model.get("username")+";"+model.get("password")+";"+model.get("age")); return "success"; &#125; @RequestMapping("/testClean") public String complete(SessionStatus sessionStatus)&#123; sessionStatus.setComplete(); return "success"; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的基本概念与入门]]></title>
    <url>%2F2019%2F06%2F08%2F2019-06-08-SpringMVC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 关于三层架构和MVC SpringMVC概念 SpringMVC的入门案例 入门案例的执行过程及原理分析 入门案例中涉及的组件 RequestMapping注解 1. 关于三层架构和MVC1.1 三层架构我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 构，也就是浏览器服务器。在 JavaEE 开发中，几乎全都是基于 B/S架构的开发。那么在 B/S架构中，系统标准的三层架构包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求web 层，web 需要接收 http 请求，完成 http 响应。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层： 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制） 持久层： 也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。 1.2 MVC模型MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职： Model （模型）： 通常指的就是我们的数据模型。作用一般情况下用于封装数据。 View （视图） ： 通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。 Controller （控制器） ： 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。它相对于前两个不是很好理解，这里举个例子：例如：我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充到模型之中。此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做的。当校验失败后，由控制器负责把错误页面展示给使用者。如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。 2. SpringMVC概念2.1 SpringMVC是什么SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。 2.2 SpringMVC在三层架构的位置 2.3 SpringMVC的优势12345678910111213141516171819201、清晰的角色划分： 前端控制器（DispatcherServlet） 请求到处理器映射（HandlerMapping） 处理器适配器（HandlerAdapter） 视图解析器（ViewResolver） 处理器或页面控制器（Controller） 验证器（ Validator） 命令对象（Command 请求参数绑定到的对象就叫命令对象） 表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。7、功能强大的数据验证、格式化、绑定机制。8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。10、强大的 JSP 标签库，使 JSP 编写更容易。………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。 2.4 SpringMVC和Struts2的优劣分析12345678910共同点： 它们都是表现层框架，都是基于 MVC 模型编写的。 它们的底层都离不开原始 ServletAPI。 它们处理请求的机制都是一个核心控制器。区别： Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。 Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便 (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。) Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。 3. SpringMVC的入门案例3.1 前期准备下载开发包： https://spring.io/projects其实 spring mvc 的 jar 包就在之前我们的 spring 框架开发包中。创建一个 javaweb 工程 创建一个 jsp 用于发送请求 jsp 中的内容： 123&lt;a href="$&#123;pageContext.request.contextPath&#125;/hello"&gt;SpringMVC 入门案例&lt;/a&gt;&lt;br/&gt;&lt;a href="hello"&gt;SpringMVC 入门案例&lt;/a&gt; 3.2 拷贝jar包 除了上面两个 jar 包之外，还需要拷贝 spring 的注解 ioc 所需 jar 包（包括一个 aop 的 jar 包）。 3.3 配置核心控制器——一个Servlet1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;!-- 配置 spring mvc 的核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVCDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取 SpringMVC 的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。 取值只能是非 0 正整数，表示启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVCDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.4 创建SpringMVC的配置文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置创建 spring 容器要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.5 编写控制器并使用注解配置123456789101112131415/*** spring mvc 的入门案例* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("helloController")public class HelloController &#123; @RequestMapping("/hello") public String sayHello() &#123; System.out.println("HelloController 的 sayHello 方法执行了。。。。"); return "success"; &#125;&#125; 3.6 测试 4. 入门案例的执行过程及原理分析4.1 案例的执行过程 1、服务器启动，应用被加载。读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象。 从入门案例中可以看到的是：HelloController 和 InternalResourceViewResolver，但是远不止这些。 2、浏览器发送请求，被 DispatherServlet 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发的路径是根据请求 URL，匹配@RequestMapping 中的内容。3、匹配到了后，执行对应方法。该方法有一个返回值。4、根据方法的返回值，借助 InternalResourceViewResolver 找到对应的结果视图。5、渲染结果视图，响应浏览器。 4.2 SpringMVC的请求响应流程 5. 入门案例中涉及的组件5.1 DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 5.2 HandlerMapping：处理器映射器HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 5.3 Handler：处理器它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 5.4 HandlerAdapter：处理器适配器通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 5.5 View Resolver：视图解析器View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 5.6 View：视图SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 5.7 &lt;mvc:annotation-driver&gt;说明在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。使 用 &lt;mvc:annotation-driven&gt; 自动加载 RequestMappingHandlerMapping （处理映射器） 和RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。它就相当于在 xml 中配置了： 123456789101112131415161718192021222324252627&lt;!-- 上面的标签相当于 如下配置--&gt;&lt;!-- Begin --&gt;&lt;!-- HandlerMapping --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;&lt;!-- HandlerAdapter --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- HadnlerExceptionResolvers --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver"&gt;&lt;/bean&gt;&lt;beanclass="org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver"&gt;&lt;/bean&gt;&lt;!-- End --&gt; 1234注意： 一般开发中，我们都需要写上此标签（虽然从入门案例中看，我们不写也行，随着课程的深入，该标签还有具体的使用场景）。明确： 我们只需要编写处理具体业务的控制器以及视图。 6. RequestMapping注解6.1 使用说明源码： 123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123;&#125; 作用：用于建立请求 URL 和处理请求方法之间的对应关系。 12345678910111213141516171819202122232425262728出现 位置： 类上： 请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的 URL 可以按照模块化管理: 例如： 账户模块： /account/add /account/update /account/delete ... 订单模块： /order/add /order/update /order/delete 把 RequsetMappding 写在类上，使我们的 URL 更加精细。 方法上： 请求 URL 的第二级访问目录。属性： value：用于指定请求的 URL。它和 path 属性的作用是一样的。 method：用于指定请求的方式。 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。 例如： params = &#123;&quot;accountName&quot;&#125;，表示请求参数必须有 accountName params = &#123;&quot;moeny!100&quot;&#125;，表示请求参数中 money 不能是 100。 headers：用于指定限制请求消息头的条件。 注意： 以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。 6.2 使用示例6.2.1 出现位置的示例控制器代码: 12345678910111213141516/*** RequestMapping 注解出现的位置* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Controller("accountController")@RequestMapping("/account")public class AccountController &#123; @RequestMapping("/findAccount") public String findAccount() &#123; System.out.println("查询了账户。。。。"); return "success"; &#125;&#125; jsp 中的代码： 12345678910111213141516171819&lt;%@ page language="java" contentType="text/html; charset=UTF-8"pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;requestmapping 的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 第一种访问方式 --&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/account/findAccount"&gt; 查询账户 &lt;/a&gt; &lt;br/&gt; &lt;!-- 第二种访问方式 --&gt; &lt;a href="account/findAccount"&gt;查询账户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 注意：当我们使用此种方式配置时，在 jsp 中第二种写法时，不要在访问 URL 前面加/ 6.2.2 method属性的示例：控制器代码： 123456789/*** 保存账户* @return*/@RequestMapping(value="/saveAccount",method=RequestMethod.POST)public String saveAccount() &#123; System.out.println("保存了账户"); return "success";&#125; jsp代码： 123456&lt;!-- 请求方式的示例 --&gt;&lt;a href="account/saveAccount"&gt;保存账户，get 请求&lt;/a&gt;&lt;br/&gt;&lt;form action="account/saveAccount" method="post"&gt; &lt;input type="submit" value=" 保存账户， post 请求 "&gt;&lt;/form&gt; 注意：当使用 get 请求时，提示错误信息是 405，信息是方法不支持 get 方式请求 6.2.3 params属性的示例：控制器的代码： 123456789/*** 删除账户* @return*/@RequestMapping(value="/removeAccount",params= &#123;"accountName","money&gt;100"&#125;)public String removeAccount() &#123; System.out.println("删除了账户"); return "success";&#125; jsp中的代码： 1234&lt;!-- 请求参数的示例 --&gt;&lt;a href="account/removeAccount?accountName=aaa&amp;money&gt;100"&gt;删除账户，金额 100&lt;/a&gt;&lt;br/&gt;&lt;a href="account/removeAccount?accountName=aaa&amp;money&gt;150"&gt;删除账户，金额 150&lt;/a&gt; 注意：当我们点击第一个超链接时,可以访问成功。当我们点击第二个超链接时，无法访问。如下图：]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的事务控制与新特性]]></title>
    <url>%2F2019%2F06%2F06%2F2019-06-06-Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[目录 Spring事务控制中我们要明确的 Spring事务控制中的API介绍 基于XML的声明式事务控制 基于注解的配置方式 与JDK相关的升级 核心容器的更新 JetBrains Kotlin语言支持 响应式编程风格 Junit5的支持 依赖类库的更新 1. Spring事务控制中我们要明确的123第一：JavaEE 体系进行分层开发，事务处理位于业务层，Spring 提供了分层设计 业务层的事务处理解决方案。第二：spring 框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在spring-tx-5.0.2.RELEASE.jar 中。第三：spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现。 2. Spring事务控制中的API介绍2.1 PlatformTransactionManager此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法，如下图： 我们在开发中都是使用它的实现类 真正管理事务的对象 12org.springframework.jdbc.datasource.DataSourceTransactionManager 用 使用 Spring JDBC 或 或 iBatis 进行持久化数据时使用org.springframework.orm.hibernate5.HibernateTransactionManager 使用 Hibernate 2.2 TransactionDefinition它是事务的定义信息对象，里面有如下方法： 2.2.1 事务的隔离级别 2.2.2 事务的传播行为1234567REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起NEVER:以非事务方式运行，如果当前存在事务，抛出异常NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。 2.2.3 超时时间默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 2.2.4 是否是只读事务建议查询时设置为只读。 2.3 TransactionStatus此接口提供的是事务具体的运行状态，方法介绍如下图： 3. 基于XML的声明式事务控制3.1 环境搭建3.1.1 第一步：拷贝必要的jar包到工程的lib目录 3.1.2 第二步：创建Spring的配置文件并导入约束此处需要导入 aop 和 tx 两个名称空间 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 3.1.3 第三步：准备数据库表和实体类创建数据库： 12create database spring_day04;use spring_day04; 创建表： 12345create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 1234567891011121314151617181920212223242526272829303132/*** 账户的实体*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", name=" + name + ", money=" + money + "]"; &#125;&#125; 3.1.4 第四步：编写业务层接口和实现类123456789101112131415161718/*** 账户的业务层接口*/public interface IAccountService &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id);//查 /** * 转账 * @param sourceName 转出账户名称 * @param targeName 转入账户名称 * @param money 转账金额 */ void transfer(String sourceName,String targeName,Float money);//增删改&#125; 12345678910111213141516171819202122232425262728/*** 账户的业务层实现类*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); int i=1/0; accountDao.updateAccount(target); &#125;&#125; 3.1.5 第五步：编写Dao接口和实现类123456789101112131415161718192021/*** 账户的 持久层 接口*/public interface IAccountDao &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 1234567891011121314151617181920212223242526272829/*** 账户的持久层实现类* 此版本 dao，只需要给它的父类注入一个数据源*/public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = getJdbcTemplate().query("select * from account where id = ? ",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = getJdbcTemplate().query("select * from account where name = ? ",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException("结果集不唯一，不是只有一个账户对象"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; getJdbcTemplate().update("update account set money = ? where id = ?",account.getMoney(),account.getId()); &#125;&#125; 1234567891011121314/*** 账户的封装类 RowMapper */public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt("id")); account.setName(rs.getString("name")); account.setMoney(rs.getFloat("money")); return account; &#125;&#125; 3.1.6 第六步：在配置文件中配置业务层和持久层对1234567891011121314151617&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;!-- 注入 dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day04"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.2 配置步骤3.2.1 第一步：配置事务管理器123456&lt;!-- 配置一个事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;!-- 注入 DataSource --&gt;&lt; property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 3.2.2 第二步：配置事务的通知引用事务管理器123&lt;!-- 事务的配置 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;&lt;/tx:advice&gt; 3.2.3 第三步：配置事务的属性12345678910111213&lt;!--在 在 tx:advice 标签内部 配置事务的属性 --&gt;&lt;tx:attributes&gt;&lt;!-- 指定方法名称：是业务核心方法 read-only：是否是只读事务。默认 false，不只读。 isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。 propagation：指定事务的传播行为。 timeout：指定超时时间。默认值为：-1。永不超时。 rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。 no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。--&gt; &lt;tx:method name="*" read-only="false" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" read-only="true" propagation="SUPPORTS"/&gt;&lt;/tx:attributes&gt; 3.2.4 第四步：配置AOP切入点表达式12345&lt;!-- 配置 aop --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))" id="pt1"/&gt;&lt;/aop:config&gt; 3.2.5 第五步：配置切入点表达式和事务通知的对应关系12&lt;!-- 在 在 aop:config 标签内部：建立事务的通知和切入点表达式的关系 --&gt;&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt; 4. 基于注解的配置方式4.1 搭建环境4.1.1 第一步：拷贝必备的jar包到工程的lib目录 4.1.2 第二步：创建Spring的配置文件导入约束并配置扫描的包1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置 JdbcTemplate--&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 spring 提供的内置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.1.3 第三步：创建数据库表和实体类和基于 xml 的配置相同。略 4.1.4 第四步：创建业务层接口和实现类并使用注解让Spring管理123456789/*** 账户的业务层实现类*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; //其余代码和基于 XML 的配置相同&#125; 4.1.5 第五步：创建Dao接口和实现类并使用注解让Spring管理12345678910/*** 账户的持久层实现类*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; //其余代码和基于 XML 的配置相同&#125; 4.2 配置步骤4.2.1 第一步：配置事务管理器并注入数据源12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 4.2.2 第二步：在业务层使用@Transactional注解123456789101112131415161718192021222324252627@Service("accountService")@Transactional(readOnly=true,propagation=Propagation.SUPPORTS)public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public Account findAccountById(Integer id) &#123; return accountDao.findAccountById(id); &#125; @Override @Transactional(readOnly=false,propagation=Propagation.REQUIRED) public void transfer(String sourceName, String targeName, Float money) &#123; //1.根据名称查询两个账户 Account source = accountDao.findAccountByName(sourceName); Account target = accountDao.findAccountByName(targeName); //2.修改两个账户的金额 source.setMoney(source.getMoney()-money);//转出账户减钱 target.setMoney(target.getMoney()+money);//转入账户加钱 //3.更新两个账户 accountDao.updateAccount(source); //int i=1/0; accountDao.updateAccount(target); &#125;&#125; 12345该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。出现接口上，表示该接口的所有实现类都有事务支持。出现在类上，表示类中所有方法有事务支持出现在方法上，表示方法有事务支持。以上三个位置的优先级：方法&gt;类&gt;接口 4.2.3 第三步：在配置文件中开启Spring对注解事务的支持12&lt;!-- 开启 spring 对注解事务的支持 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 4.3 不使用xml的配置方式12345Configuration@EnableTransactionManagementpublic class SpringTxConfiguration &#123; //里面配置数据源，配置 JdbcTemplate,配置事务管理器。在之前的步骤已经写过了。&#125; 5. 与JDK相关的升级5.1 JDK版本要求：123456spring5.0 在 2017 年 9 月发布了它的 GA（通用）版本。该版本是基于 jdk8 编写的，所以 jdk8 以下版本将无法使用。同时，可以兼容 jdk9 版本。tomcat 版本要求 8.5 及以上。注： 我们使用 jdk8 构建工程，可以降版编译。但是不能使用 jdk8 以下版本构建工程。 由于 jdk 和 tomcat 版本的更新，我们的 IDE 也需要同时更新。(目前使用的 eclipse 4.7.2) 5.2 利用JDK8版本更新的内容第一：基于 JDK8 的反射增强 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566请看下面的代码：/**** @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Test &#123; //循环次数定义：10 亿次 private static final int loopCnt = 1000 * 1000 * 1000; public static void main(String[] args) throws Exception &#123; //输出 jdk 的版本 System.out.println("java.version=" + System.getProperty("java.version")); t1(); t2(); t3(); &#125; // 每次重新生成对象 public static void t1() &#123; long s = System.currentTimeMillis(); for (int i = 0; i &lt; loopCnt; i++) &#123; Person p = new Person(); p.setAge(31); &#125; long e = System.currentTimeMillis(); System.out.println("循环 10 亿次创建对象的时间：" + (e - s)); &#125; // 同一个对象 public static void t2() &#123; long s = System.currentTimeMillis(); Person p = new Person(); for (int i = 0; i &lt; loopCnt; i++) &#123; p.setAge(32); &#125; long e = System.currentTimeMillis(); System.out.println("循环 10 亿次给同一对象赋值的时间： " + (e - s)); &#125; //使用反射创建对象 public static void t3() throws Exception &#123; long s = System.currentTimeMillis(); Class&lt;Person&gt; c = Person.class; Person p = c.newInstance(); Method m = c.getMethod("setAge", Integer.class); for (int i = 0; i &lt; loopCnt; i++) &#123; m.invoke(p, 33); &#125; long e = System.currentTimeMillis(); System.out.println("循环 10 亿次反射创建对象的时间：" + (e - s)); &#125; static class Person &#123; private int age = 20; public int getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; &#125;&#125; jdk1.8 版本（就是 JDK8）运行时间如下： 当切换到 jdk1.7 版本之后，运行时间如下： 有此我们可以看出，在反射创建对象上，jdk8 确实做了加强。 第二：@NonNull 注解和@Nullable 注解的使用 1用 @Nullable 和 @NotNull 注解来显示表明可为空的参数和以及返回值。这样就够在编译的时候处理空值而不是在运行时抛出 NullPointerExceptions。 第三：日志记录方面 1Spring Framework 5.0 带来了 Commons Logging 桥接模块的封装, 它被叫做 spring-jcl 而不是标准的 Commons Logging。当然，无需任何额外的桥接，新版本也会对 Log4j 2.x, SLF4J, JUL( java.util.logging) 进行自动检测。 6. 核心容器的更新123456Spring Framework 5.0 现在支持候选组件索引作为类路径扫描的替代方案。该功能已经在类路径扫描器中添加，以简化添加候选组件标识的步骤。应用程序构建任务可以定义当前项目自己的 META-INF/spring.components 文件。在编译时，源模型是自包含的，JPA 实体和 Spring 组件是已被标记的。从索引读取实体而不是扫描类路径对于小于 200 个类的小型项目是没有明显差异。但对大型项目影响较大。加载组件索引开销更低。因此，随着类数的增加，索引读取的启动时间将保持不变。加载组件索引的耗费是廉价的。因此当类的数量不断增长，加上构建索引的启动时间仍然可以维持一个常数,不过对于组件扫描而言，启动时间则会有明显的增长。这个对于我们处于大型 Spring 项目的开发者所意味着的，是应用程序的启动时间将被大大缩减。虽然 20或者 30 秒钟看似没什么，但如果每天要这样登上好几百次，加起来就够你受的了。使用了组件索引的话，就能帮助你每天过的更加高效。你可以在 Spring 的 Jira 上了解更多关于组件索引的相关信息。 7. JetBrains Kotlin语言支持Kolin概述：是一种支持函数式编程编程风格的面向对象语言。Kotlin 运行在 JVM 之上，但运行环境并不限于 JVM。 Kolin 的示例代码： 12345678910&#123; ("/movie" and accept(TEXT_HTML)).nest &#123; GET("/", movieHandler::findAllView) GET("/&#123;card&#125;", movieHandler::findOneView) &#125; ("/api/movie" and accept(APPLICATION_JSON)).nest &#123; GET("/", movieApiHandler::findAll) GET("/&#123;id&#125;", movieApiHandler::findOne) &#125;&#125; Kolin 注册 bean 对象到 spring 容器： 1234val context = GenericApplicationContext &#123; registerBean() registerBean &#123; Cinema(it.getBean()) &#125;&#125; 8. 响应式编程风格123456789此次 Spring 发行版本的一个激动人心的特性就是新的响应式堆栈 WEB 框架。这个堆栈完全的响应式且非阻塞，适合于事件循环风格的处理，可以进行少量线程的扩展。Reactive Streams 是来自于 Netflix, Pivotal, Typesafe, Red Hat, Oracle, Twitter 以及Spray.io 的工程师特地开发的一个 API。它为响应式编程实现的实现提供一个公共的 API，好实现Hibernate 的 JPA。这里 JPA 就是这个 API, 而 Hibernate 就是实现。Reactive Streams API 是 Java 9 的官方版本的一部分。在 Java 8 中, 你会需要专门引入依赖来使用 Reactive Streams API。Spring Framework 5.0 对于流式处理的支持依赖于 Project Reactor 来构建, 其专门实现了Reactive Streams API。Spring Framework 5.0 拥有一个新的 spring-webflux 模块，支持响应式 HTTP 和 WebSocket 客户端。Spring Framework 5.0 还提供了对于运行于服务器之上，包含了 REST, HTML, 以及 WebSocket 风格交互的响应式网页应用程序的支持。在 spring-webflux 中包含了两种独立的服务端编程模型： 基于注解：使用到了@Controller 以及 Spring MVC 的其它一些注解； 使用 Java 8 lambda 表达式的函数式风格的路由和处理。有 了 Spring Webflux, 你 现 在 可 以创建出 WebClient, 它是响应式且非阻塞的，可以 作为RestTemplate 的一个替代方案。 这里有一个使用 Spring 5.0 的 REST 端点的 WebClient 实现： 123456WebClient webClient = WebClient.create();Mono person = webClient.get() .uri(&quot;http://localhost:8080/movie/42&quot;) .accept(MediaType.APPLICATION_JSON) .exchange() .then(response -&gt; response.bodyToMono(Movie.class)); 9. Junit5的支持12345完全支持 JUnit 5 Jupiter，所以可以使用 JUnit 5 来编写测试以及扩展。此外还提供了一个编程以及扩展模型，Jupiter 子项目提供了一个测试引擎来在 Spring 上运行基于 Jupiter 的测试。另外，Spring Framework 5 还提供了在 Spring TestContext Framework 中进行并行测试的扩展。针对响应式编程模型， spring-test 现在还引入了支持 Spring WebFlux 的 WebTestClient 集成测试的支持，类似于 MockMvc，并不需要一个运行着的服务端。使用一个模拟的请求或者响应， WebTestClient就可以直接绑定到 WebFlux 服务端设施。你可以在这里找到这个激动人心的 TestContext 框架所带来的增强功能的完整列表。当然， Spring Framework 5.0 仍然支持我们的老朋友 JUnit! 在我写这篇文章的时候， JUnit 5 还只是发展到了 GA 版本。对于 JUnit4， Spring Framework 在未来还是要支持一段时间的。 10. 依赖类库的更新123456789101112131415终止支持的类库 Portlet. Velocity. JasperReports. XMLBeans. JDO. Guava.支持的类库 Jackson 2.6+ EhCache 2.10+ / 3.0 GA Hibernate 5.0+ JDBC 4.0+ XmlUnit 2.x+ OkHttp 3.x+ Netty 4.1+]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的JdbcTemplate]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04-Spring%E4%B8%AD%E7%9A%84JdbcTemplate%2F</url>
    <content type="text"><![CDATA[目录 JdbcTemplate概述 JdbcTemplate对象的创建 Spring中配置数据源 JdbcTemplate的增删改查操作 在dao中使用JdbcTemplate 1. JdbcTemplate概述它是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。spring 框架为我们提供了很多的操作模板类。 1234567操作关系型数据的： JdbcTemplate HibernateTemplate操作 nosql 数据库的： RedisTemplate操作消息队列的： JmsTemplate 我们今天的主角在 spring-jdbc-5.0.2.RELEASE.jar 中，我们在导包的时候，除了要导入这个 jar 包外，还需要导入一个 spring-tx-5.0.2.RELEASE.jar（它是和事务相关的）。 2. JdbcTemplate对象的创建我们可以参考它的源码，来一探究竟： 12345678910111213public JdbcTemplate() &#123;&#125;public JdbcTemplate(DataSource dataSource) &#123; setDataSource(dataSource); afterPropertiesSet();&#125;public JdbcTemplate(DataSource dataSource, boolean lazyInit) &#123; setDataSource(dataSource); setLazyInit(lazyInit); afterPropertiesSet();&#125; 除了默认构造函数之外，都需要提供一个数据源。既然有set方法，依据我们之前学过的依赖注入，我们可以在配置文件中配置这些对象。 3. Spring中配置数据源3.1 环境搭建 3.2 编写Spring的配置文件1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;/beans&gt; 3.3 配置数据源我们之前已经接触过了两个数据源，C3P0 和 DBCP。要想使用这两数据源都需要导入对应的 jar 包。 3.3.1 配置C3P0数据源导入到工程的 lib 目录。在 spring 的配置文件中配置： 123456&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.3.2 配置DBCP数据源导入到工程的 lib 目录。在 spring 的配置文件中配置： 1234567&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:// /spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.3.3 配置Spring内置数据源spring 框 架 也 提 供 了 一 个 内 置 数 据 源 ， 我 们 也 可 以 使 用 spring 的 内 置 数 据 源 ， 它 就 在spring-jdbc-5.0.2.REEASE.jar 包中： 1234567&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 3.4 将数据库连接的信息配置到属性文件中：【定义属性文件】 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///spring_day02jdbc.username=rootjdbc.password=123 【引入外部的属性文件】 一种方式: 12345&lt;!-- 引入外部属性文件： --&gt;&lt;beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"/&gt;&lt;/bean&gt; 另一种方式: 1&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; 4. JdbcTemplate的增删改查操作4.1 前期准备123456789创建数据库：create database spring_day02;use spring_day02;创建表：create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci; 4.2 在Spring配置文件中配置JdbcTemplate1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.3 最基本使用12345678910public class JdbcTemplateDemo2 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 jt.execute("insert into account(name,money)values('eee',500)"); &#125;&#125; 4.4 保存操作1234567891011public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //保存 jt.update("insert into account(name,money)values(?,?)","fff",5000); &#125;&#125; 4.5 更新操作1234567891011public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //修改 jt.update("update account set money = money-? where id = ?",300,6); &#125;&#125; 4.6 删除操作1234567891011public class JdbcTemplateDemo3 &#123;public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //删除 jt.update("delete from account where id = ?",6); &#125;&#125; 4.7 查询所有操作123456789101112131415161718192021222324252627public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询所有 List&lt;Account&gt; accounts = jt.query("select * from account where money &gt; ? ", new AccountRowMapper(), 500); for(Account o : accounts)&#123; System.out.println(o); &#125; &#125;&#125;public class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt("id")); account.setName(rs.getString("name")); account.setMoney(rs.getFloat("money")); return account; &#125;&#125; 4.8 查询一个操作使用 RowMapper 12345678910111213public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询一个 List&lt;Account&gt; as = jt.query("select * from account where id = ? ", new AccountRowMapper(), 55); System.out.println(as.isEmpty()?"没有结果":as.get(0)); &#125;&#125; 使用 ResultSetExtractor 的方式: 12345678910111213public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询一个 Account account = jt.query("select * from account where id = ?", new AccountResultSetExtractor(),3); System.out.println(account); &#125;&#125; 4.9 查询返回一行一列操作12345678910111213public class JdbcTemplateDemo3 &#123; public static void main(String[] args) &#123; //1.获取 Spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 id 获取 bean 对象 JdbcTemplate jt = (JdbcTemplate) ac.getBean("jdbcTemplate"); //3.执行操作 //查询返回一行一列：使用聚合函数，在不使用 group by 字句时，都是返回一行一列。最长用的就是分页中获取总记录条数 Integer total = jt.queryForObject("select count(*) from account where money &gt; ? ",Integer.class,500); System.out.println(total); &#125;&#125; 5. 在dao中使用JdbcTemplate5.1 准备实体类1234567891011121314151617181920212223242526272829303132/*** 账户的实体*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", name=" + name + ", money=" + money + "]"; &#125;&#125; 5.2 第一种方式：在dao中定义JdbcTemplate123456789101112131415161718192021222324/*** 账户的接口*/public interface IAccountDao &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 123456789101112131415161718192021222324252627282930313233343536/*** 账户的持久层实现类* 此版本的 dao ，需要给 dao 注入 JdbcTemplate*/public class AccountDaoImpl implements IAccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public Account findAccountById(Integer id) &#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account where id = ? ",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; List&lt;Account&gt; list = jdbcTemplate.query("select * from account where name = ? ",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException("结果集不唯一，不是只有一个账户对象"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; jdbcTemplate.update("update account set money = ? where id = ? ",account.getMoney(),account.getId()); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置一个 dao --&gt; &lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;!-- 注入 jdbcTemplate --&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个数据库的操作模板：JdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day04"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 思考：此种方式有什么问题吗?答案：有个小问题。就是我们的 dao 有很多时，每个 dao 都有一些重复性的代码。下面就是重复代码： 1234private JdbcTemplate jdbcTemplate;public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate;&#125; 能不能把它抽取出来呢？请看下一小节。 5.3 第二种方式：让dao继承JdbcDaoSupportJdbcDaoSupport 是spring 框架为我们提供的一个类，该类中定义了一个 JdbcTemplate 对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源：具体源码如下： 12345678910111213141516171819202122232425public abstract class JdbcDaoSupport extends DaoSupport &#123; //定义对象 private JdbcTemplate jdbcTemplate; //set 方法注入数据源，判断是否注入了，注入了就创建 JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; //如果提供了数据源就创建 JdbcTemplate this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; //使用数据源创建 JdcbTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; //当然，我们也可以通过注入 JdbcTemplate 对象 public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; initTemplateConfig(); &#125; //使用 getJdbcTmeplate 方法获取操作模板对象 public final JdbcTemplate getJdbcTemplate() &#123; return this.jdbcTemplate; &#125;&#125; 123456789101112131415161718192021/*** 账户的接口*/public interface IAccountDao &#123; /** * 根据 id 查询账户信息 * @param id * @return */ Account findAccountById(Integer id); /** * 根据名称查询账户信息 * @return */ Account findAccountByName(String name); /** * 更新账户信息 * @param account */ void updateAccount(Account account);&#125; 12345678910111213141516171819202122232425262728293031323334/*** 账户的持久层实现类* 此版本 dao，只需要给它的父类注入一个数据源*/public class AccountDaoImpl2 extends JdbcDaoSupport implements IAccountDao &#123; @Override public Account findAccountById(Integer id) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query("select * from account whereid = ? ",new AccountRowMapper(),id); return list.isEmpty()?null:list.get(0); &#125; @Override public Account findAccountByName(String name) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 List&lt;Account&gt; list = getJdbcTemplate().query("select * from account wherename = ? ",new AccountRowMapper(),name); if(list.isEmpty())&#123; return null; &#125; if(list.size()&gt;1)&#123; throw new RuntimeException("结果集不唯一，不是只有一个账户对象"); &#125; return list.get(0); &#125; @Override public void updateAccount(Account account) &#123; //getJdbcTemplate()方法是从父类上继承下来的。 getJdbcTemplate().update("update account set money = ? where id = ?",account.getMoney(),account.getId()); &#125;&#125; 配置文件： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 dao2 --&gt; &lt;bean id="accountDao2" class="com.itheima.dao.impl.AccountDaoImpl2"&gt; &lt;!-- 注入 dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///spring_day04"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 12345思考： 两版 Dao 有什么区别呢？答案： 在 第一种在 Dao 类中定义 JdbcTemplate 的方式，适用于所有配置方式（xml 和注解都可以）。 让 第二种让 Dao 继承 JdbcDaoSupport 的方式，只能用于基于 XML 的方式，注解用不了。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis快速入门]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-Redis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 Redis介绍 Redis安装配置 Redis五种数据类型 Keys命令 Redis客户端 Redis的事务 Redis的持久化方案 Redis的主从复制 Redis的集群 1. Redis介绍1.1 问题的引入 ​ 1.2 NoSQL数据库概述为了解决高并发、高可扩展、高可用、大数据存储问题而产生的数据库解决方案，就是NoSql数据库。 NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。 它不遵循SQL标准、不支持ACID、远超SQL的性能。 1.3 NoSQL用在哪些地方 1.4 Nosql数据库分类1.4.1 缓存数据库 1.4.2 文档数据库 1.4.3 列式数据库 1.4.4 图关系数据库 1.5 数据库排名 1.6 什么是Redis1.6.1 Redis介绍Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 12345字符串类型散列类型列表类型集合类型有序集合类型。 1.6.2 Redis应用场景 2. Redis安装配置2.1 Redis下载官网地址：http://redis.io/ 下载地址：http://download.redis.io/releases/redis-3.0.0.tar.gz 在Linux中使用wget下载到linux或者下载到window在上传到linux 1wget http://download.redis.io/releases/redis-3.0.0.tar.gz 2.2 Redis安装Redis是C语言开发，建议在linux上运行，我们使用Centos6.5作为安装环境。 第一步：在VMware中安装CentOS 第二步：在Linux下安装gcc环境 12# yum install gcc-c++可以通过rpm -qa | grep gcc 来查询是否已经安装了gcc 第三步：将下载的Redis源码包上传到Linux服务器中【如果是linux直接下载的，就省略这个步骤】 第四步：解压缩Redis源码包 1# tar -zxf redis-3.0.0.tar.gz 【直接解压到当前文件夹】 第五步：编译redis源码 12# cd redis-3.0.0# make 第六步：安装redis 1# make install PREFIX=/usr/local/redis 2.3 Redis启动2.3.1 前端启动启动方式： 直接运行bin/redis-server将以前端模式启动。【bin目录是在/usr/local/redis/bin】 1# ./redis-server 启动缺点： ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法 启动图例： 前端启动的关闭： 1ctrl+c 2.3.2 后端启动第一步：将redis源码包中的redis.conf配置文件复制到/usr/local/redis/bin/下 12# cd /root/redis-3.0.0# cp redis.conf /usr/local/redis/bin/ 第二步：修改redis.conf，将daemonize由no改为yes 1# vi redis.conf 第三步：执行命令 1# ./redis-server redis.conf 后端启动的关闭方式 非正常关闭（不推荐使用）： 1# kill 5528 正常关闭： 1# ./redis-cli shutdown 3. Redis五种数据类型Mysql中声明字段有哪些：int,varchar,char,datetime….. Redis中存储数据是通过key-value存储的，对于value的类型有以下几种： 12345String字符串Hash类型ListSetSortedSet（zset） PS：在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的。 3.1 String类型3.1.1 命令1. 赋值语法：SET key value 12127.0.0.1:6379&gt; set test 123OK 2. 取值语法：GET key 12127.0.0.1:6379&gt; get test&quot;123“ 3. 设置/获取多个键值语法： MSET key value [key value …] MGET key [key …] 1234567127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; mget k1 k31) &quot;v1&quot;2) &quot;v3&quot; 4. 取值并赋值语法：GETSET key value 1234127.0.0.1:6379&gt; getset s2 222&quot;111&quot;127.0.0.1:6379&gt; get s2&quot;222&quot; 5. 删除语法：DEL key 12127.0.0.1:6379&gt; del test(integer) 1 6. 数值增减递增数字 当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 Auto_increment 语法：INCR key 123456127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; incr num(integer) 3 增加指定的整数 语法：INCRBY key increment 123456127.0.0.1:6379&gt; incrby num 2(integer) 5127.0.0.1:6379&gt; incrby num 2(integer) 7127.0.0.1:6379&gt; incrby num 2(integer) 9 递减数值 语法：DECR key 1234127.0.0.1:6379&gt; decr num(integer) 9127.0.0.1:6379&gt; decr num(integer) 8 减少指定的整数 语法：DECRBY key decrement 12345678127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5127.0.0.1:6379&gt; decrby num 3(integer) 2127.0.0.1:6379&gt; decrby num 3(integer) -1 7. 其他命令（自学）向尾部追加值 APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 语法：APPEND key value 123456127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; append str &quot; world!&quot;(integer) 12127.0.0.1:6379&gt; get str &quot;hello world!&quot; 获取字符串长度 STRLEN命令返回键值的长度，如果键不存在则返回0。 语法：STRLEN key 123456127.0.0.1:6379&gt; strlen str (integer) 0127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; strlen str (integer) 5 3.1.2 应用自增主键商品编号、订单号采用string的递增数字特性生成。 定义商品编号key：items:id 1234192.168.101.3:7003&gt; INCR items:id(integer) 2192.168.101.3:7003&gt; INCR items:id(integer) 3 3.2 Hash类型3.2.1 使用String的问题假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 保存、更新： 1User对象 --&gt; json(string) --&gt; redis 如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。 1User “&#123;“username”:”gyf”,”age”:”80”&#125;” 3.2.2 Redis hash介绍hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下： 3.2.3 命令1. 赋值HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。 一次只能设置一个字段值 语法：HSET key field value 12127.0.0.1:6379&gt; hset user username zhangsan (integer) 1 一次可以设置多个字段值 语法：HMSET key field value [field value ...] 12127.0.0.1:6379&gt; hmset user age 20 username lisi OK 当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作 语法：HSETNX key field value 12127.0.0.1:6379&gt; hsetnx user age 30 如果user中没有age字段则设置age值为30，否则不做任何操作(integer) 0 2. 取值一次只能获取一个字段值 语法：HGET key field 12127.0.0.1:6379&gt; hget user username&quot;zhangsan“ 一次可以获取多个字段值 语法：HMGET key field [field ...] 123127.0.0.1:6379&gt; hmget user age username1) &quot;20&quot;2) &quot;lisi&quot; 获取所有字段值 语法：HGETALL key 12345127.0.0.1:6379&gt; hgetall user1) &quot;age&quot;2) &quot;20&quot;3) &quot;username&quot;4) &quot;lisi&quot; 3. 删除字段可以删除一个或多个字段，返回值是被删除的字段个数 语法：HDEL key field [field...] 123456127.0.0.1:6379&gt; hdel user age(integer) 1127.0.0.1:6379&gt; hdel user age name(integer) 0127.0.0.1:6379&gt; hdel user age username(integer) 1 4. 增加数字语法：HINCRBY key field increment 1234127.0.0.1:6379&gt; hincrby user age 2 将用户的年龄加2(integer) 22127.0.0.1:6379&gt; hget user age 获取用户的年龄&quot;22“ 5. 其他命令（自学）判断字段是否存在 语法：HEXISTS key field 1234127.0.0.1:6379&gt; hexists user age 查看user中是否有age字段(integer) 1127.0.0.1:6379&gt; hexists user name 查看user中是否有name字段(integer) 0 只获取字段名或字段值 语法： HKEYS key HVALS key 12345678127.0.0.1:6379&gt; hmset user age 20 name lisi OK127.0.0.1:6379&gt; hkeys user1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; hvals user1) &quot;20&quot;2) &quot;lisi&quot; 获取字段数量 语法：HLEN key 12127.0.0.1:6379&gt; hlen user(integer) 2 3.2.4 应用存储商品信息商品字段 1【商品id、商品名称、商品描述、商品库存、商品好评】 定义商品信息的key 1商品1001的信息在 Redis中的key为：[items:1001] 存储商品信息 12192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9OK 获取商品信息 123456789192.168.101.3:7003&gt; HGET items:1001 id&quot;3&quot;192.168.101.3:7003&gt; HGETALL items:10011) &quot;id&quot;2) &quot;3&quot;3) &quot;name&quot;4) &quot;apple&quot;5) &quot;price&quot;6) &quot;999.9&quot; 3.3 List类型3.3.1 ArrayList与LinkedList的区别ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。 LinkedList使用双向链表方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快。然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。 3.3.2 Redis list介绍列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。 列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。通过索引下标的操作中间的节点性能会较差。 3.3.3 命令1.向列表两端添加元素向列表左边增加元素 语法：LPUSH key value [value ...] 12127.0.0.1:6379&gt; lpush list:1 1 2 3(integer) 3 向列表右边增加元素 语法：RPUSH key value [value ...] 12127.0.0.1:6379&gt; rpush list:1 4 5 6(integer) 3 2. 查看列表LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 语法：LRANGE key start stop 1234127.0.0.1:6379&gt; lrange list:1 0 21) &quot;2&quot;2) &quot;1&quot;3) &quot;4&quot; 3. 从列表两端弹出元素LPOP命令从列表左边弹出一个元素，会分两步完成： 第一步是将列表左边的元素从列表中移除 第二步是返回被移除的元素值。 语法： LPOP key RPOP key 1234127.0.0.1:6379&gt; lpop list:1&quot;3“127.0.0.1:6379&gt; rpop list:1&quot;6“ 4. 获取列表中元素的个数语法：LLEN key 12127.0.0.1:6379&gt; llen list:1(integer) 2 5. 其它命令(自学)删除列表中指定的值 LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 123当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 语法：LREM key count value 获得/设置指定索引的元素值 语法：LINDEX key index 12127.0.0.1:6379&gt; lindex l:list 2&quot;1&quot; 设置指定索引的元素值 语法：LSET key index value 1234567127.0.0.1:6379&gt; lset l:list 2 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;2&quot;4) &quot;2&quot; 只保留列表指定片段 指定范围和LRANGE一致 语法：LTRIM key start stop 1234567891011127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;4) &quot;2&quot;127.0.0.1:6379&gt; ltrim l:list 0 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot; 向列表中插入元素 该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 语法：LINSERT key BEFORE|AFTER pivot value 1234567891011127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot; 将元素从一个列表转移到另一个列表中 语法：RPOPLPUSH source destination 12345678127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot; 3.3.4 应用商品评论列表1234思路：在Redis中创建商品评论列表用户发布商品评论，将评论信息转成json存储到list中。用户在页面查询评论列表，从redis中取出json数据展示到页面。 定义商品评论列表key： 商品编号为1001的商品评论key【items: comment:1001】 1192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289&#125;&apos; 3.4 Set类型3.4.1 Redis set介绍集合中的数据是不重复且没有顺序。 集合类型和列表类型的对比： 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 Redis还提供了多个集合之间的交集、并集、差集的运算。 3.4.2 命令1. 增加/删除元素语法：SADD key member [member ...] 1234127.0.0.1:6379&gt; sadd set a b c(integer) 3127.0.0.1:6379&gt; sadd set a(integer) 0 语法：SREM key member [member ...] 12127.0.0.1:6379&gt; srem set c d(integer) 1 2. 获取集合中的所有元素语法：SMEMBERS key 123127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a” 3. 判断元素是否在集合中语法：SISMEMBER key member 1234127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; sismember set h(integer) 0 3.4.3 运算命令1. 集合的差集运算 A-B属于A并且不属于B的元素构成的集合。 语法：SDIFF key [key ...] 12345678127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot;127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot; 2. 集合的交集运算 A ∩ B属于A且属于B的元素构成的集合。 语法：SINTER key [key ...] 123127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot;2) &quot;3&quot; 3. 集合的并集运算 A∪ B属于A或者属于B的元素构成的集合 语法：SUNION key [key ...] 12345127.0.0.1:6379&gt; sunion setA setB1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot; 3.4.4 其他命令(自学)获得集合中元素的个数 语法：SCARD key 123456127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; scard setA (integer) 3 从集合中弹出一个元素 注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 语法：SPOP key 12127.0.0.1:6379&gt; spop setA &quot;1“ 3.5 SortedSet类型zset3.5.1 redis sorted set介绍在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 在某些方面有序集合和列表类型有些相似。 121、二者都是有序的。 2、二者都可以获得某一范围的元素。 但是，二者有着很大区别： 12341、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 4、有序集合要比列表类型更耗内存。 3.5.2 命令1. 增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 语法：ZADD key score member [score member ...] 1234127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0 2. 获取元素的分数语法：ZSCORE key member 12127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot; 3. 删除元素移除有序集key中的一个或多个成员，不存在的成员将被忽略。 当key存在但不是有序集类型时，返回一个错误。 语法：ZREM key member [member ...] 12127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1 4. 获得排名在某个范围的元素列表获得排名在某个范围的元素列表 按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：ZRANGE key start stop [WITHSCORES] 1234127.0.0.1:6379&gt; zrange scoreboard 0 21) &quot;zhangsan&quot;2) &quot;wangwu&quot;3) &quot;lisi“ 按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：ZREVRANGE key start stop [WITHSCORES] 1234127.0.0.1:6379&gt; zrevrange scoreboard 0 21) &quot; lisi &quot;2) &quot;wangwu&quot;3) &quot; zhangsan “ 如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 12345127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES1) &quot;zhangsan&quot;2) &quot;80&quot;3) &quot;wangwu&quot;4) &quot;94&quot; 5. 其他命令(自学)获得指定分数范围的元素 语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 12345678127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;3) &quot;lisi&quot;4) &quot;97&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot;2) &quot;lisi&quot; 增加某个元素的分数 返回值是更改后的分数 语法：ZINCRBY key increment member 12127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“ 获得集合中元素的数量 语法：ZCARD key 12127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3 获得指定分数范围内的元素个数 语法：ZCOUNT key min max 12127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1 按照排名范围删除元素 语法：ZREMRANGEBYRANK key start stop 1234127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot; 按照分数范围删除元素 语法：ZREMRANGEBYSCORE key min max 1234127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1 获取元素的排名从小到大 语法：ZRANK key member 12127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0 从大到小 语法：ZREVRANK key member 12127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1 3.5.3 应用商品销售排行榜12需求：根据商品销售量对商品进行排行显示思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。 写入商品销售量： 商品编号1001的销量是9，商品编号1002的销量是10 1192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002 商品编号1001的销量加1 1192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001 商品销量前10名： 1192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores 4. Keys命令4.1 设置key的生存时间Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 1234EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除TTL key 查看key生于的生存时间PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 例子： 123456789101112192.168.101.3:7002&gt; set test 1 设置test的值为1OK192.168.101.3:7002&gt; get test 获取test的值&quot;1&quot;192.168.101.3:7002&gt; EXPIRE test 5 设置test的生存时间为5秒(integer) 1192.168.101.3:7002&gt; TTL test 查看test的生于生成时间还有1秒删除(integer) 1192.168.101.3:7002&gt; TTL test(integer) -2192.168.101.3:7002&gt; get test 获取test的值，已经删除(nil) 4.2 其他命令(自学)keys 返回满足给定pattern 的所有key 123456redis 127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot; exists 确认一个key 是否存在 示例：从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的 12345redis 127.0.0.1:6379&gt; exists HongWan(integer) 0redis 127.0.0.1:6379&gt; exists age(integer) 1redis 127.0.0.1:6379&gt; del 删除一个key 1234redis 127.0.0.1:6379&gt; del age(integer) 1redis 127.0.0.1:6379&gt; exists age(integer) 0 rename 重命名key 示例：age 成功的被我们改名为age_new 了 1234567redis 127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;redis 127.0.0.1:6379[1]&gt; rename age age_newOKredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age_new&quot;redis 127.0.0.1:6379[1]&gt; type 返回值的类型 示例：这个方法可以非常简单的判断出值的类型 1234567redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlistredis 127.0.0.1:6379&gt; 5. Redis客户端5.1 Redis自带的客户端 指定主机和端口 12# ./redis-cli -h 127.0.0.1 -p 6379127.0.0.1:6379&gt; exit 【退出】 12-h：redis服务器的ip地址-p：redis实例的端口号 如果不指定主机和端口也可以 1# ./redis-cli 12默认主机地址是127.0.0.1 默认端口是6379 5.2 图形界面客户端(了解)前提：需要安装图形界面管理器【redis-desktop-manager-0.8.0.3841.exe】 5.2.1 连接超时解决远程连接redis服务，需要关闭或者修改防火墙配置。 123将修改后的端口添加到防火墙中./sbin/iptables -I INPUT -p tcp --dport 8081 -j ACCEPT/etc/rc.d/init.d/iptables save 第一步：编辑iptables 1#vim /etc/sysconfig/iptables 在命令模式下，选定要复制的那一行的末尾，然后点击键盘yyp，就完成复制，然后修改。 第二步：重启防火墙 1# service iptables restart 注意：默认一共是16个数据库，每个数据库之间是相互隔离。数据库的数量是在redis.conf中配置的。 切换数据库使用命令：select 数据库编号 例如：select 1【相当于mysql 的use databasename】 5.3 Java客户端Jedis5.3.1 Jedis介绍Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。 Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 5.3.2 添加jar包12Commons-pool-1.6.jarJedis-2.1.0.jar 5.3.3 单实例连接1234567891011121314@Testpublic void testJedis() &#123; //创建一个Jedis的连接 Jedis jedis = new Jedis("127.0.0.1", 6379); jedis.select(1);//设置数据库 //执行redis命令 jedis.set("mytest", "hello world, this is jedis client!"); //从redis中取值 String result = jedis.get("mytest"); //打印结果 System.out.println(result); //关闭连接 jedis.close(); &#125; 5.3.4 连接池连接1234567891011121314@Testpublic void testJedisPool() &#123; //创建一连接池对象 JedisPool jedisPool = new JedisPool("127.0.0.1", 6379); //从连接池中获得连接 Jedis jedis = jedisPool.getResource(); String result = jedis.get("mytest"); System.out.println(result); //关闭连接 jedis.close(); //关闭连接池 jedisPool.close();&#125; 5.3.5 Spring整合jedisPool（自学）添加spring的jar包 配置spring配置文件applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool" destroy-method="close"&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig" /&gt; &lt;constructor-arg name="host" value="192.168.242.130" /&gt; &lt;constructor-arg name="port" value="6379" /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码 12345678910111213141516171819@Test public void testJedisPool() &#123; JedisPool pool = (JedisPool) applicationContext.getBean("jedisPool"); Jedis jedis = null; try &#123; jedis = pool.getResource(); jedis.set("name", "lisi"); String name = jedis.get("name"); System.out.println(name); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; // 关闭连接 jedis.close(); &#125; &#125; &#125; Jedis测试： 完成一个手机验证码功能 1234要求： 1、输入手机号，点击发送后随机生成6位数字码，2分钟有效 2、输入验证码，点击验证，返回成功或失败 3、每个手机号每天只能输入3次 6. Redis的事务6.1 什么是事务Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队 6.2 命令 6.3 事务的错误管理 6.4 为什么要有事务12想想一个场景： 有很多人有你的账户,同时去参加双十一抢购 用乐观锁和悲观锁来解决事务冲突问题 123悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。 WATCH key [key …] 在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 unwatch 取消 WATCH 命令对所有 key 的监视。 如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。 Redis事务秒杀案例 7. Redis的持久化方案Redis 提供了2个不同形式的持久化方式。 12RDB （Redis DataBase）AOF （Append Of File） 7.1 RDB持久化RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。 RDB是Redis默认采用的持久化方式。 1234rdb的保存策略 save 900 1 save 300 10 save 60 10000 7.1.1 持久化条件配置save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系。 “save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照。 “save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。 7.1.2 配置快照文件目录配置dir指定rdb快照文件的位置，默认为Redis启动时命令行所在的目录下。 12# Note that you must specify a directory here, not a file name.dir ./ 7.1.3 配置快照文件的名称设置dbfilename指定rdb快照文件的名称 12# The filename where to dump the DBdbfilename dump.rdb Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 7.1.4 问题总结通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。 如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 7.2 AOF持久化默认情况下Redis没有开启AOF（append only file）方式的持久化，【操作一次就写一次数据】 可以通过修改redis.conf配置文件中的appendonly参数开启 1appendonly yes 开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。 AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的。 1dir ./ 默认的文件名是appendonly.aof，可以通过appendfilename参数修改： 1appendfilename appendonly.aof 重启服务，再添加数据，然后会有一个aof文件,然后分析appendonly.aof文件内容 12345[root@A01 bin]# ./redis-cli shutdown[root@A01 bin]# ./redis-server redis.conf[root@A01 bin]# ./redis-cli127.0.0.1:6379&gt; set ip 192.168.1.1OK AOF和RDB同时开启，redis听谁的？ AOF和RDB同时开启，系统默认取AOF的数据 8. Redis的主从复制8.1 什么是是主从复制持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明： 主redis中的数据有三个副本（replication）即从redis1、从redis2和从redis3，即使一台redis服务器宕机其它三台redis服务也可以继续提供服务。 主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。 只有一个主redis，可以有多个从redis。 主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求 一个redis可以即是主又是从，如下图： 8.2 主从配置8.2.1 主redis配置无需特殊配置。 8.2.2 从机redis配置第一步：复制出一个从机 1cp bin/ bin2 –r 第二步：修改从机的redis.conf,配置slaveof 为主机的ip地址和端口号 第三步：修改从机的port地址为6380 在redis.conf中修改 第四步：清除从机中的持久化文件 1rm -rf appendonly.aof dump.rdb 第五步：启动从机【一定要使用配置文件启动,否则还是使用默认的端口】,如图，有两个redis服务启动 1./redis-server redis.conf 第六步：启动6380的客户端【不指定端口，默认访问的还是6379的服务】 1# ./redis-cli -p 6380 注意： ​ 主机一旦发生增删改操作，那么主机会将数据同步到从机中 ​ 从机不能执行写操作 12127.0.0.1:6380&gt; set s2 222(error) READONLY You can&apos;t write against a read only slave. 9. Redis的集群9.1 redis-cluster【集群】架构图 123456架构细节:(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可(4)redis-cluster把所有的物理节点映射到[0-16383]slot槽上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;valueRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点 示例如下： 9.2 redis-cluster投票:容错 1234(1)集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超时(cluster-node-timeout),认为该master节点挂掉.(2):什么时候整个集群不可用(cluster_state:fail)? 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。 9.3 搭建Ruby环境redis集群管理工具redis-trib.rb依赖ruby环境，首先需要安装ruby环境。 安装ruby 12# yum install ruby# yum install rubygems 使用工具上传redis-3.0.0.gem至/usr/local下 安装ruby和redis的接口程序 1# gem install /usr/local/redis-3.0.0.gem 将Redis集群搭建脚本文件复制到/usr/local/redis/redis-cluster目录下 12# cd /root/redis-3.0.0/src/# ll *.rb【查看rb文件】 1# cp redis-trib.rb /usr/local/redis/rediscluster/ -r 9.4 集群的搭建过程搭建集群最少也得需要3台主机，如果每台主机再配置一台从机的话，则最少需要6台机器。端口设计如下：7001-7006 第一步：复制出一个7001机器 1[root@A001 redis]# cp bin ./redis-cluster/7001 –r 第二步：如果存在持久化文件，则删除 1[root@A001 7001]# rm -rf appendonly.aof dump.rdb 第三步：设置集群参数 第四步：修改端口 第五步：复制出7002-7006机器 12345[root@A001 redis-cluster]# cp 7001/ 7002 -r[root@A001 redis-cluster]# cp 7001/ 7003 -r[root@A001 redis-cluster]# cp 7001/ 7004 -r[root@A001 redis-cluster]# cp 7001/ 7005 -r[root@A001 redis-cluster]# cp 7001/ 7006 –r 第六步：修改7002-7006机器的端口 第七步：启动7001-7006这六台机器 1[root@A001redis-cluster]#vi startall.sh 【然后输入上面的内容，保存并退出】 第八步：修改startall.sh文件的权限 12[root@A001 redis-cluster]# chmod u+x startall.sh[root@A001 redis-cluster]# ./startall.sh 第九步：创建集群 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@A001 redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.242.137:7001 192.168.242.137:7002 192.168.242.137:7003 192.168.242.137:7004 192.168.242.137:7005 192.168.242.137:7006&gt;&gt;&gt; Creating clusterConnecting to node 192.168.242.137:7001: OKConnecting to node 192.168.242.137:7002: OKConnecting to node 192.168.242.137:7003: OKConnecting to node 192.168.242.137:7004: OKConnecting to node 192.168.242.137:7005: OKConnecting to node 192.168.242.137:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.242.137:7001192.168.242.137:7002192.168.242.137:7003Adding replica 192.168.242.137:7004 to 192.168.242.137:7001Adding replica 192.168.242.137:7005 to 192.168.242.137:7002Adding replica 192.168.242.137:7006 to 192.168.242.137:7003M: 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24 192.168.242.137:7001 slots:0-5460 (5461 slots) masterM: 4f52a974f64343fd9f1ee0388490b3c0647a4db7 192.168.242.137:7002 slots:5461-10922 (5462 slots) masterM: cb7c5def8f61df2016b38972396a8d1f349208c2 192.168.242.137:7003 slots:10923-16383 (5461 slots) masterS: 66adf006fed43b3b5e499ce2ff1949a756504a16 192.168.242.137:7004 replicates 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24S: cbb0c9bc4b27dd85511a7ef2d01bec90e692793b 192.168.242.137:7005 replicates 4f52a974f64343fd9f1ee0388490b3c0647a4db7S: a908736eadd1cd06e86fdff8b2749a6f46b38c00 192.168.242.137:7006 replicates cb7c5def8f61df2016b38972396a8d1f349208c2Can I set the above configuration? (type &apos;yes&apos; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join..&gt;&gt;&gt; Performing Cluster Check (using node 192.168.242.137:7001)M: 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24 192.168.242.137:7001 slots:0-5460 (5461 slots) masterM: 4f52a974f64343fd9f1ee0388490b3c0647a4db7 192.168.242.137:7002 slots:5461-10922 (5462 slots) masterM: cb7c5def8f61df2016b38972396a8d1f349208c2 192.168.242.137:7003 slots:10923-16383 (5461 slots) masterM: 66adf006fed43b3b5e499ce2ff1949a756504a16 192.168.242.137:7004 slots: (0 slots) master replicates 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24M: cbb0c9bc4b27dd85511a7ef2d01bec90e692793b 192.168.242.137:7005 slots: (0 slots) master replicates 4f52a974f64343fd9f1ee0388490b3c0647a4db7M: a908736eadd1cd06e86fdff8b2749a6f46b38c00 192.168.242.137:7006 slots: (0 slots) master replicates cb7c5def8f61df2016b38972396a8d1f349208c2[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@A001 redis-cluster]# 9.5 连接集群命令： 1./redis-cli –h 127.0.0.1 –p 7001 -c【c表示集群方式连接】 9.6 查看集群状态123456789101112127.0.0.1:7003&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:3cluster_stats_messages_sent:926cluster_stats_messages_received:926 查看集群中的节点：【可以杀死一个节点，来看节点的数据】 12345678127.0.0.1:7003&gt; cluster nodes7a12bc730ddc939c84a156f276c446c28acf798c 127.0.0.1:7002 master - 0 1443601739754 2 connected 5461-1092293f73d2424a796657948c660928b71edd3db881f 127.0.0.1:7003 myself,master - 0 0 3 connected 10923-16383d8f6a0e3192c905f0aad411946f3ef9305350420 127.0.0.1:7001 master - 0 1443601741267 1 connected 0-54604170a68ba6b7757e914056e2857bb84c5e10950e 127.0.0.1:7006 slave 93f73d2424a796657948c660928b71edd3db881f 0 1443601739250 6 connectedf79802d3da6b58ef6f9f30c903db7b2f79664e61 127.0.0.1:7004 slave d8f6a0e3192c905f0aad411946f3ef9305350420 0 1443601742277 4 connected0bc78702413eb88eb6d7982833a6e040c6af05be 127.0.0.1:7005 slave 7a12bc730ddc939c84a156f276c446c28acf798c 0 1443601740259 5 connected127.0.0.1:7003&gt; 9.7 维护节点（自学）9.7.1 添加主节点集群创建成功后可以向集群中添加节点，下面是添加一个master主节点添加7007结点作为新节点 1执行命令：./redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001 查看集群结点发现7007已添加到集群中 9.7.2 hash槽重新分配添加完主节点需要对主节点进行hash槽分配，这样该主节才可以存储数据。 查看集群中槽占用情况 redis集群有16384个槽，集群中的每个结点分配自已槽，通过查看集群结点可以看到槽占用情况。 给刚添加的7007结点分配槽 第一步：连接上集群（连接集群中任意一个可用结点都行） 1root@A001 redis]# ./redis-trib.rb reshard 192.168.101.3:7001 第二步：输入要分配的槽数量 1输入：500，表示要分配500个槽 第三步：输入接收槽的结点id 123输入：15b809eadae88955e36bcdbb8144f61bbbaf38fbPS：这里准备给7007分配槽，通过cluster nodes查看7007结点id为：15b809eadae88955e36bcdbb8144f61bbbaf38fb 第四步：输入源结点id 1输入：all 第五步：输入yes开始移动槽到目标结点id 1输入：yes 9.7.3 添加从节点集群创建成功后可以向集群中添加节点，下面是添加一个slave从节点。 添加7008从结点，将7008作为7007的从结点 1命令：./redis-trib.rb add-node --slave --master-id 主节点id 新节点的ip和端口 旧节点ip和端口 执行如下命令： 1./redis-trib.rb add-node --slave --master-id cad9f7413ec6842c971dbcc2c48b4ca959eb5db4 192.168.101.3:7008 192.168.101.3:7001 1cad9f7413ec6842c971dbcc2c48b4ca959eb5db4 是7007结点的id，可通过cluster nodes查看。 注意：如果原来该结点在集群中的配置信息已经生成到cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错： 1[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0 1解决方法是删除生成的配置文件nodes.conf，删除后再执行./redis-trib.rb add-node指令 查看集群中的结点，刚添加的7008为7007的从节点： 9.7.4 删除结点1命令：./redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017 删除已经占有hash槽的结点会失败，报错如下： 1[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again. 需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）。 10. Jedis连接集群10.1 防火墙配置12345678910111213141516171819202122[root@localhost-0723 bin]# service iptables stop-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 6379 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 6380 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7001 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7002 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7003 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7004 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7005 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 7006 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT~ &quot;/etc/sysconfig/iptables&quot; 22L, 1079C 已写入 [root@localhost-0723 bin]# service iptables restartiptables：应用防火墙规则： [确定][root@localhost-0723 bin]# 10.2 代码实现创建JedisCluster类连接redis集群。 123456789101112131415161718@Testpublic void testJedisCluster() throws Exception &#123; //创建一连接，JedisCluster对象,在系统中是单例存在 Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;(); nodes.add(new HostAndPort("127.0.0.1", 7001)); nodes.add(new HostAndPort("127.0.0.1", 7002)); nodes.add(new HostAndPort("127.0.0.1", 7003)); nodes.add(new HostAndPort("127.0.0.1", 7004)); nodes.add(new HostAndPort("127.0.0.1", 7005)); nodes.add(new HostAndPort("127.0.0.1", 7006)); JedisCluster cluster = new JedisCluster(nodes); //执行JedisCluster对象中的方法，方法和redis一一对应。 cluster.set("cluster-test", "my jedis cluster test"); String result = cluster.get("cluster-test"); System.out.println(result); //程序结束时需要关闭JedisCluster对象 cluster.close();&#125; 10.3 使用Spring配置applicationContext.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 连接池配置 --&gt;&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="true" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt;&lt;/bean&gt;&lt;!-- redis集群 --&gt;&lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg index="0"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7001"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7002"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7003"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7004"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7005"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.101.3"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="7006"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 测试代码 12345678910111213141516private ApplicationContext applicationContext; @Before public void init() &#123; applicationContext = new ClassPathXmlApplicationContext( "classpath:applicationContext.xml"); &#125; // redis集群 @Test public void testJedisCluster() &#123; JedisCluster jedisCluster = (JedisCluster) applicationContext .getBean("jedisCluster"); jedisCluster.set("name", "zhangsan"); String value = jedisCluster.get("name"); System.out.println(value); &#125;]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的AOP]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03-Spring%E4%B8%AD%E7%9A%84AOP%2F</url>
    <content type="text"><![CDATA[目录 Spring中的AOP的细节 基于XML的AOP配置 基于注解的AOP配置 1. Spring中的AOP的细节1.1 说明我们学习 spring 的 aop，就是通过配置的方式，实现上一章节的功能。 1.2 AOP相关术语123456789101112131415161718Joinpoint( 连接点):所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。Pointcut( 切入点):所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。Advice( 通知/ 增强):所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。Introduction( 引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。Target( 目标对象):代理的目标对象。Weaving( 织入):是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。Proxy （代理）:一个类被 AOP 织入增强后，就产生一个结果代理类。Aspect( 切面):是切入点和通知（引介）的结合。 1.3 学习Spring中的AOP要明确的事123456a 、开发阶段（我们做的）编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP 编程人员来做。在配置文件中，声明切入点与通知间的关系，即切面。：AOP 编程人员来做。b 、运行阶段（Spring 框架完成的）Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 1.4 关于代理的选择在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 2. 基于XML的AOP配置123示例： 我们在学习 spring 的 aop 时，采用账户转账作为示例。 并且把 spring 的 ioc 也一起应用进来。 2.1 环境搭建2.1.1 第一步：准备必要的代码此处包含了实体类，业务层和持久层代码。我们沿用上一章节中的代码即可。 2.1.2 第二步：拷贝必备的jar包到工程的lib目录此处要拷贝 spring 的 ioc 和 aop 两组 jar 包 2.1.3 第三步：创建Spring的配置文件并导入约束此处要导入 aop 的约束 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt; 2.1.4 第四步：配置Spring的IOC123456789101112131415161718192021222324&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据库操作对象 --&gt;&lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 指定 connection 和线程绑定 --&gt; &lt;property name="useCurrentConnection" value="true"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 2.1.5 第五步：抽取公共代码制作成通知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class TransactionManager &#123; //定义一个 DBAssit private DBAssit dbAssit ; public void setDbAssit(DBAssit dbAssit) &#123; this.dbAssit = dbAssit; &#125; //开启事务 public void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //提交事务 public void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //回滚事务 public void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //释放资源 public void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.2 配置步骤2.2.1 第一步：把通知类bean标签配置起来1234&lt;!-- 配置通知 --&gt;&lt;bean id="txManager" class="com.itheima.utils.TransactionManager"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.2 第二步：使用aop:config声明aop配置aop:config:作用：用于声明开始 aop 的配置 123&lt;aop:config&gt; &lt;!-- 配置的代码都写在此处 --&gt;&lt;/aop:config&gt; 2.2.3 第三步：使用aop:aspect配置切面aop:aspect:作用：用于配置切面。属性：id：给切面提供一个唯一标识。ref：引用配置好的通知类 bean 的 id。 123&lt;aop:aspect id="txAdvice" ref="txManager"&gt; &lt;!--配置通知的类型要写在此处--&gt;&lt;/aop:aspect&gt; 2.2.4 第四步：使用aop:pointcut配置切入点表达式aop:pointcut ：作用：用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。属性：expression：用于定义切入点表达式。id：用于给切入点表达式提供一个唯一标识 1234&lt;aop:pointcut expression="execution( public void com.itheima.service.impl.AccountServiceImpl.transfer( java.lang.String, java.lang.String, java.lang.Float))" id="pt1"/&gt; 2.2.5 第五步：使用aop:xxx配置对应的通知类型aop:before作用：用于配置前置通知。指定增强的方法在切入点方法之前执行属性：method:用于指定通知类中的增强方法名称ponitcut-ref：用于指定切入点的表达式的引用poinitcut：用于指定切入点表达式执行时间点：切入点方法执行之前执行 1&lt;aop:before method="beginTransaction" pointcut-ref="pt1"/&gt; aop:after-returning 作用：用于配置后置通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：切入点方法正常执行之后。它和异常通知只能有一个执行 1&lt;aop:after-returning method="commit" pointcut-ref="pt1"/&gt; aop:after-throwing作用：用于配置异常通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：切入点方法执行产生异常后执行。它和后置通知只能执行一个 1&lt;aop:after-throwing method="rollback" pointcut-ref="pt1"/&gt; aop:after作用：用于配置最终通知属性：method ：指定通知中方法的名称。pointct ：定义切入点表达式pointcut-ref ：指定切入点表达式的引用执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。 1&lt;aop:after method="release" pointcut-ref="pt1"/&gt; 2.3 切入点表达式说明123456789101112131415161718192021222324252627execution:匹配方法的执行(常用) execution(表达式)表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))写法说明： 全匹配方式：public void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 访问修饰符可以省略void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 返回值可以使用*号，表示任意返回值* com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 包名可以使用*号，表示任意包，但是有几级包，需要写几个** *.*.*.*.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 使用..来表示当前包，及其子包* com..AccountServiceImpl.saveAccount(com.itheima.domain.Account) 类名可以使用*号，表示任意类* com..*.saveAccount(com.itheima.domain.Account) 方法名可以使用*号，表示任意方法* com..*.*( com.itheima.domain.Account) 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数* com..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型* com..*.*(..) 全通配方式：* *..*.*(..)注： 通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。 execution(* com.itheima.service.impl.*.*(..)) 2.4 环绕通知配置方式: 12345678&lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))"id="pt1"/&gt; &lt;aop:aspect id="txAdvice" ref="txManager"&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method="transactionAround" pointcut-ref="pt1"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1234567891011aop:around ： 作用： 用于配置环绕通知 属性： method：指定通知中方法的名称。 pointcut：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 说明： 它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意： 通常情况下，环绕通知都是独立使用的 1234567891011121314151617181920212223242526272829/*** 环绕通知* @param pjp* spring 框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。* 在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。* @return*/public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3. 基于注解的AOP配置3.1 环境搭建3.1.1 第一步：准备必要的代码和jar包拷贝上一小节的工程即可。 3.1.2 第二步：再配置文件中导入context的名称空间123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置数据库操作对象 --&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 指定 connection 和线程绑定 --&gt; &lt;property name="useCurrentConnection" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.1.3 第三步：把资源使用注解配置123456789101112/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao;&#125; 123456789101112/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private DBAssit dbAssit ;&#125; 3.1.4 第四步：在配置文件指定Spring要扫描的包12&lt;!-- 告知 spring，在创建容器时要扫描的包 --&gt;&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; 3.2 配置步骤3.2.1 第一步：把通知类也使用注解配置123456789101112/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("txManager")public class TransactionManager &#123; //定义一个 DBAssit @Autowired private DBAssit dbAssit ;&#125; 3.2.2 第二步：在通知类使用@Aspect注解声明为切面作用：把当前类声明为切面类。 1234567891011121314/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("txManager")@Aspect//表明当前类是一个切面类public class TransactionManager &#123; //定义一个 DBAssit @Autowired private DBAssit dbAssit ;&#125; 3.2.3 第三步：在增强的方法上使用注解配置通知12345@Before 作用： 把当前方法看成是前置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 123456789//开启事务@Before("execution(* com.itheima.service.impl.*.*(..))")public void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@AfterReturning 作用： 把当前方法看成是后置通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//提交事务@AfterReturning("execution(* com.itheima.service.impl.*.*(..))")public void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@AfterThrowing 作用： 把当前方法看成是异常通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//回滚事务@AfterThrowing("execution(* com.itheima.service.impl.*.*(..))")public void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125; 12345@After 作用： 把当前方法看成是最终通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用 123456789//释放资源@After("execution(* com.itheima.service.impl.*.*(..))")public void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.2.4 第四步：在Spring配置文件中开启Spring对注解AOP的支持12&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;&lt;aop:aspectj-autoproxy/&gt; 3.3 环绕通知注解配置12345@Around 作用： 把当前方法看成是环绕通知。 属性： value：用于指定切入点表达式，还可以指定切入点表达式的引用。 12345678910111213141516171819202122232425262728/*** 环绕通知* @param pjp* @return*/@Around("execution(* com.itheima.service.impl.*.*(..))")public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3.4 切入点表达式注解12345@Pointcut 作用： 指定切入点表达式 属性： value：指定表达式的内容 12@Pointcut("execution(* com.itheima.service.impl.*.*(..))")private void pt1() &#123;&#125; 引用方式： 12345678910111213141516171819202122232425262728/*** 环绕通知* @param pjp* @return*/@Around("pt1()")// 注意：千万别忘了写括号public Object transactionAround(ProceedingJoinPoint pjp) &#123; //定义返回值 Object rtValue = null; try &#123; //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); &#125;catch(Throwable e) &#123; //异常通知：回滚事务 rollback(); e.printStackTrace(); &#125;finally &#123; //最终通知：释放资源 release(); &#125; return rtValue;&#125; 3.5 不使用XML的配置方式12345@Configuration@ComponentScan(basePackages="com.itheima")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP的相关概念]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-02-AOP%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[目录 AOP概述 AOP的具体应用 1. AOP概述1.1 什么是AOPAOP：全称是 Aspect Oriented Programming 即：面向切面编程。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 1.2 AOP的作用及优势作用：在程序运行期间，不修改源码对已有方法进行增强。优势：减少重复代码提高开发效率维护方便 1.3 AOP的实现方式使用动态代理技术 2. AOP的具体应用2.1 案例中问题这是我们昨天做的增删改查例子。下面是客户的业务层实现类。我们能看出什么问题吗? 客户的业务层实现类 123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void saveAccount(Account account) throws SQLException &#123; accountDao.save(account); &#125; @Override public void updateAccount(Account account) throws SQLException&#123; accountDao.update(account); &#125; @Override public void deleteAccount(Integer accountId) throws SQLException&#123; accountDao.delete(accountId); &#125; @Override public Account findAccountById(Integer accountId) throws SQLException &#123; return accountDao.findById(accountId); &#125; @Override public List&lt;Account&gt; findAllAccount() throws SQLException&#123; return accountDao.findAll(); &#125;&#125; 问题就是：事务被自动控制了。换言之，我们使用了 connection 对象的 setAutoCommit(true)此方式控制事务，如果我们每次都执行一条 sql 语句，没有问题，但是如果业务方法一次要执行多条 sql语句，这种方式就无法实现功能了。 请看下面的示例：我们在业务层中多加入一个方法。 业务层接口 1234567/*** 转账* @param sourceName* @param targetName* @param money*/void transfer(String sourceName,String targetName,Float money); 业务层实现类： 12345678910111213@Overridepublic void transfer(String sourceName, String targetName, Float money) &#123; //根据名称查询两个账户信息 Account source = accountDao.findByName(sourceName); Account target = accountDao.findByName(targetName); //转出账户减钱，转入账户加钱 source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); //更新两个账户 accountDao.update(source); int i=1/0; //模拟转账异常 accountDao.update(target);&#125; 当我们执行时，由于执行有异常，转账失败。但是因为我们是每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性） 2.2 问题的解决解决办法：让业务层来控制事务的提交和回滚。 改造后的业务层实现类： 注：此处没有使用 spring 的 的 IoC. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl(); @Override public void saveAccount(Account account) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.save(account); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; &#125; @Override public void updateAccount(Account account) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.update(account); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125;&#125; @Override public void deleteAccount(Integer accountId) &#123; try &#123; TransactionManager.beginTransaction(); accountDao.delete(accountId); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125;&#125; @Override public Account findAccountById(Integer accountId) &#123; Account account = null; try &#123; TransactionManager.beginTransaction(); account = accountDao.findById(accountId); TransactionManager.commit(); return account; &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; return null; &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; List&lt;Account&gt; accounts = null; try &#123; TransactionManager.beginTransaction(); accounts = accountDao.findAll(); TransactionManager.commit(); return accounts; &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; return null; &#125; @Override public void transfer(String sourceName, String targetName, Float money) &#123; try &#123; TransactionManager.beginTransaction(); Account source = accountDao.findByName(sourceName); Account target = accountDao.findByName(targetName); source.setMoney(source.getMoney()-money); target.setMoney(target.getMoney()+money); accountDao.update(source); int i=1/0; accountDao.update(target); TransactionManager.commit(); &#125; catch (Exception e) &#123; TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; TransactionManager.release(); &#125; &#125;&#125; TransactionManager 类的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 事务控制类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class TransactionManager &#123; //定义一个 DBAssit private static DBAssit dbAssit = new DBAssit(C3P0Utils.getDataSource(),true); //开启事务 public static void beginTransaction() &#123; try &#123; dbAssit.getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //提交事务 public static void commit() &#123; try &#123; dbAssit.getCurrentConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //回滚事务 public static void rollback() &#123; try &#123; dbAssit.getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //释放资源 public static void release() &#123; try &#123; dbAssit.releaseConnection(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.3 新的问题上一小节的代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了一个新的问题：业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了。试想一下，如果我们此时提交，回滚，释放资源中任何一个方法名变更，都需要修改业务层的代码，况且这还只是一个业务层实现类，而实际的项目中这种业务层实现类可能有十几个甚至几十个。思考：这个问题能不能解决呢？答案是肯定的，使用下一小节中提到的技术。 2.4 动态代理回顾2.4.1 动态代理的特点字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。装饰者模式就是静态代理的一种体现。 2.4.2 动态代理常用的两种方式1234567基于接口的动态代理提供者：JDK 官方的 Proxy 类。要求：被代理类最少实现一个接口。基于子类的动态代理提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。要求：被代理类不能用 final 修饰的类（最终类）。 2.4.3 使用JDK官方的Proxy类创建代理对象此处我们使用的是一个演员的例子：在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪人来找了。下面我们就用代码演示出来。 12345678910111213141516/*** 一个经纪公司的要求:* 能做基本的表演和危险的表演*/public interface IActor &#123; /** * 基本演出 * @param money */ public void basicAct(float money); /** * 危险演出 * @param money */ public void dangerAct(float money);&#125; 12345678910111213/*** 一个演员*///实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求public class Actor implements IActor&#123; public void basicAct(float money)&#123; System.out.println("拿到钱，开始基本的表演："+money); &#125; public void dangerAct(float money)&#123; System.out.println("拿到钱，开始危险的表演："+money); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Client &#123; public static void main(String[] args) &#123; //一个剧组找演员： final Actor actor = new Actor();//直接 /** * 代理： * 间接。 * 获取代理对象： * 要求： * 被代理类最少实现一个接口 * 创建的方式 * Proxy.newProxyInstance(三个参数) * 参数含义： * ClassLoader：和被代理对象使用相同的类加载器。 * Interfaces：和被代理对象具有相同的行为。实现相同的接口。 * InvocationHandler：如何代理。 * 策略模式：使用场景是： * 数据有了，目的明确。 * 如何达成目标，就是策略。 * */ IActor proxyActor = (IActor) Proxy.newProxyInstance( actor.getClass().getClassLoader(), actor.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。 * 此方法有拦截的功能。 * * 参数： * proxy：代理对象的引用。不一定每次都用得到 * method：当前执行的方法对象 * args：执行方法所需的参数 * 返回值： * 当前执行方法的返回值 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String name = method.getName(); Float money = (Float) args[0]; Object rtValue = null; //每个经纪公司对不同演出收费不一样，此处开始判断 if("basicAct".equals(name))&#123; //基本演出，没有 2000 不演 if(money &gt; 2000)&#123; //看上去剧组是给了 8000，实际到演员手里只有 4000 //这就是我们没有修改原来 basicAct 方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; if("dangerAct".equals(name))&#123; //危险演出,没有 5000 不演 if(money &gt; 5000)&#123; //看上去剧组是给了 50000，实际到演员手里只有 25000 //这就是我们没有修改原来 dangerAct 方法源码，对方法进行了增强 rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); //没有经纪公司的时候，直接找演员。 // actor.basicAct(1000f); // actor.dangerAct(5000f); //剧组无法直接联系演员，而是由经纪公司找的演员 proxyActor.basicAct(8000f); proxyActor.dangerAct(50000f); &#125;&#125; 2.4.4 使用CGLib的Enhancer类创建代理对象还是那个演员的例子，只不过不让他实现接口。 123456789101112/*** 一个演员*/public class Actor&#123;//没有实现任何接口 public void basicAct(float money)&#123; System.out.println("拿到钱，开始基本的表演："+money); &#125; public void dangerAct(float money)&#123; System.out.println("拿到钱，开始危险的表演："+money); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Client &#123; /** * 基于子类的动态代理 * 要求： * 被代理对象不能是最终类 * 用到的类： * Enhancer * 用到的方法： * create(Class, Callback) * 方法的参数： * Class：被代理对象的字节码 * Callback：如何代理 * @param args */ public static void main(String[] args) &#123; final Actor actor = new Actor(); Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), new MethodInterceptor() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何 方法进行增强。 * * 参数： * 前三个和基于接口的动态代理是一样的。 * MethodProxy：当前执行方法的代理对象。 * 返回值： * 当前执行方法的返回值 */ @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; String name = method.getName(); Float money = (Float) args[0]; Object rtValue = null; if("basicAct".equals(name))&#123; //基本演出 if(money &gt; 2000)&#123; rtValue = method.invoke(actor, money/2); &#125; &#125; if("dangerAct".equals(name))&#123; //危险演出 if(money &gt; 5000)&#123; rtValue = method.invoke(actor, money/2); &#125; &#125; return rtValue; &#125; &#125;); cglibActor.basicAct(10000); cglibActor.dangerAct(100000); &#125;&#125; 思考：这个故事（示例）讲完之后，我们从中受到什么启发呢？它到底能应用在哪呢？ 2.5 解决案例中的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过我们此处不做那么繁琐）* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class BeanFactory &#123; /** * 创建账户业务层实现类的代理对象 * @return */ public static IAccountService getAccountService() &#123; //1.定义被代理对象 final IAccountService accountService = new AccountServiceImpl(); //2.创建代理对象 IAccountService proxyAccountService = (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(),new InvocationHandler() &#123; /** * 执行被代理对象的任何方法，都会经过该方法。 * 此处添加事务控制 */ @Override public Object invoke(Object proxy, Method method,Object[] args) throws Throwable &#123; Object rtValue = null; try &#123; //开启事务 TransactionManager.beginTransaction(); //执行业务层方法 rtValue = method.invoke(accountService, args); //提交事务 TransactionManager.commit(); &#125;catch(Exception e) &#123; //回滚事务 TransactionManager.rollback(); e.printStackTrace(); &#125;finally &#123; //释放资源 TransactionManager.release(); &#125; return rtValue; &#125; &#125;); return proxyAccountService; &#125;&#125; 当我们改造完成之后，业务层用于控制事务的重复代码就都可以删掉了。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在虚拟机上部署Web项目]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E9%83%A8%E7%BD%B2Web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[目录 获取虚拟机的IP地址 使用putty连接Linux 在Linux上安装JDK 在Linuxs上安装Mysql 在Linux上安装tomcat 部署项目war包到tomcat 1. 获取虚拟机的IP地址如果我们想用工具来连接linux来进行操作，首先要获取虚拟机的IP地址，使用ifconfig命令，如果没有IP地址，则是没有设置开机时启动网上,设置操作如下： 1vim /etc/sysconfig/network-scripts/ifcfg-eth0 123TYPE=Ethernet #以太网BOOTPROTO=DHCP #dhcp方式分配网址 ONBOOT=yes #启动网卡 改完保存wq reboot [重启]之后才会生效 在本地ping一下：ping 192.168.228.129 2. 使用putty连接Linux 点击save可以保存一个设置，下次打开就可以直接用了。 选中gyf_centos01点击load按钮 然后输入账号密码就可以连接上虚拟机了 3. 在Linux上安装JDK3.1 卸载OpenJDKRPM 是RPM Package Manager（RPM软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。 1234执行命令查看:rpm -qa 是查看所有安装的软件 --nodeps 不验证软件包的依赖关系 -e 删除软件 1rpm –qa | grep java 查看和java相关的包 1rpm -e --nodeps java-1.60-openjdk-1.6.0.0-1.66.1 卸载OpenJDK 卸载完毕 3.2 创建JDK的安装路径12在/usr/local/ 创建文件夹javamkdir java 3.3 上传安装文件到Linux使用FileZilla-3.7.3上传 3.3.1 先连接到Linux 3.3.2 把下面的几个文件，拖到root目录下 12cd ~ll 3.4 解压tar.gz123首先需要安装依赖： yum install glibc.i686 【前提得能上网】 tar –xvf xxx.tar.gz –C /usr/local/java 3.5 配置环境变量1234567vim /etc/profile #set java environment JAVA_HOME=/usr/local/java/jdk1.7.0_72 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 12重新加载配置文件：source /etc/profile 4. 在Linuxs上安装Mysql4.1 卸载自带MySQL1234先查看有没有安装mysqlrpm -qa | grep mysql删除rpm -e --nodeps mysql-libs-5.1.71-1.el6.i686 4.2 创建MySQL的安装路径 4.3 解压MySQL1tar -xvf MySQL-5.6.22-1.el6.i686.rpm-bundle.tar -C /usr/local/mysql 4.4 安装依赖（可选）12yum -y install libaio.so.1 libgcc_s.so.1 libstdc++.so.6yum update libstdc++-4.4.7-4.el6.x86_64 4.5 安装MySQL的服务端1rpm -ivh MySQL-server-5.5.49-1.linux2.6.i386.rpm 4.6 安装MySQL的客户端1rpm -ivh MySQL-client-5.5.49-1.linux2.6.i386.rpm 4.7 启动MySQL的服务12service mysql statusservice mysql start 4.8 登录MySQL1mysql –u root -p 12修改密码：set password = password(&apos;123456&apos;); 4.9 设置开机自动启动MySQL1234加入到系统服务：chkconfig --add mysql自动启动：chkconfig mysql on 4.10 开启远程服务123登录mysql授权可以远程访问:grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;123456&apos;;flush privileges; 4.11 设置Linux的防火墙1233306端口放行 且将该设置添加到防火墙的规则中/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save 配置完成以后，我们就在本地测试一下 5. 在Linux上安装tomcat5.1 创建tomcat的安装路径1在/usr/local 下mkdir tomcat 5.2 解压tomcat1tar –xvf xxx.tar.gz –C /usr/local/tomcat 5.3 设置防护墙12/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save 5.4 启动tomcat12进入到tomcat/bin执行 ./startup.sh 在本地访问一下tomcat 12关闭tomcat执行 ./shutdown.sh 6. 部署项目war包到tomcat先在linux的mysql创建表，初始化数据 把SSM web项目打包成war 1234567上传到linux的tomcat的webapps中导入windows的mysql数据和数据window导出mysqldump -uroot -p123456 bos &gt; C:/Users/guoyongfeng/Desktop/bos.sqllinux导入mysql&gt; source /root/bos.sql 访问项目 1234查看tomcat的进程idps -ef | grep java杀死tomcatkill 3355]]></content>
      <categories>
        <category>操作系统</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>虚拟机</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于注解的IoC配置和整合Junit]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IoC%E9%85%8D%E7%BD%AE%E5%92%8C%E6%95%B4%E5%90%88Junit%2F</url>
    <content type="text"><![CDATA[目录 明确：写在前面 环境搭建 常用注解 Spring管理对象细节 Spring的纯注解配置 测试类中的问题和解决思路 配置步骤 为什么不把测试类配置到xml中 1. 明确：写在前面学习基于注解的 IoC 配置，大家脑海里首先得有一个认知，即注解配置和 xml 配置要实现的功能都是一样的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌握。 2. 环境搭建2.1 第一步：拷贝必备jar包到工程的lib目录注意：在基于注解的配置中，我们还要多拷贝一个 aop 的 jar 包。如下图： 2.2 第二步：使用@Component注解配置管理的资源123456789101112131415161718192021222324252627/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("accountService")public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125;&#125;/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Component("accountDao")public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit;&#125; 注意：当我们使用注解注入时，set 方法不用写 2.3 第三步：创建Spring的xml配置文件并开启对注解的支持 注意：基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。由于我们使用了注解配置，此时不能在继承 JdbcDaoSupport，需要自己配置一个 JdbcTemplate 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 告知 spring 创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置 dbAssit --&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3. 常用注解3.1 用于创建对象的 相当于：&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 3.1.1 @Componet作用：把资源让 spring 来管理。相当于在 xml 中配置一个 bean。属性：value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。 3.1.2 @Controller @Service @Repository他们三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。他们只不过是提供了更加明确的语义化。 123@Controller ：一般用于表现层的注解。@Service ：一般用于业务层的注解。@Repository ：一般用于持久层的注解。 细节：如果注解中有且只有一个属性 要赋值时是 ，且名称是 value ，value 3.2 用于注入数据的相当于：&lt;property name=&quot;&quot; ref=&quot;&quot;&gt;、&lt;property name=&quot;&quot; value=&quot;&quot;&gt; 3.2.1 @Autowired作用：自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他 bean 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。 3.2.2 @Qualifier作用：在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用。属性：value：指定 bean 的 id。 3.2.3 @Resource作用：直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。属性：name：指定 bean 的 id。 3.2.4 @Value作用：注入基本数据类型和 String 类型数据的属性：value：用于指定值 3.3 用于改变作用范围的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt; 3.3.1 @Scope作用：指定 bean 的作用范围。属性：value：指定范围的值。取值：singleton prototype request session globalsession 3.4 和生命期相关的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot; /&gt; 3.4.1 @PostConstruct作用：用于指定初始化方法。 3.4.2 @PreDestroy作用：用于指定销毁方法。 3.5 关于Spring注解和XML的选择问题注解的优势：配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。XML 的优势：修改时，不用改源码。不涉及重新编译和部署。Spring 管理 Bean 方式的比较： 4. Spring管理对象细节基于注解的 spring IoC 配置中，bean 对象的特点和基于 XML 配置是一模一样的。 5. Spring的纯注解配置写到此处，基于注解的 IoC 配置已经完成，但是大家都发现了一个问题：我们依然离不开 spring 的 xml 配置文件，那么能不能不写这个 bean.xml，所有配置都用注解来实现呢？ 当然，同学们也需要注意一下，我们选择哪种配置的原则是简化开发和配置方便，而非追求某种技术。 5.1 待改造的问题我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置： 12&lt;!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中 --&gt;&lt;context:component-scan base-package="com.itheima"&gt;&lt;/context:component-scan&gt; 如果他要也能用注解配置，那么我们就离脱离 xml 文件又进了一步。 另外，数据源和 JdbcTemplate 的配置也需要靠注解来实现。 123456789101112&lt;!-- 配置 dbAssit --&gt;&lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt;&lt;/bean&gt; 5.2 新注解说明5.2.1 @Configuration作用：用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration 注解的类.class)。属性：value:用于指定配置类的字节码 示例代码： 123456789/*** spring 的配置类，相当于 bean.xml 文件* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Configuration public class SpringConfiguration &#123;&#125; 注意：我们已经把配置文件用类来代替了，但是如何配置创建容器时要扫描的包呢？请看下一个注解。 5.2.2 @ComponentScan作用：用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;是一样的。属性：basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。示例代码： 12345678910/*** spring 的配置类，相当于 bean.xml 文件* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@Configuration@ComponentScan("com.itheima") public class SpringConfiguration &#123;&#125; 注意：我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？请看下一个注解。 5.2.3 @Bean作用：该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。属性：name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。 示例代码： 123456789101112131415161718192021222324252627282930313233343536/*** 连接数据库的配置类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class JdbcConfig &#123; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setUser("root"); ds.setPassword("1234"); ds.setDriverClass("com.mysql.jdbc.Driver"); ds.setJdbcUrl("jdbc:mysql:///spring_day02"); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 创建一个 DBAssit，并且也存入 spring 容器中 * @param dataSource * @return */ @Bean(name="dbAssit") public DBAssit createDBAssit(DataSource dataSource) &#123; return new DBAssit(dataSource); &#125;&#125; 注意:我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？请看下一个注解。 5.2.4 @PropertySource作用：用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。属性：value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath: 示例代码： 12345678910111213141516171819202122232425262728293031323334/*** 连接数据库的配置类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; /** * 创建一个数据源，并存入 spring 容器中 * @return */ @Bean(name="dataSource") public DataSource createDataSource() &#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; jdbc.properties 文件： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/day44_ee247_springjdbc.username=rootjdbc.password=1234 注意：此时我们已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？请看下一个注解。 5.2.5 @Import作用：用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。属性：value[]：用于指定其他配置类的字节码。示例代码： 12345678910@Configuration@ComponentScan(basePackages = "com.itheima.spring")@Import(&#123; JdbcConfig.class&#125;)public class SpringConfiguration &#123;&#125;@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig&#123;&#125; 注意：我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？请看下一小节。 5.2.6 通过注解获取容器12ApplicationContext ac =new AnnotationConfigApplicationContext(SpringConfiguration.class); 5.3 工程结构图 6. 测试类中的问题和解决思路6.1 问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");IAccountService as = ac.getBean("accountService",IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 6.2 解决思路分析针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建spring 容器，我们就无须手动创建了，问题也就解决了。我们都知道，junit 单元测试的原理（在 web 阶段课程中讲过），但显然，junit 是无法实现的，因为它自己都无法知晓我们是否使用了 spring 框架，更不用说帮我们创建 spring 容器了。不过好在，junit 给我们暴露了一个注解，可以让我们替换掉它的运行器。这时，我们需要依靠 spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。 7. 配置步骤7.1 第一步：拷贝整合junit的必备jar包到lib目录此处需要注意的是，导入 jar 包时，需要导入一个 spring 中 aop 的 jar 包。 7.2 第二步：使用@RunWith注解替换原有运行器123456789/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)public class AccountServiceTest &#123;&#125; 7.3 第三步：使用@ContextConfiguration指定Spring配置文件的位置12345678910/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;)public class AccountServiceTest &#123;&#125; @ContextConfiguration 注解：locations 属性：用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明classes 属性：用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。 7.4 第四步：使用@Autowired给测试类中的变量注入数据12345678910111213/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations= &#123;"classpath:bean.xml"&#125;)public class AccountServiceTest &#123; @Autowired private IAccountService as ;&#125; 8. 为什么不把测试类配置到xml中在解释这个问题之前，先解除大家的疑虑，配到 XML 中能不能用呢？答案是肯定的，没问题，可以使用。那么为什么不采用配置到 xml 中的方式呢？这个原因是这样的：第一：当我们在 xml 中配置了一个 bean，spring 加载配置文件创建容器时，就会创建对象。第二：测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。所以，基于以上两点，我们不应该把测试配置到 xml 文件中。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyUI快速入门]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31-EasyUI%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 什么是EasyUI 第一个HelloWorld程序 创建和配置的方式 linkbutton的初始化原理 核心 常用的组件 综合案例 1. 什么是EasyUIjQuery EasyUI是一组基于jQuery的UI插件集合，而jQuery EasyUI的目标就是帮助web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javascript，也不需要对css样式有深入的了解，开发者只有需要了解一些简单的html标签。 jQuery EasyUI为我们提供了大多数UI控件的使用，如：accordion，combobox，menu，dialog，tabs，tree，validatebox，window等等。 特点: 上手很简单 功能丰富 美观的UI界面. 2. 第一个HelloWorld程序1234567891011121314步骤:1.导入相关的资源2.在页面中引入相关的配置信息&lt;link rel="stylesheet" type="text/css" href="../jquery-easyui/themes/default/easyui.css"&gt;&lt;!-- 样式文件 --&gt; &lt;link rel="stylesheet" type="text/css" href="../jquery-easyui/themes/icon.css"&gt; &lt;!-- 图标样式 --&gt; &lt;script type="text/javascript" src="../jquery-easyui/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- jQuery核心库 --&gt; &lt;script type="text/javascript" src="../jquery-easyui/jquery.easyui.min.js"&gt;&lt;/script&gt; &lt;!-- EasyUI核心库 --&gt;3.在页面添加对应的标签.每个组件都有对应的标签例如按钮就必须是&lt;a&gt;标签4.在标签上添加class=”easyui-插件名”,插件名必须全小写的.5.可以使用data-options来配置组件 3. 创建和配置的方式创建方式： 1.在页面标签中直接使用class=”easyui-插件名”来初始化组件. 1&lt;input class="easyui-datebox" name="time"&gt; 2.使用JS的初始化方式(推荐使用) 页面中： 1&lt;div id="myPanel" title="新新的标题头" data-options="width:800"&gt;EasyUI的面板&lt;/div&gt; JS中: 123456$(function()&#123; $("#myPanel").panel(&#123; height:800, title:'js中的标题' &#125;);&#125;); 配置方式： 1.在标签体重使用data-options配置信息. 1&lt;div class="easyui-panel" data-options="title:'EasyUI面板'" style="width:200px;height: 200px;"&gt;EasyUI的面板&lt;/div&gt; 2.直接在标签上配置属性,&lt;div title=&quot;标题&quot; class=&quot;easyui-panel&quot;&gt;&lt;div&gt; 3.在JS中最配置(推荐使用) 页面中： 1&lt;div id=&quot;myPanel&quot; title=&quot;标题&quot;&gt;&lt;/div&gt; JS中： 123456$(function()&#123; $("#myPanel").panel(&#123; height:800, title:'js中的标题' &#125;);&#125;); 注意:三种方式都是可以混合使用的.JS中的配置会覆盖页面中的配置. 4. linkbutton的初始化原理1.所有的标签都以class=”easyui-插件名“,通过筛选器可以找到这些标签. 2.在EasyUI代码中,准备好了一大堆的模板和样式类. 3.根据到底是什么标签,给对应的标签加上模板和样式类. 12345678910111213//放在页面加载完毕后执行$(function()&#123; //1.先获取到需要初始化的组件 var myBtn = $(".myButton"); //2.拿到一开始定义文本信息 var text = myBtn.html(); //3.定义模板 var temp = '&lt;span class="l-btn-left"&gt;&lt;span class="l-btn-text"&gt;'+text+'&lt;/span&gt;&lt;/span&gt;'; //4.在标签中插入模板 myBtn.html(temp); //5.给组件添加样式 myBtn.addClass("easyui-linkbutton l-btn");&#125;); 5. 核心5.1 属性所有的属性都定义在jQuery.fn.{plugin}.defaults里面。例如，对话框属性定义在jQuery.fn.dialog.defaults里面。 Panel（面板） 使用$.fn.panel.defaults重写默认值对象。 面板作为承载其它内容的容器。这是构建其他组件的基础（比如：layout,tabs,accordion等）。它还提供了折叠、关闭、最大化、最小化和自定义行为。面板可以很容易地嵌入到web页面的任何位置。 常用属性: 1234567891011121314151617title:设置标题iconCls :设置一个16x16图标的CSS类ID显示在面板左上角。 headerCls：添加一个CSS类ID到面板头部。 null bodyCls ： 添加一个CSS类ID到面板正文部分。 fit:当设置为true的时候面板大小将自适应父容器border boolean 定义是否显示面板边框。 collapsible boolean 定义是否显示可折叠按钮。 false minimizable boolean 定义是否显示最小化按钮。 false maximizable boolean 定义是否显示最大化按钮。 false closable boolean 定义是否显示关闭按钮。 collapsed boolean 定义是否在初始化的时候折叠面板。 false minimized boolean 定义是否在初始化的时候最小化面板。 false maximized boolean 定义是否在初始化的时候最大化面板。 false closed boolean 定义是否在初始化的时候关闭面板。 href:从远程加载文本内容cache：如果为true，在超链接载入时缓存面板内容。loadingMessage string 在加载远程数据的时候在面板内显示一条消息 使用$.fn.panel.defaults给组件添加默认值. 给组件添加默认标题. $.fn.panel.defaults.title=”默认标题”; 5.2 事件所有的事件（回调函数）也都定义在jQuery.fn.{plugin}.defaults里面。 fn大多都是以on开头的,大部分复杂组件,都可以在初始化时,使用onxxx属性配置,值为事件响应 onCollapse 折叠是触发 onExpand 展开时触发 小部分简单组件,还是使用JQuery事件监听方式,使用on方法添加事件.例如linkbutton linkButton没有事件，需要通过jquery的方式去处理.$(“#button”).on(“click”,functtion(){}); 5.3 方法调用方法的语法：$(‘selector’).plugin(‘method’, parameter); 和我们以前的调用方法的方式有些不同. 调用panel的打开方法 $(“#myPanel”).panel(“open”); $(“组件”).插件名(“方法名”,方法参数) 6. 常用的组件6.1 LinkButton(按钮)使用$.fn.linkbutton.defaults重写默认值对象。 按钮组件使用超链接按钮创建。它使用一个普通的&lt;a&gt;标签进行展示。它可以同时显示一个图标和文本,或只有图标或文字。按钮的宽度可以动态和折叠/展开以适应它的文本标签。 常用属性： iconCls：配置图标信息 plain:简洁风格 常用方法: enable：变亮按钮 disable：变灰按钮 6.2 Window(窗口)扩展自$.fn.panel.defaults。使用$.fn.window.defaults重写默认值对象。 窗口控件是一个浮动和可拖拽的面板可以用作应用程序窗口。默认情况下,窗口可以移动,调整大小和关闭。它的内容也可以被定义为静态html或要么通过ajax动态加载 常用属性: draggable boolean 定义是否能够拖拽窗口。 true resizable boolean 定义是否能够改变窗口大小。 true modal:定义是否将窗体显示为模式化窗口。 （起到遮蔽的效果） 6.3 Dialog(对话窗口)扩展自$.fn.window.defaults。使用$.fn.dialog.defaults重写默认值对象。 该对话框是一种特殊类型的窗口，它在顶部有一个工具栏，在底部有一个按钮栏。对话框窗口右上角只有一个关闭按钮用户可以配置对话框的行为显示其他工具,如collapsible,minimizable,maximizable工具等。 6.4 Dialog上的按钮创建按钮的方式: 1.array:通过数组的方式配置按钮 12345678910111213141516171819$(function()&#123; $("#myDialog").dialog(&#123; width:200, height:200, tools:[ &#123; iconCls:'icon-add', handler:function()&#123; alert("add"); &#125;, &#123; iconCls:'icon-edit', handler:function()&#123; alert("edit"); &#125; &#125; ] &#125;);&#125;); 2.selector:通过选择器的方式 1.工具栏按钮(tools)： 页面： 1234&lt;div id="tt"&gt; &lt;a class="icon-add" onclick="javascript:alert('iconadd')"&gt;&lt;/a&gt; &lt;a class="icon-remove" onclick="javascript:alert('iconremove')"&gt;&lt;/a&gt;&lt;/div&gt; JS中： 12345$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt'&#125;); 2.顶部按钮（toolbar）： 12345&lt;!--配置顶部按钮--&gt;&lt;div id="tb"&gt; &lt;a class="easyui-linkbutton" iconCls="icon-add" plain="true"&gt;新增&lt;/a&gt; &lt;a class="easyui-linkbutton" iconCls="icon-edit" plain="true"&gt;编辑&lt;/a&gt;&lt;/div&gt; 123456$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt', toolbar:'#tb'&#125;); 3.底部按钮 1234&lt;div id="bb"&gt; &lt;a href="#" class="easyui-linkbutton" iconCls="icon-save"&gt;保存&lt;/a&gt; &lt;a href="#" class="easyui-linkbutton" iconCls="icon-cancel"&gt;关闭&lt;/a&gt;&lt;/div&gt; 1234567$("#myDialog").dialog(&#123; width:200, height:200, tools:''#tt', toolbar:'#tb', buttons:'#bt'&#125;); 6.5 Tabs(选项卡)使用$.fn.tabs.defaults重写默认值对象。 选项卡显示一批面板。但在同一个时间只会显示一个面板。每个选项卡面板都有头标题和一些小的按钮工具菜单，包括关闭按钮和其他自定义按钮。 1234567891011121314151617181920212223//放在页面加载完毕后执行$(function() &#123; // 获取组件 var myTabs = $("#myTabs"); myTabs.tabs(&#123; width:500, height:'auto' &#125;); // 获取所有panel集合 var panelArr = myTabs.tabs("tabs"); // 循环 for ( var i = 0; i &lt; panelArr.length; i++) &#123; var panelUI = panelArr[i]; var title = panelUI.panel("options").tab; console.debug(panelUI.panel("options")); // 找到头部信息,添加鼠标移入事件 title.off().on("mouseenter", &#123;index : i&#125;, function(e) &#123; // 选中面板 myTabs.tabs("select", e.data.index); &#125;) &#125;&#125;); 动态添加选项卡和删除选项卡. 12345678910111213141516171819202122232425262728//放在页面加载完毕后执行$(function() &#123; // 获取组件 var myTabs = $("#myTabs"); myTabs.tabs(&#123; width:500, height:400, tools:'#tab-tools' &#125;);&#125;);var index = 0;function addPanel() &#123; // 往tabs动图添加选项卡 var myTabs = $("#myTabs"); myTabs.tabs("add", &#123; title : '面板'+(++index), closable : true, content : '面板' &#125;);&#125;function removePanel() &#123; // 目前哪个选中,就删除哪个. var myTabs = $("#myTabs"); var tabs = myTabs.tabs("getSelected"); var index = myTabs.tabs('getTabIndex', tabs); console.debug(index); myTabs.tabs("close", index);&#125; 6.6 DataGrid(数据表格)扩展自$.fn.panel.defaults。使用$.fn.datagrid.defaults重写默认值对象。 数据表格以表格形式展示数据，并提供了丰富的选择、排序、分组和编辑数据的功能支持。数据表格的设计用于缩短开发时间，并且使开发人员不需要具备特定的知识。它是轻量级的且功能丰富。单元格合并、多列标题、冻结列和页脚只是其中的一小部分功能。 常用属性: 1234567title:'数据表格',url:'data.json',//从远程地址获取对应的数据，对数据格式有要求,必须是要求格式.striped:true,//斑马线效果singleSelect:true,//单选操作toolbar:'#tb',//顶部按钮pagination:true,//配置分页栏信息fitColumns:true//表头自适应网格,需要和表头中width配合使用,此时width表示比例 列常用属性: 12345field:'listprice',//映射后台那个数据formatter:priceFormatter,//格式化函数width:1//如果没有和fitColumns配合使用表示普通的px值,如果和fitColumns配合使用,表示比例.rowspan:2//行合并colspan:5:列合并. 12345&lt;thead data-options="frozen:true"&gt; &lt;tr&gt; &lt;th data-options="field:'productid',rowspan:2,halign:'center'"&gt;产品ID&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; JS中配置表头 123456789101112131415161718frozenColumns:[ [ &#123;field:'productid',title:'产品ID',rowspan:2&#125; ] ], columns:[ [ &#123;field:'productname',title:'产品名称',width:1,rowspan:2&#125;, &#123;title:'汇总信息',width:1,colspan:5&#125; ], [ &#123;field:'unitcost',title:'成本单价',width:1&#125;, &#123;field:'status',title:'状态',width:1&#125;, &#123;field:'listprice',title:'售价',width:1&#125;, &#123;field:'attr1',title:'属性',width:1&#125;, &#123;field:'itemid',title:'分类ID',width:1&#125; ] ] 效果图： 6.7 Tree(树)使用$.fn.tree.defaults重写默认值对象。 树控件在web页面中一个将分层数据以树形结构进行显示。它提供用户展开、折叠、拖拽、编辑和异步加载等功能。 常用属性: 1234567url:远程地址,数据是要求的.标准JSON格式formatter：格式化函数lines:true,//节点之间通过线条连接animate:true,//展开收缩有动画效果. 常用事件: 123onClick：点击触发onDblClick：双击触发onSelect：选中触发. 12345678910111213141516171819202122232425262728293031323334353637$(function()&#123; //完成功能,双击自动展开或者收缩节点 //1,监听鼠标双击的事件. //2.判断节点的状态 // 如果是展开展开,让节点收缩 // 如果节点为收缩,让节点展开. $("#myTree").tree(&#123; url:'tree.json', animate:true, checkbox:true, lines:true, dnd:true, onDblClick:function(node)&#123; console.log(node); if(node.state=='open')&#123; //调用tree组件的收缩方法 $("#myTree").tree("collapse",node.target); &#125;else&#123; //调用tree组件的展开方法 $("#myTree").tree("expand",node.target); &#125; &#125;, formatter:function(node)&#123; //需要判断一下节点是否有子元素 if(node.children)&#123; //如果有 //返回的内容修改 return node.text+"("+node.children.length+")"; &#125;else&#123; //如果没有 //返回原样内容 return node.text; &#125; &#125; &#125;);&#125;); 7. 综合案例1234567891011121314151.对页面进行布局.&lt;div class=”easyui-layou”&gt; &lt;div data-options=”region:&apos;north&apos;”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;east&apos;”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;center”&gt;&lt;/div&gt; &lt;div data-options=”region:&apos;sourth&apos;”&gt;&lt;/div&gt;&lt;/div&gt;2.设置logo和版权信息.3.在左侧添加手风琴效果+树组件。4.在中间部分添加tabs组件,显示对应的数据.5.菜单添加对应的点击事件. 7.1 员工新增1.定义datagrid展示员工的数据 2.添加分页栏+顶部按钮. 3.添加员工新增的对话框(默认隐藏) 4.给新增按钮添加对应的时间,触发对话的显示. 5.监听保存按钮的事件，通过异步的方式提交数据到后台 7.2 员工编辑1.编辑的时候需要打开对话框. 2.对内容进行回显(基于同名匹配规则) 7.3 员工删除1.判断用户是否有选中数据. 2.让用户确定是否需要删除该数据. 3.调用ajax请求,把id传递到后台,进行删除. 4.提示操作反馈信息，刷新数据表格. 7.4 集成到首页中注意:href只加载body部分的内容.会发生页面不对的情况.建议使用content]]></content>
      <categories>
        <category>前端</category>
        <category>EasyUI</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>EasyUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spring的IoC实现账户的CRUD]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31-%E4%BD%BF%E7%94%A8Spring%E7%9A%84IoC%E5%AE%9E%E7%8E%B0%E8%B4%A6%E6%88%B7%E7%9A%84CRUD%2F</url>
    <content type="text"><![CDATA[目录 需求和技术要求 环境搭建 配置步骤 测试案例 1. 需求和技术要求1.1 需求实现账户的CRUD操作 1.2 技术要求 使用 spring 的 IoC 实现对象的管理使用 DBAssit 作为持久层解决方案使用 c3p0 数据源 2. 环境搭建2.1 拷贝jar包 2.2 创建数据库和编写实体类123456789create table account( id int primary key auto_increment, name varchar(40), money float)character set utf8 collate utf8_general_ci;insert into account(name,money) values(&apos;aaa&apos;,1000);insert into account(name,money) values(&apos;bbb&apos;,1000);insert into account(name,money) values(&apos;ccc&apos;,1000); 12345678910111213141516171819202122232425262728293031/*** 账户的实体类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125;&#125; 2.3 编写持久层代码123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存 * @param account */ void save(Account account); /** * 更新 * @param account */ void update(Account account); /** * 删除 * @param accountId */ void delete(Integer accountId); /** * 根据 id 查询 * @param accountId * @return */ Account findById(Integer accountId); /** * 查询所有 * @return */ List&lt;Account&gt; findAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountDaoImpl implements IAccountDao &#123; private DBAssit dbAssit; public void setDbAssit(DBAssit dbAssit) &#123; this.dbAssit = dbAssit; &#125; @Override public void save(Account account) &#123; dbAssit.update("insert into account(name,money)values(?,?)",account.getName(),account.getMoney()); &#125; @Override public void update(Account account) &#123; dbAssit.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId()); &#125; @Override public void delete(Integer accountId) &#123; dbAssit.update("delete from account where id=?",accountId); &#125; @Override public Account findById(Integer accountId) &#123; return dbAssit.query("select * from account where id=?",new BeanHandler&lt;Account&gt;(Account.class),accountId); &#125; @Override public List&lt;Account&gt; findAll() &#123; return dbAssit.query("select * from account where id=?",new BeanListHandler&lt;Account&gt;(Account.class)); &#125;&#125; 2.4 编写业务层代码123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户 * @param account */ void saveAccount(Account account); /** * 更新账户 * @param account */ void updateAccount(Account account); /** * 删除账户 * @param account */ void deleteAccount(Integer accountId); /** * 根据 id 查询账户 * @param accountId * @return */ Account findAccountById(Integer accountId); /** * 查询所有账户 * @return */ List&lt;Account&gt; findAllAccount();&#125; 123456789101112131415161718192021222324252627282930313233343536373839/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override public void saveAccount(Account account) &#123; accountDao.save(account); &#125; @Override public void updateAccount(Account account) &#123; accountDao.update(account); &#125; @Override public void deleteAccount(Integer accountId) &#123; accountDao.delete(accountId); &#125; @Override public Account findAccountById(Integer accountId) &#123; return accountDao.findById(accountId); &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAll(); &#125;&#125; 2.5 创建并编写配置文件 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 3. 配置步骤3.1 配置对象123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置 service --&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 dao --&gt; &lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dbAssit" ref="dbAssit"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 dbAssit 此处我们只注入了数据源，表明每条语句独立事务--&gt; &lt;bean id="dbAssit" class="com.itheima.dbassit.DBAssit"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///spring_day02"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4. 测试案例4.1 测试类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceTest &#123; /** * 测试保存 */ @Test public void testSaveAccount() &#123; Account account = new Account(); account.setName("黑马程序员"); account.setMoney(100000f); ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.saveAccount(account); &#125; /** * 测试查询一个 */ @Test public void testFindAccountById() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); Account account = as.findAccountById(1); System.out.println(account); &#125; /** * 测试更新 */ @Test public void testUpdateAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); Account account = as.findAccountById(1); account.setMoney(20301050f); as.updateAccount(account); &#125; /** * 测试删除 */ @Test public void testDeleteAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); as.deleteAccount(1); &#125; /** * 测试查询所有 */ @Test public void testFindAllAccount() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); IAccountService as = ac.getBean("accountService",IAccountService.class); List&lt;Account&gt; list = as.findAllAccount(); for(Account account : list) &#123; System.out.println(account); &#125; &#125;&#125; 4.2 分析测试中的问题通过上面的测试类，我们可以看出，每个测试方法都重新获取了一次 spring 的核心容器，造成了不必要的重复代码，增加了我们开发的工作量。这种情况，在开发中应该避免发生。有些同学可能想到了，我们把容器的获取定义到类中去。例如： 12345678910/*** 测试类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceTest &#123; private ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); private IAccountService as = ac.getBean("accountService",IAccountService.class);&#125; 这种方式虽然能解决问题，但是扔需要我们自己写代码来获取容器。能不能测试时直接就编写测试方法，而不需要手动编码来获取容器呢？]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架概述]]></title>
    <url>%2F2019%2F05%2F30%2F2019-05-30-Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 Spring框架概述 Ioc的概念和作用 案例的前期准备 基于XML的配置 Spring基于XML的IoC细节 Spring配置文件中提示的配置 1. Spring框架概述1.1 Spring是什么Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 1.2 Spring的发展历程1997 年 IBM提出了EJB 的思想1998 年，SUN制定开发标准规范 EJB1.01999 年，EJB1.1 发布2001 年，EJB2.0 发布2003 年，EJB2.1 发布2006 年，EJB3.0 发布Rod Johnson （ spring 之父）Expert One-to-One J2EE Design and Development(2002)阐述了 J2EE 使用EJB 开发设计的优点及解决方案Expert One-to-One J2EE Development without EJB(2004)阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）2017 年 9 9 月份发布了 g spring 的最新版本 0 spring 5.0 通用版 (GA) 1.3 Spring的优势方便解耦，简化开发通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。AOP 编程的支持通过 Spring的 AOP 功能，方便进行面向切面的编程，许多不容易用传统OOP 实现的功能可以通过 AOP 轻松应付。声明式事务的支持可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。方便程序的测试可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。方便集成各种优秀框架Spring可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持。低降低 JavaEE API 的使用难度Spring对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。Java 源码是经典学习范例Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java 设计模式灵活运用以及对 Java技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 1.4 Spring的体系结构 2. 程序的耦合和解耦2.1 什么是程序的耦合耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。 在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个准则就是高内聚低耦合。 它有如下分类： （1） 内容耦合。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。（2） 公共耦合。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。（3） 外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。（4） 控制耦合 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。（5） 标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。（6） 数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。（7） 非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。 总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。 内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 我们在开发 中，有些依赖关系是必须的，有些依赖关系可以通过优化代码来解除的。请看下面的示例代码： 123456789/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();&#125; 上面的代码表示：业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决。 再比如：早期我们的 JDBC 操作，注册驱动时，我们为什么不使用 DriverManager 的 register 方法，而是采用 Class.forName 的方式？ 123456789101112131415161718public class JdbcDemo1 &#123; /** * @author 黑马程序员 * @Company http://www.ithiema.com * @Version 1.0 * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName("com.mysql.jdbc.Driver"); //2.获取连接 //3.获取预处理 sql 语句对象 //4.获取结果集 //5.遍历结果集 &#125;&#125; 原因就是：我们的类依赖了数据库的具体驱动类（MySQL），如果这时候更换了数据库品牌（比如 Oracle），需要修改源码来重新数据库驱动。这显然不是我们想要的。 2.2 解决程序耦合的思路当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下： 1Class.forName("com.mysql.jdbc.Driver");//此处只是一个字符串 此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用配置文件配置。 2.3 工厂模式解耦在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来 并存起来。在接下来的使用的时候，直接拿过来用就好了。那么，这个读取配置文件，创建和获取三层对象的类就是工厂。 2.4 控制反转-Inversion Of Control上一小节解耦的思路有 2 个问题：1 、存哪去？分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。所以我们的答案就是在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 map 称之为 容器。2、还是没解释什么是工厂？工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。原来：我们在获取对象时，都是采用 new 的方式。是主动的。 现在：我们获取对象时，同时跟工厂要，有工厂为我们查找或者创建对象。是被动的。 这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。 明确 ioc 的作用：削减计算机程序的耦合(解除我们代码中的依赖关系)。 3. 案例的前期准备本章我们使用的案例是，账户的业务层和持久层的依赖关系解决。在开始 spring 的配置之前，我们要先准备一下环境。由于我们是使用 spring 解决依赖关系，并不是真正的要做增删改查操作，所以此时我们没必要写实体类。并且我们在此处使用的是 java 工程，不是 java web 工程。 3.1 尊卑Spring的开发包官网：http://spring.io/下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring 目录结构:) docs :API 和开发规范. libs :jar 包和源码. schema :约束. 我们使用的版本是 是 spring5.0.2 。特别说明：spring5 版本是用 jdk8 编写的，所以要求我们的 jdk 版本是 8 及以上。时 同时 tomcat 的版本要求 8.5 3.2 创建业务接口和实现类123456789101112/*** 账户的业务层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountService &#123; /** * 保存账户（此处只是模拟，并不是真的要保存） */ void saveAccount();&#125; 123456789101112131415/*** 账户的业务层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl();// 此处的依赖关系有待解决 @Override public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 3.3 创建持久层接口和实现类123456789101112/*** 账户的持久层接口* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public interface IAccountDao &#123; /** * 保存账户 */ void saveAccount();&#125; 123456789101112/*** 账户的持久层实现类* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class AccountDaoImpl implements IAccountDao &#123; @Override public void saveAccount() &#123; System.out.println("保存了账户"); &#125;&#125; 4. 基于XML的配置4.1 第一步：拷贝必备的jar包到工程的lib目录中 4.2 第二步：在类的根路径下创建一个任意名称的xml文件（不能是中文） 给配置文件导入约束： /spring-framework-5.0.2.RELEASE/docs/spring-framework-reference/html5/core.html 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 4.3 第三步：让Spring管理资源，在配置文件中配置service和dao12345678&lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中 id 属性：对象的唯一标识。 class 属性：指定要创建对象的全限定类名--&gt;&lt;!-- 配置 service --&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置 dao --&gt;&lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt;&lt;/bean&gt; 4.4 测试配置是否成功123456789101112131415161718192021/*** 模拟一个表现层* @author 黑马程序员* @Company http://www.ithiema.com* @Version 1.0*/public class Client &#123; /** * 使用 main 方法获取容器测试执行 */ public static void main(String[] args) &#123; //1.使用 ApplicationContext 接口，就是在获取 spring 容器 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); //2.根据 bean 的 id 获取对象 IAccountService aService = (IAccountService) ac.getBean("accountService"); System.out.println(aService); IAccountDao aDao = (IAccountDao) ac.getBean("accountDao"); System.out.println(aDao); &#125;&#125; 运行结果： 5. Spring基于XML的IoC细节5.1 Spring中工厂的类结构图 5.1.1 BeanFactory和ApplicationContext的区别BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。BeanFactory 和 ApplicationContext 的区别：创建对象的时间点不一样。ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。BeanFactory：什么时候使用什么时候创建对象。 5.1.2 ApplicationContext接口的实现类123456ClassPathXmlApplicationContext ：它是从类的根路径下加载配置文件 推荐使用这种FileSystemXmlApplicationContext ：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 5.2 IoC中bean标签和管理对象细节5.2.1 bean标签作用：用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性：id：给对象在容器中提供一个唯一标识。用于获取对象。class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。scope：指定对象的作用范围。 singleton :默认值，单例的. prototype :多例的. request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中. session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中. global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session. init-method：指定类中的初始化方法名称。destroy-method：指定类中销毁方法名称。 5.2.2 bean的作用范围和生命周期单例对象：scope=&quot;singleton&quot;一个应用只有一个对象的实例。它的作用范围就是整个引用。生命周期：对象出生：当应用加载，创建容器时，对象就被创建了。对象活着：只要容器在，对象一直活着。对象死亡：当应用卸载，销毁容器时，对象就被销毁了。多例对象：scope=&quot;prototype&quot;每次访问对象时，都会重新创建对象实例。生命周期：对象出生：当使用对象时，创建新的对象实例。对象活着：只要对象在使用中，就一直活着。对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。 5.2.3 实例化Bean的三种方式第一种方式：使用默认无参构造函数 1234&lt;!--在默认情况下：它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"/&gt; 第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象 1234567891011121314151617/*** 模拟一个静态工厂，创建业务层实现类*/public class StaticFactory &#123; public static IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是: 使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器 id 属性：指定 bean 的 id，用于从容器中获取 class 属性：指定静态工厂的全限定类名 factory-method 属性：指定生产对象的静态方法--&gt;&lt;bean id="accountService" class="com.itheima.factory.StaticFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象 12345678910111213141516171819/*** 模拟一个实例工厂，创建业务层实现类* 此工厂创建对象，必须现有工厂实例对象，再调用方法*/public class InstanceFactory &#123; public IAccountService createAccountService()&#123; return new AccountServiceImpl(); &#125;&#125;&lt;!-- 此种方式是： 先把工厂的创建交给 spring 来管理。 然后在使用工厂的 bean 来调用里面的方法 factory-bean 属性：用于指定实例工厂 bean 的 id。 factory-method 属性：用于指定实例工厂中创建对象的方法。--&gt;&lt;bean id="instancFactory" class="com.itheima.factory.InstanceFactory"&gt;&lt;/bean&gt;&lt;bean id="accountService" factory-bean="instancFactory" factory-method="createAccountService"&gt;&lt;/bean&gt; 5.3 Spring的依赖注入5.3.1 依赖注入的概念依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。 5.3.2 构造函数注入顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。具体代码如下： 12345678910111213141516171819/***/public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday) &#123; this.name = name; this.age = age; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 12345678910111213141516171819202122&lt;!-- 使用构造函数的方式，给 service 中的属性传值 要求： 类中需要提供一个对应参数列表的构造函数。 涉及的标签： constructor-arg 属性： index:指定参数在构造函数参数列表的索引位置 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 用这个找给谁赋值=======上面三个都是找给谁赋值，下面两个指的是赋什么值的============== value:它能赋的值是基本数据类型和 String 类型 ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;constructor-arg name="name" value=" 张三 "&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 5.3.3 set方法注入顾名思义，就是在类中提供需要注入成员的 set 方法。具体代码如下： 123456789101112131415161718192021public class AccountServiceImpl implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 12345678910111213141516&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式 涉及的标签： property 属性： name：找的是类中 set 方法后面的部分 ref：给属性赋值是其他 bean 类型的 value：给属性赋值是基本数据类型和 string 类型的 实际开发中，此种方式用的较多。--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt; 5.3.4 使用p名称空间注入数据（本质还是调用set方法）此种方式是通过在 xml中导入 p名称空间，使用 p:propertyName 来注入数据，它的本质仍然是调用类中的set 方法实现注入功能。Java 类代码： 123456789101112131415161718192021222324/*** 使用 p 名称空间注入，本质还是调用类中的 set 方法*/public class AccountServiceImpl4 implements IAccountService &#123; private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public void saveAccount() &#123; System.out.println(name+","+age+","+birthday); &#125;&#125; 配置文件代码： 12345678910&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl4" p:name="test" p:age="21" p:birthday-ref="now"/&gt;&lt;/beans&gt; 5.3.5 注入集合属性顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。具体代码如下： 12345678910111213141516171819202122232425262728293031323334/***/public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; @Override public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- 注入集合数据 List 结构的： array,list,set Map 结构的 map,entry,props,prop--&gt;&lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name="myStrs"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入 list 集合数据 --&gt; &lt;property name="myList"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 注入 set 集合数据 --&gt; &lt;property name="mySet"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入 Map 数据 --&gt; &lt;property name="myMap"&gt; &lt;props&gt; &lt;prop key="testA"&gt;aaa&lt;/prop&gt; &lt;prop key="testB"&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 注入 properties 数据 --&gt; &lt;property name="myProps"&gt; &lt;map&gt; &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt; &lt;entry key="testB"&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 6. Spring配置文件中提示的配置]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解开发]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29-Mybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[目录 mybatis的常用注解说明 使用Mybatis注解实现基本CRUD 使用注解实现复杂关系映射开发 mybatis基于注解的二级缓存 这几年来注解开发越来越流行，Mybatis 也可以使用注解开发方式，这样我们就可以减少编写 Mapper 映射文件了。本次我们先围绕一些基本的 CRUD 来学习，再学习复杂映射关系及延迟加载。 1. mybatis的常用注解说明1234567891011@Insert:实现新增@Update:实现更新@Delete:实现删除@Select:实现查询@Result:实现结果集封装@Results:可以与@Result 一起使用，封装多个结果集@ResultMap:实现引用@Results 定义的封装@One:实现一对一结果集封装@Many:实现一对多结果集封装@SelectProvider: 实现动态 SQL 映射@CacheNamespace:实现注解二级缓存的使用 2. 使用Mybatis注解实现基本CRUD单表的 CRUD 操作是最基本的操作，前面我们的学习都是基于 Mybaits 的映射文件来实现的。 2.1 编写实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 注意：此处我们故意和数据库表的列名不一致。 2.2 使用注解方式开发持久层接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据 id 查询一个用户 * @param userId * @return */ @Select("select * from user where id = #&#123;uid&#125; ") @ResultMap("userMap") User findById(Integer userId); /** * 保存操作 * @param user * @return */ @Insert("insert into user(username,sex,birthday,address)values(#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125; )") @SelectKey(keyColumn="id",keyProperty="id",resultType=Integer.class,before = false, statement = &#123; "select last_insert_id()" &#125;) int saveUser(User user); /** * 更新操作 * @param user * @return */ @Update("update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id =#&#123;id&#125; ") int updateUser(User user); /** * 删除用户 * @param userId * @return */ @Delete("delete from user where id = #&#123;uid&#125; ") int deleteUser(Integer userId); /** * 查询使用聚合函数 * @return */ @Select("select count(*) from user ") int findTotal(); /** * 模糊查询 * @param name * @return */ @Select("select * from user where username like #&#123;username&#125; ") List&lt;User&gt; findByName(String name);&#125; 通过注解方式，我们就不需要再去编写 UserDao.xml 映射文件了。 2.3 编写SqlMapConfig配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 properties 文件的位置 --&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt; &lt;!-- 配置别名的注册 --&gt; &lt;typeAliases&gt; &lt;package name="com.itheima.domain"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型是 JDBC --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 配置映射信息 --&gt; &lt;mappers&gt; &lt;!-- 配置 dao 接口的位置，它有两种方式 第一种：使用 mapper 标签配置 class 属性 第二种：使用 package 标签，直接指定 dao 接口所在的包 --&gt; &lt;package name="com.itheima.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4 编写测试方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/**** &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt;* &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisAnnotationCRUDTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试查询一个 */ @Test public void testFindById() &#123; User user = userDao.findById(41); System.out.println(user); &#125; /** * 测试保存 */ @Test public void testSave() &#123; User user = new User(); user.setUserName("mybatis annotation"); user.setUserSex("男"); user.setUserAddress("北京市顺义区"); user.setUserBirthday(new Date()); int res = userDao.saveUser(user); System.out.println("影响数据库记录的行数："+res); System.out.println("插入的主键值："+user.getUserId()); &#125; /** * 测试更新 */ @Test public void testUpdate() &#123; User user = userDao.findById(63); user.setUserBirthday(new Date()); user.setUserSex("女"); int res = userDao.updateUser(user); System.out.println(res); &#125; /** * 测试删除 */ @Test public void testDelete() &#123; int res = userDao.deleteUser(63); System.out.println(res); &#125; /** * 测试查询使用聚合函数 */ @Test public void testFindTotal() &#123; int res = userDao.findTotal(); System.out.println(res); &#125; /** * 测试模糊查询 */ @Test public void testFindByName() &#123; List&lt;User&gt; users = userDao.findByName("%m%"); for(User user : users) &#123; System.out.println(user); &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit 的注解 public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in); //3.创建 session session = factory.openSession(); //4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123; //提交事务 session.commit(); //释放资源 session.close(); //关闭流 in.close(); &#125; &#125; 3. 使用注解实现复杂关系映射开发实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，在使用注解开发时我们需要借助@Results 注解，@Result 注解，@One 注解，@Many 注解。 3.1 复杂关系映射的注解说明12345678910111213141516171819202122232425262728@Results 注解代替的是标签&lt;resultMap&gt;该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results（&#123;@Result（），@Result（）&#125;）或@Results（@Result（））@Resutl 注解代替了 &lt;id&gt; 标签和&lt;result&gt; 标签@Result 中 属性介绍： id 是否是主键字段 column 数据库的列名 property 需要装配的属性名 one 需要使用的@One 注解（@Result（one=@One）（））） many 需要使用的@Many 注解（@Result（many=@many）（）））@One 注解（一对一） 代替了&lt;assocation&gt; 标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。@One 注解属性介绍： select 指定用的 来多表查询的 sqlmapper fetchType 会覆盖全局的配置参数 lazyLoadingEnabled。。使用格式： @Result(column=" ",property="",one=@One(select=""))@Many 注解（多对一） 代替了&lt;Collection&gt; 标签, 是是多表查询的关键，在注解中用来指定子查询返回对象集合。 注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType（一般为 ArrayList）但是注解中可以不定义；使用格式： @Result(property="",column="",many=@Many(select="")) 3.2 使用注解实现一对一复杂关系映射及延迟加载需求：加载账户信息时并且加载该账户的用户信息，根据情况可实现延迟加载。（注解方式实现） 3.2.1 添加User实体类及Account实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一关系映射：从表方应该包含一个主表方的对象引用 private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 3.2.2 添加账户的持久层接口并使用注解配置1234567891011121314151617181920212223242526/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，采用延迟加载的方式查询账户的所属用户 * @return */ @Select("select * from account") @Results(id="accountMap", value= &#123; @Result(id=true,column="id",property="id"), @Result(column="uid",property="uid"), @Result(column="money",property="money"), @Result(column="uid", property="user", one=@One(select="com.itheima.dao.IUserDao.findById", fetchType=FetchType.LAZY) ) &#125;) List&lt;Account&gt; findAll();&#125; 3.2.3 添加用户的持久层接口并使用注解配置1234567891011121314151617181920212223242526272829303132/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday") &#125;) List&lt;User&gt; findAll(); /** * 根据 id 查询一个用户 * @param userId * @return */ @Select("select * from user where id = #&#123;uid&#125; ") @ResultMap("userMap") User findById(Integer userId);&#125; 3.2.4 测试一对一关联及延迟加载12345678910111213141516/**** &lt;p&gt;Title: AccountTest&lt;/p&gt;* &lt;p&gt;Description: 账户的测试类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll(); // for(Account account : accounts) &#123; // System.out.println(account); // System.out.println(account.getUser()); // &#125;&#125; 3.3 使用注解实现一对多复杂关系映射需求：查询用户信息时，也要查询他的账户列表。使用注解方式实现。分析：一个用户具有多个账户信息，所以形成了用户(User)与账户(Account)之间的一对多关系。 3.3.1 User实体类加入List&lt;Account&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; //一对多关系映射：主表方法应该包含一个从表方的集合引用 private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 3.3.2 编写用户的持久层接口并使用注解配置1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap", value= &#123; @Result(id=true,column="id",property="userId"), @Result(column="username",property="userName"), @Result(column="sex",property="userSex"), @Result(column="address",property="userAddress"), @Result(column="birthday",property="userBirthday"), @Result(column="id",property="accounts", many=@Many( select="com.itheima.dao.IAccountDao.findByUid", fetchType=FetchType.LAZY ) ) &#125;) List&lt;User&gt; findAll();&#125; @Many:相当于&lt;collection&gt;的配置select 属性：代表将要执行的 sql 语句fetchType 属性：代表加载方式，一般如果要延迟加载都设置为 LAZY 的值 3.3.3 编写账户的持久层接口并使用注解配置123456789101112131415/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 根据用户 id 查询用户下的所有账户 * @param userId * @return */ @Select("select * from account where uid = #&#123;uid&#125; ") List&lt;Account&gt; findByUid(Integer userId);&#125; 3.3.4 添加测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**** &lt;p&gt;Title: MybatisAnnotationCRUDTest&lt;/p&gt;* &lt;p&gt;Description: mybatis 的注解 crud 测试&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; /** * 测试查询所有 */ @Test public void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); // for(User user : users) &#123; // System.out.println("-----每个用户的内容-----"); // System.out.println(user); // System.out.println(user.getAccounts()); // &#125; &#125; private InputStream in; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Before//junit 的注解 public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); factory = builder.build(in); //3.创建 session session = factory.openSession(); //4.创建代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//junit 的注解 public void destroy()throws Exception &#123; //提交事务 session.commit(); //释放资源 session.close(); //关闭流 in.close(); &#125;&#125; 4. mybatis基于注解的二级缓存4.1 在SqlMapConfig中开启二级缓存支持12345&lt;!-- 配置二级缓存 --&gt;&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 4.2 在持久层接口中使用注解配置二级缓存12345678/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/@CacheNamespace(blocking=true)//mybatis 基于注解方式实现配置二级缓存public interface IUserDao &#123;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis延迟加载策略与缓存]]></title>
    <url>%2F2019%2F05%2F28%2F2019-05-28-Mybatis%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5%E4%B8%8E%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[目录 何为延迟加载 实现需求 使用assocation实现延迟加载 使用Collection实现延迟加载 Mybatis一级缓存 Mybatis二级缓存 通过前面的学习，我们已经掌握了 Mybatis 中一对一，一对多，多对多关系的配置及实现，可以实现对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的账户信息。此时就是我们所说的延迟加载。 1. 何为延迟加载延迟加载：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载. 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 坏处 ：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。 2. 实现需求需求：查询账户(Account)信息并且关联查询用户(User)信息。如果先查询账户(Account)信息即可满足要求，当我们需要查询用户(User)信息时再查询用户(User)信息。把对用户(User)信息的按需去查询就是延迟加载。 昨天实现多表操作时，我们使用了resultMap来实现一对一，一对多，多对多关系的操作。主要是通过 association、collection 实现一对一及一对多映射。association、collection 具备延迟加载功能。 3. 使用assocation实现延迟加载需求：查询账户信息同时查询用户信息。 3.1 账户的持久层DAO接口12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，同时获取账户的所属用户名称以及它的地址信息 * @return */ List&lt;Account&gt; findAll();&#125; 3.2 账户的持久层映射文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 建立对应关系 --&gt; &lt;resultMap type="account" id="accountMap"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt; &lt;association property="user" javaType="user" select="com.itheima.dao.IUserDao.findById" column="uid"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="accountMap"&gt; select * from account &lt;/select&gt;&lt;/mapper&gt; select ： 填写我们要调用的 select 映射的 idcolumn ： 填写我们要传递给 select 映射的参数 3.3 用户的持久层接口和映射文件1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 id 查询 * @param userId * @return */ User findById(Integer userId);&#125; 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 根据 id 查询 --&gt; &lt;select id="findById" resultType="user" parameterType="int" &gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 3.4 开启Mybatis的延迟加载策略进入 Mybaits 的官方文档，找到 settings 的说明信息： 我们需要在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 12345&lt;!-- 开启延迟加载的支持 --&gt;&lt;settings&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 3.5 编写测试只查询账户信息而不查用户信息12345678910111213141516171819202122232425262728293031323334353637383940/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IAccountDao accountDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;Account&gt; accounts = accountDao.findAll(); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 accountDao = session.getMapper(IAccountDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们发现，因为本次只是将Account对象查询出来放入List集合中，并没有涉及到User对象，所以就没有发出 SQL 语句查询账户所关联的 User 对象的查询。 4. 使用Collection实现延迟加载同样我们也可以在一对多关系配置的&lt;collection&gt;结点中配置延迟加载策略。&lt;collection&gt;结点中也有 select 属性，column 属性。 需求：完成加载用户对象时，查询该用户所拥有的账户信息。 4.1 在User实体类中加入List&lt;Account&gt;属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 4.2 编写用户和账户持久层接口的方法12345/*** 查询所有用户，同时获取出每个用户下的所有账户信息* @return*/List&lt;User&gt; findAll(); 123456/*** 根据用户 id 查询账户信息* @param uid* @return*/List&lt;Account&gt; findByUid(Integer uid); 4.3 编写用户持久层映射配置123456789101112131415161718192021&lt;resultMap type="user" id="userMap"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称） column 是用于指定使用哪个字段的值作为条件查询 --&gt; &lt;collection property="accounts" ofType="account" select="com.itheima.dao.IAccountDao.findByUid" column="id"&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user&lt;/select&gt; &lt;collection&gt; 标签 ：主要用于加载关联的集合对象select 属性 ：用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 idcolumn 属性 ：用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了 4.4 编写账户持久层映射配置1234&lt;!-- 根据用户 id 查询账户信息 --&gt;&lt;select id="findByUid" resultType="account" parameterType="int"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; 4.5 测试只加载用户信息1234567891011121314151617181920212223242526272829303132333435363738394041/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;User&gt; users = userDao.findAll(); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们发现并没有加载 Account 账户信息。 像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。Mybatis 中缓存分为一级缓存，二级缓存。 5. Mybatis一级缓存5.1 证明一级缓存的存在一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。 5.1.1 编写用户持久层Dao接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 id 查询 * @param userId * @return */ User findById(Integer userId);&#125; 5.1.2 编写用户持久层映射文件12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 根据 id 查询 --&gt; &lt;select id="findById" resultType="User" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt; 5.1.3 编写测试方法1234567891011121314151617181920212223242526272829303132333435363738394041424344/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindById() &#123; //6.执行操作 User user = userDao.findById(41); System.out.println("第一次查询的用户："+user); User user2 = userDao.findById(41); System.out.println("第二次查询用户："+user2); System.out.println(user == user2); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close(); &#125;&#125; 测试结果如下： 我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 id为41的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 5.2 一级缓存的分析一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。 第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。如果 sqlSession 去执行 commit 操作（执行插入、更新、删除），清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。 5.3 测试一级缓存的清空123456789101112131415161718192021222324252627282930313233343536/*** 测试一级缓存*/@Testpublic void testFirstLevelCache()&#123; User user1 = userDao.findById(41); System.out.println(user1); // sqlSession.close(); //再次获取 SqlSession 对象 // sqlSession = factory.openSession(); sqlSession.clearCache();//此方法也可以清空缓存 userDao = sqlSession.getMapper(IUserDao.class); User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125;/*** 测试缓存的同步*/@Testpublic void testClearlCache()&#123; //1.根据 id 查询用户 User user1 = userDao.findById(41); System.out.println(user1); //2.更新用户信息 user1.setUsername("update user clear cache"); user1.setAddress("北京市海淀区"); userDao.updateUser(user1); //3.再次查询 id 为 41 的用户 User user2 = userDao.findById(41); System.out.println(user2); System.out.println(user1 == user2);&#125; 当执行sqlSession.close()后，再次获取sqlSession并查询id=41的User对象时，又重新执行了sql语句，从数据库进行了查询操作。 6. Mybatis二级缓存二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 6.1 二级缓存结构图 首先开启 mybatis 的二级缓存。 sqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果 SqlSession3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。 sqlSession2 去查询与 sqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 6.2 二级缓存的开启与关闭6.2.1 第一步：在SqlMapConfig.xml文件开启二级缓存1234&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt;&lt;/settings&gt; 因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为false 代表不开启二级缓存。 6.2.2 第二步：配置相关的Mapper映射文件&lt;cache&gt;标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt;&lt;/mapper&gt; 6.2.3 第三步：配置statement上面的useCache属性1234&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="user" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125;&lt;/select&gt; 将 UserDao.xml 映射文件中的&lt;select&gt;标签中设置 useCache=”true”代表当前这个 statement 要使用二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。 6.3 二级缓存测试123456789101112131415161718192021222324252627282930313233343536373839404142/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class SecondLevelCacheTest &#123; private InputStream in; private SqlSessionFactory factory; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; in.close(); &#125; /** * 测试一级缓存 */ @Test public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125;&#125; 经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二次查询时，我们发现并没有对数据库发出 sql 语句，所以此时的数据就只能是来自于我们所说的二级缓存。 6.4 二级缓存注意事项当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这样就可以使用序列化方式来保存对象。 12345678910111213/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis多表查询之一对多与多对多]]></title>
    <url>%2F2019%2F05%2F27%2F2019-05-27-Mybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[目录 一对一查询（多对一） 一对多查询 实现Role到User的多对多 实现User到Role的多对多 本次案例主要以最为简单的用户和账户的模型来分析Mybatis多表关系。用户为User 表，账户为Account表。一个用户（User）可以有多个账户（Account）。具体关系如下： 1. 一对一查询（多对一）需求： 查询所有账户信息，关联查询下单用户信息。注意： 因为一个账户信息只能供某个用户使用，所以从查询账户信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。 1.1 方式一1.1.1 定义账户信息的实体类1234567891011121314151617181920212223242526272829303132333435/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 1.1.2 编写Sql语句实现查询账户信息时，也要查询账户所对应的用户信息。 12345678SELECT account.*, user.username, user.addressFROM account, userWHERE account.uid = user.id 在 MySQL 中测试的查询结果如下： 1.1.3 定义 AccountUser类为了能够封装上面 SQL 语句的查询结果，定义 AccountCustomer 类中要包含账户信息同时还要包含用户信息，所以我们要在定义 AccountUser 类时可以继承 User 类。 123456789101112131415161718192021222324252627/**** &lt;p&gt;Title: AccountUser&lt;/p&gt;* &lt;p&gt;Description: 它是 account 的子类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountUser extends Account implements Serializable &#123; private String username; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return super.toString() + " AccountUser [username=" + username + ", address=" + address + "]"; &#125;&#125; 1.1.4 定义账户的持久层Dao接口12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123;/*** 查询所有账户，同时获取账户的所属用户名称以及它的地址信息* @return*/List&lt;AccountUser&gt; findAll();&#125; 1.1.5 定义AccountDao.xml文件中的查询配置信息12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 配置查询所有操作--&gt; &lt;select id="findAll" resultType="accountuser"&gt; select a.*,u.username,u.address from account a,user u where a.uid =u.id; &lt;/select&gt;&lt;/mapper&gt; 注意：因为上面查询的结果中包含了账户信息同时还包含了用户信息，所以我们的返回值类型 returnType的值设置为 AccountUser 类型，这样就可以接收账户信息和用户信息了。 1.1.6 创建AccountTest测试类12345678910111213141516171819202122232425262728293031323334353637383940414243/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多账户的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class AccountTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IAccountDao accountDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;AccountUser&gt; accountusers = accountDao.findAll(); for(AccountUser au : accountusers) &#123; System.out.println(au); &#125; &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 accountDao = session.getMapper(IAccountDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 1.1.7 小结定义专门的 po 类作为输出类型，其中定义了 sql 查询结果集所有的字段。此方法较为简单，企业中使用普遍。 1.2 方式二使用 resultMap，定义专门的 resultMap 用于映射一对一查询结果。 通过面向对象的(has a)关系可以得知，我们可以在 Account 类中加入一个 User 类的对象来代表这个账户是哪个用户的。 1.2.1 修改Account类在 Account 类中加入 User 类的对象作为 Account 类的一个属性。 123456789101112131415161718192021222324252627282930313233343536373839404142/**** &lt;p&gt;Title: Account&lt;/p&gt;* &lt;p&gt;Description: 账户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUid() &#123; return uid; &#125; public void setUid(Integer uid) &#123; this.uid = uid; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Account [id=" + id + ", uid=" + uid + ", money=" + money + "]"; &#125;&#125; 1.2.2 修改AccountDao接口中的方法12345678910111213/**** &lt;p&gt;Title: IAccountDao&lt;/p&gt;* &lt;p&gt;Description: 账户的持久层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IAccountDao &#123; /** * 查询所有账户，同时获取账户的所属用户名称以及它的地址信息 * @return */ List&lt;Account&gt; findAll();&#125; 注意：第二种方式，将返回值改 为了 Account 类型。因为 Account 类中包含了一个 User 类的对象，它可以封装账户所对应的用户信息。 1.2.3 重新定义AccountDao.xml文件1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IAccountDao"&gt; &lt;!-- 建立对应关系 --&gt; &lt;resultMap type="account" id="accountMap"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;!-- 它是用于指定从表方的引用实体属性的 --&gt; &lt;association property="user" javaType="user"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="accountMap"&gt; select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id; &lt;/select&gt;&lt;/mapper&gt; 1.2.4 在AccountTest类中加入测试方法12345678@Testpublic void testFindAll() &#123; List&lt;Account&gt; accounts = accountDao.findAll(); for(Account au : accounts) &#123; System.out.println(au); System.out.println(au.getUser()); &#125; &#125; 2. 一对多查询需求：查询所有用户信息及用户关联的账户信息。 分析：用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息查询出来，我们想到了左外连接查询比较合适。 2.1 编写SQL语句1234567SELECT u.*, acc.id id, acc.uid, acc.moneyFROM user uLEFT JOIN account acc ON u.id = acc.uid 测试该 SQL 语句在 MySQL 客户端工具的查询结果如下： 2.2 User类加入List&lt;Account&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; private List&lt;Account&gt; accounts; public List&lt;Account&gt; getAccounts() &#123; return accounts; &#125; public void setAccounts(List&lt;Account&gt; accounts) &#123; this.accounts = accounts; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 2.3 在持久层Dao接口中加入查询方法12345/*** 查询所有用户，同时获取出每个用户下的所有账户信息* @return*/List&lt;User&gt; findAll(); 2.4 在持久层Dao映射文件配置1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;resultMap type="user" id="userMap"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"/&gt; &lt;result column="address" property="address"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;!-- collection 是用于建立一对多中集合属性的对应关系 ofType 用于指定集合元素的数据类型 --&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="aid" property="id"/&gt; &lt;result column="uid" property="uid"/&gt; &lt;result column="money" property="money"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultMap="userMap"&gt; select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid &lt;/select&gt;&lt;/mapper&gt; collection 部分定义了用户关联的账户信息。表示关联查询结果集property=&quot;accList&quot; ： 关联查询的结果集存储在 User 对象的上哪个属性。ofType=&quot;account&quot; ： 指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 2.5 测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 一对多的操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class UserTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindAll() &#123; //6.执行操作 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println("-------每个用户的内容---------"); System.out.println(user); System.out.println(user.getAccounts()); &#125; &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 3. 实现Role到User的多对多通过前面的学习，我们使用 Mybatis 实现一对多关系的维护。多对多关系其实我们看成是双向的一对多关系。 3.1 用户与角色的关系模型用户与角色的多对多关系模型如下： 在 MySQL 数据库中添加角色表，用户角色的中间表。 角色表 用户角色中间表 3.2 业务要求及实现SQL需求：实现查询所有对象并且加载它所分配的用户信息。分析：查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中间表(USER_ROLE 表)才能关联到用户信息。 下面是实现的 SQL 语句： 1234567891011121314SELECT r.*,u.id uid, u.username username, u.birthday birthday, u.sex sex, u.address addressFROM ROLE rINNER JOIN USER_ROLE urON ( r.id = ur.rid)INNER JOIN USER uON (ur.uid = u.id); 3.3 编写角色实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; public List&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125; public Integer getRoleId() &#123; return roleId; &#125; public void setRoleId(Integer roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleDesc() &#123; return roleDesc; &#125; public void setRoleDesc(String roleDesc) &#123; this.roleDesc = roleDesc; &#125; @Override public String toString() &#123; return "Role&#123;" + "roleId=" + roleId + ", roleName='" + roleName + '\'' + ", roleDesc='" + roleDesc + '\'' + '&#125;'; &#125;&#125; 3.4 编写Role持久层接口1234567891011/*** @author 黑马程序员* @Company http://www.ithiema.com*/public interface IRoleDao &#123; /** * 查询所有角色 * @return */ List&lt;Role&gt; findAll();&#125; 3.5 编写映射文件123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IRoleDao"&gt; &lt;!--定义 role 表的 ResultMap--&gt; &lt;resultMap id="roleMap" type="role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--查询所有--&gt; &lt;select id="findAll" resultMap="roleMap"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt;&lt;/mapper&gt; 3.6 编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** @author 黑马程序员* @Company http://www.ithiema.com*/public class RoleTest &#123; private InputStream in; private SqlSession sqlSession; private IRoleDao roleDao; @Before//用于在测试方法执行之前执行 public void init()throws Exception&#123; //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.获取 SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取 SqlSession 对象 sqlSession = factory.openSession(true); //4.获取 dao 的代理对象 roleDao = sqlSession.getMapper(IRoleDao.class); &#125; @After//用于在测试方法执行之后执行 public void destroy()throws Exception&#123; //提交事务 // sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有 */ @Test public void testFindAll()&#123; List&lt;Role&gt; roles = roleDao.findAll(); for(Role role : roles)&#123; System.out.println("---每个角色的信息----"); System.out.println(role); System.out.println(role.getUsers()); &#125; &#125;&#125; 4. 实现User到Role的多对多4.1 User到Role的多对多从 User 出发，我们也可以发现一个用户可以具有多个角色，这样用户到角色的关系也还是一对多关系。这样我们就可以认为 User 与 Role 的多对多关系，可以被拆解成两个一对多关系来实现。 4.2 实现User到Role的一对多查询需求：实现查询所有用户信息并关联查询出每个用户的角色列表。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis的动态SQL片段]]></title>
    <url>%2F2019%2F05%2F26%2F2019-05-26-Mybatis%E7%9A%84%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[目录 动态SQL之&lt;if&gt;标签 动态SQL之&lt;where&gt;标签 动态标签之&lt;foreach&gt;标签 Mybatis中简化编写的SQL片段 Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL 是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 1. 动态SQL之&lt;if&gt;标签我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果 username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1.1 持久层Dao接口123456/*** 根据用户信息，查询用户列表* @param user* @return*/List&lt;User&gt; findByUser(User user); 1.2 持久层Dao映射配置123456789&lt;select id="findByUser" resultType="user" parameterType="user"&gt; select * from user where 1=1 &lt;if test="username!=null and username != '' "&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test="address != null"&gt; and address like #&#123;address&#125; &lt;/if&gt;&lt;/select&gt; 注意：标签的 test 属性中写的是对象的属性名，如果是包装类的对象要使用 OGNL 表达式的写法。另外要注意 where 1=1 的作用~！ 1.3 测试1234567891011@Testpublic void testFindByUser() &#123; User u = new User(); u.setUsername("%王%"); u.setAddress("%顺义%"); //6.执行操作 List&lt;User&gt; users = userDao.findByUser(u); for(User user : users) &#123; System.out.println(user); &#125; &#125; 2. 动态SQL之&lt;where&gt;标签为了简化上面where 1=1的条件拼装，我们可以采用&lt;where&gt;标签来简化开发。 2.1 持久层Dao映射配置123456789101112&lt;!-- 根据用户信息查询 --&gt;&lt;select id="findByUser" resultType="user" parameterType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="username!=null and username != '' "&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test="address != null"&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3. 动态标签之&lt;foreach&gt;标签3.1 需求传入多个 id 查询用户信息，用下边两个 sql 实现： SELECT FROM USERS WHERE username LIKE ‘%张%’ AND (id =10 OR id =89 OR id=16)SELECT FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。这样我们将如何进行参数的传递？ 3.2 在QueryVo中加入一个List集合用于封装参数1234567891011121314151617/**** &lt;p&gt;Title: QueryVo&lt;/p&gt;* &lt;p&gt;Description: 查询的条件&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class QueryVo implements Serializable &#123; private List&lt;Integer&gt; ids; public List&lt;Integer&gt; getIds() &#123; return ids; &#125; public void setIds(List&lt;Integer&gt; ids) &#123; this.ids = ids; &#125;&#125; 3.3 持久层Dao接口123456/*** 根据 id 集合查询用户* @param vo* @return*/List&lt;User&gt; findInIds(QueryVo vo); 3.4 持久层Dao映射配置123456789101112&lt;!-- 查询所有用户在 id 的集合之中 --&gt;&lt;select id="findInIds" resultType="user" parameterType="queryvo"&gt;&lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="ids != null and ids.size() &gt; 0"&gt; &lt;foreach collection="ids" open="id in ( " close=")" item="uid" separator=","&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; SQL 语句：select 字段 from user where id in (?) &lt;foreach&gt;标签用于遍历集合，它的属性：collection:代表要遍历的集合元素，注意编写时不要写#{}open:代表语句的开始部分close:代表结束部分 item:代表遍历集合的每个元素，生成的变量名sperator:代表分隔符 3.5 编写测试方法12345678910111213141516@Testpublic void testFindInIds() &#123; QueryVo vo = new QueryVo(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(41); ids.add(42); ids.add(43); ids.add(46); ids.add(57); vo.setIds(ids); //6.执行操作 List&lt;User&gt; users = userDao.findInIds(vo); for(User user : users) &#123; System.out.println(user); &#125; &#125; 4. Mybatis中简化编写的SQL片段Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。 4.1 定义代码片段1234&lt;!-- 抽取重复的语句代码片段 --&gt;&lt;sql id="defaultSql"&gt; select * from user&lt;/sql&gt; 4.2 引用代码块12345678910&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="user"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt;&lt;/select&gt;&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="User" parameterType="int"&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; where id = #&#123;uid&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis连接池与事务深入]]></title>
    <url>%2F2019%2F05%2F25%2F2019-05-25-Mybatis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[目录 Mybatis的连接池技术 Mybatis的事务控制 1. Mybatis的连接池技术Mybatis 中也有连接池技术，但是它采用的是自己的连接池技术。在 Mybatis 的 SqlMapConfig.xml 配置文件中，通过&lt;dataSource type=&quot;pooled&quot;&gt;来实现 Mybatis 中连接池的配置。 1.1 Mybatis连接池的分类在 Mybatis 中我们将它的数据源 dataSource 分为以下几类： 可以看出 Mybatis 将它自己的数据源分为三类：UNPOOLED 不使用连接池的数据源POOLED 使用连接池的数据源JNDI 使用 JNDI 实现的数据源具体结构如下： 相应地，MyBatis 内部分别定义了实现了 java.sql.DataSource 接口的 UnpooledDataSource，PooledDataSource 类来表示 UNPOOLED、POOLED 类型的数据源。 在这三种数据源中，我们一般采用的是 POOLED 数据源（很多时候我们所说的数据源就是为了更好的管理数据库连接，也就是我们所说的连接池技术）。 1.2 Mybatis 中数据源的配置我们的数据源配置就是在 SqlMapConfig.xml 文件中，具体配置如下： 1234567&lt;!-- 配置数据源（连接池）信息 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; MyBatis 在初始化时，根据的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 1.3 Mybatis中DataSource的存取MyBatis 是通过工厂模式来创建数据源 DataSource 对象的， MyBatis 定义了抽象的工厂接口:org.apache.ibatis.datasource.DataSourceFactory,通过其 getDataSource()方法返回数据源DataSource。 下面是 DataSourceFactory 源码，具体如下： 12345678910111213package org.apache.ibatis.datasource;import java.util.Properties;import javax.sql.DataSource;/*** @author Clinton Begin*/public interface DataSourceFactory &#123; void setProperties(Properties props); DataSource getDataSource();&#125; MyBatis 创建了 DataSource 实例后，会将其放到 Configuration 对象内的 Environment 对象中， 供以后使用。 具体分析过程如下： 1.先进入 XMLConfigBuilder 类中，可以找到如下代码： 2.分析 configuration 对象的 environment 属性，结果如下： 1.4 Mybatis中连接的获取过程分析当我们需要创建 SqlSession 对象并需要执行 SQL 语句时，这时候 MyBatis 才会去调用 dataSource 对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。 12345678@Testpublic void testSql() throws Exception &#123; InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = factory.openSession(); List&lt;User&gt; list = sqlSession.selectList("findUserById",41); System.out.println(list.size());&#125; 只有当第 4 句sqlSession.selectList(“findUserById”)，才会触发 MyBatis 在底层执行下面这个方法来创建 java.sql.Connection 对象。 如何证明它的加载过程呢？ 我们可以通过断点调试，在 PooledDataSource 中找到如下 popConnection()方法，如下所示： 分析源代码，得出 PooledDataSource 工作原理如下： 下面是连接获取的源代码： 最后我们可以发现，真正连接打开的时间点，只是在我们执行SQL语句时，才会进行。其实这样做我们也可以进一步发现，数据库连接是我们最为宝贵的资源，只有在要用到的时候，才去获取并打开连接，当我们用完了就再立即将数据库连接归还到连接池中。 2. Mybatis的事务控制2.1 JDBC中事务的回顾在 JDBC 中我们可以通过手动方式将事务的提交改为手动方式，通过 setAutoCommit()方法就可以调整。通过 JDK 文档，我们找到该方法如下： 那么我们的 Mybatis 框架因为是对 JDBC 的封装，所以 Mybatis 框架的事务控制方式，本身也是用 JDBC的setAutoCommit()方法来设置事务提交方式的。 2.2 Mybatis中事务提交方式Mybatis 中事务的提交方式，本质上就是调用 JDBC 的 setAutoCommit()来实现事务控制。我们运行之前所写的代码： 1234567891011121314151617181920212223242526272829303132@Testpublic void testSaveUser() throws Exception &#123; User user = new User(); user.setUsername("mybatis user09"); //6.执行操作 int res = userDao.saveUser(user); System.out.println(res); System.out.println(user.getId());&#125;@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.提交事务 session.commit(); //8.释放资源 session.close(); in.close();&#125; 观察在它在控制台输出的结果： 这是我们的 Connection 的整个变化过程，通过分析我们能够发现之前的 CUD 操作过程中，我们都要手动进行事务的提交，原因是 setAutoCommit()方法，在执行时它的值被设置为 false 了，所以我们在 CUD 操作中，必须通过 sqlSession.commit()方法来执行提交操作。 2.3 Mybatis自动提交事务的设置通过上面的研究和分析，现在我们一起思考，为什么 CUD 过程中必须使用 sqlSession.commit()提交事务？主要原因就是在连接池中取出的连接，都会将调用 connection.setAutoCommit(false)方法，这样我们就必须使用 sqlSession.commit()方法，相当于使用了 JDBC 中的 connection.commit()方法实现事务提交。 明白这一点后，我们现在一起尝试不进行手动提交，一样实现 CUD 操作。 1234567891011121314151617181920@Before//在测试方法执行之前执行public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(true); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class);&#125;@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; //7.释放资源 session.close(); in.close();&#125; 所对应的 DefaultSqlSessionFactory 类的源代码： 运行的结果如下： 我们发现，此时事务就设置为自动提交了，同样可以实现CUD操作时记录的保存。虽然这也是一种方式，但就编程而言，设置为自动提交方式为 false再根据情况决定是否进行提交，这种方式更常用。因为我们可以根据业务情况来决定提交是否进行提交。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis输入参数和输出结果封装]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24-Mybatis%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[目录 parameterType配置参数 传递pojo包装对象 resultType配置结果类型 resultMap结果类型 SqlMapConfig.xml配置内容 properties（属性） typeAliases(类型别名) mappers(映射器) 1. parameterType配置参数1.1 使用说明我们在上一章节中已经介绍了 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类，本章节将介绍如何使用实体类的包装类作为参数传递。 1.2 注意事项基 本类 型和 String 我 们可 以直接 写类型 名称 ，也 可以 使用包 名 . 类名的 方式 ，例如 ：java.lang.String。 实体类类型，目前我们只能使用全限定类名。 究其原因，是 mybaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。在今天课程的最后一个章节中将讲解如何注册实体类的别名。 在 mybatis 的官方文档的说明(第 19 页) 这些都是支持的默认别名。我们也可以从源码角度来看它们分别都是如何定义出来的。可以参考 TypeAliasRegistery.class 的源码。 2. 传递pojo包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。 Pojo 类中包含 pojo。 需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。 2.1 编写QueryVo1234567891011121314151617/**** &lt;p&gt;Title: QueryVo&lt;/p&gt;* &lt;p&gt;Description: 查询条件对象&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class QueryVo implements Serializable &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 2.2 编写持久层接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的业务层接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 根据 QueryVo 中的条件查询用户 * @param vo * @return */ List&lt;User&gt; findByVo(QueryVo vo);&#125; 2.3 持久层接口的映射文件1234&lt;!-- 根据用户名称模糊查询，参数变成一个 QueryVo 对象了 --&gt;&lt;select id="findByVo" resultType="com.itheima.domain.User" parameterType="com.itheima.domain.QueryVo"&gt; select * from user where username like #&#123;user.username&#125;;&lt;/select&gt; 2.4 测试包装类作为参数1234567891011@Testpublic void testFindByQueryVo() &#123; QueryVo vo = new QueryVo(); User user = new User(); user.setUserName("%王%"); vo.setUser(user); List&lt;User&gt; users = userDao.findByVo(vo); for(User u : users) &#123; System.out.println(u); &#125;&#125; 3. resultType配置结果类型resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。 我们在前面的 CRUD 案例中已经对此属性进行过应用了。 需要注意的是，它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如：我们的实体类此时必须是全限定类名（今天最后一个章节会讲解如何配置实体类的别名） 同时，当是实体类名称时，还有一个要求，实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。 3.1 基本类型示例3.1.1 Dao接口12345/*** 查询总记录条数* @return*/int findTotal(); 3.1.2 映射配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; select count(*) from user;&lt;/select&gt; 3.2 实体类类型示例3.2.1 Dao接口12345/*** 查询所有用户* @return*/List&lt;User&gt; findAll(); 3.2.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user&lt;/select&gt; 3.3 特殊情况示例3.3.1 修改实体类实体类代码如下：（此时的实体类属性和数据库表的列名已经不一致了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Date getUserBirthday() &#123; return userBirthday; &#125; public void setUserBirthday(Date userBirthday) &#123; this.userBirthday = userBirthday; &#125; public String getUserSex() &#123; return userSex; &#125; public void setUserSex(String userSex) &#123; this.userSex = userSex; &#125; public String getUserAddress() &#123; return userAddress; &#125; public void setUserAddress(String userAddress) &#123; this.userAddress = userAddress; &#125; @Override public String toString() &#123; return "User [userId=" + userId + ", userName=" + userName + ", userBirthday=" + userBirthday + ", userSex=" + userSex + ", userAddress=" + userAddress + "]"; &#125;&#125; 3.3.2 Dao接口12345/*** 查询所有用户* @return*/List&lt;User&gt; findAll(); 3.3.3 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user&lt;/select&gt; 3.3.4 测试查询结果1234567@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125;&#125; 运行结果： 为什么名称会有值呢？ 因为：mysql 在 在 windows 系统中不区分大小写！ 3.3.5 修改映射配置使用别名查询 12345&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select id as userId,username as userName,birthday as userBirthday, sex as userSex,address as userAddress from user&lt;/select&gt; 运行结果： 思考：如果我们的查询很多，都使用别名的话写起来岂不是很麻烦，有没有别的解决办法呢？ 请看下一小节。 4. resultMap结果类型resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 4.1 定义resultMap1234567891011&lt;!-- 建立 User 实体和数据库表的对应关系type 属性：指定实体类的全限定类名id 属性：给定一个唯一标识，是给查询 select 标签引用用的。--&gt;&lt;resultMap type="com.itheima.domain.User" id="userMap"&gt; &lt;id column="id" property="userId"/&gt; &lt;result column="username" property="userName"/&gt; &lt;result column="sex" property="userSex"/&gt; &lt;result column="address" property="userAddress"/&gt; &lt;result column="birthday" property="userBirthday"/&gt;&lt;/resultMap&gt; id 标签：用于指定主键字段result 标签：用于指定非主键字段column 属性：用于指定数据库列名property 属性：用于指定实体类属性名称 4.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt; select * from user&lt;/select&gt; 4.3 测试结果1234567@Testpublic void testFindAll() &#123; List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125;&#125; 运行结果： 5. SqlMapConfig.xml配置内容5.1 SqlMapConfig.xml中配置的内容和顺序1234567891011121314151617-properties （属性） --property-settings（全局配置参数） --setting-typeAliases （类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers （映射器） --mapper --package 6. properties（属性）在使用 properties 标签配置时，我们可以采用两种方式指定属性配置。 6.1 第一种123456&lt;properties&gt; &lt;property name="jdbc.driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbc.url" value="jdbc:mysql://localhost:3306/eesy"/&gt; &lt;property name="jdbc.username" value="root"/&gt; &lt;property name="jdbc.password" value="1234"/&gt;&lt;/properties&gt; 6.2 第二种6.2.1 在classpath下定义da.properties文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/eesyjdbc.username=rootjdbc.password=1234 6.2.2 properties标签配置1234567891011121314&lt;!-- 配置连接数据库的信息resource 属性：用于指定 properties 配置文件的位置，要求配置文件必须在类路径下resource="jdbcConfig.properties"url 属性：URL： Uniform Resource Locator 统一资源定位符http://localhost:8080/mystroe/CategoryServlet URL协议 主机 端口 URIURI：Uniform Resource Identifier 统一资源标识符/mystroe/CategoryServlet它是可以在 web 应用中唯一定位一个资源的路径--&gt;&lt;properties url= file:///D:/IdeaProjects/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.properties"&gt;&lt;/properties&gt; 6.2.3 此时我们的dataSource标签就变成了引用上面的配置123456&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&lt;/dataSource&gt; 7. typeAliases(类型别名)在前面我们讲的 Mybatis 支持的默认别名，我们也可以采用自定义别名方式来开发。 7.1 自定义别名在SqlMapConfig.xml中配置： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="user" type="com.itheima.domain.User"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name="com.itheima.domain"/&gt; &lt;package name=" 其它包 "/&gt;&lt;/typeAliases&gt; 8. mappers(映射器)8.1 &lt;mapper resource=” “使用相对于类路径的资源 如： 1&lt;mapper resource="com/itheima/dao/IUserDao.xml" /&gt; 8.2 &lt;mapper class=” “使用 mapper 接口类路径 如： 1&lt;mapper class="com.itheima.dao.UserDao"/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 8.3 &lt;package name=””注册指定包下的所有 mapper 接口 如： 1&lt;package name="cn.itcast.mybatis.mapper"/&gt; 注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件系统功能设计概述]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 什么是软件功能设计 功能设计在整个软件设计中的层次 功能设计在整个软件设计中的地位 功能设计与设计模式的关系 功能设计与详细设计的关系 功能设计要考虑的东西/评价标准 功能设计的实战方法——经验总结 关于软件设计的一些思考 1. 什么是软件功能设计所谓软件的功能设计，指的是：针对软件中某一个具体的功能，所进行的设计。包括这个功能的实现方式、实现的基本结构、类的组成、职责的划分等。是软件设计中最重要的基本功。 我们看一下一个仿QQ软件所需要设计的功能： 2. 功能设计在整个软件设计中的层次软件设计的层次很多，不同的软件设计过程有不同的划分方式，大致可分为：架构设计、api/spi设计、数据库设计、功能设计、类设计、方法设计。 从难度上说：公共类库&gt;公共框架&gt;基础平台/框架&gt;应用（产品&gt;项目） 3. 功能设计在整个软件设计中的地位功能设计从属详细设计，是整个系统功能实现的基石。 4. 功能设计与设计模式的关系功能设计通常会综合应用多种设计模式，是各种设计思想的具体体现的载体。由于功能千变万化，因而要有较高的设计技巧和功力，才能设计出正确的、易用的、灵活的、扩展性高的、高性能实现。 设计模式是业界公认的，优秀的设计经验和设计理念，理解、掌握、融会贯通、并能熟练变形应用设计模式，对于功能设计是有极大的帮助的。 5. 功能设计与详细设计的关系功能设计只是详细设计中的一个部分，详细设计还包括很多其他的设计，比如：流程设计、对API/SPI的完善和细化、对数据库设计的完善和细化、对多个功能交互的控制、事务的规划、权限/安全的规划、例外的控制……很多很多 6. 功能设计要考虑的东西/评价标准这个业界并没有统一的标准，而且不同类型、不同业务的系统考虑的东西并不一样，但还是有一些通常要考虑的东西： 正确性、易用性、可扩展性、复杂性（易理解、开发难度等）、易维护、安全、性能、可复用、可测试…… 当然还有很多其他需要考虑的，比如：多线程、分布式、可靠性、稳定性、对资源的利用和消耗、可伸缩、可配置、可移植、可定制…… 7. 功能设计的实战方法——经验总结 基本的功能实现方式，并进行细化 分析每个步骤，每个细节中，哪些是可变的，哪些是不可变的。通常分析3个部分：数据输入、具体实现、数据产出。 分析这个细节步骤的功能和其他步骤的关系，比如：顺序、平行、依赖等，以确定这些职责的粒度和分离方式，从而考虑他们之间的组合方式，也需要分离这些组合方式的变与不变。 根据前面分析的结果，进行相应的类、方法的设计、进行职责的划分，并通过合适的方式把他们组织起来。通常这个时候，就会融合进一个或多个设计模式的应用。当然也可能是没有现成的设计模式，需要自己来灵活组织和实现。 按照前面讲述的评价标准，进行系统的思考和调度，以形成最终的设计。 8. 关于软件设计的一些思考 设计的基本技巧：发现和封装变化，进行抽象和封装，实现高内聚和低耦合。 设计就是危险的平衡艺术，尽可能的找到最佳平衡点。 没有完美的设计，设计总是在不断演变中。 设计是没有标准答案的，只要能更好的实现功能，更好的满足那些评价标准，就是好东西。 不要过度设计不等于不设计，而是更要精巧设计。 关于重构的思考 关于敏捷的思考 设计是否增加了复杂度 设计是否增加了软件成本 关于训练功能设计的意义]]></content>
      <categories>
        <category>软件工程</category>
        <category>系统功能设计</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>系统功能设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于代理Dao实现CRUD操作]]></title>
    <url>%2F2019%2F05%2F23%2F2019-05-23-%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%90%86Dao%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[目录 自定义流程再分析 Mybatis环境搭建步骤 根据ID查询 保存操作 用户更新 用户删除 用户模糊查询 查询使用聚合函数 Mybatis与JDBC编程的比较 1. 自定义流程再分析 2. Mybatis环境搭建步骤第一步：创建maven工程 第二步：导入坐标 第三步：编写必要代码（实体类和持久层接口） 第四步：编写SqlMapConfig.xml 第五步：编写映射配置文件 第六步：编写测试类 使用要求： 1、持久层接口和持久层接口的映射配置必须在相同的包下 2、持久层映射配置中mapper标签的namespace属性必须是持久层接口的全限定类名 3、SQL语句的配置标签 ,,, 的id属性必须和持久层接口的方法名相同。 3. 根据ID查询3.1 在持久层接口中添加findById方法123456/*** 根据 id 查询* @param userId* @return*/User findById(Integer userId); 3.2 在用户的映射配置文件中配置1234&lt;!-- 根据 id 查询 --&gt;&lt;select id="findById" resultType="com.itheima.domain.User" parameterType="int"&gt;select * from user where id = #&#123;uid&#125;&lt;/select&gt; 细节： resultType属性：用于指定结果集的类型。 parameterType属性：用于指定传入参数的类型。 sql语句中使用#{ }字符：它代表占位符，相当于原来jdbc中所学的？，都是用于执行语句时替换实际的数据。具体的数据是由#{ }里面的内容决定的。 #{ }中内容的写法：由于数据类型是基本类型，所以此处可以随意写。 3.3 在测试类中添加测试123456789101112131415161718192021222324252627282930313233343536373839404142/**** &lt;p&gt;Title: MybastisCRUDTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的 crud 操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybastisCRUDTest &#123; private InputStream in ; private SqlSessionFactory factory; private SqlSession session; private IUserDao userDao; @Test public void testFindOne() &#123; //6.执行操作 User user = userDao.findById(41); System.out.println(user); &#125; @Before//在测试方法执行之前执行 public void init()throws Exception &#123; //1.读取配置文件 in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.创建 SqlSession 工厂对象 factory = builder.build(in); //4.创建 SqlSession 对象 session = factory.openSession(); //5.创建 Dao 的代理对象 userDao = session.getMapper(IUserDao.class); &#125; @After//在测试方法执行完成之后执行 public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close(); &#125;&#125; 4. 保存操作4.1 在持久层接口中添加saveUser方法123456/*** 保存用户* @param user* @return 影响数据库记录的行数*/int saveUser(User user); 4.2 在用户的映射配置文件中配置12345&lt;!-- 保存用户--&gt;&lt;insert id="saveUser" parameterType="com.itheima.domain.User"&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 细节： parameterType属性：代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。 sql语句中使用#{ }字符：它代表占位符，相当于原来jdbc中所学的？，都是用于执行语句时替换实际的数据。具体的数据是由#{ }里面的内容决定的。 #{ }中内容的写法：由于我们保存方法的参数是一个User对象，此处要写User对象中的属性名称。它用的是ognl表达式。ognl表达式：它是apache提供的一种表达式语言，全称是：Object Graphic Navigation Language 对象图导航语言 它是按照一定的语法格式来获取数据的。语法格式就是使用#{对象.对象}的方式#{user.username}它会先去找user对象，然后在user对象中找到username属性，并调用getUsername()方法把值取出来。但是我们在parameterType属性上指定了实体类名称，所以可以省略user.而直接写username。 4.3 添加测试类中的测试方法123456789101112@Testpublic void testSave()&#123; User user = new User(); user.setUsername("modify User property"); user.setAddress("北京市顺义区"); user.setSex("男"); user.setBirthday(new Date()); System.out.println("保存操作之前："+user); //5.执行保存方法 userDao.saveUser(user); System.out.println("保存操作之后："+user);&#125; 打开 Mysql 数据库发现并没有添加任何记录，原因是什么？ 这一点和 jdbc 是一样的，我们在实现增删改时一定要去控制事务的提交，那么在 mybatis 中如何控制事务提交呢？ 可以使用:session.commit();来实现事务提交。加入事务提交后的代码如下： 1234567@After//在测试方法执行完成之后执行public void destroy() throws Exception&#123; session.commit(); //7.释放资源 session.close(); in.close();&#125; 4.4 问题扩展：新增用户id的返回值新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长 auto_increment 的值返回。 12345678&lt;insert id="saveUser" parameterType="USER"&gt; &lt;!-- 配置保存时获取插入的 id --&gt; &lt;selectKey keyColumn="id" keyProperty="id" resultType="int"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 5. 用户更新5.1 在持久层接口中添加updateUser方法123456/*** 更新用户* @param user* @return 影响数据库记录的行数*/int updateUser(User user); 5.2 在用户的映射配置文件中配置1234&lt;!-- 更新用户 --&gt;&lt;update id="updateUser" parameterType="com.itheima.domain.User"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; 5.3 加入更新的测试方法123456789@Testpublic void testUpdateUser()throws Exception&#123; //1.根据 id 查询 User user = userDao.findById(52); //2.更新操作 user.setAddress("北京市顺义区"); int res = userDao.updateUser(user); System.out.println(res);&#125; 6. 用户删除6.1 在持久层接口中添加deleteUser方法123456/*** 根据 id 删除用户* @param userId* @return*/int deleteUser(Integer userId); 6.2 在用户的映射配置文件中配置1234&lt;!-- 删除用户 --&gt;&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; delete from user where id = #&#123;uid&#125;&lt;/delete&gt; 6.3 加入删除的测试方法123456@Testpublic void testDeleteUser() throws Exception &#123; //6.执行操作 int res = userDao.deleteUser(52); System.out.println(res);&#125; 7. 用户模糊查询7.1 在持久层接口中添加findByName方法123456/*** 根据名称模糊查询* @param username* @return*/List&lt;User&gt; findByName(String username); 7.2 在用户的映射配置文件中配置1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" resultType="com.itheima.domain.User" parameterType="String"&gt; select * from user where username like #&#123;username&#125;&lt;/select&gt; 7.3 加入模糊查询的测试方法12345678@Testpublic void testFindByName()&#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName("%王%"); for(User user : users)&#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 我们在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以 SQL 语句显示为“？”。 7.4 模糊查询的另一种配置方式第一步：修改 SQL 语句的配置，配置如下： 1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" parameterType="string" resultType="com.itheima.domain.User"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。 第二步：测试，如下： 1234567891011/*** 测试模糊查询操作*/@Testpublic void testFindByName()&#123; //5.执行查询一个方法 List&lt;User&gt; users = userDao.findByName("王"); for(User user : users)&#123; System.out.println(user); &#125;&#125; 在控制台输出的执行 SQL 语句如下： 可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行的语句是不一样的。 7.5 #{}与${}的区别#{}表示一个占位符 通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，#{}可以有效防止 sql 注入。 #{}可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。 ${} 表示拼接 sql 串 通过${}可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， ${}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 7.6 模糊查询的${value}源码分析我们一起来看 TextSqlNode 类的源码： 这就说明了源码中指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字了。 8. 查询使用聚合函数8.1 在持久层接口中添加findTotal()方法12345/*** 查询总记录条数* @return*/int findTotal(); 8.2 在用户的映射配置文件中配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt; select count(*) from user;&lt;/select&gt; 8.3 加入聚合查询的测试方法123456@Testpublic void testFindTotal() throws Exception &#123; //6.执行操作 int res = userDao.findTotal(); System.out.println(res);&#125; 9. Mybatis与JDBC编程的比较1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。 解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 3.向sql语句传参数麻烦，因为sql语句的where 条件不一定，可能多也可能少，占位符需要和参数对应。 解决：Mybatis自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。 4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。 解决：Mybatis自动将 sql执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写Mybatis框架]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-22-%E6%89%8B%E5%86%99Mybatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[目录 自定义Mybatis框架的分析 前期准备 基于XML的自定义Mybatis框架 基于注解方式定义Mybatis框架 自定义Mybatis的设计模式说明 1. 自定义Mybatis框架的分析1.1 涉及知识点介绍本章我们将使用前面所学的基础知识来构建一个属于自己的持久层框架，将会涉及到的一些知识点：工厂模式（Factory 工厂模式）、构造者模式（Builder 模式）、代理模式，反射，自定义注解，注解的反射，xml 解析，数据库元数据，元数据的反射等。 1.2 分析流程 2. 前期准备2.1 创建maven工程创建 mybatis02 的工程，工程信息如下： Groupid:com.itheimaArtifactId:mybatis02Packing:jar 2.2 引入相关坐标12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 日志坐标 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解析 xml 的 dom4j --&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dom4j 的依赖包 jaxen --&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 引入工具类到项目中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/*** @author 黑马程序员* @Company http://www.ithiema.com* 用于解析配置文件*/public class XMLConfigBuilder &#123; /** * 解析主配置文件，把里面的内容填充到 DefaultSqlSession 所需要的地方 * 使用的技术： * dom4j+xpath * @param session */ public static void loadConfiguration(DefaultSqlSession session,InputStream config)&#123; try&#123; //定义封装连接信息的配置对象（mybatis 的配置对象） Configuration cfg = new Configuration(); //1.获取 SAXReader 对象 SAXReader reader = new SAXReader(); //2.根据字节输入流获取 Document 对象 Document document = reader.read(config); //3.获取根节点 Element root = document.getRootElement(); //4.使用 xpath 中选择指定节点的方式，获取所有 property 节点 List&lt;Element&gt; propertyElements = root.selectNodes("//property"); //5.遍历节点 for(Element propertyElement : propertyElements)&#123; //判断节点是连接数据库的哪部分信息 //取出 name 属性的值 String name = propertyElement.attributeValue("name"); if("driver".equals(name))&#123; //表示驱动 //获取 property 标签 value 属性的值 String driver = propertyElement.attributeValue("value"); cfg.setDriver(driver); &#125; if("url".equals(name))&#123; //表示连接字符串 //获取 property 标签 value 属性的值 String url = propertyElement.attributeValue("value"); cfg.setUrl(url); &#125; if("username".equals(name))&#123; //表示用户名 //获取 property 标签 value 属性的值 String username = propertyElement.attributeValue("value"); cfg.setUsername(username); &#125; if("password".equals(name))&#123; //表示密码 //获取 property 标签 value 属性的值 String password = propertyElement.attributeValue("value"); cfg.setPassword(password); &#125; &#125; //取出 mappers 中的所有 mapper 标签，判断他们使用了 resource 还是 class 属性 List&lt;Element&gt; mapperElements = root.selectNodes("//mappers/mapper"); //遍历集合 for(Element mapperElement : mapperElements)&#123; //判断 mapperElement 使用的是哪个属性 Attribute attribute = mapperElement.attribute("resource"); if(attribute != null)&#123; System.out.println("使用的是 XML"); //表示有 resource 属性，用的是 XML //取出属性的值 String mapperPath = attribute.getValue();// 获 取 属 性 的 值"com/itheima/dao/IUserDao.xml" //把映射配置文件的内容获取出来，封装成一个 map Map&lt;String,Mapper&gt; mappers = loadMapperConfiguration(mapperPath); //给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); &#125;else&#123; System.out.println("使用的是注解"); //表示没有 resource 属性，用的是注解 //获取 class 属性的值 String daoClassPath = mapperElement.attributeValue("class"); //根据 daoClassPath 获取封装的必要信息 Map&lt;String,Mapper&gt; mappers = loadMapperAnnotation(daoClassPath); //给 configuration 中的 mappers 赋值 cfg.setMappers(mappers); &#125; &#125; //把配置对象传递给 DefaultSqlSession session.setCfg(cfg); &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; try &#123; config.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 根据传入的参数，解析 XML，并且封装到 Map 中 * @param mapperPath 映射配置文件的位置 * @return map 中包含了获取的唯一标识（key 是由 dao 的全限定类名和方法名组成） * 以及执行所需的必要信息（value 是一个 Mapper 对象，里面存放的是执行的 SQL 语句和要封装的实体类全限定类名） */ private static Map&lt;String,Mapper&gt; loadMapperConfiguration(String mapperPath)throws IOException &#123; InputStream in = null; try&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String,Mapper&gt;(); //1.根据路径获取字节输入流 in = Resources.getResourceAsStream(mapperPath); //2.根据字节输入流获取 Document 对象 SAXReader reader = new SAXReader(); Document document = reader.read(in); //3.获取根节点 Element root = document.getRootElement(); //4.获取根节点的 namespace 属性取值 String namespace = root.attributeValue("namespace");//是组成 map 中 key 的部分 //5.获取所有的 select 节点 List&lt;Element&gt; selectElements = root.selectNodes("//select"); //6.遍历 select 节点集合 for(Element selectElement : selectElements)&#123; //取出 id 属性的值 组成 map 中 key 的部分 String id = selectElement.attributeValue("id"); //取出 resultType 属性的值 组成 map 中 value 的部分 String resultType = selectElement.attributeValue("resultType"); //取出文本内容 组成 map 中 value 的部分 String queryString = selectElement.getText(); //创建 Key String key = namespace+"."+id; //创建 Value Mapper mapper = new Mapper(); mapper.setQueryString(queryString); mapper.setResultType(resultType); //把 key 和 value 存入 mappers 中 mappers.put(key,mapper); &#125; return mappers; &#125;catch(Exception e)&#123; throw new RuntimeException(e); &#125;finally&#123; in.close(); &#125; &#125; /** * 根据传入的参数，得到 dao 中所有被 select 注解标注的方法。 * 根据方法名称和类名，以及方法上注解 value 属性的值，组成 Mapper 的必要信息 * @param daoClassPath * @return */ private static Map&lt;String,Mapper&gt; loadMapperAnnotation(String daoClassPath)throws Exception&#123; //定义返回值对象 Map&lt;String,Mapper&gt; mappers = new HashMap&lt;String, Mapper&gt;(); //1.得到 dao 接口的字节码对象 Class daoClass = Class.forName(daoClassPath); //2.得到 dao 接口中的方法数组 Method[] methods = daoClass.getMethods(); //3.遍历 Method 数组 for(Method method : methods)&#123; //取出每一个方法，判断是否有 select 注解 boolean isAnnotated = method.isAnnotationPresent(Select.class); if(isAnnotated)&#123; //创建 Mapper 对象 Mapper mapper = new Mapper(); //取出注解的 value 属性值 Select selectAnno = method.getAnnotation(Select.class); String queryString = selectAnno.value(); mapper.setQueryString(queryString); //获取当前方法的返回值，还要求必须带有泛型信息 Type type = method.getGenericReturnType();//List&lt;User&gt; //判断 type 是不是参数化的类型 if(type instanceof ParameterizedType)&#123; //强转 ParameterizedType ptype = (ParameterizedType)type; //得到参数化类型中的实际类型参数 Type[] types = ptype.getActualTypeArguments(); //取出第一个 Class domainClass = (Class)types[0]; //获取 domainClass 的类名 String resultType = domainClass.getName(); //给 Mapper 赋值 mapper.setResultType(resultType); &#125; //组装 key 的信息 //获取方法的名称 String methodName = method.getName(); String className = method.getDeclaringClass().getName(); String key = className+"."+methodName; //给 map 赋值 mappers.put(key,mapper); &#125; &#125; return mappers; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** @author 黑马程序员* @Company http://www.ithiema.com* 负责执行 SQL 语句，并且封装结果集*/public class Executor &#123; public &lt;E&gt; List&lt;E&gt; selectList(Mapper mapper, Connection conn) &#123; PreparedStatement pstm = null; ResultSet rs = null; try &#123; //1.取出 mapper 中的数据 String queryString = mapper.getQueryString();//select * from user String resultType = mapper.getResultType();//com.itheima.domain.User Class domainClass = Class.forName(resultType);//User.class //2.获取 PreparedStatement 对象 pstm = conn.prepareStatement(queryString); //3.执行 SQL 语句，获取结果集 rs = pstm.executeQuery(); //4.封装结果集 List&lt;E&gt; list = new ArrayList&lt;E&gt;();//定义返回值 while(rs.next()) &#123; //实例化要封装的实体类对象 E obj = (E)domainClass.newInstance();//User 对象 //取出结果集的元信息：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); //取出总列数 int columnCount = rsmd.getColumnCount(); //遍历总列数 for (int i = 1; i &lt;= columnCount; i++) &#123; //获取每列的名称，列名的序号是从 1 开始的 String columnName = rsmd.getColumnName(i); //根据得到列名，获取每列的值 Object columnValue = rs.getObject(columnName); //给 obj 赋值：使用 Java 内省机制（借助 PropertyDescriptor 实现属性的封装） PropertyDescriptor pd = new PropertyDescriptor(columnName,domainClass);//要求：实体类的属性和数据库表的列名保持一种 //获取它的写入方法 Method writeMethod = pd.getWriteMethod();//setUsername(String username); //把获取的列的值，给对象赋值 writeMethod.invoke(obj,columnValue); &#125; //把赋好值的对象加入到集合中 list.add(obj); &#125; return list; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; release(pstm,rs); &#125;&#125; private void release(PreparedStatement pstm,ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; if(pstm != null)&#123; try &#123; pstm.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223/**** &lt;p&gt;Title: DataSourceUtil&lt;/p&gt;* &lt;p&gt;Description: 数据源的工具类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DataSourceUtil &#123; /** * 获取连接 * @param cfg * @return */ public static Connection getConnection(Configuration cfg) &#123; try &#123; Class.forName(cfg.getDriver()); Connection conn = DriverManager.getConnection(cfg.getUrl(),cfg.getUsername() , cfg.getPassword()); return conn; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.4 编写 SqlMapConfig.xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql:///eesy" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1234"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 注意：此处我们直接使用的是 mybatis 的配置文件，但是由于我们没有使用 mybatis 的 jar 包，所以要把配置文件的约束删掉否则会报错（如果电脑能接入互联网，不删也行） 2.5 编写读取配置文件类12345678910111213141516171819/**** &lt;p&gt;Title: Resources&lt;/p&gt;* &lt;p&gt;Description: 用于读取配置文件的类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Resources &#123; /** * 用于加载 xml 文件，并且得到一个流对象 * @param xmlPath * @return * 在实际开发中读取配置文件: * 第一：使用类加载器。但是有要求：a 文件不能过大。 b 文件必须在类路径下(classpath) * 第二：使用 ServletContext 的 getRealPath() */ public static InputStream getResourceAsStream(String xmlPath) &#123; return Resources.class.getClassLoader().getResourceAsStream(xmlPath); &#125;&#125; 2.6 编写 Mapper 类123456789101112131415161718192021222324252627/**** &lt;p&gt;Title: Mapper&lt;/p&gt;* &lt;p&gt;Description: 用于封装查询时的必要信息：要执行的 SQL 语句和实体类的全限定类名&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class Mapper &#123; private String queryString;//sql private String resultType;//结果类型的全限定类名 public String getQueryString() &#123; return queryString; &#125; public void setQueryString(String queryString) &#123; this.queryString = queryString; &#125; public String getResultType() &#123; return resultType; &#125; public void setResultType(String resultType) &#123; this.resultType = resultType; &#125;&#125; 2.7 编写 Configuration 配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** 核心配置类* 1.数据库信息* 2.sql 的 map 集合*/public class Configuration &#123; private String username; //用户名 private String password;//密码 private String url;//地址 private String driver;//驱动 //map 集合 Map&lt;唯一标识，Mapper&gt; 用于保存映射文件中的 sql 标识及 sql 语句 private Map&lt;String,Mapper&gt; mappers; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getDriver() &#123; return driver; &#125; public void setDriver(String driver) &#123; this.driver = driver; &#125; public Map&lt;String, Mapper&gt; getMappers() &#123; return mappers; &#125; public void setMappers(Map&lt;String, Mapper&gt; mappers) &#123; this.mappers = mappers; &#125;&#125; 2.8 编写User实体类1234567891011121314public class User implements Serializable &#123; private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 //省略 getter 与 setter @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", sex=" + sex + ", birthday=" + birthday + ", address=" + address + "]"; &#125;&#125; 3. 基于XML的自定义Mybatis框架3.1 编写持久层接口和 IUserDao.xml12345678910111213/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注意：此处我们使用的也是 mybatis 的配置文件，所以也要把约束删除了 3.2 编写构建者类12345678910111213141516171819/**** &lt;p&gt;Title: SqlSessionFactoryBuilder&lt;/p&gt;* &lt;p&gt;Description: 用于构建 SqlSessionFactory 的&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class SqlSessionFactoryBuilder &#123; /** * 根据传入的流，实现对 SqlSessionFactory 的创建 * @param in 它就是 SqlMapConfig.xml 的配置以及里面包含的 IUserDao.xml 的配置 * @return */ public SqlSessionFactory build(InputStream in) &#123; DefaultSqlSessionFactory factory = new DefaultSqlSessionFactory(); //给 factory 中 config 赋值 factory.setConfig(in); return factory; &#125;&#125; 3.3 编写 SqlSessionFactory 接口和实现类12345678910111213/**** &lt;p&gt;Title: SqlSessionFactory&lt;/p&gt;* &lt;p&gt;Description: SqlSessionFactory 的接口&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface SqlSessionFactory &#123; /** * 创建一个新的 SqlSession 对象 * @return */ SqlSession openSession();&#125; 12345678910111213141516171819/**** &lt;p&gt;Title: DefaultSqlSessionFactory&lt;/p&gt;* &lt;p&gt;Description:SqlSessionFactory 的默认实现 &lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private InputStream config = null; public void setConfig(InputStream config) &#123; this.config = config; &#125; @Override public SqlSession openSession() &#123; DefaultSqlSession session = new DefaultSqlSession(); //调用工具类解析 xml 文件 XMLConfigBuilder.loadConfiguration(session, config); return session; &#125;&#125; 3.4 编写 SqlSession 接口和实现类123456789101112131415161718/**** &lt;p&gt;Title: SqlSession&lt;/p&gt;* &lt;p&gt;Description: 操作数据库的核心对象&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface SqlSession &#123; /** * 创建 Dao 接口的代理对象 * @param daoClass * @return */ &lt;T&gt; T getMapper(Class&lt;T&gt; daoClass); /** * 释放资源 */ void close();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/**** &lt;p&gt;Title: DefaultSqlSession&lt;/p&gt;* &lt;p&gt;Description: SqlSession 的具体实现&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class DefaultSqlSession implements SqlSession &#123; //核心配置对象 private Configuration cfg; public void setCfg(Configuration cfg) &#123; this.cfg = cfg; &#125; //连接对象 private Connection conn; //调用 DataSourceUtils 工具类获取连接 public Connection getConn() &#123; try &#123; conn = DataSourceUtil.getDataSource(cfg).getConnection(); return conn; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 动态代理： * 涉及的类：Proxy * 使用的方法：newProxyInstance * 方法的参数： * ClassLoader：和被代理对象使用相同的类加载器,通常都是固定的 * Class[]：代理对象和被代理对象要求有相同的行为。（具有相同的方法） * InvocationHandler：如何代理。需要我们自己提供的增强部分的代码 */ @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; daoClass) &#123; conn = getConn(); System.out.println(conn); T daoProxy = (T) Proxy.newProxyInstance(daoClass.getClassLoader(),new Class[] &#123;daoClass&#125;, new MapperProxyFactory(cfg.getMappers(),conn)); return daoProxy; &#125; //释放资源 @Override public void close() &#123; try &#123; System.out.println(conn); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //查询所有方法 public &lt;E&gt; List&lt;E&gt; selectList(String statement)&#123; Mapper mapper = cfg.getMappers().get(statement); return new Executor().selectList(mapper,conn); &#125;&#125; 3.5 编写用于创建 Dao 接口代理对象的类12345678910111213141516171819202122232425262728293031323334353637383940414243/**** &lt;p&gt;Title: MapperProxyFactory&lt;/p&gt;* &lt;p&gt;Description: 用于创建代理对象是增强方法&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MapperProxyFactory implements InvocationHandler &#123; private Map&lt;String,Mapper&gt; mappers; private Connection conn; public MapperProxyFactory(Map&lt;String, Mapper&gt; mappers,Connection conn) &#123; this.mappers = mappers; this.conn = conn; &#125; /** * 对当前正在执行的方法进行增强 * 取出当前执行的方法名称 * 取出当前执行的方法所在类 * 拼接成 key * 去 Map 中获取 Value（Mapper) * 使用工具类 Executor 的 selectList 方法 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; //1.取出方法名 String methodName = method.getName(); //2.取出方法所在类名 String className = method.getDeclaringClass().getName(); //3.拼接成 Key String key = className+"."+methodName; //4.使用 key 取出 mapper Mapper mapper = mappers.get(key); if(mapper == null) &#123; throw new IllegalArgumentException("传入的参数有误，无法获取执行的必要条件"); &#125; //5.创建 Executor 对象 Executor executor = new Executor(); return executor.selectList(mapper, conn); &#125;&#125; 3.6 运行测试类1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: MybatisTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的环境&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; //7.释放资源 session.close(); in.close(); &#125;&#125; 4. 基于注解方式定义Mybatis框架4.1 自定义@Select注解1234567891011/**** &lt;p&gt;Title: Select&lt;/p&gt;* &lt;p&gt;Description: 自定义查询注解&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Select &#123; String value();&#125; 4.2 修改持久层接口1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 4.3 修改 SqlMapConfig.xml1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee50"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper class="com.itheima.dao.IUserDao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5. 自定义Mybatis的设计模式说明5.1 工厂模式（SqlSessionFactory） 5.2 代理模式（MapperProxyFactory） 代理模式分为静态和动态代理。静态代理，我们通常都很熟悉。有一个写好的代理类，实现与要代理的类的一个共同的接口，目的是为了约束也为了安全。具体不再多说。 这里主要想说的是关于动态代理。我们知道静态代理若想代理多个类，实现扩展功能，那么它必须具有多个代理类分别取代理不同的实现类。这样做的后果是造成太多的代码冗余。那么我们会思考如果做，才能既满足需求，又没有太多的冗余代码呢？——————动态代理。通过前面的课程我们已经学过了基于 JDK 的动态代理实现方式，今天我们就会使用 JDK 动态代理方式来编写 MapperProxyFactory 类。 动态代理模型图： 5.3 构建者模式（SqlSessionFactoryBuilder） 具体设计模式的模型图如下： 从图中我们可以看出，创建者模式由四部分组成。 抽象创建者角色：给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体创建者角色。具体创建者必须实现这个接口的两种方法：一是建造方法，比如图中的 buildPart1 和 buildPart2 方法；另一种是结果返回方法，即图中的 getProduct 方法。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少零件，就有多少相应的建造方法。 具体创建者角色：他们在应用程序中负责创建产品的实例。这个角色要完成的任务包括：1、实现抽象创建者所声明的抽象方法，给出一步一步的完成产品创建实例的操作。2、在创建完成后，提供产品的实例。 导演者角色：这个类调用具体创建者角色以创建产品对象。但是导演者并没有产品类的具体知识，真正拥有产品类的具体知识的是具体创建者角色。 产品角色：产品便是建造中的复杂对象。一般说来，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以使不相关联的。 5.4 小结通过自定义 Mybatis 框架的学习，我们将前面的基础知识很好的结合在一起，并且强化了我们的设计模式及使用。希望大家能够抽时间多练习，这也是系统架构师的必由之路。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件项目需求分析到详细设计]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%88%B0%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[目录 软件生命周期 需求分析 详细设计 1. 软件生命周期1.1 什么是软件生命周期软件生命周期又称为软件生存周期或系统开发生命周期，是指从软件的产生直到报废的整个过程。 软件生命周期过程包括： 问题定义： 用户需要计算机解决的问题是什么？ 电商系统：要计算机实现一个平台，商家通过平台销售自己的商品，一般用户通过平台购买商品。 可行性分析 用户需要计算机解决的问题是否可行？需要进行可行性分析。 市场可行性分析，是否有市场价值。 技术可行性分析，使用什么技术解决用户提出的问题。 需求分析（重点） 将用户提出的问题进行细化。 先确定大模块：比如电商系统包括：前台（用户购买商品），后台（商家维护商品）。 对每一个大模块进行细化。。。。。 直到细化到不能细化为止（可以对需求分析的结果进行设计 ）。 设计（次重点） 确定细化问题的实现方法（比如：要设计什么接口，设计功能什么技术实现。。。）。 编码 去解决问题，依据需求和设计 文档进行开发。 测试 验证是否已经解决用户提出的问题。 单元测试（通过在开发阶段由开发人员进行测试）。 集成测试（测试业务整体流程）。 功能用例测试（对每个细化 的功能点进行测试）。 性能测试(使用专业工具进行压力和稳定性测试)。 维护（占整个软件生命周期很大的比重） 修改性维护：前期没有测试出的问题，正式上线运行后bug（缺陷）显示出来了，对这些bug进行修改。 完善性维护：在现有功能的基础上增加或完善功能。 预防性维护：后期根据正式运行的情况对系统进行优化，避免一些问题的发生。 1.2 常用的开发模型企业开发中对上边开发阶段常使用一些模型： 1.2.1 瀑布模型 强调：开发的每个阶段是顺序执行，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈（为了解决问题需要重复执行），如何在某个阶段出现问题，需要从上一个阶段甚至更早的阶段去解决排查问题。 适用场合：需求明确，解决方案明确，常在一些中小型项目中使用。 1.2.2 原型模型 强调：逐步求精（每一次修改对上次原型的完善）对原型 进行修改优化，开发阶段围绕着原型（当成样品）进行实施。 适用场合：前期需求不确定，采用原型方法方便搜集需求。 1.2.3 增量模型 增量模型：瀑布模型加上原型模型，增量模型融合了瀑布模型的基本成分（重复应用）和原型实现的迭代特征。 每一次增量经过了开发的每一个阶段（瀑布模型经过的所有阶段） 每一次增量对功能进行完善（原型模型的逐步求精） 适用场合：大型项目，需求不明确。 2. 需求分析（重点）2.1 什么是需求分析需求分析是在问题定义及可行性分析完成后细化用户对软件的功能和性能的要求，即用户希望软件能做什么事情，完成什么样的功能，达到什么性能。 包括：需求调研、需求描述（重要）、需求评审。 重要性：需求分析是软件工发的开端，我们设计的软件产品存在不完整性、不正确性大部分原因是需求分析错误所导致的，因此，需求分析是软件生命周期中最重要的过程。 2.2 需求调研目标：挖掘用户需求 过程：首先确定目标用户，开发人员和目标用户确定一个问题领域，并定义一个描述该问题的系统，用户在这个问题领域和系统下提出需求，需求类型包括：功能需求、质量需求、用户体验需求等。 需求调研方法： 根据不同的项目、不同的用户群体采用不同的方法： 与客户交谈，向用户提问题 参观用户工作流程，观察用户操作 向用户发调查问卷（通常是以选择题和是非题为主） 与同行、专家交谈，听取他们的意见 分析已经存在的软件产品，提取需求 从行业标准、规划中提取需求 上网搜索相关资料 成果物：需求调研报告.doc 2.3 需求描述(重要)通过需求调研对收集到的资料进行分析、鉴别、综合和建模，清除用户需求的模糊性、歧义性和不一致性，分析系统的数据要求，为原始问题及目标软件建立逻辑模型。 分析人员需要编写“软件需求说明书”并与用户进行交流确认。 成果物：“软件需求说明书”或“软件需求规格说明书” 重要性： 需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书 软件开发人员需要根据“软件需求规格说明书”进行设计和编码。 软件需求规格说明书的内容也是根据公司的项目管理水平而定。 内容基本包括：系统概述、运行环境、功能模块图、功能用例、性能需求、接口需求、其它需求等。 功能模块图/功能架构图：通常使用visio画。 使用powerDesigner画用例图： 描述 了每类用户所操作的功能点。 功能用例： 描述功能点的具体内容。 接口需求： 系统对外接口： 接口描述内容：商品支付接口 接口功能描述： 电商网站需要调用网银支付接口进行支付 接口方向： 电商网站–&gt;网银 接口协议：https 接口数据描述(重点)： 开发人员依据接口数据描述开发程序。 电商网站要向网银发送什么数据格式（常用格式有xml或json） （包括请求和响应两部分数据） 建议：企业开发必须经过正规的需求分析过程。 2.4 需求评审由架构师、技术经理、需求分析人员、设计人员、开发人员对“需求规格说明书”进行审核。 审核内容： 1、看需求规格说明书是否符合文档规范。 2、需求描述 是否详细（设计人员可以依据需求说明书进行设计） 3 设计根据软件需求说明书进行设计，设计系统整体架构、系统外部和内部接口、实现算法和核心代码编写等，总之包括两个阶段：总体设计（概要设计 ）、详细设计。 3.1 概要设计概要设计内容： 总体结构和模块间的关系； 系统架构包括：技术架构和功能架构。 技术架构： 系统使用什么技术完成哪些模块的功能。 javaEE常用技术架构： ssh：struts2+spring+hibernate 主要开发中小型的传统企业应用系统。 ssm：springmvc+mybatis 主要开发分布式联系网项目。 功能架构 就是需求描述的功能框图 业务流程图： 使用visio画核心业务流程图： 系统网络部署结构 定义系统的外部接口、及模块间的接口； 接口描述内容：商品支付接口 接口功能描述： 电商网站需要调用网银支付接口进行支付 接口方向： 电商网站–&gt;网银 接口协议：https 接口数据描述(重点)： 开发人员依据接口数据描述开发程序。 电商网站要向网银发送什么数据格式（常用格式有xml或json） （包括请求和响应两部分数据） 3.2 详细设计详细设计内容： ​ 详细设计的主要任务是设计每个模块的类接口、所需的局部数据结构、物理数据模型、页面原型等。 注意：一般情况下公司根据人力现状不写详细设计文档的，可以在需求分析阶段和概要设计 阶段对详细设计的内容进行描述。 每个模块的类接口： 通过伪代码实现，描述接口参数、接口功能。 局部数据结构：需要自定义什么数据类型。。 物理数据模型（重点）： 使用powerDesigner设计物理数据模型(根据公司要求可能在需求分析阶段或概要设计 阶段实现) 通过powerDesigner创建数据库表、存储过程等元素。]]></content>
      <categories>
        <category>软件工程</category>
        <category>需求分析与详细设计</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>需求分析</tag>
        <tag>详细设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架快速入门]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21-Mybatis%E6%A1%86%E6%9E%B6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[目录 Mybatis框架开发的准备 搭建Mybatis开发环境 小结 基于注解的Mybatis使用 1. Mybatis框架开发的准备1.1 官网下载 Mybatis 框架从百度中“mybatis download”可以下载最新的 Mybatis 开发包。 进入选择语言的界面，进入中文版本的开发文档。 我们可以看到熟悉的中文开发文档了。 下载相关的 jar 包或 maven 开发的坐标。 下载的 zip 文件如下 我们所使用的 Mybatis 版本是 3.4.5 版本。 2. 搭建 Mybatis 开发环境2.1 创建maven工程创建 mybatis01 的工程，工程信息如下： Groupid:com.itheimaArtifactId:mybatis01Packing:jar 2.2 添加 Mybatis3.4.5 的坐标在 pom.xml 文件中添加 Mybatis3.4.5 的坐标，如下： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 编写User实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User [id=" + id + ", username=" + username + ", birthday=" + birthday + ", sex=" + sex + ", address=" + address + "]"; &#125;&#125; 2.4 编写持久层接口IUserDaoIUserDao 接口就是我们的持久层接口（也可以写成 UserDao 或者 UserMapper）,具体代码如下： 12345678910111213/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ List&lt;User&gt; findAll();&#125; 2.5 编写持久层接口的映射文件IUserDao.xml要求： 创建位置：必须和持久层接口在相同的包中。 名称：必须以持久层接口名称命名文件名，扩展名是.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultType="com.itheima.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.6 编写 SqlMapConfig.xml 配置文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置 mysql 的环境 --&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee50"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="1234"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 --&gt; &lt;mappers&gt; &lt;mapper resource="com/itheima/dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.7 编写测试类1234567891011121314151617181920212223242526272829/**** &lt;p&gt;Title: MybatisTest&lt;/p&gt;* &lt;p&gt;Description: 测试 mybatis 的环境&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建 SqlSessionFactory 的构建者对象 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //3.使用构建者创建工厂对象 SqlSessionFactory SqlSessionFactory factory = builder.build(in); //4.使用 SqlSessionFactory 生产 SqlSession 对象 SqlSession session = factory.openSession(); //5.使用 SqlSession 创建 dao 接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //6.使用代理对象执行查询所有方法 List&lt;User&gt; users = userDao.findAll(); for(User user : users) &#123; System.out.println(user); &#125; //7.释放资源 session.close(); in.close(); &#125;&#125; 3. 小结通过快速入门示例，我们发现使用 mybatis 是非常容易的一件事情，因为只需要编写 Dao 接口并且按照mybatis 要求编写两个配置文件，就可以实现功能。远比我们之前的 jdbc 方便多了。（我们使用注解之后，将变得更为简单，只需要编写一个 mybatis 配置文件就够了。） 但是，这里面包含了许多细节，比如为什么会有工厂对象（SqlSessionFactory）,为什么有了工厂之后还要有构建者对象（SqlSessionFactoryBuilder），为什么 IUserDao.xml 在创建时有位置和文件名的要求等等。 这些问题我们在自定义 mybatis 框架的章节，通过层层剥离的方式，给大家讲解。 请注意：我们讲解自定义 Mybatis 框架，不是让大家回去自己去写个 mybatis，而是让我们能更好了了解mybatis 内部是怎么执行的，在以后的开发中能更好的使用 mybatis 框架，同时对它的设计理念（设计模式）有一个认识。 4. 基于注解的 Mybatis 使用4.1 在持久层接口中添加注解1234567891011121314/**** &lt;p&gt;Title: IUserDao&lt;/p&gt;* &lt;p&gt;Description: 用户的持久层操作&lt;/p&gt;* &lt;p&gt;Company: http://www.itheima.com/ &lt;/p&gt;*/public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") List&lt;User&gt; findAll();&#125; 4.2 修改 SqlMapConfig.xml1234&lt;!-- 告知 mybatis 映射配置的位置 --&gt;&lt;mappers&gt; &lt;mapper class="com.itheima.dao.IUserDao"/&gt;&lt;/mappers&gt; 4.3 注意事项在使用基于注解的 Mybatis 配置时，请移除 xml 的映射配置（IUserDao.xml）。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis框架概述]]></title>
    <url>%2F2019%2F05%2F20%2F2019-05-20-Mybatis%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[目录 什么是框架 JDBC编程的分析 1. 什么是框架1.1 什么是框架框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 简而言之，框架其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 1.2 框架要解决的问题框架要解决的最重要的一个问题是技术整合的问题，在 J2EE 的 框架中，有着各种各样的技术，不同的软件企业需要从 J2EE 中选择不同的技术，这就使得软件企业最终的应用依赖于这些技术，技术自身的复杂性和技术的风险性将会直接对应用造成冲击。而应用是软件企业的核心，是竞争力的关键所在，因此应该将应用自身的设计和具体的实现技术解耦。这样，软件企业的研发将集中在应用的设计上，而不是具体的技术实现，技术实现是应用的底层支撑，它不应该直接对应用产生影响。 框架一般处在低层应用平台（如 J2EE）和高层业务逻辑之间的中间层 。 1.3 软件开发的分层重要性框架的重要性在于它实现了部分功能，并且能够很好的将低层应用平台和高层业务逻辑进行了缓和。为了实现软件工程中的“高内聚、低耦合”。把问题划分开来各个解决，易于控制，易于延展，易于分配资源。 我们常见的MVC 软件设计思想就是很好的分层思想。 1.4 分层开发下的常见框架 1.5 MyBatis 框架概述mybatis是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 mybatis通过 xml 或注解的方式将要执行的各种statement配置起来，并通过java对象和statement 中sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。 采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc进行了封装，屏蔽了 jdbc api 底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 为了我们能够更好掌握框架运行的内部过程，并且有更好的体验，下面我们将从自定义 Mybatis 框架开始来学习框架。此时我们将会体验框架从无到有的过程体验，也能够很好的综合前面阶段所学的基础。 2. JDBC 编程的分析2.1 jdbc 程序的回顾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123; Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName("com.mysql.jdbc.Driver"); //通过驱动管理类获取数据库链接 connection = DriverManager .getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8","root", "root"); //定义 sql 语句 ?表示占位符 String sql = "select * from user where username = ?"; //获取预处理 statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为 sql 语句中参数的序号（从 1 开始），第二个参数为设置的参数值 preparedStatement.setString(1, "王五"); //向数据库发出 sql 执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString("id")+" "+resultSet.getString("username")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 上边使用 jdbc 的原始方法（未经封装）实现了查询数据库表记录的操作。 2.2 jdbc 问题分析1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。2、Sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java代码。3、使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。4、对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo 对象解析比较方便。]]></content>
      <categories>
        <category>Java</category>
        <category>SSM框架</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM框架</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（下）]]></title>
    <url>%2F2019%2F03%2F21%2F2019-03-21-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（中）的学习，小艾对MySQL的多表查询有了更深刻的了解，掌握前面的内容，其实对于我们一般的开发也就足够了，今天就学习MySQL原理性一点的内容。 目录 存储引擎 事务 索引 视图 DBA命令 数据库设计三大范式 1. 存储引擎 存储引擎是MySQL特有的，其它数据库没有 1.1 存储引擎的本质 通过采用不同的技术将数据存储在文件或内存中； 每一种技术都有不同的存储机制，不同的存储机制提供不同的功能和能力； 通过选择不同的技术，可以获得额外的速度或功能，改善我们的应用； 1.2 MySQL支持很多种存储引擎常见命令： 1.2.1.show engines\G (1)在创建表时，可使用Engine选项为CREATE TABLE语句显示指定存储引擎 例如： 123CREATE TABLE table_name( NO INT)ENGINE = MyISAM; (2)如果创建表时没有指定存储引擎，则使用当前默认的存储引擎； (3)默认的存储引擎可在 my.ini 配置文件中使用 default-storage-engin 选项指定； (4)修改表的存储引擎使用：ALTER TABLE 表名 ENGINE = 存储引擎名称; (5)查看表使用的存储引擎，命令如下： SHOW CREATE TABLE emp\G; SHOW TABLE STATUS LIKE ‘emp’\G; 1.3 常用的存储引擎1.3.1 MyISAM存储引擎MyISAM引擎是MySQL数据库最常用的； 它管理的表具有以下特性： 使用三个文件表示每个表： 格式文件 — 存储表的结构（mytable.frm）数据文件 — 存储表的数据（mytable.MYD）索引文件 — 存储表的索引（mytable.MYI） 可转换为压缩、只读表来节省空间 1.3.2 InnoDB存储引擎InnoDB存储引擎是MySQL数据库的缺省引擎； 它管理的表具体有以下特征： a) 每个InnoDB表在数据库目录中以.frm格式文件表示b) InnoDB表空间tablespace被用亍存储表的内容c) 提供一组用来记录事务性活劢的日志文件d) 用COMMIT（提交）、SAVEPOINT及ROLLBACK（回滚）支持事务处理e) 提供全部ACID兼容f) 在MySQL服务器崩溃后提供自劢恢复g) 多版本（MVCC）和行级锁定h) 支持外键及引用的完整性，包括级联更新和删除 1.3.3 MEMORY存储引擎使用MEMORY存储引擎的表，因为数据存储在内存中，且行的长度固定，所以使得MEMORY存储引擎非常快； MEMORY存储引擎管理的表具有下列特征： a) 在数据库目录内，每个表均以.frm格式文件表示；b) 表数据及索引被存储在内存中；c) 表级锁机制；d) 字段属性不能包含TEXT戒BLOB字段； MEMORY存储引擎以前被称为HEAP引擎； 1.4 选择合适的存储引擎MyISAM表最适合于大量的数据读而少量数据更新的混合操作。MyISAM表的另一种适用情形是使用压缩的只读表。 如果查询中包含较多的数据更新操作，应使用InnoDB。其行级锁机制和多版本的支持为数据读取和更新的混合提供了良好的并发机制。 使用MEMORY存储引擎存储非永丽需要的数据，戒者是能够从基于磁盘的表中重新生成的数据。 2. 事务2.1 事务是什么（5点） 一个最小的不可再分的工作单元； 通常一个事务对应一个完整的业务；（如：银行转账业务） 而一个完整的业务需要批量的DML（insert、update、delete）语句共同完成 事务只和DML语句有关系，戒者说叧有DML语句才有事务； 以上所描述的批量DML语句共有多少DML诧句，这个和业务逻辑有关系，业务逻辑不同DML语句个数不同 ； 2.1.1 关与银行转账业务银行转账业务：是一个完整的业务，最小的单元，不可再分，也就是说银行转账业务是一个完整的事务。 示例：账户转账 t_act账户表：actno，balance actno balance act-001 50000.0 act-002 10000.0 act-001转10000.0给act-002，操作如下： update t_act set balance = 40000.0 where actno = ‘act-001’; update t_act set balance = 20000.0 where actno = ‘act-002’; 分析： （1）以上两条DML语句必须同时成功或者同时失败，因为它为最小业务单元，不可拆分； （2）当第一条DML语句执行成功之后，并不能将底层数据库中的第一个账户的数据修改，而是将操作记录了一下，这个记录是在内存中完成的。 （3）当第二条DML与句执行成功之后，和底层数据库文件中的数据完成同步。 （4）若第二条DML语句执行失败，将清空所有的历史操作记录。 结论：要完成以上功能，必须借助事务 transaction。 2.2 概述事务可以保证多个操作原子性，要举全成功，要举全失败。对亍数据库来说，事务保证批量的DML要举全成功，要么全失败。 2.2.1 事务具有四个特征ACID：（1）原子性（Atomicity）事务是最小单元，不可再分； （2）一致性（Consistency）事务要求所有的DML语句操作的时候，必须保证同时成功或同时失败； （3）隔离性（Isolation）一个事务不会影响其它事务的运行； （4）持久性（Durability）在事务完成之后，该事务对数据库所作的更改将持久地保存在数据库中，并不会被回滚； 2.2.2 事务中的一些概念（1）开启事务：start transaction （2）结束事务：end transaction （3）提交事务：commit transaction （4）回滚事务：rollback transaction 2.3.3 和事务有关的两条SQL语句【TCL】COMMIT； 提交 ROLLBACK； 回滚 2.3.4 事务开启和结束的标志是什么 ？开始的标志 任何一条DML语句执行，标志事务的开启； 结束的标志 提交（commit）或者回滚（rollback） 提交：成功的结束，将所有的DML与句操作记录和底层硬盘文件中数据进行一次同步； 回滚：失败的结束，将所有DML语句操作记录全部清空； 2.3.5 重点（1）在事务进行过程中，未结束之前，DML语句是不会修改底层数据库文件中的数据。 （2）叧是将历史操作记录一下，在内存中完成记录。 （3）叧有在事务结束的，而且是成功结束的时候才会修改底层硬盘文件中的数据。 2.3.6 MySQL事务的提交和回滚的演示MySQL默认事务：自劢提交 show variables like ‘%commit%’; 在MySQL数据库管理系统中，默认情况下，事务是自动提交的；也就是说，叧要执行一条DML语句，就开启了事务，并且提交了事务； 第一种：关闭MySQL事务自动提交 事务成功用法：start transaction；commit; 第一步：start transaction; 手动开启事务第二步：DML语句…. 执行批量DML语句 .第三步：commit; 手动提交事务【事务成功结束】 演示例子：在t_user表中插入数据：事务成功提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询原表数据 第二步：窗口1，手动开启事务 start transaction，插入数据，查询数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，手动提交事务commit 第五步：窗口2，查询 t_user 表 回滚提交用法：start transaction; rollback;第一步：start transaction; 手动开启事务第二步：DML语句….. 批量DML语句 演示例子：在 t_user表中插入数据，事务失败提交 准备：窗口1—创建 t_user表：id为自增主键，name varchar(32) 第一步：窗口1，查询 t_user 表数据 第二步：窗口1，开启事务start transaction，并向t_user表插入数据 第三步：窗口2，查询 t_user表数据 第四步：窗口1，rollback 回滚事务，并查询t_user表数据 第五步：窗口2，查询t_user表数据 第二种：关闭MySQL事务自动提交：只对当前会话有效 两种关闭自动提交事务a） set autocommit = offb） set session autocommit = off 两种打开自动提交事务a） set autocommit = onb） set session autocommit = on注：以上打开或关闭事务只对当前窗口有效； 查询事务状态： show variables like &#39;%commit%&#39;; 2.3.7 事务的隔离级别事务四个特性ACID之一：隔离性（isolation） 隔离性有四个隔离级别： 1） read uncommitted 读未提交2） read committed 读已提交3） repeatable read 可重复读4） serializable 串行化 read committed 读未提交（级别最低） 1） 事务A和和事务B，事务A未提交的数据，事务B可以读取2） 这里读取到的数据可以叫做“脏数据”或“脏读 Dirty Read”3） 读未提交隔离级别最低，这种级别一般只在理论上存在，数据库默认隔离级别一般都高于该隔离级别； read committed 读已提交 1） 事务A和事务B，事务A提交的数据，事务B才可读取到；2） 该隔离级别高于“读未提交”级别3） 换句话说：对方事务提交之后的数据，当前事务才可读取到。4） 该隔离级别可以避免脏数据；5） 该隔离级别能够导致“不可重复读取”6） Oracle数据库管理系统默认隔离级别为“可重复读” repeatable read 可重复读 1） 事务A和事务B，事务A提交之后的数据，事务B读取不到2） 事务B是可重复读到数据的3） 这种隔离级别高于“读已提交”4） 换句话说，对方提交之后的数据，还是读取不到5） 这种隔离级别可以避免“脏读和不可重复读”，达到“重复读取”；6） MySQL数据库管理系统默认隔离级别为：可重复读7） 虽然可以达到“可重复读”效果，但是会导致“幻象读” serializable 串行化 1） 事务A和事务B，事务A在操作数据库表中数据的时候，事务B叧能排队等待；2） 这种事务隔离级别一般很少使用，吞吐量太低，用户体验不好；3） 这种隔离级别可以避免“幻象读”，每一次读取都是数据库表中真实的记录；4） 事务A和事务B不再并发； 查看隔离级别 1） 查看当前会话级隔离级别select @@tx_isolation;select @@session.tx_isolation; 2） 查看当前全局隔离级别： @@global.tx_isolation;select @@global.tx_isolation; 设置服务器缺省隔离级别 第一种：修改my.ini配置文件在 my.ini 文件中的[mysqld]下面添加：————————-my.ini——————————-[mysqld]transaction-isolation = READ-COMMITTED————————–my.ini——————————-a） 隔离级别可选项为：– READ-UNCOMMITTED– READ-COMMITTED– REPEATABLE-READ– SERIALIZABLE 第二种：通过命令方式设置事务隔离级别a） SET TRANSACTION ISOLATION LEVEL isolation-level;b） isolation-level 可选值：– READ UNCOMMITTED– READ COMMITTED– REPEATABLE READ– SERIALIZABLE 设置隔离级别作用的范围 1） 事务隔离级别的作用范围分为两种：会话级、全局级a） 会话级（session）：叧对当前会话有效b） 全局级（global）：对所有会话有效2） 使用方法如下 a） 会话级：SET TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;SET SESSION TRANSACTION ISOLATION LEVEL ISOLATION-LEVEL;b） 全局级SET GLOBAL TRANSACTION ISOLATION LEVEL; 隔离级别不一致性问题的关系 隔离级别 脏读 不可重复读 幻象读 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 不可能 可能 串行化 不可能 不可能 不可能 隔离级别不一致性问题的关系 1） 读未提交 READ UNCOMMITTED 会话一 会话二 set global transaction isolation level read uncommitted; 退出DOS窗口 use bjpowernode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpowernode; start transaction; start transaction; insert into t_user(name) values(‘king’); select * from t_user; 2） 读已提交 READ COMMITTED 会话一 会话二 set global transaction isolation level read committed; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; insert into t_user(name) values(‘allen’); select * from t_user; commit; select * from t_user; 3） 可重复读 REPEATABLE READ 会话一 会话二 set global transaction isolation level repeatable read; 退出DOS窗口 use bjpownode;Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32)); use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; 4） 串行化 SERIALIZABLE 会话一 会话二 use bjpowernode; Drop table if exists t_user;create table t_user(no int(3) primary key auto_increment,name varchar(32));insert into t_user(name) values(‘zhangsan’);insert into t_user(name) values(‘lisi’); set global transaction isolation level serializable; 退出DOS窗口 use bjpownode; use bjpownode; start transaction; start transaction; select * from t_user; select * from t_user; insert into t_user(name) values(‘allen’); select * from t_user; commit; 3.索引3.1 索引原理3.1.1 什么索引索引对应的英语单词：index 索引作用： 相当于一本字典目录，提高程序的检索 / 查询效率；表中每一个字段都可添加索引 主键自动添加索引： 能够通过主键查询的尽量通过主键查询，效率较高； 索引和表相同，存储在硬盘文件中 索引和表相同，都是一个对象，表是存储在硬盘文件中的，那举索引也是表的一部分，索引也存储在硬盘文件中； MySQL数据库中表的检索方式有2种： 第一种：全表扫描（效率较低） 举例：查询ename=’KING’假设有一张表：emp 员工表，select from emp where ename = ‘KING’;若ename没有添加索引，那举通过ename过滤数据的时候，ename字段会全表扫描；假设有一张表：dept 部门表，select from dept where dname = ‘ACCOUNTING’；若dname没有添加索引，那举通过dname过滤数据的时候，dname字段会全表扫描； 第二种：通过索引检索（提高查询效率） 3.1.2 什么情况下适合给表中字段添加索引1） 该字段数据量庞大2） 该字段很少的DML操作（由亍索引也需要维护，DML操作多的话，也影响检索效率）3） 该字段经常出现在where条件中注：实际开发中会根据项目需求或客户需求等综合因素来做调整 3.1.3 索引的应用创建索引 1） 语法结构：a） create index 索引名 on 表名（列名）b） create unique index 索引名 on 表名（列名）注：添加unique表示在该表中的该列添加一个唯一性约束示例：create index dept_dname_index on dept(dname); 查看索引 1） 语法结构：a） show index from 表名示例：show index from dept; 删除索引 1） 语法结构：a） drop index 索引名 on 表名;示例：drop index dept_dname_index on dept; 4.视图4.1 什么是视图1） 视图对应英文单词：view2） 视图在数据库管理系统中也是一个对象，也是以文件形式存在的3） 视图也对应了一个查询结果，叧是从不同的角度查看数据 4.2 创建视图语法结构：create view 视图名称 as 查询语句； 例子：从emp表查询empno,ename,sal，结果当作视图展示 4.3 删除视图语法结构：drop view if exists 视图名称; 示例：删除myview视图：drop view if exists myview; 4.4 修改视图语法结构：alter view 视图名称 as 查询语句 示例：将myview视图修改为deptno,ename,job,sal 4.5 视图作用4.5.1 面向视图查询，可以提高查询效率例如 1） 单独执行：select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;2） 将上面执行结果当作视图对象创建create view myview as select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;3） 面向视图查询：没有迚行表连接，提高检索效率select * from myview;【非常重要】隐藏表的实现细节 1、 create view myview as select empno a,ename b,sal c from emp;2、面向视图查询，叧知道myview视图中有a,b,c三个字段，不知道该视图背后真实表的结构是什么 5.DBA命令5.1 新建用户CREATE USER username IDENTIFIED BY ‘password’; username：你将创建的用户名,password：该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.示例：create user p361 identified by ‘123’;–可以登录但是只可以看见一个库 information_schema 5.2 授权命令详解 示例：grant all privileges on dbname.tbname to ‘username‘@’login ip’ identified by ‘password’ with grant option; 1) dbname=表示所有数据库2) tbname=表示所有表3) login ip=%表示任何ip4) password为空，表示不需要密码即可登录5) with grant option; 表示该用户还可以授权给其他用户细粒度授权1、首先以root用户进入mysql2、然后键入命令：grant select,insert,update,delete on . to p361 @localhost Identified by “123”;3、如果希望该用户能够在任何机器上登陆mysql，则将localhost改为 “%” 。 粗粒度授权我们测试用户一般使用该命令授权：GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123”;注意：用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:GRANT ALL PRIVILEGES ON . TO ‘p361‘@’%’ Identified by “123” WITH GRANT OPTION;用户权限privileges包括：1） alter：修改数据库的表2） create：创建新的数据库戒表3） delete：删除表数据4） drop：删除数据库/表5） index：创建/删除索引6） insert：添加表数据7） select：查询表数据8） update：更新表数据9） all：允许任何操作10） usage：叧允许登录 5.3 回收授权命令详解 revoke privileges on dbname[.tbname] from username;revoke all privileges on . from p361; use mysqlselect * from user进入 mysql库中修改密码; update user set password = password(‘qwe’) where user = ‘p646’;刷新权限;flush privileges 5.4 导入导出导出：mysqldump 导出整个数据库C: \Administrator&gt; mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p123导出指定库下的指定表C: \Administrator&gt;mysqldump bjpowernode emp&gt; D:\ bjpowernode.sql -uroot -p123 导入：source 登录MySQL数据库管理系统之后执行：mysql&gt;source D:\ bjpowernode.sql 6.数据库设计三范式定义：设计数据库的时候所依据的规范，共有三个规范； 6.1 第一范式：主键、字段不能再分定义：要求有主键，数据库中不能出现重复记录，每一个字段是原子性不能再分； 示例：不符合第一范式 学生编号 学生姓名 联系方式 1001 张三 zs@gmail.com,1359999999 1002 李四 ls@gmail.com,13699999999 1001 王五 ww@163.net,13488888888 分析以上设计存在的问题：1） 数据存在重复记录，数据不唯一，没有主键2） 联系方式可以再分，不是原子性修改以上设计方案： 学生编号(pk) 学生姓名 email 联系电话 1001 张三 zs@gmail.com 1359999999 1002 李四 ls@gmail.com 13699999999 1003 王五 ww@163.net 13488888888 结论：关于第一范式 1、 每一行必须唯一，也就是每个表必须有主键，这是我们数据库设计的最基本要求，2、 主键主要通常采用数值型或定长字符串表示3、 关亍列丌可再分，应根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段了； 6.2 第二范式：非主键字段完成依赖主键定义：第二范式是建立在第一范式基础之上，要求数据库中所有非主键字段完全依赖主键，不能产生部分依赖；（严格意义上说：尽量不要使用联合主键） 示例一：数据仍然可能重复 学生编号 学生姓名 教师编号 教师姓名 1001 张三 001 王老师 1002 李四 002 赵老师 1003 王五 001 王老师 1001 张三 002 超老师 示例二：确定主键，学生编号、教师编号，出现冗余 学生编号（PK） 教师编号(PK) 学生姓名 教师姓名 1001 001 张三 王老师 1002 002 李四 赵老师 1003 001 王五 王老师 1001 002 张三 赵老师 综合分析：1、 以上虽然确定了主键，但此表会出现大量冗余，主要涉及到的冗余字段为“学生姓名”和“教师姓名”；2、 出现冗余的原因在于：学生姓名部分依赖了主键的一个字段学生编号，而没有依赖教师编号，而教师姓名部分依赖了主键的一个字段教师编号，这就是第二范式部分依赖。 解决方案如下： 学生信息表： 学生编号（PK） 学生姓名 1001 张三 1002 李四 1003 王五 教师信息表： 教师编号（PK） 教师姓名 001 王老师 002 赵老师 教师和学生的关系表： 学生编号(PK) fk-&gt;学生表的学生编号 教师编号(PK) fk-&gt;教师表的教师编号 1001 001 1002 002 1003 001 1001 002 结论：一种典型的“多对多”的设计 6.3 第三范式定义：建立在第二范式基础之上，要求非主键字段不能产生传递依赖于主键字段； 示例一：学生信息表 学生编号（PK） 学生姓名 班级编号 班级名称 1001 张三 01 一年一班 1002 李四 02 一年二班 1003 王五 03 一年三班 1004 六 03 一年三班 综合分析：1、从表中看出，班级名称字段存在冗余，因为班级名称字段没有直接依赖于主键2、班级名称字段依赖于班级编号，班级编号依赖于学生编号，那么这就是传递依赖， 解决方案：1、 将冗余字段单独拿出来建立表2、 如下表所示：学生信息表中班级编号设为外键FK学生信息表： 学生编号（PK） 学生姓名 班级编号（FK） 1001 张三 01 1002 李四 02 1003 王五 03 1004 赵六 03 班级信息表： 班级编号（PK） 班级名称 01 一年一班 02 一年二班 03 一年三班 结论： 典型的一对多以上设计是一种典型的一对多的设计，一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的一方的主键 6.4 三范式总结6.4.1 一对一第一种方案：分两张表存储，共享主键 1） 示例：t_husband 和 t_wife两张表丈夫表 ：t_husband hno（PK） hname 1 Zhangsan 2 Wangwu 3 zhaoliu 妻子表：t_wife wno（PK）【同时也是外键FK，引用t_husband的主键】 wname 3 a 2 b 1 c 第二种方案：分两张表存储，外键唯一 示例：t_husband 和 t_wife两张表 丈夫表 ：t_husband hno（PK） hname Wifeno（FK - unique） 1 Zhangsan 100 2 Wangwu 200 3 zhaoliu 300 妻子表：t_wife wno（PK） wname 100 a 200 b 300 c 6.4.2 一对多分两张表存储，在多的一方添加外键，这个外键字段引用一的一方中的主键字段例如：学生信息表和班级信息表，请参考：20.3.2 示例一 6.4.3 多对多例如：分三张表存储，在学生表中存储学生信息，在课程表中存储课程信息，在选课表中存储学生选课信息，请参考：20.2 6.5 实际开发中是怎么的？1） 数据库设计尽量遵循三范式2） 根据实际需求迚行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。 好，终于学完MySQL了，那么MySQL的学习就暂告一段落了。这么多东西，小艾要去休息休息消化消化一下才行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（中）]]></title>
    <url>%2F2019%2F03%2F19%2F2019-03-19-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%AD)%20%2F</url>
    <content type="text"><![CDATA[经过上次的MySQL快速入门（上）的学习，小艾已经有初步对MySQL的了解，前面学习的内容还是比较简单的，今天，就再深入的学习MySQL的查询吧。 目录 连接查询 子查询 union合并集合 limit使用 表 1. 连接查询在实际开发中，数据往往不是存放储一张表中，而是同时存储在多张表中，这些表与表存在着关系，我们在检索数据的时候往往需要多张表联合起来检索，这种多表联合检索被称为连表查询或跨表查询。 1.1 笛卡尔积现象含义：若两张表进行连接查询的时候没有任何条件限制，最终的查询结果总数是两张表记录的乘积，该现在称为笛卡尔积现象。 1.1.1 显示每个员工信息，并显示所属部门名称 1.2连接查询根据：年代分类1.2.1 SQL92语法语法结构：select xxxx from A表名,B表名 where 表连接条件 and 数据查询条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e,dept d where e.deptno = d.deptno; 缺点：表连接条件与查询条件放在一起，没有分离； 1.2.2 SQL99语法【只掌握SQL99】语法结构：select xxxx from A表名 join B表名 on 表的连接条件; 示例：查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称。 select d.dname,e.ename from emp e join dept d on e.deptno = d.deptno; 优点：表连接独立，结构清晰，如果结果数据不满足要求，可再追加where条件进行过滤； 1.3连接查询根据：连接方式分类1.3.1 内连接定义：只连接匹配的行，即A表与B表相连接，能够匹配的记录查询出来。 （1）等值连接 示例：查询员工的名称和员工所对应的部门名称 select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;注：inner可忽略 （2）非等值连接 示例：查询员工的工资等级 select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可忽略 （3）自连接 示例：查询员工的名称和员工对应的领导名称 select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno;注：inner可忽略 1.3.2 外连接定义：A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的完全查询出来，对方表没有匹配的记录时，会自动模拟出null值与之匹配；注意：外连接的查询结果条数 &gt;= 内连接的查询结果条数 （1）左外连接（左连接） 定义：包含左边表的全部行（不管右边的表中是否存在不它们匹配的行），以及右边表中全部匹配的行； （2）右外连接（右连接） 定义：包含右边表的全部行（不管左边的表中是否存在不它们匹配的行），以及左边表中全部匹配的行； （3）全连接（了解） 定义：包含左、右两个表的全部行，不管另外一边的表中是否存在不它们匹配的行。 1.4七大案例详解1.4.1 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（笛卡尔积）注意：多张表查询时，通常会对表起别名，若两张表中有相同名称的字段时，该相同名称字段不知道属亍哪张表中，这时需要通过对表起别名来限制该字段属于哪张表，并且提高SQL语句的效率，可读性也高。 思路分析：（1） Step 1：先查询出员工姓名和部门编号；emp员工表 （2）Step 2：再查询出部门编号和部门名称；dept部门表 联想：当多张表连接查询时，若没有任何条件限制，会发生什么？ select e.ename,d.dname from emp e,dept d;预测查询结果： 验证结果： 结论：为了避免笛卡尔积现象的发生，必须在进行表连接的时候添加限制条件； 1.4.2 查询每一个员工所在的部门名称，要求最终显示员工姓名和对应的部门名称（内连接：等值）思路分析（1） Step 1：从emp e 员工信息表查询出员工姓名、部门编号； （2）Step 2：从dept d部门信息表查询出部门编号、部门名称； 注意：在连接查询时，即使我们使用的了限制条件，但是匹配次数没有减少，只显示有效数据； （3）Step 3：内连接等值条件：e.deptno=d.deptno SQL92语法：内连接中的等值连接（不建议）select e.ename,d.dname from emp e,dept d where e.deptno = d.deptno; SQL99语法：select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e join dept d on e.deptno = d.deptno;//inner可省略 1.4.3 找出每一个员工对应的工资等级，要求显示员工姓名、工资、工资等级（内连接：非等值）思路分析 （1）Step 1：从emp e员工信息表查询出员工的姓名、工资 （2）Step 2：从salgrade s工资等级表查询出工资等级信息 （3）Step 3：内连接非等值条件：between s.losal and s.hisal; SQL92语法：（不建议）select e.ename,e.sal,s.grade from emp e , salgrade s where e.sal between s.losal and s.hisal; SQL99语法：内连接中的非等值连接select e.ename,e.sal,s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal; select e.ename,e.sal,s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;注：inner可以省略 1.4.4 找出每一个员工的上级领导，要求显示员工姓名及对应的领导姓名（内连接：自连接）思路分析： （1）Step 1：从emp a员工信息表查询出员工编号、员工名称、领导编号 （2）Step 2：从emp b领导信息表查询出领导姓名、领导编号 （3）Step 3：自连接条件为：领导编号=员工编号 SQL92语法：（不建议） select a.ename empname,b.ename leadername from emp a,emp bwhere a.mgr = b.empno; SQL99语法：内连接中的自连接 select a.ename empname ,b.ename leadername from emp a inner join emp b on a.mgr = b.empno;select a.ename empname ,b.ename leadername from emp a join emp b on a.mgr = b.empno ;注：inner可以省略 1.4.5 找出每一个员工对应的部门名称，要求部门名称全部显示（左/右外连接）思路分析： （1）Step 1：先查询出每一个员工对应的部门名称 （2）Step 2：查询部门信息 （3）Step 3：右外连接条件：员工表的部门编号=部门表的部门编号 SQL99语法：外连接中的右外连接【右连接】 select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno;select e.ename,d.dname from emp e right join dept d on e.deptno = d.deptno;//outer可省略 SQL99语法：外连接中的左外连接【左连接】 select e.ename,d.dname from dept d left outer join emp e on e.deptno = d.deptno;select e.ename,d.dname from dept d left join emp e on e.deptno = d.deptno;//outer可省略 注意：任何一个右外连接都可写成左外连接，任何一个左外连接都可写成右外连接； 1.4.6 为什么 inner 和 outer 可以省略，加上去有什么好处？可以省略，因为区分内连接与外连接不是依靠这两个关键字，而是看SQL语句中的left/right关键字；加上left、right关键字增强SQL语句的可读性。 1.4.7 找出每一个员工对应的领导名，要求显示所有员工（左外连接）思路分析： （1）Step 1：显示每一个员工对应的领导名 （2）Step 2：以上查询结果缺少一位员工King，通过左外连接查询全部员工。 SQL99语法：select a.ename empname ,b.ename leadername from emp a left join emp b on a.mgr = b.empno; 1.4.8 找出每一个员工对应的部门名称，以及该员工对应的工资等级，要求显示员工姓名、部门名称、工资等级。思路分析： （1）Step 1：查询出员工对应的部门编号和工资emp e表 （2）Step 2：查询出部门信息dept d表 （3）Step 3：查询出工资等级信息salgrade s表 （4）多表连接条件：员工表与部门表连接（e.deptno = d.deptno），再与工资等级表连接（e.sal between s.losal and s.hisal） 重点：多张表进行表连接的语法格式： 123456789101112select xxxxfrom A表join B表on 连接条件1join C表on 连接条件2； 原理：A表和B表通过连接条件1连接之后，A表再和C表通过连接条件2进行连接； 12345678910111213emp e表、dept d表、salgrade s表select e.ename,d.dname,e.sal,s.gradefrom emp ejoin dept don e.deptno = d.deptnojoin salgrade son e.sal between s.losal and s.hisal; 2.子查询定义：select 语句嵌套 select 语句被称为子查询；注意：select子句可出现在select、from、where关键字后面，如下：select … (select)…【很少很少使用了解即可】from …(select)…where …(select)… 2.1 案例2.1.1 （where后）找出薪水比公司平均薪水高的员工，要求显示员工名和薪水注意：select ename,sal from emp where sal &gt; avg(sal);执行错误：因为分组函数不能直接使用在where关键字后面 思路分析： （1）第一步：找出公司的平均薪水，平均薪水：2073.214286 （2）第二步：找出薪水比公司平均薪水：2073.214286高的员工 （3）第三步：将平均薪水2073.214286值替换为它的查询语句即可； 2.1.2 （from后）找出每个部门的平均薪水，并且要求显示平均薪水的薪水等级思路分析： （1）第一步：根据部门分组找出每个部门的平均薪水 （2）第二步：查询出薪水等级信息 （3）第三步：将第一步查询结果当作一张临时表 t，然后将t表与薪水等级表做进行表连接，条件t.avgsal between s.losal and s.hisal; 小窍门：可将查询结果当做临时表 2.1.3 （select后使用了解）select e.ename,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; 3.union合并集合定义：将查询的结果集合幵注意事项：合并结果集的时候，查询字段个数必须相同； 3.1 示例3.1.1 查询出job为MANAGER和SALESMAN的员工123select empno,ename,job from emp where job = ‘MANAGER’unionselect ename,job from emp where job = ‘SALESMAN’; 以上写法错误： 正确写法： 123select empno,ename,job from emp where job = ‘MANAGER’unionselect empno,ename,job from emp where job = ‘SALESMAN’; 注意：查询字段类型在MySQL中不必完全相同，但是Oracle中一定要类型也相同； 写法错误： 123select e.empno,e.ename from emp eunionselect d.dname,d.loc from dept d; 正确写法： 123select e.empno,e.ename from emp eunionselect d.deptno,d.loc from dept d; 3.1.2 查询包含 MANAGER 和 SALESMAN 的员工信息（1）第一种方式：in (‘MANAGER’,‘SALESMAN’) select * from emp where job in(‘MANAGER’,‘SALESMAN’);select * from emp where job = ‘MANAGER’or job = ‘SALESMAN’; （2）第二种试：使用 union关键字查询 123select * from emp where job = &apos;MANAGER&apos;unionselect * from emp where job = &apos;SALESMAN&apos;; 4.limit使用作用：（只在MySQL中起作用）获取一表前几条或中间某几行数据； 4.1 用法：limit 起始下标m,长度nm：记录开始的index，默认从 0 开始，表示第一条记录；n ：指从第 m+1 条开始，取 n 条； 4.2 取前5个员工信息思路分析 （1）第一步：查询出全部员工的信息 （2）第二步：使用limit取出前5个员工的信息 以上SQL语句中的“limit 5”中的“5”表示：从表中记录下标0开始，取5条记录，等同于 select * from emp limit 0,5; 4.3 找出工资排名在前5的员工思路分析： （1）第一步：按照工资降序排列 order by desc （2）第二步：在以上基础上，取前5个员工limit出现在SQL语句的最后位置 4.4 找出工资掋名在[ 3-9 ]的员工思路分析： （1）第一步：按照工资降序排列 order by desc （2）第二步：使用limit取出排名在3到9的员工 4.5 MySQL中通用的分页SQL语句提示：每页显示3条记录（长度为3） 第1页：0，3 包含页：1，2，3 limit 0,3第2页：3，3 包含页：4，5，6 limit 3,3第3页：6，3 包含页：7，8，9 limit 6,3… …每页显示pageSize条记录第pageNo页：(pageNo – 1) * pageSize，pageSize 12345678select enamefrom emporder by sal desclimit (pageNo – 1) * pageSize , pageSize; 通用分页SQL【只适用于MySQL数据库管理系统】 12345678select t.*from torder by t.xx desc/asclimit (pageNo – 1) * pageSize , pageSize; 5.表5.1 定义：表（table）：是数据库最基本的组成单元，数据库是用来存储数据的，数据库中有很多表，每一个表都是一个独立的单元，表也是一个结构化的文件，由行和列组成，行称为数据或记录，列称为字段，字段又包含：字段名称、字段类型、长度、约束。 5.2 创建表5.2.1 语法格式:create table 表名称(字段名 类型(长度) 约束)； 5.2.2 MySQL常用数据类型 （1）VARCHAR：可变长度字符串 VARCHAR(3)表示存储的数据长度不能超过3个字符长度 （2）CHAR：定长字符串 CHAR(3) 表示存储的数据长度不能超过3个字符长度 （3）INT：整数型 INT(3)表示最大可以存储999 （4）BIGINT：长整型 对应java程序中的long类型 （5）FLOAT：浮点型单精度 FLOAT(7,2)表示7个有效数字，2个有效小数位 （6）DOUBLE：浮点型双精度 DOUBLE(7,2)表示7个有效数字，2个有效小数位 （7）DATE：日期类型 实际开发中，常用字符串代替日期类型 （8）BLOB：二迚制大对象 Binary Large Object 与门存储图片、视频、声音等数据 数据库存储图片是很常见，但存储大视频是很少的，一般都是存储视频地址 （9）CLOB：字符型大对象 Character Large Object 可存储超大文本，可存储4G+字符串 （10）注意：VARCHAR与CHAR对比： 都是字符串 VARCHAR比较智能，可以根据实际的数据长度分配空间，比较节省空间；但在分配的时候需要相关判断，效率低。 CHAR不需要劢态分配空间，所以执行效率高，但是可能会导致空间浪费 若字段中的数据不具备伸缩性，建议采用CHAR类型存储 若字段中的数据具备很强的伸缩性，建议采用VARCHAR类型存储 5.2.3 创建表格&lt;t_student 学生信息表&gt;学生信息表字段包括： 学号：no INT(10)姓名：name varchar(32)性别：sex char(1)出生日期：birth date邮箱：email varchar(128) 建表语句，如下图： 注意： 表格名称最好以 t_ 或 tbl_ 开始，增强可读性VARCHAR长度最好是2的倍数，方便存储中文 5.2.4 删除表格： drop table t_student;（如果数据库中没有该表格，则会报错）； drop table if exists t_student;最好采用这种方式删除表格，但这是MySQL特色其它数据库无法使用 5.2.5 向t_student表格中插入数据DML语句包括：insert、update、delete；（增删改表中的数据不表结构无关） 插入数据 insert 语法 Insert into 表名(字段名1，字段名2，…) values(值1, 值1,…); 注意：字段和数值必须一 一对应，字段不数据个数必须相同，数据类型必须一致；第一种方式：向 t_student 表格中所有字段插入数据 INSERT INTO t_student(no,name,sex,birth,email) VALUES(1,&#39;zhangsan&#39;,&#39;m&#39;,&#39;1970-01-01&#39;,&#39;zhangsan@powernode.com&#39;);INSERT INTO t_student(no,name,sex,birth,email) VALUES(2,&#39;lisi&#39;,&#39;f&#39;,&#39;1978-10-10&#39;,&#39;lisi@powernode.com&#39;); 第二种方式：向 t_student 表格中部分字段插入数据insert into t_student(name,email) values(&#39;wangwu&#39;,&#39;wangwu@163.com&#39;); 注意：默认情况下，当表创建之后，没有指定约束也没指定默认值，系统默认值就是NULL ，默认值NULL表示：若插入的时候没有指定任何数据，默认插入 NULL 值。目前wangwu的 no、sex、birth 值为 null ，我们可以往里插入值吗？ 以上执行insert 语句叧能导致底层数据表中新增一条记录；若希望NULL值变为其它值，我们必须使用UPDATE更新语句；第三种方式：向 t_student 表格中所有字段插入数据INSERT INTO t_student VALUES(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1990-01-18&#39;,&#39;zhaoliu@126.com&#39;); 结论：不建议将前面的字段省略，若省略就表示要将表中所有字段必须赋值，并且程序不健壮，若修改表结构，将可能导致INSERT语句执行失败； 插入中文试试？ insert into t_student(no,name) values(5,’李丽’); 查看建表语句：show create table t_student; 错误原因：DOS窗口字符编码为GBK，数据库字符编码为UTF-8，可以使用MySQL-Front工具插入数据，该MySQL客户端开发软件在实际工作中使用较多； 查看变量：show variables like &#39;%char%&#39;; 设置结果编码集（叧对当前窗口有效） set character_set_results = &#39;GBK&#39;; 5.2.6 创建表格时给字段设置默认值:default 默认值 联想知识点： 该文件是一个普通的文本文件，以.sql后缀结尾的文件我们称为SQL脚本； 在SQL脚本中包含了大量的SQL语句，我们可以通过直接使用source执行这个大批量脚本； 在项目中期入职，数据库环境都已完善，PM可能会给程序员SQL脚本完成数据库的初始化； 如果脚本过大，我们可以使用Sublime Text这个软件； 额外小知识点：获取数据库系统当前时间 使用 now() 函数 创建机构表： 获取系统时间另外方式，通过java的Date对象也可获取； 5.2.7 表的复制定义：将查询结果当作一张表创建 语法结构：CREATE TABLE 表名 as select查询语句； （1）完全复制emp表到emp1： create table emp1 as select * from emp; （2）选择性复制emp表到emp2: create table emp2 as select ename,sal from emp; 5.2.8 将查询结果插入到某张表中语法结构: INSERT INTO 表名 select查询语句； （1）从emp2表中查询出员工工资为3000的，同时将查询结果插入到emp2表中 （2）复制emp表为emp_bak，再将emp表中数据插入到emp_bak中 create table emp_bak as select * from emp;insert into emp_bak select * from emp2 where sal = 3000; 5.3 增 / 删 / 改 表结构5.3.1 语法结构：新增：ALTER TABLE 表名 ADD 字段名 字段类型（长度）；修改：ALTER TABLE 表名 MODIFY 字段名 字段类型（长度）；删除：ALTER TABLE 表名 DROP 字段名; 5.3.2 创建t_student表：no int(10)、name varchar(32)编号：no int(10)姓名：name varchar(32) 5.3.3 【增加】给 t_student 表添加一个电话字段alter table t_student add tel varchar(10); 5.3.4 【修改】将字段 tel 长度扩展到20个长度alter table t_student modify tel varchar(20); 5.3.5 【删除】将 t_student 表中的 tel 字段删除alter table t_student drop tel; 5.4 添加 / 修改 / 删除 表数据5.4.1 DML数据操作诧句：insert 、update 、delete；5.4.2 insert 添加数据语法格式：insert into 表名(字段名1，字段名2,…) values(值1,值2,…); 创建表 s_student 省略字段插入 insert into t_student values(4,&#39;zhaoliu&#39;,&#39;m&#39;,&#39;1990-01-18&#39;,&#39;zhaoliu@126.com&#39;); 注意：不建议使用此种方式，因为当数据库表中的字段位置发生改变的时候会影响到insert语句 5.4.3 update 修改数据语法格式：UPDATE 表名 SET 字段名 = 字段值，字段名 = 字段值 WHERE 条件；注意：update如果没有条件限制，将把整张表的数据全部更新； 示例一：向 t_student 表中插入数据 准备工作：1、 向t_student表添加 email varchar(128)2、 向t_student表插入测试数据 （1）将编号no为3的记录name改为zhangsan,email改为zhangsan@126.com； update t_student set name = &#39;zhangsan&#39;,email = &#39;zhangsan@126.com&#39; where no = 3; （2）将所有名字 name 改为 lisi update t_student set name = &#39;lisi&#39;; （3）将 emp_bak 表中的 name 包含“o”字母的改为 wangwu ;update emp_bak set name=&#39;wangwu&#39; where email like &#39;%O%&#39;; （4）将 emp_bak 表中工作岗位为 MANAGER 和 SALESMAN 员工的工资上调10%；update emp_bak set sal=sal*1.1 where job in (&#39;MANAGER&#39;,&#39;SALESMAN&#39;); 5.4.4 delete 删除数据语法格式： DELETE FROM 表名 WHERE 条件限制；注意：若没有条件限制，会将表中所有记录全部删除； 示例一：将 t_student 表中 no 为 3的学生删除delete from t_student where no = 3; 示例二：将 t_student 表中的数据全部删除delete from t_student; 将 emp_bak 表中部门编号为20的 MANAGER 删除掉；delete from emp_bak where deptno = 20 and job = ‘MANAGER’; 5.5 创建表加入约束英文单词：constraint什么是约束？实际上是对表中数据的限制条件；设计表时加入约束的目的？保证表中数据的完整和有效； 5.5.1 非空约束（not null）作用：not null约束的字段不能为 NULL 值，必须赋具体数据；示例：需求如下所示：创建t_user表，name字段不能为空表名：t_user 字段名 字段类型 约束 id int(10) name varchar(32) not null不为空 email varchar(128) 向 t_user 表中插入数据 5.5.2 唯一性约束（unique）作用：unique约束的字段具有唯一性，不可重复 示例：创建t_user表，name丌能为空，email保证唯一方法一：【列级约束】保证邮箱email地址唯一email varchar(128) unique 向 t_user 表中插入数据 注意：”unique约束”约束的字段不能重复，但是可以为NULL，NULL不是一个值，也不能用等号比较； 方法二：【表级约束】保证邮箱email地址唯一unique(email) 以上写法与例1效果相同 使用表级约束给多个字段联合添加约束： 【以下程序表示：name和email两个字段联合唯一】 向 t_user 表中插入数据 以上语句执行失败，原因：表级联合约束限制； 表级约束还可以给约束起名字，原因：以后可通过名字操作这个约束 查询唯一性约束的名字 查看 information_schema 库的表 table_constraint 该表格专门存储约束信息 查询出表 t_user 中的唯一约束名称 组合使用 not null 和 unique 作用：被 not null 和 unique 约束的字段，该字段即不能为null 也不能重复；示例： 需求，创建t_user表，用户编号为id，用户名称name即不能为空也不能重复 向 t_user 表中插入数据 正确写法：insert into t_user(id,name) values(3,’jack’); 错误写法：insert into t_user(id) values(3); 错误原因：name 字段约束条件：即不为空也不能重复 5.5.3 主键约束PK（primary key）主键约束 primary key 简称 PK 实例讲解主键：中国公民身份信息 id Name Sex Age 身份证号 张三 男 27 身份证号 张三 男 27 主键涉及到的3个术语: 主键约束、主键字段、主键值 主键约束、主键字段、主键值三者之间关系？ 表中某个字段添加主键约束之后，该字段被称为主键字段，主键字段中出现的每一个数据都被称为主键值； 主键作用 添加主键primary key的字段即不能重复也不能为空，效果不“not null nuique”相同，但本质是不同的，添加主键约束之后，主键不仅会有“not null unique”作用，而且主键字段还会自劢添加“索引 — index”； 一张表应该有主键，若没有，表示这张表是无效的【联想：数据库设计第一范式】，“主键值”是当前行数据的唯一标识，“主键值”是当前行数据的身仹证号；（即使表中两行数据完全相同，但是由亍主键不同，我们也认为这是两行完全不同的数据） 主键根据个数分类：单一主键、复合主键 【单一主键】是给一个字段添加主键约束； 创建单一主键约束【列/表级】 【列级】单一主键约束：id int(10) primary key 创建t_user表：包含：id int(10) 主键、name varchar(32) 【表级】单一主键约束: 表级单一主键命名：constraint t_uer_id_pk primary key(id) 以上方式实际工作中最常用； 【复合主键】是给多个字段联合添加一个主键约束； 需求：创建t_user表包含id,name,email，id和name是复合主键primary key(id,name) 复合主键命名： constraint t_user_id_name_pk primary key(id,name) 插入数据测试结果 创建 t_uer 表，测试联合主键功能 表中主键个数（只能有一个） 无论是单一主键还是复合主键，一张表中主键约束只能有一个； 主键根据性质分类：自然主键、业务主键 自然主键：主键值若是一个自然数，并且这个自然数与业务没有任何关系，这种主键称为自然主键； 业务主键：主键值若和当前表中的业务紧密相关，那么这种主键值被业务主键；如果业务发生改变时，业务主键往往会受到影响，所以业务主键使用较少，大多情况使用自然主键。 【如：身份证号位数扩展】 MySQL中自动生成主键值（MySQL特有） 定义：MySQL数据库管理系统中提供了一个自增数字auto_increment，与门用来自动生成主键值，主键值丌需要用户去维护，也丌需要用户生成，MySQL会自劢生成。自增数字默认从1开始，以1递增：1、2、3、4、… 示例： 递增关键字：auto_increment 创建 t_user表：id,name，id为自增主键 5.5.4 外键约束FK（foreign key）外键约束 foreign key 简称：FK 外键涉及到的术语：外键约束、外键字段、外键值 外键约束、外键字段、外键值三者之间的关系？ 给某个字段添加外键约束之后，该字段称为外键字段，外键字段中的数据称为外键值； 外键根据个数分为：单一外键、复合外键 【单一外键】：给一个字段添加外键约束【复合外键】：给多个字段联合添加一个外键 外键在同一张表中可以有多个外键存在 示例一： 需求：设计数据库表用来存储学生和班级信息（给出两种解决方案） 需求分析： 学生表 t_student包含：sno,sname,classno,cname 学生信息和班级信息之间的关系：一个班级对应多个学生，典型的一对多关系； 第一种解决方案：将学生信息和班级信息存储到同一张表中 学生信息表：t_student sno(PK) sname classno cname 1 Jack 100 北京市101中学高三1班 2 Lucy 100 北京市101中学高三1班 3 Lily 100 北京市101中学高三1班 4 Ford 200 北京市101中学高三2班 5 allen 200 北京市101中学高三2班 6 Jason 300 北京市101中学高三3班 7 Teddy 300 北京市101中学高三3班 以上设计的缺点：数据冗余 第二种解决方案：将学生信息和班级信息分开两张表存储：学生表 + 班级表思路分析：第一步：创建t_student表和t_class表 学生表 t_student Sno sname 1 Jack 2 Lucy 3 Lily 4 Ford 5 Allen 6 Jason 7 Teddy 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 第二步：t_student表要与t_class表有关系，需要在t_student表中添加一个classno字段做为外键 学生表 t_student Sno sname classno(FK) 1 Jack 100 2 Lucy 100 3 Lily 100 4 Ford 200 5 Allen 200 6 Jason 300 7 Teddy 300 班级表 t_class Cno cname 100 北京市101中学高三1班 200 北京市101中学高三2班 300 北京市101中学高三3班 结论（classno值必须来自cno）：为了保证 t_student 表中的 classno 字段中的数据必须来自 t_class表中的 cno 字段中数据，有必要给 t_student 表中classno 字段添加外键约束；classno 称为外键字段，classno 中的100、200、300称为外键值，classno在这里是单一外键； 请注意以下三点： 外键字段可以为NULL，外键为空的数据也叨孤儿数据； 被引用字段必须具有unique约束； 有了外键引用乊后，表分为父表和子表，以上父表：班级表 t_class； 子表是：学生表 t_student；创建表时先创建父表，再删除子表；插入数据时，先插入父表数据,再插入子表数据； 示例一的完整实现 测试：在t_student表中插入一个班级编号为400的 执行失败原因：引用外键值在外键表 t_class 中 cno数据中不存在； 示例二：找出每个学生的班级名称 找出每个学生的班级名称 重点：典型的一对多设计是，在多的一方加外键。 在MySQL中没有提供修改外键约束的语法功能 5.5.5 级联更新与级联删除用法：在添加级联更新不级联删除的时候，需要在外键约束后面添关键字； 注意：级联更新不级联删除操作谨慎使用，因为级联操作会将数据改变或者删除【数据无价】 （1）级联删除：on delete cascade 定义：在删除父表数据的时候，级联删除子表中数据； 删除外键约束 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 添加外键约束及级联删除功能 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段)REFERENCES 引用表名(引用表中字段名称) ON DELETE CASCADE; 级联删除—完整示例 第一步：删除t_student中的外键 alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联删除 on delete cascade; 第三步：删除t_class表中班级编号为200的信息，包括所在班级的学生信息 （2）级联更新：on update cascade 定义：在更新父表中数据的时候，级联更新子表中数据； 删除外键约束（没有修改外键约束语法） 语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键字段; 更新外键约束和添加级联更新功能 语法：**ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段) REFERENCES 引用表名称(引用表字段) ON UPDATE CASCADE;** 级联更新—完整示例 第一步：删除 t_student中的外键alter table t_student drop foreign key t_student_classno_fk; 第二步：增加t_student_classno_fk外键，幵加入级联更新 on update cascade; 第三步：更新t_class表中班级编号200改为100，包括所在班级的学生信息 好，今天就学这么多先~好好休息一下，慢慢吸收。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL快速入门（上）]]></title>
    <url>%2F2019%2F03%2F17%2F2019-03-17-MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[因为有了数据库管理系统，我们操作数据更加的方便直观，不再需要通过IO流的操作进行数据管理。而我们今天就来学习一款比较流行的关系型数据库管理系统——MySQL。 目录 学前准备 常用命令 演示数据结构 简单的查询 条件查询 数据排序 处理函数 总结 1. 学前准备1.1 安装MySQL（省）1.2 启动MySQL的服务1.2.1 可以通过服务管理器管理MySQL的服务停止MySQL服务 启动MySQL服务 1.2.2 在DOS窗口直接通过命令行的形式进行控制启动MySQL服务：net start mysql 停止MySQL服务：net stop mysql 1.3 MySQL登录配置用户环境变量path:C:\Program Files\MySQL\MySQL Server 5.7\bin，否则如下图显示 提示：mysql不是内部或外部命令，也不是可运行的程序戒批处理文件。 配置完成之后，再次运行，提示：ERROR 1045 (28000): Access denied for user ‘ODBC‘@’localhost’ (using password: NO) 打开dos窗口，输入mysql –uusername –ppassword，点击回车登录，看到以“mysql&gt;”说明已经登录成功 1.4 表的定义表是一种结构化的文件，可以用来存储特定类型的数据，如：学生信息、课程信息等，都可以放到表中，另外表都有特定的名称，而且不能重复。表中有以下几个概念：列、行、主键。 （1）列（字段） 列， 通常叫做字段，每一个字段都包含：字段名称、字段数据类型、字段约束、字段长度； （2）行记录 行，通常叫做表中的记录。表中的数据是按行（记录）存储的，表里可以有0条或多条记录； 1.5 SQL的分类（1）数据库查询语言（DQL） 简称：DQL，Data Query Language 代表关键字：select （2）数据库操作语言（DML） 简称：MQL，Data Manipulation Language 代表关键字：update、delete、insert 增、删、改表中的数据 （3）数据库定义语言（DDL） 简称：DDL，Data Denifition Language 代表关键字：create、drop、alter 创建、删除、修改表的结构 （4）事务控制语言（TCL） 简称：TCL，Transaction ControlLanguage 代表关键字：commit、rollback （5）数据控制语言（DCL） 简称：DCL，Data Controller Language 代表关键字：grant、revoke （6）DML与DDL的区别是什么？ DML是修改数据库表中的数据，而DDL是修改数据中表的结构 1.6 导入演示数据 使用MySQL命令行客户端来装载数据库 (1) 连接MySQL：mysql -uroot -p123 (2) 创建数据库：create database bjpowernode; (3) 选择数据库：use bjpowernode; (4)导入数据库：source D:\bjpowernode.sql (5)删除数据库：drop database bjpowernode; 查看数据库相关命令 (1) 查看数据库管理系统中所有的数据库：show databases; (2) 查看bjpowernode数据库中的所有表格：show tables; (3) 查看描述表的结构：desc 表名; 演示数据表结构描述 (1) 表名称：dept 描述：部门信息表 (2) 表名称：emp 描述：员工信息表 注：DEPTNO是外键，DEPTNO的值来源于dept表的主键，起到了约束的作用 表名称：salgrade 描述：薪水等级信息表 2. 常用命令2.1 查看MySQL版本（进入Mysql前）2.1.1. mysql –versionC:\Users\Administrator&gt;mysql --version 2.1.2. mysql -V（注：大写字母V）C:\Users\Administrator&gt;mysql –V 2.2 查询当前使用数据库及MySQL版本(进入MySQL后)2.2.1. 查看当前使用数据库select database (); 2.2.2. 查看MySQL数据库版本select version(); 2.3 创建数据库2.3.1. create database 数据库名称；mysql&gt;create database bjpowernode; 2.3.2. use 数据库名称；use bjpowernode;注：在数据库中创建表，因此创建表的时候必须要先选择数据库。 2.4 终止一条语句2.4.1. 如果想要终止一条SQL询句，可输入\c；2.5 退出MySQL2.5.1. 可使用exit、\q或exit；最方便快捷的是crtl+c3. 演示数据结构3.1. 如何取得演示数据3.1.1. 查看和指定现有的数据库show databases; 3.1.2. 指定当前缺省数据库use bjpowernode; 3.1.3. 查看当前使用的数据库select database(); 3.1.4. 查看当前数据库中的表show tables; 3.1.5. 查看其它数据库中的表show tables from 数据库名称； 3.1.6. 查看表结构desc 表名称； 3.1.7. 查看表的创建语句show create table 表名称; 4. 简单的查询4.1 查询一个字段4.1.1 查询员工姓名注：在SQL语句中不区分大小写；SQL语句以；分号结束select ename from emp; 注：select语句后面跟的是字段名称，select是关键字，select和字段名称之间采用空格隔开，from表示将要查询的表，它和字段之间采用空格隔开。 4.2 查询多个字段4.2.1 查询员工编号和员工姓名注：多个字段查询时，字段与字段之间用,隔开select empno,ename from emp; 注：查询多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段不能使用逗号了. 4.3 查询全部字段我们可以将所有字段放到 select 语句之后，这种方案不方便，但是比较清楚，我们可以采用下面的方式查询全部字段。select * from emp; 注：采用 select from emp，虽然简单，但是 号不是很明确，并且select 语句会先去编译，将``转换成字段，建议查询全部字段将相关字段写到 select 语句的后面，在以后 java连接数据库的时候，是需要在 java 程序中编写 SQL 语句的，这个时候编写SQL语句不建议使用 select * 这种形式，建议写明字段，这个 SQL 语句的可读性强。 4.4 计算员工的年薪4.4.1 列出员工编号，姓名和年薪mysql&gt;select empno,ename,sal*12 from emp; 注：字段上可以使用数学表达式，只要SQL语句中有 select 关键字，不会修改底层数据库字段的值； 4.5 将查询出来的字段重命名和显示为中文4.5.1 select empno,ename,sal * 12 as yearsal from emp;或者 select empno,ename,sal * 12 yearsal from emp; 4.5.2. select empno,ename,sal * 12 as ‘年薪’ from emp;或者 select empno,ename,sal * 12 ‘年薪’ from emp; 注： 重命名为中文时必须加单引号或双引号； 标准SQL询句中类型为字符串时必须加单引号，加单引号适用于任何数据库； SQL询句中类型为字符串时也可加双引号，叧适用于MySQL数据库中； 为了SQL询句的通用性，建议全部使用单引号； 5. 条件查询注意：条件查询需要用到 where 语句，where 必须放到 from 语句表的后面；执行顺序：先from再where过滤后再检索出来。 5.1 支持如下运算符 运算符 说明 = 等于 &lt;&gt;或!= 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between…and… 两值之间，等同于&gt;=and&lt;= is null 为null（is not null不为空） and 并且 or 或者 in 包含，相当于多个or（not in不在这个范围中） not not可以取非，主要用在is或in中 like like称为模糊查询，支持%或者下划线匹配，%匹配任意个字符，一个下划线匹配一个字符 5.2 等号（=）操作符5.2.1 查询薪水为5000的员工select empno,ename,sal from emp where sal = 5000; 5.2.2 查询 job 为 MANAGER 的员工错诣：select empno,ename,job from emp where job = MANAGER; 以上查询结构出现错误，因为 job 字段为字符串，所以出现了以上错误信息；正确：select empno,ename,job from emp where job =“manager”; 也可使用单引号 select empno,ename,job from emp where job = &#39;manager&#39;; select empno,ename,job from emp where job = &#39;MANAGER&#39;; 以上输入结果输入结果正确，MySQL默认情况下大小写不敏感； 5.3 不等号（&lt;&gt;、!=）操作符5.3.1. 查询薪水不等于 5000 的员工select empno,ename,sal from emp where sal &lt;&gt; 5000; 以下写法等同于上的写法，建议使用第一种写法select empno,ename,sal from emp where sal != 5000;数值也可以采用单引号引起来，如下语句也是正确，但不建议，原因MySQL数据库做数据类型自动转换select empno,ename,sal from emp where sal &lt;&gt; ‘5000’; 5.3.2. 查询工作岗位不等于MANAGER的员工 5.4 between … and …操作符5.4.1. 查询薪水为1600到3000的员工（第一种方式：采用&gt;=、&lt;=）select empno,ename,sal from emp where sal &gt;= 1600 and sal &lt;= 3000; 5.4.2. 查询薪水为1600到3000的员式（第二种方式：采用between…and…）select empno,ename,sal from emp where sal between 1600 and 3000; 注：关于between … and … 它是包含最大值和最小值的 5.4.3. （了解）between … and … 同样也可用在字符上，用在字符上区间为：前闭后开；select ename from emp where ename between ‘A‘ and ’F‘; 5.5 is nullNull 为空，它不是一个数值，不是一个空串，为null可以设置这个字段不填值，如果查诟为null的字段，采用is null。 5.5.1 查询津贴为空的员工错诣：select empno,ename,comm from emp where comm = null; 原因：以上无法查诟出符合条件的数据，因为null类型比较特殊，必须使用 is 来比较正确：select empno,ename,comm from emp where comm is null; 5.5.2 查询津贴不为空的员工select empno,ename,comm from emp where comm is not null; 5.6 and含义：表示并且，表示所有查诟条件必须满足 5.6.1. 查询工作岗位为“MANAGER”并且薪水大于2500的员工select empno,ename,job,sal from emp where job =’MANAGER‘ and sal &gt; 2500; 5.7 or含义：只要满足条件即可，相当于包含 5.7.1 查询出 job 为 SALESMAN 或 job为MANAGER的员工select ename,job from emp where job = ’SALESMAN‘or job = ’MANAGER‘; 5.8 and与or表达式的优先级and的优先级高于or 5.8.1. 查询薪水大于1800，并且部门编号为20或30的员工错误：select * from emp sal&gt;1800 and deptno=20 or deptno = 30; 分析：以上输出的结果不是我们预期的结果，薪水小于1800的也查出来了，原因是表达式的优先级导致的，首先SQL语句过滤了 sal &gt; 1800 and deptno = 20，然后再将deptno = 30的员工合并过来，所以是不正确的。正确：select * from emp where sal&gt;1800 and (deptno=20 or deptno=30); 注：关于运算符的问题不用死记硬背，没有把握的尽量采用括号； 5.9 in含义：表示包含的意思，完全可以采用or来表示，采用in会更简洁一些。 5.9.1 查询出Job为 SALESMAN 和 Job为 MANAGER 的员工select ename,job from emp where job in (‘SALESMAN’,＇MANAGER’); 5.9.2. 查询出薪水为1600和3000的员工select ename,sal from emp where sal in (1600,3000); 5.9.3. 查询出薪水不是1600和3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10 not5.10.1 第一种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal &lt;&gt; 1600 and sal &lt;&gt; 3000; 5.10.2 第二种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where not (sal = 1600 or sal = 3000); 5.10.3. 第三种写法：查询出薪水不是1600和薪水不是3000的员工select ename,sal from emp where sal not in (1600,3000); 5.10.4 查询出津贴不为null的员工select * from emp where comm is not null; 5.11 Like含义：like可以实现模糊查诟，like支持%和下划线匹配 5.11.1. 查询以姓名以 M 开头的所有员工‘M%’select ename from emp where ename like ‘M%’; 5.11.2. 查询姓名以N结尾的所有员工‘%N’select ename from emp where ename like &#39;%N&#39;; 5.11.3. 查询姓名中包含O的所有员工‘%O%’select ename from emp where ename like &#39;%O%&#39;; 5.11.4. 查询姓名中第二个字符为A的所有员工‘_A%’select ename from emp where ename like &#39;_A%&#39;; 5.11.5. 查询姓名中倒数第二个字符为E的所有员工‘%E_’select ename from emp where ename like &#39;%E_&#39;; 5.11.6. 查询姓名中第三个字符为R的所有员工姓名‘__R%’select ename from emp where ename like ‘__R%’; 6. 数据排序6.1. 单一字段排序 order by 字段名称6.1.1. 作用：通过哪个或哪些字段进行排序含义：排序采用 order by 子句，order by 后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序（asc），如果存在 where 子句，那么 order by 必须放到where 语句后面。（1） 按照薪水由小到大排序（系统默认由小到大）select ename,sal from emp order by sal; （2）取得 job 为 MANAGER 的员工，按照薪水由小到大排序（系统默认由小到大）select ename,job,sal from emp where job = ‘MANAGER’ order by sal; 注：如果包含 where 语句 order by 必须放到 where 后面，如果没有 where 语句 order by 放到表的后面； （3） 以下语法是错误的：a） select * from emp order by sal where job = ‘MANAGER’; 6.2. 手动指定字段排序6.2.1. 手动指定按照薪水由小到大排序（升序关键字 asc）select ename,sal from emp order by sal asc; 6.2.2. 手动指定按照薪水由大到小排序（降序关键字desc）select ename,sal from emp order by sal desc; 6.3. 多个字段排序6.3.1. 按照 job 和薪水倒序排序select ename,job,ename from emp order by job desc,sal desc; 注意：如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序； 6.4. 使用字段位置排序按照薪水升序排序（不建议采用此方法，采用数字含义不明确，可读性不强，程序不健壮）select * from emp order by 6; 7. 处理函数7.1. 数据处理函数（单行处理函数） lower 转换小写 upper 转换大写 substr 取子串（substr（被截取的字符串，起始下标，截取的长度）） length 取长度 trim 去空格 str_to_date 将字符串换成日期 date_format 格式化日期 format 设置干分位 round 四舍五入 rand() 生成随机数 ifnull 可以将null转换成一个具体值 注意：数据处理函数是该数据本身特有的，有些函数可能在其它数据库不起作用； 7.1.1. lower(字段名)函数: 转换为小写用法：lower(要转换字段名称)查询员工姓名，将员工姓名全部转换成小写select lower(ename) as ename from emp; 7.1.2. upper(字段名)函数：转换为大写用法：upper(要转换字段名称)查询员工姓名，将员工姓名全部转换为大写select upper(ename) as ename from emp; 7.1.3. substr(字段名,起始下标,截取长度)函数：取子串用法：substr(被截取字段名称,起始下标,截取长度)注意：起始下标：从1开始查询并显示所有员工姓名的第二个字母select substr(ename,2,1) from emp; 查询员工姓名中第二个字母为A的所有员工select ename from emp where substr(enam,2,1) = ‘A’; 联想知识点，模糊查诟：select ename from emp where ename like ’_A%‘; 7.1.4. length(字段名)函数：取字段长度用法：length(字段名称)取得员工姓名长度select ename,length(ename) as nameLength from emp; 7.1.5. ifnull(字段名,替换值)函数：空值处理函数用法：ifnull(字段名称,将要替换)结论：在数据库中，有Null参与数学运算的结果一定为Null；为了防止计算结果出现Null，建议先使用ifnull函数预先处理。查询员工姓名及补助，如果补助为Null设置为0；select ename,ifnull(comm,0) from emp; 查询员工薪水与补助的和 错误写法：select sal+comm from emp; 正确写法：select sal + ifnull(comm,0) from emp; 没有补助的员工，将每月补助100，求员工的年薪select ename, (sal + ifnull(comm,100)) * 12 yearsal from emp; 7.1.6. case…when…then…else…end用法：匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 12345case job when &apos;MANAGER&apos; then sal * 1.1 when &apos;SALESMAN&apos; then sal * 1.5 else salend 注意：使用在DQL询句中； 匹配工作岗位，当为MANAGER时，薪水上调10%，当为SALESMAN时，薪水上调50%，其它岗位薪水不变 1.1.7. trim(‘字符串’)函数：去除首尾空格作用：trim函数去除首尾空格，不会去除中间空格用法：trim(字符串)取得工作岗位为manager的所有员工select * from emp where job = trim(&#39; manager &#39;);注意：MySQL默认去除字段后面的空格，原因：MySQL语法松散 7.1.8. round(数字,保留小数位数)函数：四舍五入用法：round(要四舍五入的数字,四舍五入到哪一位)，默认保留整数位保留整数位或不保留小数位：select round(125.18)；或者 select round(125.18,0); 保留1位小数：select round(125.18,1); 保留2位小数：select round(125.18,2); 个数位四舍五入：select round(125.18,-1); 7.1.9. rand()函数：生成随机数生成一个 0≤ v ≤ 1.0的随机数;select rand(); 生成一个0-100的随机数select round(rand()*100); 7.1.10. str_to_date函数：将字符串转换为日期作用：将‘日期字符串’转换为‘日期类型’数据执行结果：DATE类型用法：str_to_date(‘日期字符串’,‘日期格式’) 1）日期字符串：日期格式的字符串日期格式：告知MySQL输入日期字符串的格式是什么MySQL日期格式： 序号 格式符 功能 格式符 功能 1 %Y 代表四位的年份 %y 代表两位的年份 2 %m 代表月，格式（01…12） %c 代表月，格式（1…12） 3 %d 代表日 4 %H 代表24小时制 %h 代表12小时制 5 %i 代表分钟，格式（00…59） 6 %S或%s 代 表 秒 , 格 式（00…59） 查询出1981-12-03入职的员工执行成功：select ename,hiredate from emp where hiredate = ‘1981-12-03’; 1、在MySQL中日期作为查询条件时，可以使用字符串为其赋值，常用格式有三种:1949-10-101949/10/10194910102、输入的日期字符串格式不MySQL默认日期格式相同，MySQL默认日期格式：%y-%m-%d查询出02-20-1981入职的员工错误执行：select ename,hiredate from emp where hiredate = &#39;02-20-1981&#39;; 错误原因：‘02-20-1981’是一个字符串varchar类型，不MySQL中DATE默认类型丌匹配正确写法：select ename,hiredate from emp where hiredate = str_to_date(‟02-20-1981‟,‘%m-%d-%Y’); 总结：1、日期是数据库本身的特色，也是数据库本身机制中的一个重要内容，所以仍需掌握；2、每一个数据库处理日期时采用的机制都不一样，都有自己的一套处理机制，所以在实际开发中将日期字段定义为DATE类型的情况很少；3、如果使用日期类型，java程序将不能通用。实际开发中，一般会使用“日期字符串”来表示日期； 创建 t_student 表【create语句，以后再细讲】，插入含有日期的数据 插入数据：1980-01-18【insert 语句，以后详细讲】 执行成功：‘1980-01-18’虽然是一个varchar类型，但是由于格式和MySQL数据库默认的日期格式相同，所以存在自动类型转换。 执行失败：再次插入01-18-1980A.‘01-18-1980’日期字符串的格式和MySQL默认的格式不同；B．‘01-18-1980’是varchar类型，birth字段需要DATE类型，类型不匹配； 正确写法： 结论：str_to_date凼数通常使用在插入操作中；字段DATA类型，不接收varchar类型，需要先通过该函数将varchar变成data再插入数据。 7.1.11. date_format函数：将日期转换为特定格式字符串作用：将‘日期类型’转换为特定格式的‘日期字符串’类型用法： date_format(日期类型数据,’日期格式’)查询员工的入职日期，以‘10-12-1980’的格式显示到窗口中； 查询员工的入职日期，以‘10/12/1980’的格式显示到窗口中； MySQL日期默认格式示例 以下两个DQL询句执行结果相同第一种：hiredate自劢转换成varchar类型，默认采用%Y-%m-%d格式 第二种：通过date_format(hiredate,’%Y-%m-%d’)函数 7.2. 分组函数/聚合函数/多行处理函数7.2.1. 常用以下几种 sum 求和 avg 取平均 max 取最大值 min 取最小值 count 取记录数 7.2.2. 什么是单行处理函数，什么是多行处理函数？单行函数都是一行输入对应一行输出多行处理函数都是多行输入对应一行输出 7.2.3. 注意：1、分组函数自动忽略空值，丌需要手劢增加where条件排除空值；2、分组函数不能直接使用在where关键字后面； 7.2.4. sum(字段)函数作用：求某一列的和，null会自劢被忽略；用法： sum(字段名称) 案例 （1）取得薪水的合计 （2）取得补助的合计 注意：null 会被忽略不计 （3）取得总共薪水（工资+补助）合计 统计结果错误，原因： 1、comm字段有 null 值，在多列进行运算时，叧要有 null 参不的数学运算结果都为 null2、sum函数会自劢忽略掉null值，正确的做法是将comm的null值转换为0，如：ifnull(comm,0)纠正以上错误，如下：sum(sal + ifnull(comm,0)) 7.2.5. avg(字段名)函数作用：求某一列的平均值，null会被自劢忽略用法：avg(字段名称) 案例 （1）取得平均薪水avg(sal) 7.2.6. max(字段名)函数作用：取得某一列的最大值用法：max(字段名称)案例：（1）取得最高薪水max(sal) （2）取得最晚入职的员工max(hireddate)说明：日期类型也可以进行大小比较 7.2.7. min(字段名)函数作用：取得某一列最小值用法：min(字段名称)案例（1）得最低薪水min(sal) （2）取得最早入职的员工min(hiredate) 7.2.8. count函数作用：取得某字段值不为null的记录总数用法：count(字段名称) 或 count()注意：1、 count()表示取得当前查诟表所有记录2、 count(字段名称)，不会统计为 null 的记录案例（1） 取得所有员工数count(*) （2）取得补助不为空的所有员工数count(comm) （3）取得补助为空的员工数量 is null select count(*) from emp where comm is null； 查询出补助comm为null的数量 7.2.9. 组合聚合函数sum、avg、max、min、count可以将这些聚合函数都放到 select 中一起使用select count(*),sum(sal),avg(sal),max(sal),min(sal) from emp; 7.3. distinct 去除重复记录作用：将查询结果中某一字段的的重复记录去除掉用法：distinct 字段名或 distinct 字段名1, 字段名2 … …distinct 字段名A：去除不字段名A相同的记录distinct 字段名A,字段名B：去除不字段名A和字段名B同时相同的记录注意：distinct叧能出现在所有字段最前面，后面如果有多个字段及为多字段联合去重 7.3.1. 案例（1）查询全公司有哪些工作岗位 （2）查询全公司工作岗位数量 （3）去除部门编号deptno和工作岗位job重复的记录 7.4. 分组查询：group by作用：通过哪个或哪些字段进行分组用法：group by 字段名称 7.4.1. 案例（1）找出每个工作岗位的最高薪水思路分析：按照工作岗位分组，然后对每一组求最大值。SQL询句中肯定包含 group by、max(sal)； 重点结论：有 group by 的DQL询句中，select 语句后面只能跟 分组函数 + 参与分组的字段； （2）计算每个工作岗位的最高薪水，并且按照由低到高进行排序思路分析：先按照工作岗位 job 进行分组，然后对每一组薪水求最大值max，最后再根据每一组薪水的最大值进行由低到高排序； 注意：如果使用了 order by ，order by 必须放到 group by后面； （3）计算每个部门的平均薪水思路分析：首先，按照部门编号分组，然后对每一组的薪水求平均值 （4）计算出不同部门不同岗位的最高薪水思路分析：首先把deptno和job看成一个字段进行联合字段分组，联系到distinct关键字。 （5）找出每个工作岗位的最高薪水，除MANAGER之外思路分析：先将job等于MANAGER的过滤掉，然后再根据工作岗位进行分组，对每一组求最大薪水。 7.4.2. having作用：如果想对分组的数据再进行过滤，需要使用having子句； （1）找出每个工作岗位的平均薪水，要求显示平均薪水大于2000的；思路分析：先对工作岗位 job 分组，然后对每一组薪水求平均值，最后再对每一组平均薪水的值进行大于2000的条件过滤； 错误写法：select job,avg(sal) from emp where avg(avg) &gt; 2000 group by job;原因：where关键字后面不能直接使用分组函数，这与SQL询句的执行顺序有关系，它会先执行from emp，然后再进行 where 条件过滤，where条件过滤结束之后再执行 group by 分组，之后才会显示出查询结果。正确写法：select job,avg(sal) from emp group by job having avg(sal) &gt; 2000; 注意：能够在where在过滤的数据不要放到having中进行过滤，否则影响SQL询句的执行效率 7.4.3. where 与 having 区别： where 和 having 都是为了完成数据的过滤，它们后面都是添加条件； where 是在 group by之前完成过滤； having 是在 group by 之后完成过滤； 8. 总结一个完整的SQL语句如下： 123456789101112select xxxxfrom xxxxwhere xxxxgroup by xxxxhaving xxxxorder by xxxx 以上关键字的顺序不能变，严格遵守以上语句的执行顺序： from 将硬盘上的表文件加载到内存 where:将符合条件的数据行摘取出来。生成一张新的临时表 group by :根据列中的数据种类，将当前临时表划分成若干个新的临时表 having : 可以过滤掉group by生成的不符合条件的临时表 select : 对当前临时表进行整列读取 order by : 对select生成的临时表，进行重新排序，生成新的临时表 limit : 对最终生成的临时表的数据行，进行截取。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM快速入门]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16-JVM-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM快速入门 听说Java虚拟机是我们成为一名优秀程序员必须掌握的一个知识，这也是我们和一般只会敲代码的程序员特别能体现差距的地方。所以小艾今天就赶紧的去学习了一下JVM。 目录 JVM体系结构概述 堆体系结构概述 堆参数调优入门 GC垃圾回收 总结 一、JVM体系结构概述首先我们要知道JVM是运行在操作系统之上的，与硬件并没有直接的交互。 它的体系结构概览如下图所示： 其中的灰色区域Java栈、本地方法栈、程序计数器三块绝对不会有垃圾回收，而所谓的JVM调优就是调方法区和堆，主要是堆。记住这两点后，我们来详细的了解一下各个模块，先从红色的类装载子系统和执行引擎说起。 1.1 类装载器Class Loader它类似于快递员，负责把硬盘上的class文件送去执行，也就是说只负责class文件的加载，至于它是否运行由Execution Engine决定。 注意硬盘上的Car.class是小写的class，是指存在于硬盘上的一个文件。 1.1.1 类加载器的分类Java是由C++演变过来的，分为“虚拟机自带的加载器”和“用户自定义加载器”。 虚拟机自带的加载器 启动类加载器（Bootstrap）C++编写 扩展类加载器（Extension）Java编写 应用程序类加载器（AppClassLoader）Java编写，也叫系统类加载器，加载当前应用的classpath的所有类。 用户自定义加载器 Java.lang.ClassLoader的子类，用户可以定制类的加载方式。 它的特点包括“双亲委派机制”和“沙箱安全机制” 双亲委派机制 双亲委派模型的运作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会去尝试自己加载。 沙箱机制 沙箱机制是基于双亲委派机制上的采取一种JVM的自我保护机制，假设你要写一个java.lang.String的类，由于双亲委派机制的原理，此请求会先交给Bootstrap试图进行加载，但是Bootstrap在加载类时首先通过包和类名查找rt.jar中有没有该类，有则优先加载rt.jar包中的类，因此就保证了java的运行机制不会被破坏。 Sun.misc.Launcher它是Java虚拟机的入口应用，最后Execution Engine执行引擎负责解析命令，提交到操作系统执行。 1.2 本地方法栈本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生的时候是C/C++横行的时候，要想立足，必须调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies. 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等待。 1.3 PC寄存器PC寄存器也叫Program Counter Register程序计数器，每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储下一条指令的地址，就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。直白点说就是程序执行顺序的调度依靠它来完成。 1.4 方法区方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享空间。 静态变量+常量+类信息（构造方法/接口定义）+运行时常量池存在方法区中，But实例变量存在堆内存中，与方法区无关。 1.5 栈偏理论：程序=算法+数据结构 偏应用：程序=框架+业务逻辑 其中有种数据结构叫做栈，后进先出，先进后出，类似于子弹夹。对于Java来说，栈里存放的就是方法，main方法是最先进的所以在底层，main方法中引用的方法先完成后，main方法才能执行出栈。 栈也叫栈内存，主管Java程序的运行，是在线程创建时创建的，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 1.5.1 栈存储什么栈帧中主要保存3类数据： 本地变量（Local Variable）：输入参数和输出参数以及方法内的变量。 栈操作（Operand Stack）：记录出栈、入栈的操作。 栈帧数据（Frame Data）：包括类文件、方法等待。 1.5.2 栈运行原理栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中。 A方法又调用了B方法，于是产生栈帧F2也被压入栈， B方法又调用了C方法，于是产生栈帧F3也被压入栈， ……. ……. 执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧… … 遵循“先进后出”/“后进先出”原则。 栈帧2是最先被调用的方法，先入栈，然后方法2又调用了方法1，栈帧1处于栈顶的位置，栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2，线程结束，栈释放。 每次执行一个方法都会产生一个栈帧，保存到栈（后进先出）的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。 栈的大小也是有极限的。 栈异常：Exception in thread “main” java.lang.StackOverflowError 1.5.3 栈+堆+方法区的交互关系 HotSpot是SUN公司的Java虚拟机版本名，是使用指针的方式来访问对象，Java堆中会存放访问类元数据的地址，即指向方法区中的模板文件，保证每一个实例一致性，reference存储的就直接是对象的地址。 三种JVM Sun公司的HotSpot BEA公司的JRockit IBM公司的J9 VM SUN和EBA都被Oracle公司收购，进行了产品整合，PK后产生了Java8。 二、堆体系结构概述2.1 堆一个JVM实例中只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分： Young Generation Space 新生区 Young/New Tenure generation Space 养老区 Old/Tenure Permanent Space 永久区 Perm 2.1.1 新生区新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区（Eden Space）和幸存者区（Survivor Space），所有的类都是在伊甸区被new出来的。辛存区有两个：0区（Survivor 0 Space）和1区（Survivor 1 Space）。当伊甸区的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC（Full GC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。 如果出现java.lang.OutOfMemoryError：Java head space异常，说明Java虚拟机的堆内存不够。原因有二： （1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。 （2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。 2.1.2 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError：PermGen Space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 JDK1.6及之前：有永久代，常量池1.6在方法区 JDK1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆。 JDK1.8及以后：无永久代，常量池1.8在元空间。 属性三区结构后方可学习JVM垃圾收集 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Parmanent Gen）”，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口interface）的一个实现，JDK1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 三、堆参数调优入门我们先来看看Java7和Java8的堆结构区别 Java7 Java8之后最初的永久代取消了，由元空间取代。 3.1 堆内存调优简介01 123456public static void main(String[] args)&#123;long maxMemory = Runtime.getRuntime().maxMemory() ;//返回 Java 虚拟机试图使用的最大内存量。long totalMemory = Runtime.getRuntime().totalMemory() ;//返回 Java 虚拟机中的内存总量。System.out.println("MAX_MEMORY = " + maxMemory + "（字节）、" + (maxMemory / (double)1024 / 1024) + "MB");System.out.println("TOTAL_MEMORY = " + totalMemory + "（字节）、" + (totalMemory / (double)1024 / 1024) + "MB");&#125; 发现默认的情况下分配的内存是总内存的“1/4”、而初始化的内存为“1/64” VM参数： -Xms1024m -Xmx1024m -XX:+PrintGCDetails 12345String str = "www.atguigu.com" ;while(true) &#123; str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;&#125; VM参数：-Xms8m -Xmx8m -XX:+PrintGCDetails 3.2 MAT 官网访问地址：https://projects.eclipse.org/projects/tools.mat/downloads -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件。 -Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError 四、GC垃圾回收 4.1 GC是什么（分代算法）GC俗称垃圾回收器 （java Garbage Collection） 次数上频繁收集Young区 次数上较少收集Old区 基本上不动Perm区 4.2 GC4大算法JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 普通GC（minor GC）：只针对新生代区域的GC。 全局GC（major GC or Full GC）：针对年老代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 4.2.1 引用计数法4.2.2 复制算法（Copying）年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying） 原理： Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old generation中，也即一旦收集后，Eden区就变成空的了。 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过==-XX:MaxTenuringThreshold== 来设定参数)，这些对象就会成为老年代。 -XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数 解析： 年轻代中的GC,主要是复制算法（Copying） HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区 （分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。 动图 缺点 复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也是相当明显的。 它浪费了一半的内存，这太要命了。 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。 4.2.3 标记清除老年代一般是由标记清除或者是标记整理的混合实现。 原理 当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。 标记：从引用根节点开始标记所有被引用的对象。标记的过程其实就是遍历所有的GC Roots，然后将所有GC Roots可达的对象，标记为存活的对象。 清除：遍历整个堆，把未标记的对象清除。 用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行。 动图 缺点： 此算法需要暂停整个应用，会产生内存碎片 4.2.4 标记压缩老年代一般是由标记清除或者是标记整理的混合实现。 原理 在整理压缩阶段，不再对标记的对像做回收，而是通过所有存活对像都向一端移动，然后直接清除边界以外的内存。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。 缺点 标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 4.2.5 标记清除压缩 动图 4.2.6 这几种算法的比较内存效率：复制算法&gt;标记清除算法&gt;标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。内存整齐度：复制算法=标记整理算法&gt;标记清除算法。内存利用率：标记整理算法=标记清除算法&gt;复制算法。 可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。 难道就没有一种最优算法吗？ 猜猜看 答案是没有，没有最好，只有更好，最适合的算法。 五、总结通过上面的学习，相信你已经对Java虚拟机有了初步的了解，接来下还需要再深入一点学习JVM的知识。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019%2F03%2F03%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo介绍 hexo 可以理解为是基于node.js制作的一个博客工具，不是我们理解的一个开源的博客系统。 hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
